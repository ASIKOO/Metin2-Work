; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?ms_isMinLODModeEnable@@3_NA			; ms_isMinLODModeEnable
_BSS	SEGMENT
?ms_isMinLODModeEnable@@3_NA DB 01H DUP (?)		; ms_isMinLODModeEnable
_BSS	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?SetMinLODMode@CGrannyLODController@@SAX_N@Z	; CGrannyLODController::SetMinLODMode
PUBLIC	??0CGrannyLODController@@QAE@XZ			; CGrannyLODController::CGrannyLODController
PUBLIC	??1CGrannyLODController@@UAE@XZ			; CGrannyLODController::~CGrannyLODController
PUBLIC	?Clear@CGrannyLODController@@QAEXXZ		; CGrannyLODController::Clear
PUBLIC	?CreateDeviceObjects@CGrannyLODController@@QAEXXZ ; CGrannyLODController::CreateDeviceObjects
PUBLIC	?DestroyDeviceObjects@CGrannyLODController@@QAEXXZ ; CGrannyLODController::DestroyDeviceObjects
PUBLIC	?AddModel@CGrannyLODController@@QAEXPAVCGraphicThing@@HPAV1@@Z ; CGrannyLODController::AddModel
PUBLIC	?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z ; CGrannyLODController::AttachModelInstance
PUBLIC	?DetachModelInstance@CGrannyLODController@@QAEXPAV1@@Z ; CGrannyLODController::DetachModelInstance
PUBLIC	?SetLODLimits@CGrannyLODController@@QAEXMM@Z	; CGrannyLODController::SetLODLimits
PUBLIC	?SetLODLevel@CGrannyLODController@@QAEXE@Z	; CGrannyLODController::SetLODLevel
PUBLIC	?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z ; CGrannyLODController::SetMaterialImagePointer
PUBLIC	?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z ; CGrannyLODController::SetMaterialData
PUBLIC	?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z ; CGrannyLODController::SetSpecularInfo
PUBLIC	?RenderWithOneTexture@CGrannyLODController@@QAEXXZ ; CGrannyLODController::RenderWithOneTexture
PUBLIC	?RenderWithTwoTexture@CGrannyLODController@@QAEXXZ ; CGrannyLODController::RenderWithTwoTexture
PUBLIC	?BlendRenderWithOneTexture@CGrannyLODController@@QAEXXZ ; CGrannyLODController::BlendRenderWithOneTexture
PUBLIC	?BlendRenderWithTwoTexture@CGrannyLODController@@QAEXXZ ; CGrannyLODController::BlendRenderWithTwoTexture
PUBLIC	?Update@CGrannyLODController@@QAEXMMM@Z		; CGrannyLODController::Update
PUBLIC	?UpdateLODLevel@CGrannyLODController@@QAEXMM@Z	; CGrannyLODController::UpdateLODLevel
PUBLIC	?UpdateTime@CGrannyLODController@@QAEXM@Z	; CGrannyLODController::UpdateTime
PUBLIC	?UpdateSkeleton@CGrannyLODController@@QAEXPBUD3DXMATRIX@@M@Z ; CGrannyLODController::UpdateSkeleton
PUBLIC	?Deform@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyLODController::Deform
PUBLIC	?DeformNoSkin@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyLODController::DeformNoSkin
PUBLIC	?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyLODController::DeformAll
PUBLIC	?RenderToShadowMap@CGrannyLODController@@QAEXXZ	; CGrannyLODController::RenderToShadowMap
PUBLIC	?RenderShadow@CGrannyLODController@@QAEXXZ	; CGrannyLODController::RenderShadow
PUBLIC	?ReloadTexture@CGrannyLODController@@QAEXXZ	; CGrannyLODController::ReloadTexture
PUBLIC	?GetBoundBox@CGrannyLODController@@QAEXPAUD3DXVECTOR3@@0@Z ; CGrannyLODController::GetBoundBox
PUBLIC	?Intersect@CGrannyLODController@@QAE_NPBUD3DXMATRIX@@PAM11@Z ; CGrannyLODController::Intersect
PUBLIC	?SetLocalTime@CGrannyLODController@@QAEXM@Z	; CGrannyLODController::SetLocalTime
PUBLIC	?ResetLocalTime@CGrannyLODController@@QAEXXZ	; CGrannyLODController::ResetLocalTime
PUBLIC	?SetMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@MHM@Z ; CGrannyLODController::SetMotionPointer
PUBLIC	?ChangeMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@HM@Z ; CGrannyLODController::ChangeMotionPointer
PUBLIC	?SetMotionAtEnd@CGrannyLODController@@QAEXXZ	; CGrannyLODController::SetMotionAtEnd
PUBLIC	?isModelInstance@CGrannyLODController@@QAEHXZ	; CGrannyLODController::isModelInstance
PUBLIC	?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
PUBLIC	?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z ; CGrannyLODController::SetCurrentModelInstance
PUBLIC	?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ ; CGrannyLODController::RefreshAttachedModelInstance
PUBLIC	?__ReserveSharedDeformableVertexBuffer@CGrannyLODController@@IAEXK@Z ; CGrannyLODController::__ReserveSharedDeformableVertexBuffer
PUBLIC	??0SAttachingModelData@CGrannyLODController@@QAE@XZ ; CGrannyLODController::SAttachingModelData::SAttachingModelData
PUBLIC	??1SAttachingModelData@CGrannyLODController@@QAE@XZ ; CGrannyLODController::SAttachingModelData::~SAttachingModelData
PUBLIC	??4SAttachingModelData@CGrannyLODController@@QAEAAU01@$$QAU01@@Z ; CGrannyLODController::SAttachingModelData::operator=
PUBLIC	?deallocate@?$allocator@USAttachingModelData@CGrannyLODController@@@std@@QAEXQAUSAttachingModelData@CGrannyLODController@@I@Z ; std::allocator<CGrannyLODController::SAttachingModelData>::deallocate
PUBLIC	??1?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::~vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >
PUBLIC	?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::erase
PUBLIC	?clear@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::clear
PUBLIC	?_Destroy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXPAUSAttachingModelData@CGrannyLODController@@0@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@ABEII@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXQAUSAttachingModelData@CGrannyLODController@@II@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Change_array
PUBLIC	?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Tidy
PUBLIC	?_Xlength@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@CAXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Xlength
PUBLIC	??0?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >
PUBLIC	??1?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::~deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >
PUBLIC	?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
PUBLIC	?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
PUBLIC	?_Unchecked_end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Unchecked_end
PUBLIC	??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::operator[]
PUBLIC	?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::back
PUBLIC	?push_front@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXABQAVCGrannyModelInstance@@@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::push_front
PUBLIC	?pop_back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::pop_back
PUBLIC	?_Xlen@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@ABEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Xlen
PUBLIC	?_Growmap@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXI@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Growmap
PUBLIC	?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Tidy
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >
PUBLIC	??_GCGrannyLODController@@UAEPAXI@Z		; CGrannyLODController::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@PAVCGraphicVertexBuffer@@@std@@QAEXQAPAVCGraphicVertexBuffer@@I@Z ; std::allocator<CGraphicVertexBuffer *>::deallocate
PUBLIC	??0?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
PUBLIC	??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::~vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
PUBLIC	?clear@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXPAPAVCGraphicVertexBuffer@@0@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@ABEII@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXQAPAVCGraphicVertexBuffer@@II@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@CAXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Xlength
PUBLIC	?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z ; __FreeDeformVertexBuffer
PUBLIC	?__ReserveSharedVertexBuffers@@YAXII@Z		; __ReserveSharedVertexBuffers
PUBLIC	?GrannyCreateSharedDeformBuffer@@YAXXZ		; GrannyCreateSharedDeformBuffer
PUBLIC	?GrannyDestroySharedDeformBuffer@@YAXXZ		; GrannyDestroySharedDeformBuffer
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
PUBLIC	??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator=
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >
PUBLIC	??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,void (__cdecl*)(CGrannyModelInstance *)>
PUBLIC	??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FCreateDeviceObjects>
PUBLIC	??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FDestroyDeviceObjects>
PUBLIC	??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::emplace_back<CGraphicVertexBuffer * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXABQAVCGraphicVertexBuffer@@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_back_with_unused_capacity<CGraphicVertexBuffer * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_reallocate<CGraphicVertexBuffer * const &>
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$emplace_back@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXABUSAttachingModelData@CGrannyLODController@@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::emplace_back<CGrannyLODController::SAttachingModelData const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXABUSAttachingModelData@CGrannyLODController@@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back_with_unused_capacity<CGrannyLODController::SAttachingModelData const &>
PUBLIC	??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_reallocate<CGrannyLODController::SAttachingModelData const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
PUBLIC	??$_Destroy_in_place@PAPAVCGrannyModelInstance@@@std@@YAXAAPAPAVCGrannyModelInstance@@@Z ; std::_Destroy_in_place<CGrannyModelInstance * *>
PUBLIC	??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>
PUBLIC	??$_Destroy_range@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAXPAPAPAVCGrannyModelInstance@@QAPAPAV1@@Z ; std::_Destroy_range<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Copy_memmove@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@00@Z ; std::_Copy_memmove<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
PUBLIC	??$_Zero_range@PAPAPAVCGrannyModelInstance@@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0@Z ; std::_Zero_range<CGrannyModelInstance * * *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >
PUBLIC	??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >
PUBLIC	??$_Copy_memmove@PAPAVCGraphicVertexBuffer@@PAPAV1@@std@@YAPAPAVCGraphicVertexBuffer@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicVertexBuffer * *,CGraphicVertexBuffer * *>
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::~_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >
PUBLIC	??$_Emplace_back@USAttachingModelData@CGrannyLODController@@@?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEX$$QAUSAttachingModelData@CGrannyLODController@@@Z ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back<CGrannyLODController::SAttachingModelData>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7CGrannyLODController@@6B@			; CGrannyLODController::`vftable'
PUBLIC	??_C@_0BG@IJPBENCD@NEW_ERROR?5?$CF8d?3?5?$CFd?$CI?$CFd?$CJ@ ; `string'
PUBLIC	??_C@_0HN@JOABBJCG@CGrannyLODController?3?3RefreshAt@ ; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CGrannyLODController@@6B@			; CGrannyLODController::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGrannyLODController@@@8		; CGrannyLODController `RTTI Type Descriptor'
PUBLIC	??_R3CGrannyLODController@@8			; CGrannyLODController::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGrannyLODController@@8			; CGrannyLODController::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGrannyLODController@@8		; CGrannyLODController::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@41f00000
PUBLIC	__real@42b40000
PUBLIC	__real@43fa0000
PUBLIC	__real@44bb8000
PUBLIC	__real@451c4000
PUBLIC	__real@459c4000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_fabs:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?MIN@@YAHHH@Z:PROC				; MIN
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?fMINMAX@@YAMMMM@Z:PROC				; fMINMAX
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	__time64:PROC
EXTRN	??0CGraphicBase@@QAE@XZ:PROC			; CGraphicBase::CGraphicBase
EXTRN	??1CGraphicBase@@UAE@XZ:PROC			; CGraphicBase::~CGraphicBase
EXTRN	??0CGraphicVertexBuffer@@QAE@XZ:PROC		; CGraphicVertexBuffer::CGraphicVertexBuffer
EXTRN	??1CGraphicVertexBuffer@@UAE@XZ:PROC		; CGraphicVertexBuffer::~CGraphicVertexBuffer
EXTRN	?Destroy@CGraphicVertexBuffer@@QAEXXZ:PROC	; CGraphicVertexBuffer::Destroy
EXTRN	?GetVertexCount@CGraphicVertexBuffer@@QBEHXZ:PROC ; CGraphicVertexBuffer::GetVertexCount
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetDeformVertexCount@CGrannyModel@@QBEHXZ:PROC	; CGrannyModel::GetDeformVertexCount
EXTRN	?GetModelPointer@CGraphicThing@@QAEPAVCGrannyModel@@H@Z:PROC ; CGraphicThing::GetModelPointer
EXTRN	?GetModelCount@CGraphicThing@@QBEHXZ:PROC	; CGraphicThing::GetModelCount
EXTRN	?New@CGrannyModelInstance@@SAPAV1@XZ:PROC	; CGrannyModelInstance::New
EXTRN	?Delete@CGrannyModelInstance@@SAXPAV1@@Z:PROC	; CGrannyModelInstance::Delete
EXTRN	?CreateDeviceObjects@CGrannyModelInstance@@QAE_NXZ:PROC ; CGrannyModelInstance::CreateDeviceObjects
EXTRN	?DestroyDeviceObjects@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::DestroyDeviceObjects
EXTRN	?Update@CGrannyModelInstance@@QAEXK@Z:PROC	; CGrannyModelInstance::Update
EXTRN	?UpdateLocalTime@CGrannyModelInstance@@QAEXM@Z:PROC ; CGrannyModelInstance::UpdateLocalTime
EXTRN	?UpdateSkeleton@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@M@Z:PROC ; CGrannyModelInstance::UpdateSkeleton
EXTRN	?DeformNoSkin@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z:PROC ; CGrannyModelInstance::DeformNoSkin
EXTRN	?Deform@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z:PROC ; CGrannyModelInstance::Deform
EXTRN	?RenderWithOneTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::RenderWithOneTexture
EXTRN	?RenderWithTwoTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::RenderWithTwoTexture
EXTRN	?BlendRenderWithOneTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::BlendRenderWithOneTexture
EXTRN	?BlendRenderWithTwoTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::BlendRenderWithTwoTexture
EXTRN	?RenderWithoutTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::RenderWithoutTexture
EXTRN	?SetMaterialImagePointer@CGrannyModelInstance@@QAEXPBDPAVCGraphicImage@@@Z:PROC ; CGrannyModelInstance::SetMaterialImagePointer
EXTRN	?SetMaterialData@CGrannyModelInstance@@QAEXPBDABUSMaterialData@@@Z:PROC ; CGrannyModelInstance::SetMaterialData
EXTRN	?SetSpecularInfo@CGrannyModelInstance@@QAEXPBDHM@Z:PROC ; CGrannyModelInstance::SetSpecularInfo
EXTRN	?SetLinkedModelPointer@CGrannyModelInstance@@QAEXPAVCGrannyModel@@PAVCGraphicVertexBuffer@@PAPAV1@@Z:PROC ; CGrannyModelInstance::SetLinkedModelPointer
EXTRN	?SetMotionPointer@CGrannyModelInstance@@QAEXPBVCGrannyMotion@@MHM@Z:PROC ; CGrannyModelInstance::SetMotionPointer
EXTRN	?ChangeMotionPointer@CGrannyModelInstance@@QAEXPBVCGrannyMotion@@HM@Z:PROC ; CGrannyModelInstance::ChangeMotionPointer
EXTRN	?SetMotionAtEnd@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::SetMotionAtEnd
EXTRN	?CopyMotion@CGrannyModelInstance@@QAEXPAV1@_N@Z:PROC ; CGrannyModelInstance::CopyMotion
EXTRN	?SetLocalTime@CGrannyModelInstance@@QAEXM@Z:PROC ; CGrannyModelInstance::SetLocalTime
EXTRN	?ResetLocalTime@CGrannyModelInstance@@QAEHXZ:PROC ; CGrannyModelInstance::ResetLocalTime
EXTRN	?SetParentModelInstance@CGrannyModelInstance@@QAEXPBV1@PBD@Z:PROC ; CGrannyModelInstance::SetParentModelInstance
EXTRN	?SetParentModelInstance@CGrannyModelInstance@@QAEXPBV1@H@Z:PROC ; CGrannyModelInstance::SetParentModelInstance
EXTRN	?Intersect@CGrannyModelInstance@@QAE_NPBUD3DXMATRIX@@PAM11@Z:PROC ; CGrannyModelInstance::Intersect
EXTRN	?GetBoundBox@CGrannyModelInstance@@QAEXPAUD3DXVECTOR3@@0@Z:PROC ; CGrannyModelInstance::GetBoundBox
EXTRN	?ReloadTexture@CGrannyModelInstance@@QAEXXZ:PROC ; CGrannyModelInstance::ReloadTexture
EXTRN	??_ECGrannyLODController@@UAEPAXI@Z:PROC	; CGrannyLODController::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A:BYTE ; CGraphicBase::ms_matIdentity
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
	ALIGN	4

?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A DB 06cH DUP (?) ; gs_vbs
?gs_emptyVB@@3VCGraphicVertexBuffer@@A DB 020H DUP (?)	; gs_emptyVB
_BSS	ENDS
;	COMDAT ?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA
_BSS	SEGMENT
?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA DQ 01H DUP (?) ; `__AllocDeformVertexBuffer'::`2'::base
_BSS	ENDS
;	COMDAT ?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA DD 01H DUP (?) ; `__AllocDeformVertexBuffer'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_vbs$initializer$@@3P6AXXZA DD FLAT:??__Egs_vbs@@YAXXZ ; gs_vbs$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@451c4000
CONST	SEGMENT
__real@451c4000 DD 0451c4000r			; 2500
CONST	ENDS
;	COMDAT __real@44bb8000
CONST	SEGMENT
__real@44bb8000 DD 044bb8000r			; 1500
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@42b40000
CONST	SEGMENT
__real@42b40000 DD 042b40000r			; 90
CONST	ENDS
;	COMDAT __real@41f00000
CONST	SEGMENT
__real@41f00000 DD 041f00000r			; 30
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGrannyLODController@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGrannyLODController@@8 DD FLAT:??_R0?AVCGrannyLODController@@@8 ; CGrannyLODController::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGrannyLODController@@8
rdata$r	ENDS
;	COMDAT ??_R2CGrannyLODController@@8
rdata$r	SEGMENT
??_R2CGrannyLODController@@8 DD FLAT:??_R1A@?0A@EA@CGrannyLODController@@8 ; CGrannyLODController::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGrannyLODController@@8
rdata$r	SEGMENT
??_R3CGrannyLODController@@8 DD 00H			; CGrannyLODController::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGrannyLODController@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGrannyLODController@@@8
data$rs	SEGMENT
??_R0?AVCGrannyLODController@@@8 DD FLAT:??_7type_info@@6B@ ; CGrannyLODController `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGrannyLODController@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGrannyLODController@@6B@
rdata$r	SEGMENT
??_R4CGrannyLODController@@6B@ DD 00H			; CGrannyLODController::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGrannyLODController@@@8
	DD	FLAT:??_R3CGrannyLODController@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0HN@JOABBJCG@CGrannyLODController?3?3RefreshAt@
CONST	SEGMENT
??_C@_0HN@JOABBJCG@CGrannyLODController?3?3RefreshAt@ DB 'CGrannyLODContr'
	DB	'oller::RefreshAttachedModelInstance : m_AttachedModelDataVect'
	DB	'or[%d]->pkLODController->GetModelIntance()==NULL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IJPBENCD@NEW_ERROR?5?$CF8d?3?5?$CFd?$CI?$CFd?$CJ@
CONST	SEGMENT
??_C@_0BG@IJPBENCD@NEW_ERROR?5?$CF8d?3?5?$CFd?$CI?$CFd?$CJ@ DB 'NEW_ERROR'
	DB	' %8d: %d(%d)', 00H				; `string'
CONST	ENDS
_DATA	SEGMENT
?LODHEIGHT_ACTOR@@3MA DD 043fa0000r		; 500	; LODHEIGHT_ACTOR
?LODDISTANCE_ACTOR@@3MA DD 0459c4000r		; 5000	; LODDISTANCE_ACTOR
?LODDISTANCE_BUILDING@@3MA DD 046c35000r	; 25000	; LODDISTANCE_BUILDING
_DATA	ENDS
;	COMDAT ??_7CGrannyLODController@@6B@
CONST	SEGMENT
??_7CGrannyLODController@@6B@ DD FLAT:??_R4CGrannyLODController@@6B@ ; CGrannyLODController::`vftable'
	DD	FLAT:??_ECGrannyLODController@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$40 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$40
__ehfuncinfo$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$1
__ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$1
__ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z$1
__ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__ReserveSharedVertexBuffers@@YAXII@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__ReserveSharedVertexBuffers@@YAXII@Z$0
__ehfuncinfo$?__ReserveSharedVertexBuffers@@YAXII@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__ReserveSharedVertexBuffers@@YAXII@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z$0
__ehfuncinfo$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z$0
__ehfuncinfo$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z$0
__ehfuncinfo$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z$0
__ehfuncinfo$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z$0
__ehfuncinfo$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z$0
__ehfuncinfo$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGrannyLODController@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CGrannyLODController@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGrannyLODController@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CGrannyLODController@@QAE@XZ$1
__ehfuncinfo$??0CGrannyLODController@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0CGrannyLODController@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?gs_emptyVB$initializer$@@3P6AXXZA DD FLAT:??__Egs_emptyVB@@YAXXZ ; gs_emptyVB$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@USAttachingModelData@CGrannyLODController@@@?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEX$$QAUSAttachingModelData@CGrannyLODController@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USAttachingModelData@CGrannyLODController@@@?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEX$$QAUSAttachingModelData@CGrannyLODController@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back<CGrannyLODController::SAttachingModelData>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	50		 push	 eax
  00044	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	83 c0 1c	 add	 eax, 28			; 0000001cH
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0005e	c9		 leave
  0005f	c2 04 00	 ret	 4
??$_Emplace_back@USAttachingModelData@CGrannyLODController@@@?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEX$$QAUSAttachingModelData@CGrannyLODController@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back<CGrannyLODController::SAttachingModelData>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::~_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::~_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicVertexBuffer@@PAPAV1@@std@@YAPAPAVCGraphicVertexBuffer@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicVertexBuffer@@PAPAV1@@std@@YAPAPAVCGraphicVertexBuffer@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicVertexBuffer * *,CGraphicVertexBuffer * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicVertexBuffer@@PAPAV1@@std@@YAPAPAVCGraphicVertexBuffer@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicVertexBuffer * *,CGraphicVertexBuffer * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z PROC ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@USAttachingModelData@CGrannyLODController@@@?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEX$$QAUSAttachingModelData@CGrannyLODController@@@Z ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back<CGrannyLODController::SAttachingModelData>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >::~_Uninitialized_backout_al<std::allocator<CGrannyLODController::SAttachingModelData> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ENDP ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicVertexBuffer@@PAPAV1@@std@@YAPAPAVCGraphicVertexBuffer@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicVertexBuffer * *,CGraphicVertexBuffer * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAPAPAVCGrannyModelInstance@@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAPAVCGrannyModelInstance@@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0@Z PROC ; std::_Zero_range<CGrannyModelInstance * * *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAPAPAVCGrannyModelInstance@@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0@Z ENDP ; std::_Zero_range<CGrannyModelInstance * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@00@Z PROC ; std::_Copy_memmove<CGrannyModelInstance * * *,CGrannyModelInstance * * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@00@Z ENDP ; std::_Copy_memmove<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
__Mycont_$ = -16					; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 f0	 mov	 DWORD PTR __Mycont_$[ebp], eax

; 1089 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00023	8b 4d f0	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0002b	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0002f	c9		 leave
  00030	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1003 : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	33 c0		 xor	 eax, eax
  00005	40		 inc	 eax
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 1004 :     // deallocate a plain pointer using an allocator
; 1005 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1006 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1007 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);
; 1008 :     } else {
; 1009 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1010 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1011 :     }
; 1012 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 908  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 909  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 910  :         _Left = _STD move(_Right);
; 911  :     }
; 912  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 26		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00023	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00028	33 c0		 xor	 eax, eax
  0002a	83 e0 01	 and	 eax, 1
  0002d	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  0003b	eb c9		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAXPAPAPAVCGrannyModelInstance@@QAPAPAV1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Destroy_range@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAXPAPAPAVCGrannyModelInstance@@QAPAPAV1@@Z PROC ; std::_Destroy_range<CGrannyModelInstance * * *,CGrannyModelInstance * * *>, COMDAT

; 974  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 975  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 976  :     if _CONSTEXPR_IF (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 977  :         for (; _First != _Last; ++_First) {
; 978  :             _Destroy_in_place(*_First);
; 979  :         }
; 980  :     }
; 981  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAXPAPAPAVCGrannyModelInstance@@QAPAPAV1@@Z ENDP ; std::_Destroy_range<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z
_TEXT	SEGMENT
__UFirst$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>, COMDAT

; 1912 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1913 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1914 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1915 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1916 :         return _Zero_range(_UFirst, _UFirst + _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00009	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __UFirst$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAPAVCGrannyModelInstance@@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0@Z ; std::_Zero_range<CGrannyModelInstance * * *>
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 1917 :     } else {
; 1918 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1919 :         for (; 0 < _Count; --_Count) {
; 1920 :             _Backout._Emplace_back();
; 1921 :         }
; 1922 : 
; 1923 :         return _Backout._Release();
; 1924 :     }
; 1925 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__UFirst$ = -12						; size = 4
__ULast$ = -8						; size = 4
__UDest$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z PROC ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>, COMDAT

; 1629 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1630 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1631 :     _Adl_verify_range(_First, _Last);
; 1632 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1633 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1557 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00015	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 02	 sar	 eax, 2
  0001b	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1634 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00021	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax

; 1635 :     if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
; 1636 :         _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);

  00024	ff 75 fc	 push	 DWORD PTR __UDest$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __ULast$[ebp]
  0002a	ff 75 f4	 push	 DWORD PTR __UFirst$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@00@Z ; std::_Copy_memmove<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00038	8b 45 fc	 mov	 eax, DWORD PTR __UDest$[ebp]
  0003b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1647 :     return _Dest;

  0003e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1648 : }

  00041	c9		 leave
  00042	c3		 ret	 0
??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ENDP ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAPAVCGrannyModelInstance@@@std@@YAXAAPAPAVCGrannyModelInstance@@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAPAVCGrannyModelInstance@@@std@@YAXAAPAPAVCGrannyModelInstance@@@Z PROC ; std::_Destroy_in_place<CGrannyModelInstance * *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAPAVCGrannyModelInstance@@@std@@YAXAAPAPAVCGrannyModelInstance@@@Z ENDP ; std::_Destroy_in_place<CGrannyModelInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
__Newsize$ = 36						; size = 4
__Constructed_last$ = 40				; size = 4
$T19 = 44						; size = 4
$T20 = 48						; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_reallocate<CGrannyLODController::SAttachingModelData const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 20	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 1c		 push	 28			; 0000001cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 49 92
	24 09		 mov	 DWORD PTR $T22[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 18 ff ff
	ff 7f		 mov	 DWORD PTR $T16[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 14	 mov	 DWORD PTR $T15[ebp], eax
  000b7	8b 45 14	 mov	 eax, DWORD PTR $T15[ebp]
  000ba	89 45 10	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 10	 mov	 eax, DWORD PTR $T14[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 0c	 cmp	 eax, DWORD PTR $T13[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@CAXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 24	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 24	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@ABEII@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 49 92
	24 09		 mov	 DWORD PTR __Max_possible$2[ebp], 153391689 ; 09249249H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 49 92
	24 09		 cmp	 DWORD PTR __Newcapacity$[ebp], 153391689 ; 09249249H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  00104	89 45 08	 mov	 DWORD PTR $T12[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 08	 push	 DWORD PTR $T12[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]
  0011e	89 45 28	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 28	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  0013e	89 45 2c	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 00	 mov	 eax, DWORD PTR $T10[ebp]
  00144	89 45 30	 mov	 DWORD PTR $T20[ebp], eax
  00147	8b 45 2c	 mov	 eax, DWORD PTR $T19[ebp]
  0014a	8b 4d 30	 mov	 ecx, DWORD PTR $T20[ebp]
  0014d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014f	89 08		 mov	 DWORD PTR [eax], ecx
  00151	8b 45 30	 mov	 eax, DWORD PTR $T20[ebp]
  00154	83 c0 04	 add	 eax, 4
  00157	50		 push	 eax
  00158	8b 4d 2c	 mov	 ecx, DWORD PTR $T19[ebp]
  0015b	83 c1 04	 add	 ecx, 4
  0015e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00163	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  00167	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  0016a	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0016d	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00170	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00173	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00175	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00177	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0017a	8b 00		 mov	 eax, DWORD PTR [eax]
  0017c	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0017f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00182	8b 00		 mov	 eax, DWORD PTR [eax]
  00184	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00187	33 c0		 xor	 eax, eax
  00189	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0018c	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0018f	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00192	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00195	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00198	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0019b	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0019e	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  001a1	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001a4	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  001a7	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  001aa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >
  001af	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001b2	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001b4	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001b7	8b 00		 mov	 eax, DWORD PTR [eax]
  001b9	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001bc	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001bf	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001c2	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001c5	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001c8	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001cb	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001ce	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001d1	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001d4	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >
  001d9	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001dc	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001df	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e2	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001e5	8b 00		 mov	 eax, DWORD PTR [eax]
  001e7	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ea	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ed	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001f0	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001f3	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f6	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001f9	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  001fd	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00200	8d 44 01 1c	 lea	 eax, DWORD PTR [ecx+eax+28]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00204	50		 push	 eax
  00205	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  00208	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  0020b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAPAUSAttachingModelData@CGrannyLODController@@QAU12@0PAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Uninitialized_move<CGrannyLODController::SAttachingModelData *,std::allocator<CGrannyLODController::SAttachingModelData> >
  00210	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00213	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00215	ff 75 28	 push	 DWORD PTR __Constructed_last$[ebp]
  00218	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0021b	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXPAUSAttachingModelData@CGrannyLODController@@0@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00223	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00226	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00229	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0022c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USAttachingModelData@CGrannyLODController@@@std@@QAEXQAUSAttachingModelData@CGrannyLODController@@I@Z ; std::allocator<CGrannyLODController::SAttachingModelData>::deallocate

; 762  :         _RERAISE;

  00231	6a 00		 push	 0
  00233	6a 00		 push	 0
  00235	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0023a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0023f	c3		 ret	 0
$LN7@Emplace_re:
  00240	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00244	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00246	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0024a	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0024d	ff 75 24	 push	 DWORD PTR __Newsize$[ebp]
  00250	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00253	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00256	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXQAUSAttachingModelData@CGrannyLODController@@II@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0025b	6b 45 60 1c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 28
  0025f	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00262	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00265	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026c	59		 pop	 ecx
  0026d	5f		 pop	 edi
  0026e	5e		 pop	 esi
  0026f	5b		 pop	 ebx
  00270	83 c5 70	 add	 ebp, 112		; 00000070H
  00273	c9		 leave
  00274	c2 08 00	 ret	 8
  00277	cc		 int	 3
  00278	cc		 int	 3
  00279	cc		 int	 3
  0027a	cc		 int	 3
  0027b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_reallocate<CGrannyLODController::SAttachingModelData const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXABUSAttachingModelData@CGrannyLODController@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
__Ptr$ = -24						; size = 4
__My_data$ = -20					; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXABUSAttachingModelData@CGrannyLODController@@@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back_with_unused_capacity<CGrannyLODController::SAttachingModelData const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00041	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
  00044	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00047	8b 4d f4	 mov	 ecx, DWORD PTR $T6[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
  0004e	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	50		 push	 eax
  00055	8b 4d f0	 mov	 ecx, DWORD PTR $T5[ebp]
  00058	83 c1 04	 add	 ecx, 4
  0005b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00060	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00068	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00070	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00073	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00075	c9		 leave
  00076	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXABUSAttachingModelData@CGrannyLODController@@@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back_with_unused_capacity<CGrannyLODController::SAttachingModelData const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXABUSAttachingModelData@CGrannyLODController@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXABUSAttachingModelData@CGrannyLODController@@@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::emplace_back<CGrannyLODController::SAttachingModelData const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXABUSAttachingModelData@CGrannyLODController@@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_back_with_unused_capacity<CGrannyLODController::SAttachingModelData const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEPAUSAttachingModelData@CGrannyLODController@@QAU23@ABU23@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Emplace_reallocate<CGrannyLODController::SAttachingModelData const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXABUSAttachingModelData@CGrannyLODController@@@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::emplace_back<CGrannyLODController::SAttachingModelData const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__New_proxy$ = -8					; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1106 :     void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 e4 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
  00017	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0001c	76 05		 jbe	 SHORT $LN6@Alloc_prox

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Alloc_prox:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	c1 e0 03	 shl	 eax, 3
  00029	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002c	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00034	59		 pop	 ecx
  00035	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00038	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	89 45 f8	 mov	 DWORD PTR __New_proxy$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1108 :         _Construct_in_place(*_New_proxy, this);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00044	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	ff 75 f8	 push	 DWORD PTR __New_proxy$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00050	59		 pop	 ecx
  00051	59		 pop	 ecx

; 1109 :         _Myproxy            = _New_proxy;

  00052	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 1110 :         _New_proxy->_Mycont = this;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Alloc_prox:

; 1111 :     }

  00062	c9		 leave
  00063	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1031 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1032 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1033 :     using _Ty = typename _Alloc::value_type;
; 1034 :     _Ptr->~_Ty();
; 1035 :     _Deallocate_plain(_Al, _Ptr);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 1036 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ
_TEXT	SEGMENT
__Off$ = -20						; size = 4
__Block$ = -16						; size = 4
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 54   :     _NODISCARD reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 55   :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f8	 mov	 DWORD PTR __Off$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0001a	8b 45 f8	 mov	 eax, DWORD PTR __Off$[ebp]
  0001d	c1 e8 02	 shr	 eax, 2
  00020	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	49		 dec	 ecx
  00027	23 c1		 and	 eax, ecx
  00029	89 45 f0	 mov	 DWORD PTR __Block$[ebp], eax

; 56   :         _Size_type _Off   = _Myoff % _DEQUESIZ;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	33 d2		 xor	 edx, edx
  00034	6a 04		 push	 4
  00036	59		 pop	 ecx
  00037	f7 f1		 div	 ecx
  00039	89 55 ec	 mov	 DWORD PTR __Off$[ebp], edx

; 57   :         return _Mycont->_Map[_Block][_Off];

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	8b 4d f0	 mov	 ecx, DWORD PTR __Block$[ebp]
  00047	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR __Off$[ebp]
  0004d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 58   :     }

  00050	c9		 leave
  00051	c3		 ret	 0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_reallocate<CGraphicVertexBuffer * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@CAXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@ABEII@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAPAPAVCGraphicVertexBuffer@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Uninitialized_move<CGraphicVertexBuffer * *,std::allocator<CGraphicVertexBuffer *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXPAPAVCGraphicVertexBuffer@@0@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicVertexBuffer@@@std@@QAEXQAPAVCGraphicVertexBuffer@@I@Z ; std::allocator<CGraphicVertexBuffer *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXQAPAVCGraphicVertexBuffer@@II@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_reallocate<CGraphicVertexBuffer * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXABQAVCGraphicVertexBuffer@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXABQAVCGraphicVertexBuffer@@@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_back_with_unused_capacity<CGraphicVertexBuffer * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXABQAVCGraphicVertexBuffer@@@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_back_with_unused_capacity<CGraphicVertexBuffer * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::emplace_back<CGraphicVertexBuffer * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXABQAVCGraphicVertexBuffer@@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_back_with_unused_capacity<CGraphicVertexBuffer * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEPAPAVCGraphicVertexBuffer@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Emplace_reallocate<CGraphicVertexBuffer * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::emplace_back<CGraphicVertexBuffer * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\ModelInstance.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
_TEXT	SEGMENT
__ULast$ = -80						; size = 8
__UFirst$ = -72						; size = 8
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_pModelInstance$ = -56					; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
tv187 = -40						; size = 4
tv192 = -36						; size = 4
$T7 = -32						; size = 4
tv174 = -28						; size = 4
$T8 = -24						; size = 4
tv148 = -20						; size = 4
$T9 = -15						; size = 1
$T10 = -14						; size = 1
$T11 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Func$ = 32						; size = 1
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z PROC ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FDestroyDeviceObjects>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 504  :         return {this->_Myoff, this->_Getcont()};

  0002c	8b 45 10	 mov	 eax, DWORD PTR __First$[ebp+8]
  0002f	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
  00032	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00035	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00038	83 7d 08 00	 cmp	 DWORD PTR __First$[ebp], 0
  0003c	74 0a		 je	 SHORT $LN17@for_each
  0003e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 ec	 mov	 DWORD PTR tv148[ebp], eax
  00046	eb 04		 jmp	 SHORT $LN18@for_each
$LN17@for_each:
  00048	83 65 ec 00	 and	 DWORD PTR tv148[ebp], 0
$LN18@for_each:
  0004c	8b 45 ec	 mov	 eax, DWORD PTR tv148[ebp]
  0004f	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00052	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp]
  00055	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  0005b	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax

; 504  :         return {this->_Myoff, this->_Getcont()};

  0005e	8b 45 1c	 mov	 eax, DWORD PTR __Last$[ebp+8]
  00061	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
  00064	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00067	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0006a	83 7d 14 00	 cmp	 DWORD PTR __Last$[ebp], 0
  0006e	74 0a		 je	 SHORT $LN33@for_each
  00070	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	89 45 e4	 mov	 DWORD PTR tv174[ebp], eax
  00078	eb 04		 jmp	 SHORT $LN34@for_each
$LN33@for_each:
  0007a	83 65 e4 00	 and	 DWORD PTR tv174[ebp], 0
$LN34@for_each:
  0007e	8b 45 e4	 mov	 eax, DWORD PTR tv174[ebp]
  00081	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00084	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00087	89 45 b0	 mov	 DWORD PTR __ULast$[ebp], eax
  0008a	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR __ULast$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00090	eb 07		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 65   :         ++_Myoff;

  00092	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  00095	40		 inc	 eax
  00096	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax
$LN4@for_each:

; 115  :         return _Myoff == _Right._Myoff;

  00099	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  0009c	3b 45 b4	 cmp	 eax, DWORD PTR __ULast$[ebp+4]
  0009f	75 09		 jne	 SHORT $LN55@for_each
  000a1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  000a8	eb 04		 jmp	 SHORT $LN56@for_each
$LN55@for_each:
  000aa	83 65 dc 00	 and	 DWORD PTR tv192[ebp], 0
$LN56@for_each:
  000ae	8a 45 dc	 mov	 al, BYTE PTR tv192[ebp]
  000b1	88 45 f3	 mov	 BYTE PTR $T11[ebp], al

; 119  :         return !(*this == _Right);

  000b4	0f b6 45 f3	 movzx	 eax, BYTE PTR $T11[ebp]
  000b8	85 c0		 test	 eax, eax
  000ba	75 09		 jne	 SHORT $LN50@for_each
  000bc	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv187[ebp], 1
  000c3	eb 04		 jmp	 SHORT $LN51@for_each
$LN50@for_each:
  000c5	83 65 d8 00	 and	 DWORD PTR tv187[ebp], 0
$LN51@for_each:
  000c9	8a 45 d8	 mov	 al, BYTE PTR tv187[ebp]
  000cc	88 45 f2	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  000cf	0f b6 45 f2	 movzx	 eax, BYTE PTR $T10[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	74 1d		 je	 SHORT $LN3@for_each
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 171  :         return const_cast<reference>(_Mybase::operator*());

  000d7	8d 4d b8	 lea	 ecx, DWORD PTR __UFirst$[ebp]
  000da	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000df	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 308  :         _Func(*_UFirst);

  000e2	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000e5	8b 00		 mov	 eax, DWORD PTR [eax]
  000e7	89 45 c8	 mov	 DWORD PTR _pModelInstance$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\ModelInstance.h

; 36   : 			{pModelInstance->DestroyDeviceObjects();}

  000ea	8b 4d c8	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  000ed	e8 00 00 00 00	 call	 ?DestroyDeviceObjects@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::DestroyDeviceObjects
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 309  :     }

  000f2	eb 9e		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  000f4	8a 45 20	 mov	 al, BYTE PTR __Func$[ebp]
  000f7	88 45 f1	 mov	 BYTE PTR $T9[ebp], al
  000fa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fe	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8a 45 f1	 mov	 al, BYTE PTR $T9[ebp]

; 312  : }

  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010f	59		 pop	 ecx
  00110	c9		 leave
  00111	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ENDP ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FDestroyDeviceObjects>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\ModelInstance.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
_TEXT	SEGMENT
__ULast$ = -80						; size = 8
__UFirst$ = -72						; size = 8
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_pModelInstance$ = -56					; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
tv187 = -40						; size = 4
tv192 = -36						; size = 4
$T7 = -32						; size = 4
tv174 = -28						; size = 4
$T8 = -24						; size = 4
tv148 = -20						; size = 4
$T9 = -15						; size = 1
$T10 = -14						; size = 1
$T11 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Func$ = 32						; size = 1
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z PROC ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FCreateDeviceObjects>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 504  :         return {this->_Myoff, this->_Getcont()};

  0002c	8b 45 10	 mov	 eax, DWORD PTR __First$[ebp+8]
  0002f	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax
  00032	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00035	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00038	83 7d 08 00	 cmp	 DWORD PTR __First$[ebp], 0
  0003c	74 0a		 je	 SHORT $LN17@for_each
  0003e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 ec	 mov	 DWORD PTR tv148[ebp], eax
  00046	eb 04		 jmp	 SHORT $LN18@for_each
$LN17@for_each:
  00048	83 65 ec 00	 and	 DWORD PTR tv148[ebp], 0
$LN18@for_each:
  0004c	8b 45 ec	 mov	 eax, DWORD PTR tv148[ebp]
  0004f	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00052	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp]
  00055	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  0005b	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax

; 504  :         return {this->_Myoff, this->_Getcont()};

  0005e	8b 45 1c	 mov	 eax, DWORD PTR __Last$[ebp+8]
  00061	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
  00064	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00067	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0006a	83 7d 14 00	 cmp	 DWORD PTR __Last$[ebp], 0
  0006e	74 0a		 je	 SHORT $LN33@for_each
  00070	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	89 45 e4	 mov	 DWORD PTR tv174[ebp], eax
  00078	eb 04		 jmp	 SHORT $LN34@for_each
$LN33@for_each:
  0007a	83 65 e4 00	 and	 DWORD PTR tv174[ebp], 0
$LN34@for_each:
  0007e	8b 45 e4	 mov	 eax, DWORD PTR tv174[ebp]
  00081	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00084	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00087	89 45 b0	 mov	 DWORD PTR __ULast$[ebp], eax
  0008a	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR __ULast$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00090	eb 07		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 65   :         ++_Myoff;

  00092	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  00095	40		 inc	 eax
  00096	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax
$LN4@for_each:

; 115  :         return _Myoff == _Right._Myoff;

  00099	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  0009c	3b 45 b4	 cmp	 eax, DWORD PTR __ULast$[ebp+4]
  0009f	75 09		 jne	 SHORT $LN55@for_each
  000a1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  000a8	eb 04		 jmp	 SHORT $LN56@for_each
$LN55@for_each:
  000aa	83 65 dc 00	 and	 DWORD PTR tv192[ebp], 0
$LN56@for_each:
  000ae	8a 45 dc	 mov	 al, BYTE PTR tv192[ebp]
  000b1	88 45 f3	 mov	 BYTE PTR $T11[ebp], al

; 119  :         return !(*this == _Right);

  000b4	0f b6 45 f3	 movzx	 eax, BYTE PTR $T11[ebp]
  000b8	85 c0		 test	 eax, eax
  000ba	75 09		 jne	 SHORT $LN50@for_each
  000bc	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv187[ebp], 1
  000c3	eb 04		 jmp	 SHORT $LN51@for_each
$LN50@for_each:
  000c5	83 65 d8 00	 and	 DWORD PTR tv187[ebp], 0
$LN51@for_each:
  000c9	8a 45 d8	 mov	 al, BYTE PTR tv187[ebp]
  000cc	88 45 f2	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  000cf	0f b6 45 f2	 movzx	 eax, BYTE PTR $T10[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	74 1d		 je	 SHORT $LN3@for_each
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 171  :         return const_cast<reference>(_Mybase::operator*());

  000d7	8d 4d b8	 lea	 ecx, DWORD PTR __UFirst$[ebp]
  000da	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000df	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 308  :         _Func(*_UFirst);

  000e2	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000e5	8b 00		 mov	 eax, DWORD PTR [eax]
  000e7	89 45 c8	 mov	 DWORD PTR _pModelInstance$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\ModelInstance.h

; 30   : 			{pModelInstance->CreateDeviceObjects();}

  000ea	8b 4d c8	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  000ed	e8 00 00 00 00	 call	 ?CreateDeviceObjects@CGrannyModelInstance@@QAE_NXZ ; CGrannyModelInstance::CreateDeviceObjects
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 309  :     }

  000f2	eb 9e		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  000f4	8a 45 20	 mov	 al, BYTE PTR __Func$[ebp]
  000f7	88 45 f1	 mov	 BYTE PTR $T9[ebp], al
  000fa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fe	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8a 45 f1	 mov	 al, BYTE PTR $T9[ebp]

; 312  : }

  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010f	59		 pop	 ecx
  00110	c9		 leave
  00111	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ENDP ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FCreateDeviceObjects>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -80						; size = 8
__UFirst$ = -72						; size = 8
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
tv186 = -40						; size = 4
tv191 = -36						; size = 4
$T8 = -32						; size = 4
tv173 = -28						; size = 4
$T9 = -24						; size = 4
tv147 = -20						; size = 4
$T10 = -14						; size = 1
$T11 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Func$ = 32						; size = 4
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,void (__cdecl*)(CGrannyModelInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 504  :         return {this->_Myoff, this->_Getcont()};

  0002c	8b 45 10	 mov	 eax, DWORD PTR __First$[ebp+8]
  0002f	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
  00032	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00035	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00038	83 7d 08 00	 cmp	 DWORD PTR __First$[ebp], 0
  0003c	74 0a		 je	 SHORT $LN17@for_each
  0003e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 ec	 mov	 DWORD PTR tv147[ebp], eax
  00046	eb 04		 jmp	 SHORT $LN18@for_each
$LN17@for_each:
  00048	83 65 ec 00	 and	 DWORD PTR tv147[ebp], 0
$LN18@for_each:
  0004c	8b 45 ec	 mov	 eax, DWORD PTR tv147[ebp]
  0004f	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00052	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  00055	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
  00058	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  0005b	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax

; 504  :         return {this->_Myoff, this->_Getcont()};

  0005e	8b 45 1c	 mov	 eax, DWORD PTR __Last$[ebp+8]
  00061	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  00064	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00067	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  0006a	83 7d 14 00	 cmp	 DWORD PTR __Last$[ebp], 0
  0006e	74 0a		 je	 SHORT $LN33@for_each
  00070	8b 45 14	 mov	 eax, DWORD PTR __Last$[ebp]
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
  00075	89 45 e4	 mov	 DWORD PTR tv173[ebp], eax
  00078	eb 04		 jmp	 SHORT $LN34@for_each
$LN33@for_each:
  0007a	83 65 e4 00	 and	 DWORD PTR tv173[ebp], 0
$LN34@for_each:
  0007e	8b 45 e4	 mov	 eax, DWORD PTR tv173[ebp]
  00081	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00084	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00087	89 45 b0	 mov	 DWORD PTR __ULast$[ebp], eax
  0008a	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR __ULast$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00090	eb 07		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 65   :         ++_Myoff;

  00092	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  00095	40		 inc	 eax
  00096	89 45 bc	 mov	 DWORD PTR __UFirst$[ebp+4], eax
$LN4@for_each:

; 115  :         return _Myoff == _Right._Myoff;

  00099	8b 45 bc	 mov	 eax, DWORD PTR __UFirst$[ebp+4]
  0009c	3b 45 b4	 cmp	 eax, DWORD PTR __ULast$[ebp+4]
  0009f	75 09		 jne	 SHORT $LN55@for_each
  000a1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  000a8	eb 04		 jmp	 SHORT $LN56@for_each
$LN55@for_each:
  000aa	83 65 dc 00	 and	 DWORD PTR tv191[ebp], 0
$LN56@for_each:
  000ae	8a 45 dc	 mov	 al, BYTE PTR tv191[ebp]
  000b1	88 45 f3	 mov	 BYTE PTR $T11[ebp], al

; 119  :         return !(*this == _Right);

  000b4	0f b6 45 f3	 movzx	 eax, BYTE PTR $T11[ebp]
  000b8	85 c0		 test	 eax, eax
  000ba	75 09		 jne	 SHORT $LN50@for_each
  000bc	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv186[ebp], 1
  000c3	eb 04		 jmp	 SHORT $LN51@for_each
$LN50@for_each:
  000c5	83 65 d8 00	 and	 DWORD PTR tv186[ebp], 0
$LN51@for_each:
  000c9	8a 45 d8	 mov	 al, BYTE PTR tv186[ebp]
  000cc	88 45 f2	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  000cf	0f b6 45 f2	 movzx	 eax, BYTE PTR $T10[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	74 16		 je	 SHORT $LN3@for_each
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 171  :         return const_cast<reference>(_Mybase::operator*());

  000d7	8d 4d b8	 lea	 ecx, DWORD PTR __UFirst$[ebp]
  000da	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000df	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 308  :         _Func(*_UFirst);

  000e2	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  000e5	ff 30		 push	 DWORD PTR [eax]
  000e7	ff 55 20	 call	 DWORD PTR __Func$[ebp]
  000ea	59		 pop	 ecx

; 309  :     }

  000eb	eb a5		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  000ed	8b 45 20	 mov	 eax, DWORD PTR __Func$[ebp]
  000f0	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000f3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000fb	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]

; 312  : }

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00101	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00108	59		 pop	 ecx
  00109	c9		 leave
  0010a	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z$1:
  00008	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,void (__cdecl*)(CGrannyModelInstance *)>
; Function compile flags: /Odspy
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Parent_proxy$1 = -12					; size = 4
__Parent$ = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1133 :         if (_Myproxy != _Right._Myproxy) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00013	74 38		 je	 SHORT $LN7@operator

; 1134 :             if (_Right._Myproxy) {

  00015	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00018	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001b	74 2a		 je	 SHORT $LN5@operator

; 1135 :                 _Adopt(_Right._Myproxy->_Mycont);

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	89 45 f8	 mov	 DWORD PTR __Parent$[ebp], eax

; 1157 :         if (_Parent) {

  00027	83 7d f8 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  0002b	74 12		 je	 SHORT $LN10@operator

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Parent$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 f4	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  0003d	eb 06		 jmp	 SHORT $LN12@operator
$LN10@operator:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 20 00	 and	 DWORD PTR [eax], 0
$LN12@operator:

; 1136 :             } else { // becoming invalid, disown current parent

  00045	eb 06		 jmp	 SHORT $LN7@operator
$LN5@operator:

; 1137 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1138 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1139 :                 _Orphan_me();
; 1140 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1141 :                 _Myproxy = nullptr;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 20 00	 and	 DWORD PTR [eax], 0
$LN7@operator:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00053	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00056	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ
_TEXT	SEGMENT
__Off$ = -24						; size = 4
__Block$ = -20						; size = 4
__Off$ = -16						; size = 4
__Mycont$ = -12						; size = 4
tv89 = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*, COMDAT
; _this$ = ecx

; 260  :     _NODISCARD reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 0c		 je	 SHORT $LN5@operator
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN6@operator
$LN5@operator:
  0001d	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN6@operator:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00024	89 45 f4	 mov	 DWORD PTR __Mycont$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 268  :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	89 45 f0	 mov	 DWORD PTR __Off$[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00030	8b 45 f0	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	c1 e8 02	 shr	 eax, 2
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00039	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003c	49		 dec	 ecx
  0003d	23 c1		 and	 eax, ecx
  0003f	89 45 ec	 mov	 DWORD PTR __Block$[ebp], eax

; 269  :         _Size_type _Off   = _Myoff % _DEQUESIZ;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	33 d2		 xor	 edx, edx
  0004a	6a 04		 push	 4
  0004c	59		 pop	 ecx
  0004d	f7 f1		 div	 ecx
  0004f	89 55 e8	 mov	 DWORD PTR __Off$[ebp], edx

; 270  :         return _Mycont->_Map[_Block][_Off];

  00052	8b 45 f4	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	8b 4d ec	 mov	 ecx, DWORD PTR __Block$[ebp]
  0005b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0005e	8b 4d e8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00061	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 271  :     }

  00064	c9		 leave
  00065	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -8					; size = 4
_this$ = -4						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >, COMDAT
; _this$ = ecx

; 252  :     _Deque_const_iterator() noexcept : _Myoff(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 20 00	 and	 DWORD PTR [eax], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 252  :     _Deque_const_iterator() noexcept : _Myoff(0) {

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  0001c	33 c0		 xor	 eax, eax
  0001e	74 11		 je	 SHORT $LN10@Deque_cons

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00020	33 c0		 xor	 eax, eax
  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	89 45 f8	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  0002d	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  0002f	eb 06		 jmp	 SHORT $LN1@Deque_cons
$LN10@Deque_cons:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 20 00	 and	 DWORD PTR [eax], 0
$LN1@Deque_cons:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 254  :     }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c9		 leave
  0003b	c3		 ret	 0
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?GrannyDestroySharedDeformBuffer@@YAXXZ
_TEXT	SEGMENT
$T1 = -84						; size = 4
$T2 = -80						; size = 4
tv135 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
___param0$ = -56					; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
___param0$ = -44					; size = 4
_pkEachVB$9 = -40					; size = 4
tv187 = -36						; size = 4
tv201 = -32						; size = 4
__My_data$10 = -28					; size = 4
__My_data$11 = -24					; size = 4
_vbs$12 = -20						; size = 4
$T13 = -16						; size = 4
_i$14 = -12						; size = 4
_v$15 = -8						; size = 4
$T16 = -2						; size = 1
$T17 = -1						; size = 1
?GrannyDestroySharedDeformBuffer@@YAXXZ PROC		; GrannyDestroySharedDeformBuffer, COMDAT

; 123  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H

; 124  : #ifdef _DEBUG
; 125  : 	TraceError("granny_shared_vbs:");
; 126  : #endif
; 127  : 	for (int i = 0; i != SHARED_VB_NUM; ++i)

  00006	83 65 f4 00	 and	 DWORD PTR _i$14[ebp], 0
  0000a	eb 07		 jmp	 SHORT $LN4@GrannyDest
$LN2@GrannyDest:
  0000c	8b 45 f4	 mov	 eax, DWORD PTR _i$14[ebp]
  0000f	40		 inc	 eax
  00010	89 45 f4	 mov	 DWORD PTR _i$14[ebp], eax
$LN4@GrannyDest:
  00013	83 7d f4 09	 cmp	 DWORD PTR _i$14[ebp], 9
  00017	0f 84 f3 00 00
	00		 je	 $LN1@GrannyDest

; 128  : 	{	
; 129  : 		std::vector<CGraphicVertexBuffer*>& vbs = gs_vbs[i];

  0001d	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$14[ebp], 12
  00021	05 00 00 00 00	 add	 eax, OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
  00026	89 45 ec	 mov	 DWORD PTR _vbs$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00029	83 65 f8 00	 and	 DWORD PTR _v$15[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR _vbs$12[ebp]
  00030	89 45 e8	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	8b 45 e8	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00036	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00039	8b 45 e8	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00041	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00044	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00047	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  0004a	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 135  : 		for (v = vbs.begin(); v != vbs.end(); ++v)

  0004d	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	89 45 f8	 mov	 DWORD PTR _v$15[ebp], eax
  00055	eb 09		 jmp	 SHORT $LN7@GrannyDest
$LN5@GrannyDest:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00057	8b 45 f8	 mov	 eax, DWORD PTR _v$15[ebp]
  0005a	83 c0 04	 add	 eax, 4
  0005d	89 45 f8	 mov	 DWORD PTR _v$15[ebp], eax
$LN7@GrannyDest:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00060	8b 45 ec	 mov	 eax, DWORD PTR _vbs$12[ebp]
  00063	89 45 e4	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00066	8b 45 e4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00069	89 45 ac	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0006c	8b 45 e4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0006f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00072	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00075	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00078	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0007b	8d 45 c4	 lea	 eax, DWORD PTR $T6[ebp]
  0007e	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00081	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  00084	8b 4d f8	 mov	 ecx, DWORD PTR _v$15[ebp]
  00087	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00089	75 09		 jne	 SHORT $LN60@GrannyDest
  0008b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv201[ebp], 1
  00092	eb 04		 jmp	 SHORT $LN61@GrannyDest
$LN60@GrannyDest:
  00094	83 65 e0 00	 and	 DWORD PTR tv201[ebp], 0
$LN61@GrannyDest:
  00098	8a 45 e0	 mov	 al, BYTE PTR tv201[ebp]
  0009b	88 45 ff	 mov	 BYTE PTR $T17[ebp], al

; 153  :         return !(*this == _Right);

  0009e	0f b6 45 ff	 movzx	 eax, BYTE PTR $T17[ebp]
  000a2	85 c0		 test	 eax, eax
  000a4	75 09		 jne	 SHORT $LN55@GrannyDest
  000a6	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv187[ebp], 1
  000ad	eb 04		 jmp	 SHORT $LN56@GrannyDest
$LN55@GrannyDest:
  000af	83 65 dc 00	 and	 DWORD PTR tv187[ebp], 0
$LN56@GrannyDest:
  000b3	8a 45 dc	 mov	 al, BYTE PTR tv187[ebp]
  000b6	88 45 fe	 mov	 BYTE PTR $T16[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 135  : 		for (v = vbs.begin(); v != vbs.end(); ++v)

  000b9	0f b6 45 fe	 movzx	 eax, BYTE PTR $T16[ebp]
  000bd	85 c0		 test	 eax, eax
  000bf	74 42		 je	 SHORT $LN6@GrannyDest
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _v$15[ebp]
  000c4	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000c7	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000ca	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 137  : 			CGraphicVertexBuffer* pkEachVB = (*v);

  000cd	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  000d0	8b 00		 mov	 eax, DWORD PTR [eax]
  000d2	89 45 d8	 mov	 DWORD PTR _pkEachVB$9[ebp], eax

; 138  : 			pkEachVB->Destroy();

  000d5	8b 4d d8	 mov	 ecx, DWORD PTR _pkEachVB$9[ebp]
  000d8	e8 00 00 00 00	 call	 ?Destroy@CGraphicVertexBuffer@@QAEXXZ ; CGraphicVertexBuffer::Destroy

; 139  : 			delete pkEachVB;

  000dd	8b 45 d8	 mov	 eax, DWORD PTR _pkEachVB$9[ebp]
  000e0	89 45 f0	 mov	 DWORD PTR $T13[ebp], eax
  000e3	83 7d f0 00	 cmp	 DWORD PTR $T13[ebp], 0
  000e7	74 11		 je	 SHORT $LN9@GrannyDest
  000e9	6a 01		 push	 1
  000eb	8b 45 f0	 mov	 eax, DWORD PTR $T13[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR $T13[ebp]
  000f3	ff 10		 call	 DWORD PTR [eax]
  000f5	89 45 b4	 mov	 DWORD PTR tv135[ebp], eax
  000f8	eb 04		 jmp	 SHORT $LN10@GrannyDest
$LN9@GrannyDest:
  000fa	83 65 b4 00	 and	 DWORD PTR tv135[ebp], 0
$LN10@GrannyDest:

; 140  : 		}

  000fe	e9 54 ff ff ff	 jmp	 $LN5@GrannyDest
$LN6@GrannyDest:

; 141  : 		vbs.clear();

  00103	8b 4d ec	 mov	 ecx, DWORD PTR _vbs$12[ebp]
  00106	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::clear

; 142  : 	}

  0010b	e9 fc fe ff ff	 jmp	 $LN2@GrannyDest
$LN1@GrannyDest:

; 143  : 	
; 144  : }

  00110	c9		 leave
  00111	c3		 ret	 0
?GrannyDestroySharedDeformBuffer@@YAXXZ ENDP		; GrannyDestroySharedDeformBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?GrannyCreateSharedDeformBuffer@@YAXXZ
_TEXT	SEGMENT
?GrannyCreateSharedDeformBuffer@@YAXXZ PROC		; GrannyCreateSharedDeformBuffer, COMDAT

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 115  : 	__ReserveSharedVertexBuffers(SHARED_VB_500, 40);

  00003	6a 28		 push	 40			; 00000028H
  00005	6a 00		 push	 0
  00007	e8 00 00 00 00	 call	 ?__ReserveSharedVertexBuffers@@YAXII@Z ; __ReserveSharedVertexBuffers
  0000c	59		 pop	 ecx
  0000d	59		 pop	 ecx

; 116  : 	__ReserveSharedVertexBuffers(SHARED_VB_1000, 20);

  0000e	6a 14		 push	 20			; 00000014H
  00010	6a 01		 push	 1
  00012	e8 00 00 00 00	 call	 ?__ReserveSharedVertexBuffers@@YAXII@Z ; __ReserveSharedVertexBuffers
  00017	59		 pop	 ecx
  00018	59		 pop	 ecx

; 117  : 	__ReserveSharedVertexBuffers(SHARED_VB_1500, 20);

  00019	6a 14		 push	 20			; 00000014H
  0001b	6a 02		 push	 2
  0001d	e8 00 00 00 00	 call	 ?__ReserveSharedVertexBuffers@@YAXII@Z ; __ReserveSharedVertexBuffers
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx

; 118  : 	__ReserveSharedVertexBuffers(SHARED_VB_2000, 40);

  00024	6a 28		 push	 40			; 00000028H
  00026	6a 03		 push	 3
  00028	e8 00 00 00 00	 call	 ?__ReserveSharedVertexBuffers@@YAXII@Z ; __ReserveSharedVertexBuffers
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx

; 119  : 	__ReserveSharedVertexBuffers(SHARED_VB_3000, 20);

  0002f	6a 14		 push	 20			; 00000014H
  00031	6a 05		 push	 5
  00033	e8 00 00 00 00	 call	 ?__ReserveSharedVertexBuffers@@YAXII@Z ; __ReserveSharedVertexBuffers
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx

; 120  : }

  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?GrannyCreateSharedDeformBuffer@@YAXXZ ENDP		; GrannyCreateSharedDeformBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?__ReserveSharedVertexBuffers@@YAXII@Z
_TEXT	SEGMENT
_capacity$ = -36					; size = 4
$T2 = -32						; size = 4
tv80 = -28						; size = 4
$T3 = -24						; size = 4
_pkNewVB$4 = -20					; size = 4
_i$5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_index$ = 8						; size = 4
_count$ = 12						; size = 4
?__ReserveSharedVertexBuffers@@YAXII@Z PROC		; __ReserveSharedVertexBuffers, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__ReserveSharedVertexBuffers@@YAXII@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 94   : 	NANOBEGIN

  00028	eb		 DB	 -21			; ffffffebH
  00029	03		 DB	 3
  0002a	d6		 DB	 -42			; ffffffd6H
  0002b	d7		 DB	 -41			; ffffffd7H
  0002c	01		 DB	 1
  0002d	83 7d 08 09	 cmp	 DWORD PTR _index$[ebp], 9
  00031	72 05		 jb	 SHORT $LN5@ReserveSha

; 95   : 	if (index >= SHARED_VB_NUM)
; 96   : 		return;

  00033	e9 89 00 00 00	 jmp	 $LN1@ReserveSha
$LN5@ReserveSha:

; 97   : 
; 98   : 	unsigned capacity = (index + 1) * 500;

  00038	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0003b	40		 inc	 eax
  0003c	69 c0 f4 01 00
	00		 imul	 eax, eax, 500
  00042	89 45 dc	 mov	 DWORD PTR _capacity$[ebp], eax

; 99   : 
; 100  : 	for (unsigned i = 0; i != count; ++i)

  00045	83 65 f0 00	 and	 DWORD PTR _i$5[ebp], 0
  00049	eb 07		 jmp	 SHORT $LN4@ReserveSha
$LN2@ReserveSha:
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _i$5[ebp]
  0004e	40		 inc	 eax
  0004f	89 45 f0	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@ReserveSha:
  00052	8b 45 f0	 mov	 eax, DWORD PTR _i$5[ebp]
  00055	3b 45 0c	 cmp	 eax, DWORD PTR _count$[ebp]
  00058	74 62		 je	 SHORT $LN3@ReserveSha

; 101  : 	{
; 102  : 		CGraphicVertexBuffer* pkNewVB = new CGraphicVertexBuffer;

  0005a	6a 20		 push	 32			; 00000020H
  0005c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00061	59		 pop	 ecx
  00062	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  00065	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00069	83 7d e8 00	 cmp	 DWORD PTR $T3[ebp], 0
  0006d	74 0d		 je	 SHORT $LN7@ReserveSha
  0006f	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  00072	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  00077	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  0007a	eb 04		 jmp	 SHORT $LN8@ReserveSha
$LN7@ReserveSha:
  0007c	83 65 e4 00	 and	 DWORD PTR tv80[ebp], 0
$LN8@ReserveSha:
  00080	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  00083	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00086	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	89 45 ec	 mov	 DWORD PTR _pkNewVB$4[ebp], eax

; 103  : 		pkNewVB->Create(

  00090	6a 01		 push	 1
  00092	6a 08		 push	 8
  00094	68 12 01 00 00	 push	 274			; 00000112H
  00099	ff 75 dc	 push	 DWORD PTR _capacity$[ebp]
  0009c	8b 45 ec	 mov	 eax, DWORD PTR _pkNewVB$4[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR _pkNewVB$4[ebp]
  000a4	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  000a7	8d 45 ec	 lea	 eax, DWORD PTR _pkNewVB$4[ebp]
  000aa	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 108  : 		gs_vbs[index].push_back(pkNewVB);

  000ab	6b 4d 08 0c	 imul	 ecx, DWORD PTR _index$[ebp], 12
  000af	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  000b5	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::emplace_back<CGraphicVertexBuffer * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 109  : 	}

  000ba	eb 8f		 jmp	 SHORT $LN2@ReserveSha
$LN3@ReserveSha:

; 110  : 	NANOEND

  000bc	eb		 DB	 -21			; ffffffebH
  000bd	03		 DB	 3
  000be	d6		 DB	 -42			; ffffffd6H
  000bf	d7		 DB	 -41			; ffffffd7H
  000c0	00		 DB	 0
$LN1@ReserveSha:
  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cb	59		 pop	 ecx
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx
  000cf	c9		 leave
  000d0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__ReserveSharedVertexBuffers@@YAXII@Z$0:
  00000	6a 20		 push	 32			; 00000020H
  00002	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?__ReserveSharedVertexBuffers@@YAXII@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__ReserveSharedVertexBuffers@@YAXII@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__ReserveSharedVertexBuffers@@YAXII@Z ENDP		; __ReserveSharedVertexBuffers
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z
_TEXT	SEGMENT
tv86 = -12						; size = 4
_index$1 = -8						; size = 4
$T2 = -4						; size = 4
_pkDelVB$ = 8						; size = 4
?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z PROC ; __FreeDeformVertexBuffer, COMDAT

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 74   : 	if (pkDelVB)

  00006	83 7d 08 00	 cmp	 DWORD PTR _pkDelVB$[ebp], 0
  0000a	74 63		 je	 SHORT $LN1@FreeDeform

; 75   : 	{
; 76   : 		if (pkDelVB == &gs_emptyVB)

  0000c	81 7d 08 00 00
	00 00		 cmp	 DWORD PTR _pkDelVB$[ebp], OFFSET ?gs_emptyVB@@3VCGraphicVertexBuffer@@A
  00013	75 02		 jne	 SHORT $LN3@FreeDeform

; 77   : 			return;

  00015	eb 58		 jmp	 SHORT $LN1@FreeDeform
$LN3@FreeDeform:

; 78   : 
; 79   : 		unsigned index = (pkDelVB->GetVertexCount() - 1) / 500;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pkDelVB$[ebp]
  0001a	e8 00 00 00 00	 call	 ?GetVertexCount@CGraphicVertexBuffer@@QBEHXZ ; CGraphicVertexBuffer::GetVertexCount
  0001f	48		 dec	 eax
  00020	99		 cdq
  00021	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00026	f7 f9		 idiv	 ecx
  00028	89 45 f8	 mov	 DWORD PTR _index$1[ebp], eax

; 80   : 		if (index < SHARED_VB_NUM)

  0002b	83 7d f8 09	 cmp	 DWORD PTR _index$1[ebp], 9
  0002f	73 15		 jae	 SHORT $LN4@FreeDeform
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00031	8d 45 08	 lea	 eax, DWORD PTR _pkDelVB$[ebp]
  00034	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 82   : 			gs_vbs[index].push_back(pkDelVB);			

  00035	6b 4d f8 0c	 imul	 ecx, DWORD PTR _index$1[ebp], 12
  00039	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0003f	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicVertexBuffer@@@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXABQAVCGraphicVertexBuffer@@@Z ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::emplace_back<CGraphicVertexBuffer * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 83   : 		}

  00044	eb 29		 jmp	 SHORT $LN1@FreeDeform
$LN4@FreeDeform:

; 84   : 		else
; 85   : 		{
; 86   : 			pkDelVB->Destroy();

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _pkDelVB$[ebp]
  00049	e8 00 00 00 00	 call	 ?Destroy@CGraphicVertexBuffer@@QAEXXZ ; CGraphicVertexBuffer::Destroy

; 87   : 			delete pkDelVB;

  0004e	8b 45 08	 mov	 eax, DWORD PTR _pkDelVB$[ebp]
  00051	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00054	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  00058	74 11		 je	 SHORT $LN7@FreeDeform
  0005a	6a 01		 push	 1
  0005c	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00064	ff 10		 call	 DWORD PTR [eax]
  00066	89 45 f4	 mov	 DWORD PTR tv86[ebp], eax
  00069	eb 04		 jmp	 SHORT $LN1@FreeDeform
$LN7@FreeDeform:
  0006b	83 65 f4 00	 and	 DWORD PTR tv86[ebp], 0
$LN1@FreeDeform:

; 88   : 		}
; 89   : 	}
; 90   : }

  0006f	c9		 leave
  00070	c3		 ret	 0
?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z ENDP ; __FreeDeformVertexBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z
_TEXT	SEGMENT
$T2 = -96						; size = 8
$T3 = -88						; size = 4
$T4 = -84						; size = 4
$T5 = -80						; size = 4
_pkRetVB$6 = -76					; size = 4
$T7 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$8 = -64					; size = 4
$T9 = -60						; size = 4
__My_data$10 = -56					; size = 4
_capacity$ = -52					; size = 4
tv133 = -48						; size = 4
$T11 = -44						; size = 4
tv157 = -40						; size = 4
__My_data$12 = -36					; size = 4
_index$ = -32						; size = 4
_pkNewVB$ = -28						; size = 4
__Mylast$13 = -24					; size = 4
_vbs$14 = -20						; size = 4
$T15 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_deformableVertexCount$ = 8				; size = 4
?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z PROC ; __AllocDeformVertexBuffer, COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 36   : 	if (deformableVertexCount == 0)

  00025	83 7d 08 00	 cmp	 DWORD PTR _deformableVertexCount$[ebp], 0
  00029	75 0a		 jne	 SHORT $LN3@AllocDefor

; 37   : 		return &gs_emptyVB;

  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_emptyVB@@3VCGraphicVertexBuffer@@A
  00030	e9 a4 01 00 00	 jmp	 $LN1@AllocDefor
$LN3@AllocDefor:

; 38   : 
; 39   : 	unsigned capacity	= (((deformableVertexCount-1) / 500) + 1) * 500;

  00035	8b 45 08	 mov	 eax, DWORD PTR _deformableVertexCount$[ebp]
  00038	48		 dec	 eax
  00039	33 d2		 xor	 edx, edx
  0003b	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00040	f7 f1		 div	 ecx
  00042	40		 inc	 eax
  00043	69 c0 f4 01 00
	00		 imul	 eax, eax, 500
  00049	89 45 cc	 mov	 DWORD PTR _capacity$[ebp], eax

; 40   : 	unsigned index		= (deformableVertexCount-1) / 500;	

  0004c	8b 45 08	 mov	 eax, DWORD PTR _deformableVertexCount$[ebp]
  0004f	48		 dec	 eax
  00050	33 d2		 xor	 edx, edx
  00052	b9 f4 01 00 00	 mov	 ecx, 500		; 000001f4H
  00057	f7 f1		 div	 ecx
  00059	89 45 e0	 mov	 DWORD PTR _index$[ebp], eax

; 41   : 	if (index < SHARED_VB_NUM)

  0005c	83 7d e0 09	 cmp	 DWORD PTR _index$[ebp], 9
  00060	0f 83 98 00 00
	00		 jae	 $LN4@AllocDefor

; 42   : 	{	
; 43   : 		std::vector<CGraphicVertexBuffer*>& vbs = gs_vbs[index];

  00066	6b 45 e0 0c	 imul	 eax, DWORD PTR _index$[ebp], 12
  0006a	05 00 00 00 00	 add	 eax, OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
  0006f	89 45 ec	 mov	 DWORD PTR _vbs$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00072	8b 45 ec	 mov	 eax, DWORD PTR _vbs$14[ebp]
  00075	89 45 dc	 mov	 DWORD PTR __My_data$12[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00078	8b 45 dc	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0007b	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$12[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00083	75 09		 jne	 SHORT $LN13@AllocDefor
  00085	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv157[ebp], 1
  0008c	eb 04		 jmp	 SHORT $LN14@AllocDefor
$LN13@AllocDefor:
  0008e	83 65 d8 00	 and	 DWORD PTR tv157[ebp], 0
$LN14@AllocDefor:
  00092	8a 45 d8	 mov	 al, BYTE PTR tv157[ebp]
  00095	88 45 f3	 mov	 BYTE PTR $T15[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 44   : 		if (!vbs.empty())

  00098	0f b6 45 f3	 movzx	 eax, BYTE PTR $T15[ebp]
  0009c	85 c0		 test	 eax, eax
  0009e	75 5e		 jne	 SHORT $LN4@AllocDefor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000a0	8b 45 ec	 mov	 eax, DWORD PTR _vbs$14[ebp]
  000a3	89 45 c8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000a6	6a 04		 push	 4
  000a8	58		 pop	 eax
  000a9	6b c0 ff	 imul	 eax, eax, -1
  000ac	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  000af	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000b2	89 45 c4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 48   : 			CGraphicVertexBuffer* pkRetVB = vbs.back();

  000b5	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 b4	 mov	 DWORD PTR _pkRetVB$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000bd	8b 45 ec	 mov	 eax, DWORD PTR _vbs$14[ebp]
  000c0	89 45 c0	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000c3	8b 45 c0	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000c6	83 c0 04	 add	 eax, 4
  000c9	89 45 e8	 mov	 DWORD PTR __Mylast$13[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000cc	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$13[ebp]
  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	83 e8 04	 sub	 eax, 4
  000d4	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000d7	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000da	89 45 ac	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _vbs$14[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e0	89 45 b8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000e3	8b 45 b8	 mov	 eax, DWORD PTR $T7[ebp]
  000e6	89 45 a8	 mov	 DWORD PTR $T3[ebp], eax

; 1338 :         --_Mylast;

  000e9	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$13[ebp]
  000ec	8b 00		 mov	 eax, DWORD PTR [eax]
  000ee	83 e8 04	 sub	 eax, 4
  000f1	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$13[ebp]
  000f4	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 50   : 			return pkRetVB;

  000f6	8b 45 b4	 mov	 eax, DWORD PTR _pkRetVB$6[ebp]
  000f9	e9 db 00 00 00	 jmp	 $LN1@AllocDefor
$LN4@AllocDefor:

; 55   : 	static time_t base = time(NULL);

  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00103	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0010a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0010d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA
  00113	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00119	7e 32		 jle	 SHORT $LN2@AllocDefor
  0011b	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA
  00120	e8 00 00 00 00	 call	 __Init_thread_header
  00125	59		 pop	 ecx
  00126	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA, -1
  0012d	75 1e		 jne	 SHORT $LN2@AllocDefor
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  0012f	6a 00		 push	 0
  00131	e8 00 00 00 00	 call	 __time64
  00136	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 55   : 	static time_t base = time(NULL);

  00137	a3 00 00 00 00	 mov	 DWORD PTR ?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA, eax
  0013c	89 15 04 00 00
	00		 mov	 DWORD PTR ?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA+4, edx
  00142	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4HA
  00147	e8 00 00 00 00	 call	 __Init_thread_footer
  0014c	59		 pop	 ecx
$LN2@AllocDefor:

; 56   : 	//TraceError("NEW %8d: %d(%d)", time(NULL) - base, capacity, deformableVertexCount);
; 57   : 
; 58   : 	CGraphicVertexBuffer* pkNewVB = new CGraphicVertexBuffer;

  0014d	6a 20		 push	 32			; 00000020H
  0014f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00154	59		 pop	 ecx
  00155	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
  00158	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0015c	83 7d d4 00	 cmp	 DWORD PTR $T11[ebp], 0
  00160	74 0d		 je	 SHORT $LN8@AllocDefor
  00162	8b 4d d4	 mov	 ecx, DWORD PTR $T11[ebp]
  00165	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  0016a	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  0016d	eb 04		 jmp	 SHORT $LN9@AllocDefor
$LN8@AllocDefor:
  0016f	83 65 d0 00	 and	 DWORD PTR tv133[ebp], 0
$LN9@AllocDefor:
  00173	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00176	89 45 b0	 mov	 DWORD PTR $T5[ebp], eax
  00179	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0017d	8b 45 b0	 mov	 eax, DWORD PTR $T5[ebp]
  00180	89 45 e4	 mov	 DWORD PTR _pkNewVB$[ebp], eax

; 59   : 
; 60   : 	if (!pkNewVB->Create(

  00183	6a 01		 push	 1
  00185	6a 08		 push	 8
  00187	68 12 01 00 00	 push	 274			; 00000112H
  0018c	ff 75 cc	 push	 DWORD PTR _capacity$[ebp]
  0018f	8b 45 e4	 mov	 eax, DWORD PTR _pkNewVB$[ebp]
  00192	8b 00		 mov	 eax, DWORD PTR [eax]
  00194	8b 4d e4	 mov	 ecx, DWORD PTR _pkNewVB$[ebp]
  00197	ff 50 04	 call	 DWORD PTR [eax+4]
  0019a	0f b6 c0	 movzx	 eax, al
  0019d	85 c0		 test	 eax, eax
  0019f	75 35		 jne	 SHORT $LN6@AllocDefor
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\time.h

; 536  :             return _time64(_Time);

  001a1	6a 00		 push	 0
  001a3	e8 00 00 00 00	 call	 __time64
  001a8	59		 pop	 ecx
  001a9	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
  001ac	89 55 a4	 mov	 DWORD PTR $T2[ebp+4], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 66   : 		TraceError("NEW_ERROR %8d: %d(%d)", time(NULL) - base, capacity, deformableVertexCount);

  001af	ff 75 08	 push	 DWORD PTR _deformableVertexCount$[ebp]
  001b2	ff 75 cc	 push	 DWORD PTR _capacity$[ebp]
  001b5	8b 45 a0	 mov	 eax, DWORD PTR $T2[ebp]
  001b8	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA
  001be	8b 4d a4	 mov	 ecx, DWORD PTR $T2[ebp+4]
  001c1	1b 0d 04 00 00
	00		 sbb	 ecx, DWORD PTR ?base@?1??__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z@4_JA+4
  001c7	51		 push	 ecx
  001c8	50		 push	 eax
  001c9	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IJPBENCD@NEW_ERROR?5?$CF8d?3?5?$CFd?$CI?$CFd?$CJ@
  001ce	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001d3	83 c4 14	 add	 esp, 20			; 00000014H
$LN6@AllocDefor:

; 67   : 	}
; 68   : 
; 69   : 	return pkNewVB;

  001d6	8b 45 e4	 mov	 eax, DWORD PTR _pkNewVB$[ebp]
$LN1@AllocDefor:

; 70   : }

  001d9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001dc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e3	59		 pop	 ecx
  001e4	c9		 leave
  001e5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z$0:
  00000	6a 20		 push	 32			; 00000020H
  00002	ff 75 d4	 push	 DWORD PTR $T11[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z ENDP ; __AllocDeformVertexBuffer
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_emptyVB@@YAXXZ
text$yd	SEGMENT
??__Fgs_emptyVB@@YAXXZ PROC				; `dynamic atexit destructor for 'gs_emptyVB'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_emptyVB@@3VCGraphicVertexBuffer@@A
  00008	e8 00 00 00 00	 call	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fgs_emptyVB@@YAXXZ ENDP				; `dynamic atexit destructor for 'gs_emptyVB''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ??__Egs_emptyVB@@YAXXZ
text$di	SEGMENT
??__Egs_emptyVB@@YAXXZ PROC				; `dynamic initializer for 'gs_emptyVB'', COMDAT

; 30   : static CGraphicVertexBuffer gs_emptyVB;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_emptyVB@@3VCGraphicVertexBuffer@@A
  00008	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  0000d	68 00 00 00 00	 push	 OFFSET ??__Fgs_emptyVB@@YAXXZ ; `dynamic atexit destructor for 'gs_emptyVB''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__Egs_emptyVB@@YAXXZ ENDP				; `dynamic initializer for 'gs_emptyVB''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fgs_vbs@@YAXXZ
text$yd	SEGMENT
??__Fgs_vbs@@YAXXZ PROC					; `dynamic atexit destructor for 'gs_vbs'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::~vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
  00008	6a 09		 push	 9
  0000a	6a 0c		 push	 12			; 0000000cH
  0000c	68 00 00 00 00	 push	 OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
  00011	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??__Fgs_vbs@@YAXXZ ENDP					; `dynamic atexit destructor for 'gs_vbs''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ??__Egs_vbs@@YAXXZ
text$di	SEGMENT
??__Egs_vbs@@YAXXZ PROC					; `dynamic initializer for 'gs_vbs'', COMDAT

; 28   : static std::vector<CGraphicVertexBuffer*> gs_vbs[SHARED_VB_NUM];

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET ??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::~vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
  00008	68 00 00 00 00	 push	 OFFSET ??0?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
  0000d	6a 09		 push	 9
  0000f	6a 0c		 push	 12			; 0000000cH
  00011	68 00 00 00 00	 push	 OFFSET ?gs_vbs@@3PAV?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@A
  00016	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  0001b	68 00 00 00 00	 push	 OFFSET ??__Fgs_vbs@@YAXXZ ; `dynamic atexit destructor for 'gs_vbs''
  00020	e8 00 00 00 00	 call	 _atexit
  00025	59		 pop	 ecx
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??__Egs_vbs@@YAXXZ ENDP					; `dynamic initializer for 'gs_vbs''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXQAPAVCGraphicVertexBuffer@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXQAPAVCGraphicVertexBuffer@@II@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXQAPAVCGraphicVertexBuffer@@II@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXPAPAVCGraphicVertexBuffer@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXPAPAVCGraphicVertexBuffer@@0@Z PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXPAPAVCGraphicVertexBuffer@@0@Z ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@YAXPAPAVCGraphicVertexBuffer@@QAPAV1@AAV?$allocator@PAVCGraphicVertexBuffer@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicVertexBuffer *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::~vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@AAEXXZ ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::~vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$vector@PAVCGraphicVertexBuffer@@V?$allocator@PAVCGraphicVertexBuffer@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >::vector<CGraphicVertexBuffer *,std::allocator<CGraphicVertexBuffer *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCGraphicVertexBuffer@@@std@@QAEXQAPAVCGraphicVertexBuffer@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicVertexBuffer@@@std@@QAEXQAPAVCGraphicVertexBuffer@@I@Z PROC ; std::allocator<CGraphicVertexBuffer *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicVertexBuffer@@@std@@QAEXQAPAVCGraphicVertexBuffer@@I@Z ENDP ; std::allocator<CGraphicVertexBuffer *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGrannyLODController@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGrannyLODController@@UAEPAXI@Z PROC		; CGrannyLODController::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGrannyLODController@@UAE@XZ ; CGrannyLODController::~CGrannyLODController
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 3c		 push	 60			; 0000003cH
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCGrannyLODController@@UAEPAXI@Z ENDP		; CGrannyLODController::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >, COMDAT
; _this$ = ecx

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1097 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
__Ptr$ = -100						; size = 4
__Count$ = -96						; size = 4
$T8 = -92						; size = 4
$T9 = -88						; size = 4
$T10 = -84						; size = 4
$T11 = -80						; size = 4
$T12 = -76						; size = 4
$T13 = -72						; size = 4
$T14 = -68						; size = 4
$T15 = -64						; size = 4
__Ptr$ = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
$T18 = -48						; size = 4
$T19 = -44						; size = 4
$T20 = -40						; size = 4
$T21 = -36						; size = 4
$T22 = -32						; size = 4
$T23 = -28						; size = 4
$T24 = -24						; size = 4
$T25 = -20						; size = 4
tv149 = -16						; size = 4
__Block$26 = -12					; size = 4
_this$ = -8						; size = 4
$T27 = -1						; size = 1
?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1469 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 88	 mov	 DWORD PTR $T3[ebp], eax

; 1522 :         return _Mypair._Get_first();

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00015	89 45 ec	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T25[ebp]
  0001b	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
$LN2@Tidy:

; 1534 :         return _Mypair._Myval2;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T24[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T24[ebp]
  00027	83 c0 10	 add	 eax, 16			; 00000010H
  0002a	89 45 e4	 mov	 DWORD PTR $T23[ebp], eax

; 1010 :         return _Mysize() == 0;

  0002d	8b 45 e4	 mov	 eax, DWORD PTR $T23[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 09		 jne	 SHORT $LN30@Tidy
  00035	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv149[ebp], 1
  0003c	eb 04		 jmp	 SHORT $LN31@Tidy
$LN30@Tidy:
  0003e	83 65 f0 00	 and	 DWORD PTR tv149[ebp], 0
$LN31@Tidy:
  00042	8a 45 f0	 mov	 al, BYTE PTR tv149[ebp]
  00045	88 45 ff	 mov	 BYTE PTR $T27[ebp], al

; 1470 :         _Orphan_all();
; 1471 : 
; 1472 :         _Alpty _Almap(_Getal());
; 1473 :         while (!empty()) {

  00048	0f b6 45 ff	 movzx	 eax, BYTE PTR $T27[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN3@Tidy

; 1474 :             pop_back();

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?pop_back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::pop_back

; 1475 :         }

  00058	eb c4		 jmp	 SHORT $LN2@Tidy
$LN3@Tidy:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 e0	 mov	 DWORD PTR $T22[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T22[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 dc	 mov	 DWORD PTR $T21[ebp], eax

; 1476 : 
; 1477 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00069	8b 45 dc	 mov	 eax, DWORD PTR $T21[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax
$LN6@Tidy:
  00071	83 7d f4 00	 cmp	 DWORD PTR __Block$26[ebp], 0
  00075	0f 86 84 00 00
	00		 jbe	 $LN5@Tidy

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Block$26[ebp]
  0007e	48		 dec	 eax
  0007f	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	89 45 d8	 mov	 DWORD PTR $T20[ebp], eax

; 1538 :         return _Get_data()._Map;

  00088	8b 45 d8	 mov	 eax, DWORD PTR $T20[ebp]
  0008b	83 c0 04	 add	 eax, 4
  0008e	89 45 d4	 mov	 DWORD PTR $T19[ebp], eax

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00091	8b 45 d4	 mov	 eax, DWORD PTR $T19[ebp]
  00094	8b 00		 mov	 eax, DWORD PTR [eax]
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  00099	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  0009d	74 5b		 je	 SHORT $LN7@Tidy

; 1530 :         return _Mypair._Myval2;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T18[ebp], eax

; 1538 :         return _Get_data()._Map;

  000a5	8b 45 d0	 mov	 eax, DWORD PTR $T18[ebp]
  000a8	83 c0 04	 add	 eax, 4
  000ab	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 1522 :         return _Mypair._Get_first();

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b1	89 45 cc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  000b4	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  000b7	89 45 80	 mov	 DWORD PTR $T1[ebp], eax

; 1479 :                 _Getal().deallocate(_Map()[_Block], _DEQUESIZ);

  000ba	8b 45 c8	 mov	 eax, DWORD PTR $T16[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000c2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000c5	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c8	6a 04		 push	 4
  000ca	58		 pop	 eax
  000cb	c1 e0 02	 shl	 eax, 2
  000ce	50		 push	 eax
  000cf	ff 75 c4	 push	 DWORD PTR __Ptr$[ebp]
  000d2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR $T15[ebp], eax

; 1538 :         return _Get_data()._Map;

  000df	8b 45 c0	 mov	 eax, DWORD PTR $T15[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 bc	 mov	 DWORD PTR $T14[ebp], eax

; 1480 :                 _Destroy_in_place(_Map()[_Block]);

  000e8	8b 45 bc	 mov	 eax, DWORD PTR $T14[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000f0	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAPAVCGrannyModelInstance@@@std@@YAXAAPAPAVCGrannyModelInstance@@@Z ; std::_Destroy_in_place<CGrannyModelInstance * *>
  000f9	59		 pop	 ecx
$LN7@Tidy:

; 1481 :             }
; 1482 :         }

  000fa	e9 72 ff ff ff	 jmp	 $LN6@Tidy
$LN5@Tidy:

; 1530 :         return _Mypair._Myval2;

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00102	89 45 b8	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00105	8b 45 b8	 mov	 eax, DWORD PTR $T13[ebp]
  00108	83 c0 04	 add	 eax, 4
  0010b	89 45 b4	 mov	 DWORD PTR $T12[ebp], eax

; 1483 : 
; 1484 :         if (_Map() != _Mapptr()) {

  0010e	8b 45 b4	 mov	 eax, DWORD PTR $T12[ebp]
  00111	83 38 00	 cmp	 DWORD PTR [eax], 0
  00114	74 3f		 je	 SHORT $LN8@Tidy

; 1530 :         return _Mypair._Myval2;

  00116	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	89 45 b0	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0011c	8b 45 b0	 mov	 eax, DWORD PTR $T11[ebp]
  0011f	83 c0 08	 add	 eax, 8
  00122	89 45 a8	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00128	89 45 ac	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  0012b	8b 45 ac	 mov	 eax, DWORD PTR $T10[ebp]
  0012e	83 c0 04	 add	 eax, 4
  00131	89 45 a4	 mov	 DWORD PTR $T8[ebp], eax

; 1485 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for map

  00134	8b 45 a8	 mov	 eax, DWORD PTR $T9[ebp]
  00137	8b 00		 mov	 eax, DWORD PTR [eax]
  00139	89 45 a0	 mov	 DWORD PTR __Count$[ebp], eax
  0013c	8b 45 a4	 mov	 eax, DWORD PTR $T8[ebp]
  0013f	8b 00		 mov	 eax, DWORD PTR [eax]
  00141	89 45 9c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00144	8b 45 a0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	50		 push	 eax
  0014b	ff 75 9c	 push	 DWORD PTR __Ptr$[ebp]
  0014e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00153	59		 pop	 ecx
  00154	59		 pop	 ecx
$LN8@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00158	89 45 98	 mov	 DWORD PTR $T7[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0015b	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  0015e	83 c0 08	 add	 eax, 8
  00161	89 45 94	 mov	 DWORD PTR $T6[ebp], eax

; 1486 :         }
; 1487 : 
; 1488 :         _Mapsize() = 0;

  00164	8b 45 94	 mov	 eax, DWORD PTR $T6[ebp]
  00167	83 20 00	 and	 DWORD PTR [eax], 0

; 1530 :         return _Mypair._Myval2;

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	89 45 90	 mov	 DWORD PTR $T5[ebp], eax

; 1538 :         return _Get_data()._Map;

  00170	8b 45 90	 mov	 eax, DWORD PTR $T5[ebp]
  00173	83 c0 04	 add	 eax, 4
  00176	89 45 8c	 mov	 DWORD PTR $T4[ebp], eax

; 1489 :         _Map()     = _Mapptr();

  00179	8b 45 8c	 mov	 eax, DWORD PTR $T4[ebp]
  0017c	83 20 00	 and	 DWORD PTR [eax], 0

; 1490 :     }

  0017f	c9		 leave
  00180	c3		 ret	 0
?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Growmap@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -164						; size = 4
__Max_possible$2 = -160					; size = 4
$T3 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
$T6 = -144						; size = 4
$T7 = -140						; size = 4
__Ptr$ = -136						; size = 4
__Count$ = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
$T10 = -120						; size = 4
$T11 = -116						; size = 4
$T12 = -112						; size = 4
$T13 = -108						; size = 4
$T14 = -104						; size = 4
$T15 = -100						; size = 4
$T16 = -96						; size = 4
$T17 = -92						; size = 4
$T18 = -88						; size = 4
$T19 = -84						; size = 4
$T20 = -80						; size = 4
$T21 = -76						; size = 4
$T22 = -72						; size = 4
$T23 = -68						; size = 4
$T24 = -64						; size = 4
$T25 = -60						; size = 4
$T26 = -56						; size = 4
$T27 = -52						; size = 4
$T28 = -48						; size = 4
$T29 = -44						; size = 4
$T30 = -40						; size = 4
$T31 = -36						; size = 4
$T32 = -32						; size = 4
$T33 = -28						; size = 4
$T34 = -24						; size = 4
$T35 = -20						; size = 4
$T36 = -16						; size = 4
$T37 = -12						; size = 4
$T38 = -8						; size = 4
$T39 = -4						; size = 4
$T40 = 0						; size = 4
$T41 = 4						; size = 4
$T42 = 8						; size = 4
$T43 = 12						; size = 4
$T44 = 16						; size = 4
$T45 = 20						; size = 4
$T46 = 24						; size = 4
$T47 = 28						; size = 4
$T48 = 32						; size = 4
$T49 = 36						; size = 4
$T50 = 40						; size = 4
$T51 = 44						; size = 4
$T52 = 48						; size = 4
$T53 = 52						; size = 4
$T54 = 56						; size = 4
$T55 = 60						; size = 4
$T56 = 64						; size = 4
__Count$ = 68						; size = 4
tv232 = 72						; size = 4
$T57 = 76						; size = 4
$T58 = 80						; size = 4
tv73 = 84						; size = 4
tv214 = 88						; size = 4
__Overflow_is_possible$59 = 95				; size = 1
__Newmap$ = 96						; size = 4
__Newsize$ = 100					; size = 4
__Myboff$ = 104						; size = 4
__Myptr$ = 108						; size = 4
_this$ = 112						; size = 4
__Count$ = 124						; size = 4
?_Growmap@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXI@Z PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Growmap, COMDAT
; _this$ = ecx

; 1430 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1522 :         return _Mypair._Get_first();

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00011	89 45 40	 mov	 DWORD PTR $T56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00014	8b 45 40	 mov	 eax, DWORD PTR $T56[ebp]
  00017	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0001d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 3c	 mov	 DWORD PTR $T55[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00023	8b 45 3c	 mov	 eax, DWORD PTR $T55[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	89 45 38	 mov	 DWORD PTR $T54[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  0002c	8b 45 38	 mov	 eax, DWORD PTR $T54[ebp]
  0002f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00032	76 19		 jbe	 SHORT $LN10@Growmap

; 1530 :         return _Mypair._Myval2;

  00034	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 34	 mov	 DWORD PTR $T53[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0003a	8b 45 34	 mov	 eax, DWORD PTR $T53[ebp]
  0003d	83 c0 08	 add	 eax, 8
  00040	89 45 30	 mov	 DWORD PTR $T52[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  00043	8b 45 30	 mov	 eax, DWORD PTR $T52[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 54	 mov	 DWORD PTR tv73[ebp], eax
  0004b	eb 07		 jmp	 SHORT $LN11@Growmap
$LN10@Growmap:
  0004d	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN11@Growmap:
  00054	8b 45 54	 mov	 eax, DWORD PTR tv73[ebp]
  00057	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax
$LN2@Growmap:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 2c	 mov	 DWORD PTR $T51[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 2c	 mov	 eax, DWORD PTR $T51[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 28	 mov	 DWORD PTR $T50[ebp], eax

; 1435 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _DEQUEMAPSIZ) {

  00069	8b 45 28	 mov	 eax, DWORD PTR $T50[ebp]
  0006c	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0006f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00071	3b 4d 7c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00074	72 06		 jb	 SHORT $LN4@Growmap
  00076	83 7d 64 08	 cmp	 DWORD PTR __Newsize$[ebp], 8
  0007a	73 70		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1526 :         return _Mypair._Get_first();

  0007c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007f	89 45 24	 mov	 DWORD PTR $T49[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1526 :         return _Mypair._Get_first();

  00082	8b 45 24	 mov	 eax, DWORD PTR $T49[ebp]
  00085	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0008b	c7 45 50 ff ff
	ff 3f		 mov	 DWORD PTR $T58[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00092	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T48[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  00099	8b 45 20	 mov	 eax, DWORD PTR $T48[ebp]
  0009c	89 45 4c	 mov	 DWORD PTR $T57[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009f	8b 45 50	 mov	 eax, DWORD PTR $T58[ebp]
  000a2	3b 45 4c	 cmp	 eax, DWORD PTR $T57[ebp]
  000a5	73 08		 jae	 SHORT $LN56@Growmap
  000a7	8d 45 50	 lea	 eax, DWORD PTR $T58[ebp]
  000aa	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
  000ad	eb 06		 jmp	 SHORT $LN57@Growmap
$LN56@Growmap:
  000af	8d 45 4c	 lea	 eax, DWORD PTR $T57[ebp]
  000b2	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
$LN57@Growmap:
  000b5	8b 45 48	 mov	 eax, DWORD PTR tv232[ebp]
  000b8	89 45 1c	 mov	 DWORD PTR $T47[ebp], eax
  000bb	8b 45 1c	 mov	 eax, DWORD PTR $T47[ebp]
  000be	89 45 18	 mov	 DWORD PTR $T46[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  000c1	8b 45 18	 mov	 eax, DWORD PTR $T46[ebp]
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
  000c6	89 45 14	 mov	 DWORD PTR $T45[ebp], eax

; 1436 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1437 :             if (max_size() / _DEQUESIZ - _Newsize < _Newsize) {

  000c9	8b 45 14	 mov	 eax, DWORD PTR $T45[ebp]
  000cc	c1 e8 02	 shr	 eax, 2
  000cf	2b 45 64	 sub	 eax, DWORD PTR __Newsize$[ebp]
  000d2	3b 45 64	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  000d5	73 08		 jae	 SHORT $LN5@Growmap

; 1438 :                 _Xlen(); // result too long

  000d7	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ?_Xlen@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@ABEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Xlen
$LN5@Growmap:

; 1439 :             }
; 1440 : 
; 1441 :             _Newsize *= 2;

  000df	8b 45 64	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e2	d1 e0		 shl	 eax, 1
  000e4	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1442 :         }

  000e7	e9 6e ff ff ff	 jmp	 $LN2@Growmap
$LN3@Growmap:

; 1530 :         return _Mypair._Myval2;

  000ec	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	89 45 10	 mov	 DWORD PTR $T44[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  000f2	8b 45 10	 mov	 eax, DWORD PTR $T44[ebp]
  000f5	83 c0 08	 add	 eax, 8
  000f8	89 45 0c	 mov	 DWORD PTR $T43[ebp], eax

; 1443 :         _Count = _Newsize - _Mapsize();

  000fb	8b 45 0c	 mov	 eax, DWORD PTR $T43[ebp]
  000fe	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00101	2b 08		 sub	 ecx, DWORD PTR [eax]
  00103	89 4d 7c	 mov	 DWORD PTR __Count$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00106	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00109	89 45 08	 mov	 DWORD PTR $T42[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0010c	8b 45 08	 mov	 eax, DWORD PTR $T42[ebp]
  0010f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00112	89 45 04	 mov	 DWORD PTR $T41[ebp], eax

; 1444 : 
; 1445 :         size_type _Myboff = _Myoff() / _DEQUESIZ;

  00115	8b 45 04	 mov	 eax, DWORD PTR $T41[ebp]
  00118	8b 00		 mov	 eax, DWORD PTR [eax]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	89 45 68	 mov	 DWORD PTR __Myboff$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00120	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00123	89 45 00	 mov	 DWORD PTR $T40[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00126	8b 45 00	 mov	 eax, DWORD PTR $T40[ebp]
  00129	83 c0 08	 add	 eax, 8
  0012c	89 45 fc	 mov	 DWORD PTR $T39[ebp], eax

; 1446 :         _Mapptr _Newmap   = _Almap.allocate(_Mapsize() + _Count);

  0012f	8b 45 fc	 mov	 eax, DWORD PTR $T39[ebp]
  00132	8b 00		 mov	 eax, DWORD PTR [eax]
  00134	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  00137	89 45 44	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0013a	c6 45 5f 01	 mov	 BYTE PTR __Overflow_is_possible$59[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0013e	c7 85 60 ff ff
	ff ff ff ff 3f	 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00148	81 7d 44 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0014f	76 05		 jbe	 SHORT $LN80@Growmap

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00151	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN80@Growmap:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00156	8b 45 44	 mov	 eax, DWORD PTR __Count$[ebp]
  00159	c1 e0 02	 shl	 eax, 2
  0015c	89 45 f8	 mov	 DWORD PTR $T38[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0015f	ff 75 f8	 push	 DWORD PTR $T38[ebp]
  00162	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00167	59		 pop	 ecx
  00168	89 45 60	 mov	 DWORD PTR __Newmap$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1447 :         _Mapptr _Myptr    = _Newmap + _Myboff;

  0016b	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  0016e	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00171	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00174	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00177	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	89 45 f4	 mov	 DWORD PTR $T37[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017d	8b 45 f4	 mov	 eax, DWORD PTR $T37[ebp]
  00180	83 c0 04	 add	 eax, 4
  00183	89 45 e4	 mov	 DWORD PTR $T33[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00186	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00189	89 45 f0	 mov	 DWORD PTR $T36[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0018c	8b 45 f0	 mov	 eax, DWORD PTR $T36[ebp]
  0018f	83 c0 08	 add	 eax, 8
  00192	89 45 e8	 mov	 DWORD PTR $T34[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00195	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00198	89 45 ec	 mov	 DWORD PTR $T35[ebp], eax

; 1538 :         return _Get_data()._Map;

  0019b	8b 45 ec	 mov	 eax, DWORD PTR $T35[ebp]
  0019e	83 c0 04	 add	 eax, 4
  001a1	89 45 e0	 mov	 DWORD PTR $T32[ebp], eax

; 1448 : 
; 1449 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  001a4	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001a7	8b 45 e8	 mov	 eax, DWORD PTR $T34[ebp]
  001aa	8b 00		 mov	 eax, DWORD PTR [eax]
  001ac	8b 4d e4	 mov	 ecx, DWORD PTR $T33[ebp]
  001af	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001b1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001b4	50		 push	 eax
  001b5	8b 45 e0	 mov	 eax, DWORD PTR $T32[ebp]
  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
  001ba	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001bd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c9	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1450 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  001cc	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  001cf	3b 45 7c	 cmp	 eax, DWORD PTR __Count$[ebp]
  001d2	77 60		 ja	 SHORT $LN6@Growmap

; 1530 :         return _Mypair._Myval2;

  001d4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	89 45 dc	 mov	 DWORD PTR $T31[ebp], eax

; 1538 :         return _Get_data()._Map;

  001da	8b 45 dc	 mov	 eax, DWORD PTR $T31[ebp]
  001dd	83 c0 04	 add	 eax, 4
  001e0	89 45 d4	 mov	 DWORD PTR $T29[ebp], eax

; 1530 :         return _Mypair._Myval2;

  001e3	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	89 45 d8	 mov	 DWORD PTR $T30[ebp], eax

; 1538 :         return _Get_data()._Map;

  001e9	8b 45 d8	 mov	 eax, DWORD PTR $T30[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 d0	 mov	 DWORD PTR $T28[ebp], eax

; 1451 :             _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old

  001f2	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001f5	8b 45 d4	 mov	 eax, DWORD PTR $T29[ebp]
  001f8	8b 00		 mov	 eax, DWORD PTR [eax]
  001fa	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001fd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00200	50		 push	 eax
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T28[ebp]
  00204	ff 30		 push	 DWORD PTR [eax]
  00206	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1452 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new

  00211	8b 45 7c	 mov	 eax, DWORD PTR __Count$[ebp]
  00214	2b 45 68	 sub	 eax, DWORD PTR __Myboff$[ebp]
  00217	50		 push	 eax
  00218	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  0021b	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>
  00220	59		 pop	 ecx
  00221	59		 pop	 ecx

; 1453 :             _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new

  00222	ff 75 68	 push	 DWORD PTR __Myboff$[ebp]
  00225	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  00228	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>
  0022d	59		 pop	 ecx
  0022e	59		 pop	 ecx

; 1454 :         } else { // increment not greater than offset of initial block

  0022f	e9 8b 00 00 00	 jmp	 $LN7@Growmap
$LN6@Growmap:

; 1530 :         return _Mypair._Myval2;

  00234	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00237	89 45 cc	 mov	 DWORD PTR $T27[ebp], eax

; 1538 :         return _Get_data()._Map;

  0023a	8b 45 cc	 mov	 eax, DWORD PTR $T27[ebp]
  0023d	83 c0 04	 add	 eax, 4
  00240	89 45 c4	 mov	 DWORD PTR $T25[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00243	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00246	89 45 c8	 mov	 DWORD PTR $T26[ebp], eax

; 1538 :         return _Get_data()._Map;

  00249	8b 45 c8	 mov	 eax, DWORD PTR $T26[ebp]
  0024c	83 c0 04	 add	 eax, 4
  0024f	89 45 c0	 mov	 DWORD PTR $T24[ebp], eax

; 1455 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  00252	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  00255	8b 45 c4	 mov	 eax, DWORD PTR $T25[ebp]
  00258	8b 00		 mov	 eax, DWORD PTR [eax]
  0025a	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0025d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00260	50		 push	 eax
  00261	8b 45 c0	 mov	 eax, DWORD PTR $T24[ebp]
  00264	ff 30		 push	 DWORD PTR [eax]
  00266	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  0026b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1530 :         return _Mypair._Myval2;

  0026e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00271	89 45 bc	 mov	 DWORD PTR $T23[ebp], eax

; 1538 :         return _Get_data()._Map;

  00274	8b 45 bc	 mov	 eax, DWORD PTR $T23[ebp]
  00277	83 c0 04	 add	 eax, 4
  0027a	89 45 b4	 mov	 DWORD PTR $T21[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0027d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00280	89 45 b8	 mov	 DWORD PTR $T22[ebp], eax

; 1538 :         return _Get_data()._Map;

  00283	8b 45 b8	 mov	 eax, DWORD PTR $T22[ebp]
  00286	83 c0 04	 add	 eax, 4
  00289	89 45 b0	 mov	 DWORD PTR $T20[ebp], eax

; 1456 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0028c	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  0028f	8b 45 b4	 mov	 eax, DWORD PTR $T21[ebp]
  00292	8b 00		 mov	 eax, DWORD PTR [eax]
  00294	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00297	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0029a	50		 push	 eax
  0029b	8b 45 b0	 mov	 eax, DWORD PTR $T20[ebp]
  0029e	8b 00		 mov	 eax, DWORD PTR [eax]
  002a0	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002a3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAPAPAPAVCGrannyModelInstance@@QAPAPAV1@0PAPAPAV1@@Z ; std::uninitialized_copy<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1457 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block

  002b2	ff 75 7c	 push	 DWORD PTR __Count$[ebp]
  002b5	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  002b8	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAPAVCGrannyModelInstance@@I@std@@YAPAPAPAVCGrannyModelInstance@@PAPAPAV1@I@Z ; std::_Uninitialized_value_construct_n_unchecked1<CGrannyModelInstance * * *,unsigned int>
  002bd	59		 pop	 ecx
  002be	59		 pop	 ecx
$LN7@Growmap:

; 1530 :         return _Mypair._Myval2;

  002bf	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002c2	89 45 ac	 mov	 DWORD PTR $T19[ebp], eax

; 1538 :         return _Get_data()._Map;

  002c5	8b 45 ac	 mov	 eax, DWORD PTR $T19[ebp]
  002c8	83 c0 04	 add	 eax, 4
  002cb	89 45 9c	 mov	 DWORD PTR $T15[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002ce	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002d1	89 45 a8	 mov	 DWORD PTR $T18[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  002d4	8b 45 a8	 mov	 eax, DWORD PTR $T18[ebp]
  002d7	83 c0 08	 add	 eax, 8
  002da	89 45 a0	 mov	 DWORD PTR $T16[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002dd	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	89 45 a4	 mov	 DWORD PTR $T17[ebp], eax

; 1538 :         return _Get_data()._Map;

  002e3	8b 45 a4	 mov	 eax, DWORD PTR $T17[ebp]
  002e6	83 c0 04	 add	 eax, 4
  002e9	89 45 98	 mov	 DWORD PTR $T14[ebp], eax

; 1458 :         }
; 1459 : 
; 1460 :         _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize());

  002ec	8b 45 a0	 mov	 eax, DWORD PTR $T16[ebp]
  002ef	8b 00		 mov	 eax, DWORD PTR [eax]
  002f1	8b 4d 9c	 mov	 ecx, DWORD PTR $T15[ebp]
  002f4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f6	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002f9	50		 push	 eax
  002fa	8b 45 98	 mov	 eax, DWORD PTR $T14[ebp]
  002fd	8b 00		 mov	 eax, DWORD PTR [eax]
  002ff	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00302	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ??$_Destroy_range@PAPAPAVCGrannyModelInstance@@PAPAPAV1@@std@@YAXPAPAPAVCGrannyModelInstance@@QAPAPAV1@@Z ; std::_Destroy_range<CGrannyModelInstance * * *,CGrannyModelInstance * * *>
  0030b	59		 pop	 ecx
  0030c	59		 pop	 ecx

; 1530 :         return _Mypair._Myval2;

  0030d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00310	89 45 94	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00313	8b 45 94	 mov	 eax, DWORD PTR $T13[ebp]
  00316	83 c0 04	 add	 eax, 4
  00319	89 45 90	 mov	 DWORD PTR $T12[ebp], eax

; 1461 :         if (_Map() != _Mapptr()) {

  0031c	8b 45 90	 mov	 eax, DWORD PTR $T12[ebp]
  0031f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00322	74 4b		 je	 SHORT $LN8@Growmap

; 1530 :         return _Mypair._Myval2;

  00324	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00327	89 45 8c	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0032a	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  0032d	83 c0 08	 add	 eax, 8
  00330	89 45 84	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00333	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00336	89 45 88	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  00339	8b 45 88	 mov	 eax, DWORD PTR $T10[ebp]
  0033c	83 c0 04	 add	 eax, 4
  0033f	89 45 80	 mov	 DWORD PTR $T8[ebp], eax

; 1462 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for old

  00342	8b 45 84	 mov	 eax, DWORD PTR $T9[ebp]
  00345	8b 00		 mov	 eax, DWORD PTR [eax]
  00347	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Count$[ebp], eax
  0034d	8b 45 80	 mov	 eax, DWORD PTR $T8[ebp]
  00350	8b 00		 mov	 eax, DWORD PTR [eax]
  00352	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00358	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR __Count$[ebp]
  0035e	c1 e0 02	 shl	 eax, 2
  00361	50		 push	 eax
  00362	ff b5 78 ff ff
	ff		 push	 DWORD PTR __Ptr$[ebp]
  00368	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0036d	59		 pop	 ecx
  0036e	59		 pop	 ecx
$LN8@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  0036f	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00372	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 1538 :         return _Get_data()._Map;

  00378	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0037e	83 c0 04	 add	 eax, 4
  00381	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 1463 :         }
; 1464 : 
; 1465 :         _Map() = _Newmap; // point at new

  00387	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0038d	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00390	89 08		 mov	 DWORD PTR [eax], ecx

; 1466 :         _Mapsize() += _Count;

  00392	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00398	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0039b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0039e	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  003a4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  003aa	83 c0 08	 add	 eax, 8
  003ad	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1466 :         _Mapsize() += _Count;

  003b0	8b 45 58	 mov	 eax, DWORD PTR tv214[ebp]
  003b3	8b 00		 mov	 eax, DWORD PTR [eax]
  003b5	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  003b8	8b 4d 58	 mov	 ecx, DWORD PTR tv214[ebp]
  003bb	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Growmap:

; 1467 :     }

  003bd	83 c5 74	 add	 ebp, 116		; 00000074H
  003c0	c9		 leave
  003c1	c2 04 00	 ret	 4
?_Growmap@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXI@Z ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Xlen@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@ABEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@ABEXXZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Xlen, COMDAT
; _this$ = ecx

; 1422 :     [[noreturn]] void _Xlen() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1423 :         _Xlength_error("deque<T> too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  0000c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1424 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Xlen@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@ABEXXZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?pop_back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
__Ptr$ = -52						; size = 4
__Block$ = -48						; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
$T11 = -32						; size = 4
$T12 = -28						; size = 4
$T13 = -24						; size = 4
$T14 = -20						; size = 4
$T15 = -16						; size = 4
__Newoff$ = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?pop_back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXXZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::pop_back, COMDAT
; _this$ = ecx

; 1126 :     void pop_back() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T15[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T15[ebp]
  00012	83 c0 0c	 add	 eax, 12			; 0000000cH
  00015	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T14[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR $T14[ebp]
  00021	83 c0 10	 add	 eax, 16			; 00000010H
  00024	89 45 e4	 mov	 DWORD PTR $T12[ebp], eax

; 1127 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1128 :         if (empty()) {
; 1129 :             _STL_REPORT_ERROR("deque empty before pop");
; 1130 :         } else { // something to erase, do it
; 1131 :             size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1132 :             _Orphan_off(_Newoff);
; 1133 :             size_type _Block = _Getblock(_Newoff);
; 1134 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1135 :             if (--_Mysize() == 0) {
; 1136 :                 _Myoff() = 0;
; 1137 :             }
; 1138 :         }
; 1139 : 
; 1140 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1141 :         size_type _Newoff = _Myoff() + _Mysize() - 1;

  00027	8b 45 e8	 mov	 eax, DWORD PTR $T13[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR $T12[ebp]
  0002f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00031	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]
  00035	89 45 f4	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T11[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00041	c1 e8 02	 shr	 eax, 2
  00044	8b 4d e0	 mov	 ecx, DWORD PTR $T11[ebp]
  00047	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0004a	49		 dec	 ecx
  0004b	23 c1		 and	 eax, ecx
  0004d	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  00050	8b 45 dc	 mov	 eax, DWORD PTR $T10[ebp]
  00053	89 45 d0	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1538 :         return _Get_data()._Map;

  0005c	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  0005f	83 c0 04	 add	 eax, 4
  00062	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1142 :         size_type _Block  = _Getblock(_Newoff);
; 1143 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	6a 04		 push	 4
  0006c	59		 pop	 ecx
  0006d	f7 f1		 div	 ecx
  0006f	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	8b 4d d0	 mov	 ecx, DWORD PTR __Block$[ebp]
  00077	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0007a	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0007d	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00080	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00083	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00089	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0008c	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0008f	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  00092	8b 45 b0	 mov	 eax, DWORD PTR $T1[ebp]
  00095	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0009e	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000a1	83 c0 10	 add	 eax, 16			; 00000010H
  000a4	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  000a7	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	48		 dec	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR tv88[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax
  000b2	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000b5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000b8	75 15		 jne	 SHORT $LN3@pop_back

; 1530 :         return _Mypair._Myval2;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000c0	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000c3	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c6	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 1145 :             _Myoff() = 0;

  000c9	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000cc	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@pop_back:

; 1146 :         }
; 1147 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1148 :     }

  000cf	c9		 leave
  000d0	c3		 ret	 0
?pop_back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXXZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?push_front@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXABQAVCGrannyModelInstance@@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
__Max_possible$3 = -64					; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
$T11 = -32						; size = 4
$T12 = -28						; size = 4
$T13 = -24						; size = 4
__Ptr$ = -20						; size = 4
$T14 = -16						; size = 4
$T15 = -12						; size = 4
$T16 = -8						; size = 4
$T17 = -4						; size = 4
$T18 = 0						; size = 4
$T19 = 4						; size = 4
$T20 = 8						; size = 4
$T21 = 12						; size = 4
$T22 = 16						; size = 4
$T23 = 20						; size = 4
$T24 = 24						; size = 4
$T25 = 28						; size = 4
$T26 = 32						; size = 4
$T27 = 36						; size = 4
$T28 = 40						; size = 4
$T29 = 44						; size = 4
$T30 = 48						; size = 4
$T31 = 52						; size = 4
$T32 = 56						; size = 4
$T33 = 60						; size = 4
$T34 = 64						; size = 4
$T35 = 68						; size = 4
$T36 = 72						; size = 4
$T37 = 76						; size = 4
$T38 = 80						; size = 4
$T39 = 84						; size = 4
tv94 = 88						; size = 4
tv166 = 92						; size = 4
__Block$ = 96						; size = 4
tv84 = 100						; size = 4
__Overflow_is_possible$40 = 107				; size = 1
__Newoff$ = 108						; size = 4
_this$ = 112						; size = 4
__Val$ = 124						; size = 4
?push_front@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXABQAVCGrannyModelInstance@@@Z PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::push_front, COMDAT
; _this$ = ecx

; 1079 :     void push_front(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00011	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax
  00014	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 54	 mov	 DWORD PTR $T39[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001a	8b 45 54	 mov	 eax, DWORD PTR $T39[ebp]
  0001d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00020	89 45 50	 mov	 DWORD PTR $T38[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  00023	8b 45 50	 mov	 eax, DWORD PTR $T38[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	33 d2		 xor	 edx, edx
  0002a	6a 04		 push	 4
  0002c	59		 pop	 ecx
  0002d	f7 f1		 div	 ecx
  0002f	85 d2		 test	 edx, edx
  00031	75 3a		 jne	 SHORT $LN2@push_front

; 1530 :         return _Mypair._Myval2;

  00033	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00036	89 45 4c	 mov	 DWORD PTR $T37[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00039	8b 45 4c	 mov	 eax, DWORD PTR $T37[ebp]
  0003c	83 c0 08	 add	 eax, 8
  0003f	89 45 40	 mov	 DWORD PTR $T34[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00042	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00045	89 45 48	 mov	 DWORD PTR $T36[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00048	8b 45 48	 mov	 eax, DWORD PTR $T36[ebp]
  0004b	83 c0 10	 add	 eax, 16			; 00000010H
  0004e	89 45 44	 mov	 DWORD PTR $T35[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  00051	8b 45 44	 mov	 eax, DWORD PTR $T35[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	83 c0 04	 add	 eax, 4
  00059	c1 e8 02	 shr	 eax, 2
  0005c	8b 4d 40	 mov	 ecx, DWORD PTR $T34[ebp]
  0005f	39 01		 cmp	 DWORD PTR [ecx], eax
  00061	77 0a		 ja	 SHORT $LN2@push_front
  00063	6a 01		 push	 1
  00065	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Growmap@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXI@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Growmap
$LN2@push_front:
  0006d	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  00070	89 45 64	 mov	 DWORD PTR tv84[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00073	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00076	89 45 3c	 mov	 DWORD PTR $T33[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00079	8b 45 3c	 mov	 eax, DWORD PTR $T33[ebp]
  0007c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0007f	89 45 64	 mov	 DWORD PTR tv84[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00082	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00085	89 45 38	 mov	 DWORD PTR $T32[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00088	8b 45 38	 mov	 eax, DWORD PTR $T32[ebp]
  0008b	83 c0 08	 add	 eax, 8
  0008e	89 45 34	 mov	 DWORD PTR $T31[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  00091	8b 45 34	 mov	 eax, DWORD PTR $T31[ebp]
  00094	8b 00		 mov	 eax, DWORD PTR [eax]
  00096	8d 04 85 ff ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-1]
  0009d	8b 4d 64	 mov	 ecx, DWORD PTR tv84[ebp]
  000a0	23 01		 and	 eax, DWORD PTR [ecx]
  000a2	8b 4d 64	 mov	 ecx, DWORD PTR tv84[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1530 :         return _Mypair._Myval2;

  000a7	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	89 45 30	 mov	 DWORD PTR $T30[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000ad	8b 45 30	 mov	 eax, DWORD PTR $T30[ebp]
  000b0	83 c0 0c	 add	 eax, 12			; 0000000cH
  000b3	89 45 2c	 mov	 DWORD PTR $T29[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  000b6	8b 45 2c	 mov	 eax, DWORD PTR $T29[ebp]
  000b9	83 38 00	 cmp	 DWORD PTR [eax], 0
  000bc	74 19		 je	 SHORT $LN5@push_front

; 1530 :         return _Mypair._Myval2;

  000be	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	89 45 28	 mov	 DWORD PTR $T28[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000c4	8b 45 28	 mov	 eax, DWORD PTR $T28[ebp]
  000c7	83 c0 0c	 add	 eax, 12			; 0000000cH
  000ca	89 45 24	 mov	 DWORD PTR $T27[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  000cd	8b 45 24	 mov	 eax, DWORD PTR $T27[ebp]
  000d0	8b 00		 mov	 eax, DWORD PTR [eax]
  000d2	89 45 58	 mov	 DWORD PTR tv94[ebp], eax
  000d5	eb 1a		 jmp	 SHORT $LN6@push_front
$LN5@push_front:

; 1530 :         return _Mypair._Myval2;

  000d7	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000da	89 45 20	 mov	 DWORD PTR $T26[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  000dd	8b 45 20	 mov	 eax, DWORD PTR $T26[ebp]
  000e0	83 c0 08	 add	 eax, 8
  000e3	89 45 1c	 mov	 DWORD PTR $T25[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  000e6	8b 45 1c	 mov	 eax, DWORD PTR $T25[ebp]
  000e9	8b 00		 mov	 eax, DWORD PTR [eax]
  000eb	c1 e0 02	 shl	 eax, 2
  000ee	89 45 58	 mov	 DWORD PTR tv94[ebp], eax
$LN6@push_front:
  000f1	8b 45 58	 mov	 eax, DWORD PTR tv94[ebp]
  000f4	89 45 6c	 mov	 DWORD PTR __Newoff$[ebp], eax
  000f7	8b 45 6c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  000fa	48		 dec	 eax
  000fb	89 45 6c	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  000fe	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00101	89 45 18	 mov	 DWORD PTR $T24[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00104	8b 45 6c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00107	c1 e8 02	 shr	 eax, 2
  0010a	8b 4d 18	 mov	 ecx, DWORD PTR $T24[ebp]
  0010d	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00110	49		 dec	 ecx
  00111	23 c1		 and	 eax, ecx
  00113	89 45 14	 mov	 DWORD PTR $T23[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  00116	8b 45 14	 mov	 eax, DWORD PTR $T23[ebp]
  00119	89 45 60	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0011c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0011f	89 45 10	 mov	 DWORD PTR $T22[ebp], eax

; 1538 :         return _Get_data()._Map;

  00122	8b 45 10	 mov	 eax, DWORD PTR $T22[ebp]
  00125	83 c0 04	 add	 eax, 4
  00128	89 45 0c	 mov	 DWORD PTR $T21[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  0012b	8b 45 0c	 mov	 eax, DWORD PTR $T21[ebp]
  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
  00130	8b 4d 60	 mov	 ecx, DWORD PTR __Block$[ebp]
  00133	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00137	75 58		 jne	 SHORT $LN3@push_front

; 1522 :         return _Mypair._Get_first();

  00139	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0013c	89 45 08	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0013f	8b 45 08	 mov	 eax, DWORD PTR $T20[ebp]
  00142	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00145	c6 45 6b 01	 mov	 BYTE PTR __Overflow_is_possible$40[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00149	c7 45 c0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00150	6a 04		 push	 4
  00152	58		 pop	 eax
  00153	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00158	76 05		 jbe	 SHORT $LN88@push_front

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0015a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN88@push_front:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0015f	6a 04		 push	 4
  00161	58		 pop	 eax
  00162	c1 e0 02	 shl	 eax, 2
  00165	89 45 04	 mov	 DWORD PTR $T19[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00168	ff 75 04	 push	 DWORD PTR $T19[ebp]
  0016b	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00170	59		 pop	 ecx
  00171	89 45 f8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00174	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00177	89 45 00	 mov	 DWORD PTR $T18[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017a	8b 45 00	 mov	 eax, DWORD PTR $T18[ebp]
  0017d	83 c0 04	 add	 eax, 4
  00180	89 45 fc	 mov	 DWORD PTR $T17[ebp], eax

; 1080 :         _Orphan_all();
; 1081 :         _PUSH_FRONT_BEGIN;

  00183	8b 45 fc	 mov	 eax, DWORD PTR $T17[ebp]
  00186	8b 00		 mov	 eax, DWORD PTR [eax]
  00188	8b 4d 60	 mov	 ecx, DWORD PTR __Block$[ebp]
  0018b	8b 55 f8	 mov	 edx, DWORD PTR $T16[ebp]
  0018e	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN3@push_front:

; 1530 :         return _Mypair._Myval2;

  00191	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00194	89 45 f4	 mov	 DWORD PTR $T15[ebp], eax

; 1538 :         return _Get_data()._Map;

  00197	8b 45 f4	 mov	 eax, DWORD PTR $T15[ebp]
  0019a	83 c0 04	 add	 eax, 4
  0019d	89 45 f0	 mov	 DWORD PTR $T14[ebp], eax

; 1082 :         _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ), _Val);

  001a0	8b 45 6c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  001a3	33 d2		 xor	 edx, edx
  001a5	6a 04		 push	 4
  001a7	59		 pop	 ecx
  001a8	f7 f1		 div	 ecx
  001aa	8b 45 f0	 mov	 eax, DWORD PTR $T14[ebp]
  001ad	8b 00		 mov	 eax, DWORD PTR [eax]
  001af	8b 4d 60	 mov	 ecx, DWORD PTR __Block$[ebp]
  001b2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  001b5	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  001b8	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  001bb	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  001be	89 45 e4	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001c1	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001c4	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001c7	8b 45 e8	 mov	 eax, DWORD PTR $T13[ebp]
  001ca	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001cd	8b 45 e4	 mov	 eax, DWORD PTR $T12[ebp]
  001d0	89 45 e0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001d3	8b 45 7c	 mov	 eax, DWORD PTR __Val$[ebp]
  001d6	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  001d9	8b 45 e0	 mov	 eax, DWORD PTR $T11[ebp]
  001dc	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  001df	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001e1	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  001e3	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  001e9	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  001ec	83 c0 0c	 add	 eax, 12			; 0000000cH
  001ef	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1083 :         _PUSH_FRONT_END;

  001f2	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp]
  001f5	8b 4d 6c	 mov	 ecx, DWORD PTR __Newoff$[ebp]
  001f8	89 08		 mov	 DWORD PTR [eax], ecx
  001fa	8b 45 b8	 mov	 eax, DWORD PTR $T1[ebp]
  001fd	89 45 5c	 mov	 DWORD PTR tv166[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00200	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00203	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00206	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  00209	83 c0 10	 add	 eax, 16			; 00000010H
  0020c	89 45 5c	 mov	 DWORD PTR tv166[ebp], eax

; 1083 :         _PUSH_FRONT_END;

  0020f	8b 45 5c	 mov	 eax, DWORD PTR tv166[ebp]
  00212	8b 00		 mov	 eax, DWORD PTR [eax]
  00214	40		 inc	 eax
  00215	8b 4d 5c	 mov	 ecx, DWORD PTR tv166[ebp]
  00218	89 01		 mov	 DWORD PTR [ecx], eax
$LN91@push_front:

; 1084 :     }

  0021a	83 c5 74	 add	 ebp, 116		; 00000074H
  0021d	c9		 leave
  0021e	c2 04 00	 ret	 4
?push_front@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXABQAVCGrannyModelInstance@@@Z ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::push_front
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
__First$ = -20						; size = 8
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::back, COMDAT
; _this$ = ecx

; 1063 :     _NODISCARD reference back() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1064 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1065 :         _STL_VERIFY(!empty(), "back() called on empty deque");
; 1066 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1067 : 
; 1068 :         return *_Prev_iter(_Unchecked_end());

  00009	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Unchecked_end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Unchecked_end
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001a	89 4d ec	 mov	 DWORD PTR __First$[ebp], ecx
  0001d	89 45 f0	 mov	 DWORD PTR __First$[ebp+4], eax

; 76   :         --_Myoff;

  00020	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp+4]
  00023	48		 dec	 eax
  00024	89 45 f0	 mov	 DWORD PTR __First$[ebp+4], eax

; 191  :         return *this;

  00027	8d 45 ec	 lea	 eax, DWORD PTR __First$[ebp]
  0002a	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	89 4d e4	 mov	 DWORD PTR $T2[ebp], ecx
  00038	89 45 e8	 mov	 DWORD PTR $T2[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 171  :         return const_cast<reference>(_Mybase::operator*());

  0003b	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0003e	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  00043	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 1064 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1065 :         _STL_VERIFY(!empty(), "back() called on empty deque");
; 1066 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1067 : 
; 1068 :         return *_Prev_iter(_Unchecked_end());

  00046	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]

; 1069 :     }

  00049	c9		 leave
  0004a	c3		 ret	 0
?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z
_TEXT	SEGMENT
$T1 = -64						; size = 8
$T2 = -56						; size = 8
__Tmp$3 = -48						; size = 8
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
___param0$ = -24					; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
$T10 = -12						; size = 4
$T11 = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::operator[], COMDAT
; _this$ = ecx

; 1039 :     _NODISCARD reference operator[](size_type _Pos) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T11[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T10[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T10[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax

; 914  :         return _Unchecked_iterator(_Myoff(), _STD addressof(_Get_data()));

  00024	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  0002c	8b 45 ec	 mov	 eax, DWORD PTR $T8[ebp]
  0002f	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
  00032	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00035	89 45 cc	 mov	 DWORD PTR $T2[ebp+4], eax

; 914  :         return _Unchecked_iterator(_Myoff(), _STD addressof(_Get_data()));

  00038	8d 45 c8	 lea	 eax, DWORD PTR $T2[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax

; 206  :         _Deque_unchecked_iterator _Tmp = *this;

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00041	8b 08		 mov	 ecx, DWORD PTR [eax]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	89 4d d0	 mov	 DWORD PTR __Tmp$3[ebp], ecx
  00049	89 45 d4	 mov	 DWORD PTR __Tmp$3[ebp+4], eax

; 87   :         _Myoff += _Off;

  0004c	8b 45 d4	 mov	 eax, DWORD PTR __Tmp$3[ebp+4]
  0004f	03 45 08	 add	 eax, DWORD PTR __Pos$[ebp]
  00052	89 45 d4	 mov	 DWORD PTR __Tmp$3[ebp+4], eax

; 202  :         return *this;

  00055	8d 45 d0	 lea	 eax, DWORD PTR __Tmp$3[ebp]
  00058	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax

; 207  :         return _Tmp += _Off;

  0005b	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00063	89 4d c0	 mov	 DWORD PTR $T1[ebp], ecx
  00066	89 45 c4	 mov	 DWORD PTR $T1[ebp+4], eax
  00069	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 171  :         return const_cast<reference>(_Mybase::operator*());

  0006f	8b 4d dc	 mov	 ecx, DWORD PTR $T5[ebp]
  00072	e8 00 00 00 00	 call	 ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  00077	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax

; 1040 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1041 :         _STL_VERIFY(_Pos < _Mysize(), "deque subscript out of range");
; 1042 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1043 : 
; 1044 :         return *(_Unchecked_begin() + static_cast<difference_type>(_Pos));

  0007a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]

; 1045 :     }

  0007d	c9		 leave
  0007e	c2 04 00	 ret	 4
??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Unchecked_end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -32					; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Unchecked_end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 921  :     _Unchecked_iterator _Unchecked_end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0002a	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax

; 922  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00033	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	03 01		 add	 eax, DWORD PTR [ecx]
  0003d	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 52   :         : _Mycont(static_cast<const _Mydeque*>(_Pdeque)), _Myoff(_Off) {}

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00046	89 08		 mov	 DWORD PTR [eax], ecx
  00048	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004b	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 922  :         return _Unchecked_iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 923  :     }

  00054	c9		 leave
  00055	c2 04 00	 ret	 4
?_Unchecked_end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -36					; size = 4
___param0$ = -32					; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end, COMDAT
; _this$ = ecx

; 905  :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0002a	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00033	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	03 01		 add	 eax, DWORD PTR [ecx]
  0003d	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	83 20 00	 and	 DWORD PTR [eax], 0
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00053	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00056	83 7d f8 00	 cmp	 DWORD PTR $T7[ebp], 0
  0005a	74 12		 je	 SHORT $LN34@end

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	89 45 dc	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00067	8b 4d dc	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  0006c	eb 06		 jmp	 SHORT $LN22@end
$LN34@end:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071	83 20 00	 and	 DWORD PTR [eax], 0
$LN22@end:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00074	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 907  :     }

  00077	c9		 leave
  00078	c2 04 00	 ret	 4
?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -28					; size = 4
___param0$ = -24					; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin, COMDAT
; _this$ = ecx

; 897  :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00024	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	8b 4d e8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00042	83 7d f8 00	 cmp	 DWORD PTR $T5[ebp], 0
  00046	74 12		 je	 SHORT $LN28@begin

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00048	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 e4	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	8b 4d e4	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  00058	eb 06		 jmp	 SHORT $LN16@begin
$LN28@begin:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	83 20 00	 and	 DWORD PTR [eax], 0
$LN16@begin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 899  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??1?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Old_val$3 = -24					; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
??1?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::~deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >, COMDAT
; _this$ = ecx

; 869  :     ~deque() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 870  :         _Tidy();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Tidy

; 1522 :         return _Mypair._Get_first();

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0001d	83 65 ec 00	 and	 DWORD PTR $T4[ebp], 0

; 1530 :         return _Mypair._Myval2;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	89 45 e8	 mov	 DWORD PTR __Old_val$3[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Old_val$3[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0003d	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00040	8d 45 ff	 lea	 eax, DWORD PTR __Proxy_allocator$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00049	59		 pop	 ecx
  0004a	59		 pop	 ecx

; 873  :     }

  0004b	c9		 leave
  0004c	c3		 ret	 0
??1?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::~deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
??0?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ PROC ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >, COMDAT
; _this$ = ecx

; 596  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001a	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0001d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00020	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 597  :         _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));

  00029	8d 45 ff	 lea	 eax, DWORD PTR $T4[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 598  :     }

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c9		 leave
  00039	c3		 ret	 0
??0?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ENDP ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@CAXXZ PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@CAXXZ ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXQAUSAttachingModelData@CGrannyLODController@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXQAUSAttachingModelData@CGrannyLODController@@II@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXQAUSAttachingModelData@CGrannyLODController@@II@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@ABEII@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 49 92
	24 09		 mov	 DWORD PTR $T7[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXPAUSAttachingModelData@CGrannyLODController@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXPAUSAttachingModelData@CGrannyLODController@@0@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXPAUSAttachingModelData@CGrannyLODController@@0@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXXZ PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@YAXPAUSAttachingModelData@CGrannyLODController@@QAU12@AAV?$allocator@USAttachingModelData@CGrannyLODController@@@0@@Z ; std::_Destroy_range<std::allocator<CGrannyLODController::SAttachingModelData> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T4 = -36						; size = 4
__Last$ = -32						; size = 4
__My_data$ = -28					; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Whereptr$ = -16					; size = 4
__Dest$ = -12						; size = 4
__Mylast$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::erase, COMDAT
; _this$ = ecx

; 1341 :     iterator erase(const_iterator _Where) noexcept(is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1342 :         const pointer _Whereptr = _Where._Ptr;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Whereptr$[ebp], eax

; 1343 :         auto& _My_data          = _Mypair._Myval2;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1344 :         pointer& _Mylast        = _My_data._Mylast;

  00015	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1345 : 
; 1346 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1347 :         _STL_VERIFY(
; 1348 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1349 :             "vector erase iterator outside range");
; 1350 :         _Orphan_range(_Whereptr, _Mylast);
; 1351 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1352 : 
; 1353 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  0001e	8b 45 f0	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR __Dest$[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  0002c	8b 45 f0	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0002f	83 c0 1c	 add	 eax, 28			; 0000001cH
  00032	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4632 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00035	eb 12		 jmp	 SHORT $LN6@erase
$LN4@erase:
  00037	8b 45 f4	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0003d	89 45 f4	 mov	 DWORD PTR __Dest$[ebp], eax
  00040	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00043	83 c0 1c	 add	 eax, 28			; 0000001cH
  00046	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax
$LN6@erase:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  0004c	3b 45 e0	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004f	74 13		 je	 SHORT $LN3@erase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00051	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00054	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4633 :         *_Dest = _STD move(*_First);

  00057	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0005d	e8 00 00 00 00	 call	 ??4SAttachingModelData@CGrannyLODController@@QAEAAU01@$$QAU01@@Z

; 4634 :     }

  00062	eb d3		 jmp	 SHORT $LN4@erase
$LN3@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1354 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00064	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	83 e8 1c	 sub	 eax, 28			; 0000001cH
  0006c	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0006f	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00072	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00078	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0007b	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0007e	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  00081	8b 4d e8	 mov	 ecx, DWORD PTR $T5[ebp]
  00084	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00087	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0008c	33 c0		 xor	 eax, eax
  0008e	83 e0 01	 and	 eax, 1
  00091	74 0c		 je	 SHORT $LN57@erase
  00093	6a 1c		 push	 28			; 0000001cH
  00095	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00098	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0009d	59		 pop	 ecx
  0009e	59		 pop	 ecx
$LN57@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1355 :         --_Mylast;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	83 e8 1c	 sub	 eax, 28			; 0000001cH
  000a7	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000aa	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000ac	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000af	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000b2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b5	8b 4d f0	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  000b8	89 08		 mov	 DWORD PTR [eax], ecx

; 1356 :         return iterator(_Whereptr, _STD addressof(_My_data));

  000ba	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1357 :     }

  000bd	c9		 leave
  000be	c2 08 00	 ret	 8
?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ PROC ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::~vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::~vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USAttachingModelData@CGrannyLODController@@@std@@QAEXQAUSAttachingModelData@CGrannyLODController@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USAttachingModelData@CGrannyLODController@@@std@@QAEXQAUSAttachingModelData@CGrannyLODController@@I@Z PROC ; std::allocator<CGrannyLODController::SAttachingModelData>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USAttachingModelData@CGrannyLODController@@@std@@QAEXQAUSAttachingModelData@CGrannyLODController@@I@Z ENDP ; std::allocator<CGrannyLODController::SAttachingModelData>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??4SAttachingModelData@CGrannyLODController@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
$T2 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4SAttachingModelData@CGrannyLODController@@QAEAAU01@$$QAU01@@Z PROC ; CGrannyLODController::SAttachingModelData::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00011	89 08		 mov	 DWORD PTR [eax], ecx
  00013	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 04	 add	 eax, 4
  00022	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00025	8b 45 f8	 mov	 eax, DWORD PTR __Right$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  00031	74 13		 je	 SHORT $LN5@operator

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00033	33 c0		 xor	 eax, eax
  00035	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  00038	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0003b	ff 75 f8	 push	 DWORD PTR __Right$[ebp]
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
$LN5@operator:
  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c9		 leave
  0004a	c2 04 00	 ret	 4
??4SAttachingModelData@CGrannyLODController@@QAEAAU01@$$QAU01@@Z ENDP ; CGrannyLODController::SAttachingModelData::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1SAttachingModelData@CGrannyLODController@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SAttachingModelData@CGrannyLODController@@QAE@XZ PROC ; CGrannyLODController::SAttachingModelData::~SAttachingModelData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	c9		 leave
  00013	c3		 ret	 0
??1SAttachingModelData@CGrannyLODController@@QAE@XZ ENDP ; CGrannyLODController::SAttachingModelData::~SAttachingModelData
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0SAttachingModelData@CGrannyLODController@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SAttachingModelData@CGrannyLODController@@QAE@XZ PROC ; CGrannyLODController::SAttachingModelData::SAttachingModelData, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c9		 leave
  00016	c3		 ret	 0
??0SAttachingModelData@CGrannyLODController@@QAE@XZ ENDP ; CGrannyLODController::SAttachingModelData::SAttachingModelData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?__ReserveSharedDeformableVertexBuffer@CGrannyLODController@@IAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_deformableVertexCount$ = 8				; size = 4
?__ReserveSharedDeformableVertexBuffer@CGrannyLODController@@IAEXK@Z PROC ; CGrannyLODController::__ReserveSharedDeformableVertexBuffer, COMDAT
; _this$ = ecx

; 298  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 299  : 	if (m_pkSharedDeformableVertexBuffer && 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0000e	74 12		 je	 SHORT $LN2@ReserveSha
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00016	e8 00 00 00 00	 call	 ?GetVertexCount@CGraphicVertexBuffer@@QBEHXZ ; CGraphicVertexBuffer::GetVertexCount
  0001b	3b 45 08	 cmp	 eax, DWORD PTR _deformableVertexCount$[ebp]
  0001e	72 02		 jb	 SHORT $LN2@ReserveSha

; 300  : 		m_pkSharedDeformableVertexBuffer->GetVertexCount() >= deformableVertexCount)
; 301  : 		return;	

  00020	eb 1b		 jmp	 SHORT $LN1@ReserveSha
$LN2@ReserveSha:

; 302  : 
; 303  : 	__FreeDeformVertexBuffer(m_pkSharedDeformableVertexBuffer);

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	ff 70 38	 push	 DWORD PTR [eax+56]
  00028	e8 00 00 00 00	 call	 ?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z ; __FreeDeformVertexBuffer
  0002d	59		 pop	 ecx

; 304  : 
; 305  : 	m_pkSharedDeformableVertexBuffer = __AllocDeformVertexBuffer(deformableVertexCount);

  0002e	ff 75 08	 push	 DWORD PTR _deformableVertexCount$[ebp]
  00031	e8 00 00 00 00	 call	 ?__AllocDeformVertexBuffer@@YAPAVCGraphicVertexBuffer@@I@Z ; __AllocDeformVertexBuffer
  00036	59		 pop	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	89 41 38	 mov	 DWORD PTR [ecx+56], eax
$LN1@ReserveSha:

; 306  : }

  0003d	c9		 leave
  0003e	c2 04 00	 ret	 4
?__ReserveSharedDeformableVertexBuffer@CGrannyLODController@@IAEXK@Z ENDP ; CGrannyLODController::__ReserveSharedDeformableVertexBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ
_TEXT	SEGMENT
__My_data$1 = -28					; size = 4
$T2 = -24						; size = 4
_pSrcInstance$3 = -20					; size = 4
_rModelData$4 = -16					; size = 4
__My_data$5 = -12					; size = 4
_this$ = -8						; size = 4
_i$6 = -4						; size = 4
?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ PROC ; CGrannyLODController::RefreshAttachedModelInstance, COMDAT
; _this$ = ecx

; 576  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 577  : 	if (!m_pCurrentModelInstance)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00010	75 05		 jne	 SHORT $LN5@RefreshAtt

; 578  : 		return;

  00012	e9 8a 00 00 00	 jmp	 $LN1@RefreshAtt
$LN5@RefreshAtt:

; 580  : 	for (DWORD i = 0; i < m_AttachedModelDataVector.size(); ++i)

  00017	83 65 fc 00	 and	 DWORD PTR _i$6[ebp], 0
  0001b	eb 07		 jmp	 SHORT $LN4@RefreshAtt
$LN2@RefreshAtt:
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _i$6[ebp]
  00020	40		 inc	 eax
  00021	89 45 fc	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@RefreshAtt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002a	89 45 f4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __My_data$5[ebp]
  00030	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00033	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00036	2b 01		 sub	 eax, DWORD PTR [ecx]
  00038	99		 cdq
  00039	6a 1c		 push	 28			; 0000001cH
  0003b	59		 pop	 ecx
  0003c	f7 f9		 idiv	 ecx
  0003e	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 580  : 	for (DWORD i = 0; i < m_AttachedModelDataVector.size(); ++i)

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$6[ebp]
  00044	3b 45 e8	 cmp	 eax, DWORD PTR $T2[ebp]
  00047	73 58		 jae	 SHORT $LN1@RefreshAtt
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004f	89 45 e4	 mov	 DWORD PTR __My_data$1[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00052	6b 45 fc 1c	 imul	 eax, DWORD PTR _i$6[ebp], 28
  00056	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$1[ebp]
  00059	03 01		 add	 eax, DWORD PTR [ecx]
  0005b	89 45 f0	 mov	 DWORD PTR _rModelData$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 584  : 		CGrannyModelInstance * pSrcInstance = rModelData.pkLODController->GetModelInstance();

  0005e	8b 45 f0	 mov	 eax, DWORD PTR _rModelData$4[ebp]
  00061	8b 08		 mov	 ecx, DWORD PTR [eax]
  00063	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00068	89 45 ec	 mov	 DWORD PTR _pSrcInstance$3[ebp], eax

; 585  : 		if (!pSrcInstance)

  0006b	83 7d ec 00	 cmp	 DWORD PTR _pSrcInstance$3[ebp], 0
  0006f	75 11		 jne	 SHORT $LN6@RefreshAtt

; 586  : 		{
; 587  : 			Tracenf("CGrannyLODController::RefreshAttachedModelInstance : m_AttachedModelDataVector[%d]->pkLODController->GetModelIntance()==NULL", i);

  00071	ff 75 fc	 push	 DWORD PTR _i$6[ebp]
  00074	68 00 00 00 00	 push	 OFFSET ??_C@_0HN@JOABBJCG@CGrannyLODController?3?3RefreshAt@
  00079	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0007e	59		 pop	 ecx
  0007f	59		 pop	 ecx

; 588  : 			continue;

  00080	eb 9b		 jmp	 SHORT $LN2@RefreshAtt
$LN6@RefreshAtt:

; 589  : 		}
; 590  : 
; 591  : 		pSrcInstance->SetParentModelInstance(m_pCurrentModelInstance, rModelData.strBoneName.c_str());

  00082	8b 4d f0	 mov	 ecx, DWORD PTR _rModelData$4[ebp]
  00085	83 c1 04	 add	 ecx, 4
  00088	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0008d	50		 push	 eax
  0008e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00091	ff 70 20	 push	 DWORD PTR [eax+32]
  00094	8b 4d ec	 mov	 ecx, DWORD PTR _pSrcInstance$3[ebp]
  00097	e8 00 00 00 00	 call	 ?SetParentModelInstance@CGrannyModelInstance@@QAEXPBV1@PBD@Z ; CGrannyModelInstance::SetParentModelInstance

; 592  : 	}

  0009c	e9 7c ff ff ff	 jmp	 $LN2@RefreshAtt
$LN1@RefreshAtt:

; 593  : }

  000a1	c9		 leave
  000a2	c3		 ret	 0
?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ ENDP ; CGrannyLODController::RefreshAttachedModelInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pgrnModelInstance$ = 8					; size = 4
?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z PROC ; CGrannyLODController::SetCurrentModelInstance, COMDAT
; _this$ = ecx

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 561  : 	// Copy Motion
; 562  : 	pgrnModelInstance->CopyMotion(m_pCurrentModelInstance, true);

  00007	6a 01		 push	 1
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	ff 70 20	 push	 DWORD PTR [eax+32]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pgrnModelInstance$[ebp]
  00012	e8 00 00 00 00	 call	 ?CopyMotion@CGrannyModelInstance@@QAEXPAV1@_N@Z ; CGrannyModelInstance::CopyMotion

; 563  : 	m_pCurrentModelInstance = pgrnModelInstance;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _pgrnModelInstance$[ebp]
  0001d	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 564  : 
; 565  : 	// Change children attaching link
; 566  : 	RefreshAttachedModelInstance();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ ; CGrannyLODController::RefreshAttachedModelInstance

; 567  : 
; 568  : 	// Change parent attaching link
; 569  : 	if (m_pAttachedParentModel)

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  0002f	74 0b		 je	 SHORT $LN1@SetCurrent

; 570  : 	{
; 571  : 		m_pAttachedParentModel->RefreshAttachedModelInstance();

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00037	e8 00 00 00 00	 call	 ?RefreshAttachedModelInstance@CGrannyLODController@@IAEXXZ ; CGrannyLODController::RefreshAttachedModelInstance
$LN1@SetCurrent:

; 572  : 	}
; 573  : }

  0003c	c9		 leave
  0003d	c2 04 00	 ret	 4
?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z ENDP ; CGrannyLODController::SetCurrentModelInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ PROC ; CGrannyLODController::GetModelInstance, COMDAT
; _this$ = ecx

; 693  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 694  : 	return m_pCurrentModelInstance;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 695  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ENDP ; CGrannyLODController::GetModelInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?isModelInstance@CGrannyLODController@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?isModelInstance@CGrannyLODController@@QAEHXZ PROC	; CGrannyLODController::isModelInstance, COMDAT
; _this$ = ecx

; 685  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 686  : 	if (!m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	75 04		 jne	 SHORT $LN2@isModelIns

; 687  : 		return FALSE;

  00010	33 c0		 xor	 eax, eax
  00012	eb 03		 jmp	 SHORT $LN1@isModelIns
$LN2@isModelIns:

; 688  : 
; 689  : 	return TRUE;

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
$LN1@isModelIns:

; 690  : }

  00017	c9		 leave
  00018	c3		 ret	 0
?isModelInstance@CGrannyLODController@@QAEHXZ ENDP	; CGrannyLODController::isModelInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetMotionAtEnd@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetMotionAtEnd@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::SetMotionAtEnd, COMDAT
; _this$ = ecx

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 680  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0b		 je	 SHORT $LN1@SetMotionA

; 681  : 		m_pCurrentModelInstance->SetMotionAtEnd();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00016	e8 00 00 00 00	 call	 ?SetMotionAtEnd@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::SetMotionAtEnd
$LN1@SetMotionA:

; 682  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?SetMotionAtEnd@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::SetMotionAtEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?ChangeMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@HM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pMotion$ = 8						; size = 4
_iLoopCount$ = 12					; size = 4
_speedRatio$ = 16					; size = 4
?ChangeMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@HM@Z PROC ; CGrannyLODController::ChangeMotionPointer, COMDAT
; _this$ = ecx

; 673  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 674  : 	assert(m_pCurrentModelInstance != NULL);
; 675  : 	m_pCurrentModelInstance->ChangeMotionPointer(c_pMotion, iLoopCount, speedRatio);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _speedRatio$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	ff 75 0c	 push	 DWORD PTR _iLoopCount$[ebp]
  00015	ff 75 08	 push	 DWORD PTR _c_pMotion$[ebp]
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001e	e8 00 00 00 00	 call	 ?ChangeMotionPointer@CGrannyModelInstance@@QAEXPBVCGrannyMotion@@HM@Z ; CGrannyModelInstance::ChangeMotionPointer

; 676  : }

  00023	c9		 leave
  00024	c2 0c 00	 ret	 12			; 0000000cH
?ChangeMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@HM@Z ENDP ; CGrannyLODController::ChangeMotionPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@MHM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pMotion$ = 8						; size = 4
_fBlendTime$ = 12					; size = 4
_iLoopCount$ = 16					; size = 4
_speedRatio$ = 20					; size = 4
?SetMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@MHM@Z PROC ; CGrannyLODController::SetMotionPointer, COMDAT
; _this$ = ecx

; 667  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 668  : 	assert(m_pCurrentModelInstance != NULL);
; 669  : 	m_pCurrentModelInstance->SetMotionPointer(c_pMotion, fBlendTime, iLoopCount, speedRatio);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _speedRatio$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	ff 75 10	 push	 DWORD PTR _iLoopCount$[ebp]
  00015	51		 push	 ecx
  00016	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fBlendTime$[ebp]
  0001b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00020	ff 75 08	 push	 DWORD PTR _c_pMotion$[ebp]
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00029	e8 00 00 00 00	 call	 ?SetMotionPointer@CGrannyModelInstance@@QAEXPBVCGrannyMotion@@MHM@Z ; CGrannyModelInstance::SetMotionPointer

; 670  : }

  0002e	c9		 leave
  0002f	c2 10 00	 ret	 16			; 00000010H
?SetMotionPointer@CGrannyLODController@@QAEXPBVCGrannyMotion@@MHM@Z ENDP ; CGrannyLODController::SetMotionPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?ResetLocalTime@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ResetLocalTime@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::ResetLocalTime, COMDAT
; _this$ = ecx

; 661  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  : 	assert(m_pCurrentModelInstance != NULL);
; 663  : 	m_pCurrentModelInstance->ResetLocalTime();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	e8 00 00 00 00	 call	 ?ResetLocalTime@CGrannyModelInstance@@QAEHXZ ; CGrannyModelInstance::ResetLocalTime

; 664  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?ResetLocalTime@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::ResetLocalTime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetLocalTime@CGrannyLODController@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fLocalTime$ = 8					; size = 4
?SetLocalTime@CGrannyLODController@@QAEXM@Z PROC	; CGrannyLODController::SetLocalTime, COMDAT
; _this$ = ecx

; 655  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 656  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 16		 je	 SHORT $LN2@SetLocalTi

; 657  : 		m_pCurrentModelInstance->SetLocalTime(fLocalTime);

  00010	51		 push	 ecx
  00011	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fLocalTime$[ebp]
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00021	e8 00 00 00 00	 call	 ?SetLocalTime@CGrannyModelInstance@@QAEXM@Z ; CGrannyModelInstance::SetLocalTime
$LN2@SetLocalTi:

; 658  : }

  00026	c9		 leave
  00027	c2 04 00	 ret	 4
?SetLocalTime@CGrannyLODController@@QAEXM@Z ENDP	; CGrannyLODController::SetLocalTime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?Intersect@CGrannyLODController@@QAE_NPBUD3DXMATRIX@@PAM11@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pMatrix$ = 8						; size = 4
_u$ = 12						; size = 4
_v$ = 16						; size = 4
_t$ = 20						; size = 4
?Intersect@CGrannyLODController@@QAE_NPBUD3DXMATRIX@@PAM11@Z PROC ; CGrannyLODController::Intersect, COMDAT
; _this$ = ecx

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 649  : 	if (!m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	75 04		 jne	 SHORT $LN2@Intersect

; 650  : 		return false;

  00010	32 c0		 xor	 al, al
  00012	eb 17		 jmp	 SHORT $LN1@Intersect
$LN2@Intersect:

; 651  : 	return m_pCurrentModelInstance->Intersect(c_pMatrix, u, v, t);

  00014	ff 75 14	 push	 DWORD PTR _t$[ebp]
  00017	ff 75 10	 push	 DWORD PTR _v$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR _u$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR _c_pMatrix$[ebp]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00026	e8 00 00 00 00	 call	 ?Intersect@CGrannyModelInstance@@QAE_NPBUD3DXMATRIX@@PAM11@Z ; CGrannyModelInstance::Intersect
$LN1@Intersect:

; 652  : }

  0002b	c9		 leave
  0002c	c2 10 00	 ret	 16			; 00000010H
?Intersect@CGrannyLODController@@QAE_NPBUD3DXMATRIX@@PAM11@Z ENDP ; CGrannyLODController::Intersect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?GetBoundBox@CGrannyLODController@@QAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vtMin$ = 8						; size = 4
_vtMax$ = 12						; size = 4
?GetBoundBox@CGrannyLODController@@QAEXPAUD3DXVECTOR3@@0@Z PROC ; CGrannyLODController::GetBoundBox, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 11		 je	 SHORT $LN1@GetBoundBo

; 644  : 		m_pCurrentModelInstance->GetBoundBox(vtMin, vtMax);

  00010	ff 75 0c	 push	 DWORD PTR _vtMax$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _vtMin$[ebp]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001c	e8 00 00 00 00	 call	 ?GetBoundBox@CGrannyModelInstance@@QAEXPAUD3DXVECTOR3@@0@Z ; CGrannyModelInstance::GetBoundBox
$LN1@GetBoundBo:

; 645  : }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?GetBoundBox@CGrannyLODController@@QAEXPAUD3DXVECTOR3@@0@Z ENDP ; CGrannyLODController::GetBoundBox
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?ReloadTexture@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ReloadTexture@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::ReloadTexture, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0b		 je	 SHORT $LN1@ReloadText

; 638  : 		m_pCurrentModelInstance->ReloadTexture();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00016	e8 00 00 00 00	 call	 ?ReloadTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::ReloadTexture
$LN1@ReloadText:

; 639  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?ReloadTexture@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::ReloadTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?RenderShadow@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderShadow@CGrannyLODController@@QAEXXZ PROC		; CGrannyLODController::RenderShadow, COMDAT
; _this$ = ecx

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 631  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0b		 je	 SHORT $LN1@RenderShad

; 632  : 		m_pCurrentModelInstance->RenderWithOneTexture();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00016	e8 00 00 00 00	 call	 ?RenderWithOneTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::RenderWithOneTexture
$LN1@RenderShad:

; 633  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?RenderShadow@CGrannyLODController@@QAEXXZ ENDP		; CGrannyLODController::RenderShadow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?RenderToShadowMap@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderToShadowMap@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::RenderToShadowMap, COMDAT
; _this$ = ecx

; 624  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 625  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0b		 je	 SHORT $LN1@RenderToSh

; 626  : 		m_pCurrentModelInstance->RenderWithoutTexture();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00016	e8 00 00 00 00	 call	 ?RenderWithoutTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::RenderWithoutTexture
$LN1@RenderToSh:

; 627  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?RenderToShadowMap@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::RenderToShadowMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 12
$T3 = -68						; size = 12
_i$ = -56						; size = 12
_pkModelInst$4 = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv262 = -28						; size = 4
tv230 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_pWorldMatrix$ = 8					; size = 4
?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z PROC ; CGrannyLODController::DeformAll, COMDAT
; _this$ = ecx

; 602  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >

; 603  : 	std::deque<CGrannyModelInstance *>::iterator i;

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 604  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  00034	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 24	 add	 ecx, 36			; 00000024H
  0003e	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00043	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
  00046	ff 75 e0	 push	 DWORD PTR $T7[ebp]
  00049	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0004c	e8 00 00 00 00	 call	 ??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
  00051	eb 07		 jmp	 SHORT $LN4@DeformAll
$LN2@DeformAll:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00053	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp+8]
  00056	40		 inc	 eax
  00057	89 45 d0	 mov	 DWORD PTR _i$[ebp+8], eax
$LN4@DeformAll:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 604  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  0005a	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 24	 add	 ecx, 36			; 00000024H
  00064	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00069	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0006f	8b 4d d0	 mov	 ecx, DWORD PTR _i$[ebp+8]
  00072	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00075	75 09		 jne	 SHORT $LN121@DeformAll
  00077	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv230[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN122@DeformAll
$LN121@DeformAll:
  00080	83 65 e8 00	 and	 DWORD PTR tv230[ebp], 0
$LN122@DeformAll:
  00084	8a 45 e8	 mov	 al, BYTE PTR tv230[ebp]
  00087	88 45 f3	 mov	 BYTE PTR $T9[ebp], al

; 355  :         return !(*this == _Right);

  0008a	0f b6 45 f3	 movzx	 eax, BYTE PTR $T9[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	75 09		 jne	 SHORT $LN116@DeformAll
  00092	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv262[ebp], 1
  00099	eb 04		 jmp	 SHORT $LN117@DeformAll
$LN116@DeformAll:
  0009b	83 65 e4 00	 and	 DWORD PTR tv262[ebp], 0
$LN117@DeformAll:
  0009f	8a 45 e4	 mov	 al, BYTE PTR tv262[ebp]
  000a2	88 45 f2	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 604  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  000a5	0f b6 45 f2	 movzx	 eax, BYTE PTR $T8[ebp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 20		 je	 SHORT $LN3@DeformAll
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  000b0	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000b5	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 606  : 		CGrannyModelInstance* pkModelInst=(*i);

  000b8	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 d4	 mov	 DWORD PTR _pkModelInst$4[ebp], eax

; 607  : 		pkModelInst->Deform(c_pWorldMatrix);		

  000c0	ff 75 08	 push	 DWORD PTR _c_pWorldMatrix$[ebp]
  000c3	8b 4d d4	 mov	 ecx, DWORD PTR _pkModelInst$4[ebp]
  000c6	e8 00 00 00 00	 call	 ?Deform@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyModelInstance::Deform

; 608  : 	}	

  000cb	eb 86		 jmp	 SHORT $LN2@DeformAll
$LN3@DeformAll:

; 609  : }

  000cd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000db	59		 pop	 ecx
  000dc	c9		 leave
  000dd	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DeformAll@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ENDP ; CGrannyLODController::DeformAll
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?DeformNoSkin@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pWorldMatrix$ = 8					; size = 4
?DeformNoSkin@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z PROC ; CGrannyLODController::DeformNoSkin, COMDAT
; _this$ = ecx

; 612  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 613  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0e		 je	 SHORT $LN1@DeformNoSk

; 614  : 		m_pCurrentModelInstance->DeformNoSkin(c_pWorldMatrix);

  00010	ff 75 08	 push	 DWORD PTR _c_pWorldMatrix$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00019	e8 00 00 00 00	 call	 ?DeformNoSkin@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyModelInstance::DeformNoSkin
$LN1@DeformNoSk:

; 615  : }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?DeformNoSkin@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ENDP ; CGrannyLODController::DeformNoSkin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?Deform@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pWorldMatrix$ = 8					; size = 4
?Deform@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z PROC ; CGrannyLODController::Deform, COMDAT
; _this$ = ecx

; 618  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 619  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 0e		 je	 SHORT $LN1@Deform

; 620  : 		m_pCurrentModelInstance->Deform(c_pWorldMatrix);

  00010	ff 75 08	 push	 DWORD PTR _c_pWorldMatrix$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00019	e8 00 00 00 00	 call	 ?Deform@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyModelInstance::Deform
$LN1@Deform:

; 621  : }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?Deform@CGrannyLODController@@QAEXPBUD3DXMATRIX@@@Z ENDP ; CGrannyLODController::Deform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?UpdateSkeleton@CGrannyLODController@@QAEXPBUD3DXMATRIX@@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pWorldMatrix$ = 8					; size = 4
_fElapsedTime$ = 12					; size = 4
?UpdateSkeleton@CGrannyLODController@@QAEXPBUD3DXMATRIX@@M@Z PROC ; CGrannyLODController::UpdateSkeleton, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 	if (m_pCurrentModelInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0000e	74 19		 je	 SHORT $LN2@UpdateSkel

; 598  : 		m_pCurrentModelInstance->UpdateSkeleton(c_pWorldMatrix, fElapsedTime);

  00010	51		 push	 ecx
  00011	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	ff 75 08	 push	 DWORD PTR _c_pWorldMatrix$[ebp]
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00024	e8 00 00 00 00	 call	 ?UpdateSkeleton@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@M@Z ; CGrannyModelInstance::UpdateSkeleton
$LN2@UpdateSkel:

; 599  : }

  00029	c9		 leave
  0002a	c2 08 00	 ret	 8
?UpdateSkeleton@CGrannyLODController@@QAEXPBUD3DXMATRIX@@M@Z ENDP ; CGrannyLODController::UpdateSkeleton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?UpdateTime@CGrannyLODController@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fElapsedTime$ = 8					; size = 4
?UpdateTime@CGrannyLODController@@QAEXM@Z PROC		; CGrannyLODController::UpdateTime, COMDAT
; _this$ = ecx

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 532  : 	assert(m_pCurrentModelInstance != NULL);
; 533  : 
; 534  : 	m_pCurrentModelInstance->Update(m_dwLODAniFPS);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00013	e8 00 00 00 00	 call	 ?Update@CGrannyModelInstance@@QAEXK@Z ; CGrannyModelInstance::Update

; 535  : 
; 536  : 	//DWORD t3=timeGetTime();
; 537  : 	m_pCurrentModelInstance->UpdateLocalTime(fElapsedTime);

  00018	51		 push	 ecx
  00019	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  0001e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00029	e8 00 00 00 00	 call	 ?UpdateLocalTime@CGrannyModelInstance@@QAEXM@Z ; CGrannyModelInstance::UpdateLocalTime

; 538  : 
; 539  : 	//DWORD t4=timeGetTime();
; 540  : 
; 541  : #ifdef __PERFORMANCE_CHECKER__
; 542  : 	{
; 543  : 		static FILE* fp=fopen("perf_lod_update.txt", "w");
; 544  : 
; 545  : 		if (t4-t1>3)
; 546  : 		{
; 547  : 			fprintf(fp, "LOD.Total %d (Time %f)\n", t4-t1, timeGetTime()/1000.0f);
; 548  : 			fprintf(fp, "LOD.SMI %d\n", t2-t1);
; 549  : 			fprintf(fp, "LOD.UP %d\n", t3-t2);
; 550  : 			fprintf(fp, "LOD.UL %d\n", t4-t3);
; 551  : 			fprintf(fp, "-------------------------------- \n");
; 552  : 			fflush(fp);
; 553  : 		}			
; 554  : 		fflush(fp);
; 555  : 	}
; 556  : #endif
; 557  : }

  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
?UpdateTime@CGrannyLODController@@QAEXM@Z ENDP		; CGrannyLODController::UpdateTime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?UpdateLODLevel@CGrannyLODController@@QAEXMM@Z
_TEXT	SEGMENT
tv402 = -108						; size = 8
$T1 = -100						; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
$T7 = -76						; size = 4
$T8 = -72						; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
_fLODStep$12 = -56					; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
$T18 = -32						; size = 4
tv311 = -28						; size = 4
_fLODFactor$19 = -24					; size = 4
tv398 = -20						; size = 4
tv150 = -16						; size = 4
_bLODLevel$20 = -12					; size = 1
_this$ = -8						; size = 4
$T21 = -1						; size = 1
_fDistanceFromCenter$ = 8				; size = 4
_fDistanceFromCamera$ = 12				; size = 4
?UpdateLODLevel@CGrannyLODController@@QAEXMM@Z PROC	; CGrannyLODController::UpdateLODLevel, COMDAT
; _this$ = ecx

; 456  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 24	 add	 eax, 36			; 00000024H
  0000f	89 45 e0	 mov	 DWORD PTR $T18[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00012	8b 45 e0	 mov	 eax, DWORD PTR $T18[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax

; 1001 :         return _Mysize();

  0001b	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 457  : 	if (m_que_pkModelInst.size()<=1)

  00023	83 7d d8 01	 cmp	 DWORD PTR $T16[ebp], 1
  00027	77 05		 ja	 SHORT $LN2@UpdateLODL

; 458  : 		return;

  00029	e9 90 02 00 00	 jmp	 $LN1@UpdateLODL
$LN2@UpdateLODL:

; 459  : 	
; 460  : 	assert(m_pCurrentModelInstance != NULL);
; 461  : 
; 462  : 	
; 463  : 	if (fDistanceFromCenter > LOD_APPLY_MIN) //  LOD  

  0002e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDistanceFromCenter$[ebp]
  00033	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@43fa0000
  0003a	0f 86 15 02 00
	00		 jbe	 $LN3@UpdateLODL

; 464  : 	{	
; 465  : 		//    fLODRate 
; 466  : 		// 3 LOD ..   0,    
; 467  : 
; 468  : 		// 100fps 50fps 33fps 25fps 20fps
; 469  : 		// 10ms 20ms 30ms 40ms 50ms
; 470  : 		float fLODFactor = fMINMAX(0.0f, (m_fLODDistance-fDistanceFromCamera), m_fLODDistance);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	51		 push	 ecx
  00044	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00056	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fDistanceFromCamera$[ebp]
  0005b	51		 push	 ecx
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	51		 push	 ecx
  00062	0f 57 c0	 xorps	 xmm0, xmm0
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	e8 00 00 00 00	 call	 ?fMINMAX@@YAMMMM@Z	; fMINMAX
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00072	d9 5d e8	 fstp	 DWORD PTR _fLODFactor$19[ebp]

; 471  : 		
; 472  : 		if (m_fLODDistance>0.0f)

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0007d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00084	76 2a		 jbe	 SHORT $LN5@UpdateLODL

; 473  : 			m_dwLODAniFPS = (DWORD) ((CGrannyModelInstance::ANIFPS_MAX - CGrannyModelInstance::ANIFPS_MIN) * fLODFactor / m_fLODDistance + CGrannyModelInstance::ANIFPS_MIN);

  00086	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42b40000
  0008e	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _fLODFactor$19[ebp]
  00093	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00096	f3 0f 5e 40 04	 divss	 xmm0, DWORD PTR [eax+4]
  0009b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@41f00000
  000a3	e8 00 00 00 00	 call	 __ftoui3
  000a8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  000ae	eb 0a		 jmp	 SHORT $LN6@UpdateLODL
$LN5@UpdateLODL:

; 474  : 		else
; 475  : 			m_dwLODAniFPS = CGrannyModelInstance::ANIFPS_MIN;

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	c7 40 08 1e 00
	00 00		 mov	 DWORD PTR [eax+8], 30	; 0000001eH
$LN6@UpdateLODL:

; 476  : 		
; 477  : 		assert(m_dwLODAniFPS > 0);
; 478  : 		m_dwLODAniFPS /= 10;

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c0	33 d2		 xor	 edx, edx
  000c2	6a 0a		 push	 10			; 0000000aH
  000c4	59		 pop	 ecx
  000c5	f7 f1		 div	 ecx
  000c7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 479  : 		m_dwLODAniFPS *= 10;

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	6b 40 08 0a	 imul	 eax, DWORD PTR [eax+8], 10
  000d4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	89 41 08	 mov	 DWORD PTR [ecx+8], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	83 c0 24	 add	 eax, 36			; 00000024H
  000e0	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  000e3	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp]
  000e6	83 c0 10	 add	 eax, 16			; 00000010H
  000e9	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax

; 1001 :         return _Mysize();

  000ec	8b 45 d0	 mov	 eax, DWORD PTR $T14[ebp]
  000ef	8b 00		 mov	 eax, DWORD PTR [eax]
  000f1	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 481  : 		float fLODStep = m_fLODDistance / m_que_pkModelInst.size();

  000f4	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000f7	89 45 ec	 mov	 DWORD PTR tv398[ebp], eax
  000fa	f2 0f 2a 45 ec	 cvtsi2sd xmm0, DWORD PTR tv398[ebp]
  000ff	8b 45 ec	 mov	 eax, DWORD PTR tv398[ebp]
  00102	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00105	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0010e	f2 0f 11 45 94	 movsd	 QWORD PTR tv402[ebp], xmm0
  00113	f2 0f 5a 45 94	 cvtsd2ss xmm0, QWORD PTR tv402[ebp]
  00118	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00120	f3 0f 5e c8	 divss	 xmm1, xmm0
  00124	f3 0f 11 4d c8	 movss	 DWORD PTR _fLODStep$12[ebp], xmm1

; 482  : 		BYTE bLODLevel = BYTE(fLODFactor / fLODStep);

  00129	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fLODFactor$19[ebp]
  0012e	f3 0f 5e 45 c8	 divss	 xmm0, DWORD PTR _fLODStep$12[ebp]
  00133	f3 0f 2c c0	 cvttss2si eax, xmm0
  00137	88 45 f4	 mov	 BYTE PTR _bLODLevel$20[ebp], al

; 483  : 
; 484  : 		if (m_fLODDistance <= 5000.0f)

  0013a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  00145	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00149	0f 82 b0 00 00
	00		 jb	 $LN7@UpdateLODL

; 485  : 		{
; 486  : 			if (fDistanceFromCamera < 500.0f)

  0014f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43fa0000
  00157	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fDistanceFromCamera$[ebp]
  0015b	76 06		 jbe	 SHORT $LN8@UpdateLODL

; 487  : 			{
; 488  : 				bLODLevel = 0;

  0015d	c6 45 f4 00	 mov	 BYTE PTR _bLODLevel$20[ebp], 0

; 489  : 			}

  00161	eb 2c		 jmp	 SHORT $LN13@UpdateLODL
$LN8@UpdateLODL:

; 490  : 			else if (fDistanceFromCamera < 1500.0f)

  00163	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44bb8000
  0016b	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fDistanceFromCamera$[ebp]
  0016f	76 06		 jbe	 SHORT $LN10@UpdateLODL

; 491  : 			{
; 492  : 				bLODLevel = 1;

  00171	c6 45 f4 01	 mov	 BYTE PTR _bLODLevel$20[ebp], 1

; 493  : 			}

  00175	eb 18		 jmp	 SHORT $LN13@UpdateLODL
$LN10@UpdateLODL:

; 494  : 			else if (fDistanceFromCamera < 2500.0f)

  00177	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@451c4000
  0017f	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fDistanceFromCamera$[ebp]
  00183	76 06		 jbe	 SHORT $LN12@UpdateLODL

; 495  : 			{
; 496  : 				bLODLevel = 2;

  00185	c6 45 f4 02	 mov	 BYTE PTR _bLODLevel$20[ebp], 2

; 497  : 			}

  00189	eb 04		 jmp	 SHORT $LN13@UpdateLODL
$LN12@UpdateLODL:

; 498  : 			else
; 499  : 			{
; 500  : 				bLODLevel = 3;

  0018b	c6 45 f4 03	 mov	 BYTE PTR _bLODLevel$20[ebp], 3
$LN13@UpdateLODL:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00192	83 c0 24	 add	 eax, 36			; 00000024H
  00195	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00198	8b 45 c4	 mov	 eax, DWORD PTR $T11[ebp]
  0019b	83 c0 10	 add	 eax, 16			; 00000010H
  0019e	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax

; 1001 :         return _Mysize();

  001a1	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  001a4	8b 00		 mov	 eax, DWORD PTR [eax]
  001a6	89 45 bc	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 503  : 			bLODLevel = (BYTE) (m_que_pkModelInst.size() - min(bLODLevel, m_que_pkModelInst.size()) - 1);

  001a9	0f b6 45 f4	 movzx	 eax, BYTE PTR _bLODLevel$20[ebp]
  001ad	3b 45 bc	 cmp	 eax, DWORD PTR $T9[ebp]
  001b0	73 09		 jae	 SHORT $LN19@UpdateLODL
  001b2	0f b6 45 f4	 movzx	 eax, BYTE PTR _bLODLevel$20[ebp]
  001b6	89 45 f0	 mov	 DWORD PTR tv150[ebp], eax
  001b9	eb 20		 jmp	 SHORT $LN48@UpdateLODL
$LN19@UpdateLODL:
  001bb	8b 45 9c	 mov	 eax, DWORD PTR $T1[ebp]
  001be	89 45 f0	 mov	 DWORD PTR tv150[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  001c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001c4	83 c0 24	 add	 eax, 36			; 00000024H
  001c7	89 45 b8	 mov	 DWORD PTR $T8[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  001ca	8b 45 b8	 mov	 eax, DWORD PTR $T8[ebp]
  001cd	83 c0 10	 add	 eax, 16			; 00000010H
  001d0	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax

; 1001 :         return _Mysize();

  001d3	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  001d6	8b 00		 mov	 eax, DWORD PTR [eax]
  001d8	89 45 f0	 mov	 DWORD PTR tv150[ebp], eax
$LN48@UpdateLODL:

; 1534 :         return _Mypair._Myval2;

  001db	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001de	83 c0 24	 add	 eax, 36			; 00000024H
  001e1	89 45 b0	 mov	 DWORD PTR $T6[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  001e4	8b 45 b0	 mov	 eax, DWORD PTR $T6[ebp]
  001e7	83 c0 10	 add	 eax, 16			; 00000010H
  001ea	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax

; 1001 :         return _Mysize();

  001ed	8b 45 ac	 mov	 eax, DWORD PTR $T5[ebp]
  001f0	8b 00		 mov	 eax, DWORD PTR [eax]
  001f2	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 503  : 			bLODLevel = (BYTE) (m_que_pkModelInst.size() - min(bLODLevel, m_que_pkModelInst.size()) - 1);

  001f5	8b 45 a8	 mov	 eax, DWORD PTR $T4[ebp]
  001f8	2b 45 f0	 sub	 eax, DWORD PTR tv150[ebp]
  001fb	48		 dec	 eax
  001fc	88 45 f4	 mov	 BYTE PTR _bLODLevel$20[ebp], al
$LN7@UpdateLODL:

; 504  : 		}
; 505  : 		
; 506  : 		if (ms_isMinLODModeEnable)

  001ff	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_isMinLODModeEnable@@3_NA ; ms_isMinLODModeEnable
  00206	85 c0		 test	 eax, eax
  00208	74 04		 je	 SHORT $LN14@UpdateLODL

; 507  : 			bLODLevel=0;

  0020a	c6 45 f4 00	 mov	 BYTE PTR _bLODLevel$20[ebp], 0
$LN14@UpdateLODL:

; 508  : 
; 509  : 		SetLODLevel(bLODLevel);

  0020e	ff 75 f4	 push	 DWORD PTR _bLODLevel$20[ebp]
  00211	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00214	e8 00 00 00 00	 call	 ?SetLODLevel@CGrannyLODController@@QAEXE@Z ; CGrannyLODController::SetLODLevel

; 510  : 
; 511  : 		if (m_pCurrentModelInstance != m_que_pkModelInst[m_bLODLevel])

  00219	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021c	0f b6 40 1c	 movzx	 eax, BYTE PTR [eax+28]
  00220	50		 push	 eax
  00221	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00224	83 c1 24	 add	 ecx, 36			; 00000024H
  00227	e8 00 00 00 00	 call	 ??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::operator[]
  0022c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022f	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00232	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00234	74 1d		 je	 SHORT $LN15@UpdateLODL

; 512  : 		{
; 513  : 			SetCurrentModelInstance(m_que_pkModelInst[m_bLODLevel]);

  00236	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00239	0f b6 40 1c	 movzx	 eax, BYTE PTR [eax+28]
  0023d	50		 push	 eax
  0023e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00241	83 c1 24	 add	 ecx, 36			; 00000024H
  00244	e8 00 00 00 00	 call	 ??A?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@I@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::operator[]
  00249	ff 30		 push	 DWORD PTR [eax]
  0024b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0024e	e8 00 00 00 00	 call	 ?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z ; CGrannyLODController::SetCurrentModelInstance
$LN15@UpdateLODL:

; 514  : 		}
; 515  : 	}

  00253	eb 69		 jmp	 SHORT $LN17@UpdateLODL
$LN3@UpdateLODL:

; 516  : 	else
; 517  : 	{
; 518  : 		m_dwLODAniFPS=CGrannyModelInstance::ANIFPS_MAX;

  00255	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00258	c7 40 08 78 00
	00 00		 mov	 DWORD PTR [eax+8], 120	; 00000078H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  0025f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00262	83 c0 24	 add	 eax, 36			; 00000024H
  00265	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00268	8b 45 a4	 mov	 eax, DWORD PTR $T3[ebp]
  0026b	83 c0 10	 add	 eax, 16			; 00000010H
  0026e	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax

; 1010 :         return _Mysize() == 0;

  00271	8b 45 a0	 mov	 eax, DWORD PTR $T2[ebp]
  00274	83 38 00	 cmp	 DWORD PTR [eax], 0
  00277	75 09		 jne	 SHORT $LN152@UpdateLODL
  00279	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv311[ebp], 1
  00280	eb 04		 jmp	 SHORT $LN153@UpdateLODL
$LN152@UpdateLODL:
  00282	83 65 e4 00	 and	 DWORD PTR tv311[ebp], 0
$LN153@UpdateLODL:
  00286	8a 45 e4	 mov	 al, BYTE PTR tv311[ebp]
  00289	88 45 ff	 mov	 BYTE PTR $T21[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 520  : 		if (!m_que_pkModelInst.empty())

  0028c	0f b6 45 ff	 movzx	 eax, BYTE PTR $T21[ebp]
  00290	85 c0		 test	 eax, eax
  00292	75 2a		 jne	 SHORT $LN17@UpdateLODL

; 521  : 		{
; 522  : 			if (m_pCurrentModelInstance != m_que_pkModelInst.back())

  00294	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00297	83 c1 24	 add	 ecx, 36			; 00000024H
  0029a	e8 00 00 00 00	 call	 ?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::back
  0029f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a2	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  002a5	3b 08		 cmp	 ecx, DWORD PTR [eax]
  002a7	74 15		 je	 SHORT $LN17@UpdateLODL

; 523  : 			{
; 524  : 				SetCurrentModelInstance(m_que_pkModelInst.back());

  002a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	83 c1 24	 add	 ecx, 36			; 00000024H
  002af	e8 00 00 00 00	 call	 ?back@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEAAPAVCGrannyModelInstance@@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::back
  002b4	ff 30		 push	 DWORD PTR [eax]
  002b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ?SetCurrentModelInstance@CGrannyLODController@@IAEXPAVCGrannyModelInstance@@@Z ; CGrannyLODController::SetCurrentModelInstance
$LN17@UpdateLODL:
$LN1@UpdateLODL:

; 525  : 			}
; 526  : 		}
; 527  : 	}
; 528  : }

  002be	c9		 leave
  002bf	c2 08 00	 ret	 8
?UpdateLODLevel@CGrannyLODController@@QAEXMM@Z ENDP	; CGrannyLODController::UpdateLODLevel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?Update@CGrannyLODController@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fElapsedTime$ = 8					; size = 4
_fDistanceFromCenter$ = 12				; size = 4
_fDistanceFromCamera$ = 16				; size = 4
?Update@CGrannyLODController@@QAEXMMM@Z PROC		; CGrannyLODController::Update, COMDAT
; _this$ = ecx

; 450  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 451  : 	UpdateLODLevel(fDistanceFromCenter, fDistanceFromCamera);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDistanceFromCamera$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	51		 push	 ecx
  00013	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fDistanceFromCenter$[ebp]
  00018	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?UpdateLODLevel@CGrannyLODController@@QAEXMM@Z ; CGrannyLODController::UpdateLODLevel

; 452  : 	UpdateTime(fElapsedTime);

  00025	51		 push	 ecx
  00026	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  0002b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?UpdateTime@CGrannyLODController@@QAEXM@Z ; CGrannyLODController::UpdateTime

; 453  : }

  00038	c9		 leave
  00039	c2 0c 00	 ret	 12			; 0000000cH
?Update@CGrannyLODController@@QAEXMMM@Z ENDP		; CGrannyLODController::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?BlendRenderWithTwoTexture@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlendRenderWithTwoTexture@CGrannyLODController@@QAEXXZ PROC ; CGrannyLODController::BlendRenderWithTwoTexture, COMDAT
; _this$ = ecx

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 445  : 	assert(m_pCurrentModelInstance != NULL);
; 446  : 	m_pCurrentModelInstance->BlendRenderWithTwoTexture();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	e8 00 00 00 00	 call	 ?BlendRenderWithTwoTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::BlendRenderWithTwoTexture

; 447  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?BlendRenderWithTwoTexture@CGrannyLODController@@QAEXXZ ENDP ; CGrannyLODController::BlendRenderWithTwoTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?BlendRenderWithOneTexture@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlendRenderWithOneTexture@CGrannyLODController@@QAEXXZ PROC ; CGrannyLODController::BlendRenderWithOneTexture, COMDAT
; _this$ = ecx

; 432  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 433  : 	assert(m_pCurrentModelInstance != NULL);
; 434  : 	m_pCurrentModelInstance->BlendRenderWithOneTexture();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	e8 00 00 00 00	 call	 ?BlendRenderWithOneTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::BlendRenderWithOneTexture

; 435  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?BlendRenderWithOneTexture@CGrannyLODController@@QAEXXZ ENDP ; CGrannyLODController::BlendRenderWithOneTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?RenderWithTwoTexture@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderWithTwoTexture@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::RenderWithTwoTexture, COMDAT
; _this$ = ecx

; 438  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 439  : 	assert(m_pCurrentModelInstance != NULL);
; 440  : 	m_pCurrentModelInstance->RenderWithTwoTexture();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	e8 00 00 00 00	 call	 ?RenderWithTwoTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::RenderWithTwoTexture

; 441  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?RenderWithTwoTexture@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::RenderWithTwoTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?RenderWithOneTexture@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderWithOneTexture@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::RenderWithOneTexture, COMDAT
; _this$ = ecx

; 409  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 410  : 	assert(m_pCurrentModelInstance != NULL);
; 411  : 
; 412  : //#define CHECK_LOD
; 413  : #ifdef CHECK_LOD
; 414  : 	if (m_que_pkModelInst.size() > 0 && m_pCurrentModelInstance == m_que_pkModelInst[0])
; 415  : 		m_pCurrentModelInstance->RenderWithoutTexture();
; 416  : 
; 417  : 	if (m_que_pkModelInst.size() > 1 && m_pCurrentModelInstance == m_que_pkModelInst[1])
; 418  : 		m_pCurrentModelInstance->RenderWithOneTexture();
; 419  : 
; 420  : 	if (m_que_pkModelInst.size() > 2 && m_pCurrentModelInstance == m_que_pkModelInst[2])
; 421  : 		m_pCurrentModelInstance->RenderWithOneTexture();
; 422  : 
; 423  : 	if (m_que_pkModelInst.size() > 3 && m_pCurrentModelInstance == m_que_pkModelInst[3])
; 424  : 		m_pCurrentModelInstance->RenderWithOneTexture();
; 425  : 
; 426  : #else
; 427  : 	m_pCurrentModelInstance->RenderWithOneTexture();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000d	e8 00 00 00 00	 call	 ?RenderWithOneTexture@CGrannyModelInstance@@QAEXXZ ; CGrannyModelInstance::RenderWithOneTexture

; 428  : #endif
; 429  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?RenderWithOneTexture@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::RenderWithOneTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z
_TEXT	SEGMENT
$T2 = -80						; size = 12
$T3 = -68						; size = 12
_i$ = -56						; size = 12
_pkModelInst$4 = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv264 = -28						; size = 4
tv232 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_szMtrlName$ = 8					; size = 4
_bEnable$ = 12						; size = 4
_fPower$ = 16						; size = 4
?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z PROC	; CGrannyLODController::SetSpecularInfo, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >

; 173  : 	std::deque<CGrannyModelInstance *>::iterator i;

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 174  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  00034	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 24	 add	 ecx, 36			; 00000024H
  0003e	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00043	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
  00046	ff 75 e0	 push	 DWORD PTR $T7[ebp]
  00049	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0004c	e8 00 00 00 00	 call	 ??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
  00051	eb 07		 jmp	 SHORT $LN70@SetSpecula
$LN2@SetSpecula:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00053	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp+8]
  00056	40		 inc	 eax
  00057	89 45 d0	 mov	 DWORD PTR _i$[ebp+8], eax
$LN70@SetSpecula:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 174  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  0005a	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 24	 add	 ecx, 36			; 00000024H
  00064	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00069	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0006f	8b 4d d0	 mov	 ecx, DWORD PTR _i$[ebp+8]
  00072	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00075	75 09		 jne	 SHORT $LN121@SetSpecula
  00077	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv232[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN122@SetSpecula
$LN121@SetSpecula:
  00080	83 65 e8 00	 and	 DWORD PTR tv232[ebp], 0
$LN122@SetSpecula:
  00084	8a 45 e8	 mov	 al, BYTE PTR tv232[ebp]
  00087	88 45 f3	 mov	 BYTE PTR $T9[ebp], al

; 355  :         return !(*this == _Right);

  0008a	0f b6 45 f3	 movzx	 eax, BYTE PTR $T9[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	75 09		 jne	 SHORT $LN116@SetSpecula
  00092	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv264[ebp], 1
  00099	eb 04		 jmp	 SHORT $LN117@SetSpecula
$LN116@SetSpecula:
  0009b	83 65 e4 00	 and	 DWORD PTR tv264[ebp], 0
$LN117@SetSpecula:
  0009f	8a 45 e4	 mov	 al, BYTE PTR tv264[ebp]
  000a2	88 45 f2	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 174  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  000a5	0f b6 45 f2	 movzx	 eax, BYTE PTR $T8[ebp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 31		 je	 SHORT $LN3@SetSpecula
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  000b0	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000b5	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 176  : 		CGrannyModelInstance* pkModelInst=(*i);

  000b8	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 d4	 mov	 DWORD PTR _pkModelInst$4[ebp], eax

; 177  : 		pkModelInst->SetSpecularInfo(c_szMtrlName, bEnable, fPower);

  000c0	51		 push	 ecx
  000c1	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fPower$[ebp]
  000c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000cb	ff 75 0c	 push	 DWORD PTR _bEnable$[ebp]
  000ce	ff 75 08	 push	 DWORD PTR _c_szMtrlName$[ebp]
  000d1	8b 4d d4	 mov	 ecx, DWORD PTR _pkModelInst$4[ebp]
  000d4	e8 00 00 00 00	 call	 ?SetSpecularInfo@CGrannyModelInstance@@QAEXPBDHM@Z ; CGrannyModelInstance::SetSpecularInfo

; 178  : 	}

  000d9	e9 75 ff ff ff	 jmp	 $LN2@SetSpecula
$LN3@SetSpecula:

; 179  : }

  000de	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	c9		 leave
  000ee	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetSpecularInfo@CGrannyLODController@@QAEXPBDHM@Z ENDP	; CGrannyLODController::SetSpecularInfo
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 12
$T3 = -68						; size = 12
_i$ = -56						; size = 12
_pkModelInst$4 = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv263 = -28						; size = 4
tv231 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_szImageName$ = 8					; size = 4
_c_rkMaterialData$ = 12					; size = 4
?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z PROC ; CGrannyLODController::SetMaterialData, COMDAT
; _this$ = ecx

; 162  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >

; 163  : 	std::deque<CGrannyModelInstance *>::iterator i;

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 164  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  00034	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 24	 add	 ecx, 36			; 00000024H
  0003e	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00043	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
  00046	ff 75 e0	 push	 DWORD PTR $T7[ebp]
  00049	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0004c	e8 00 00 00 00	 call	 ??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
  00051	eb 07		 jmp	 SHORT $LN4@SetMateria
$LN2@SetMateria:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00053	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp+8]
  00056	40		 inc	 eax
  00057	89 45 d0	 mov	 DWORD PTR _i$[ebp+8], eax
$LN4@SetMateria:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 164  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  0005a	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 24	 add	 ecx, 36			; 00000024H
  00064	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00069	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0006f	8b 4d d0	 mov	 ecx, DWORD PTR _i$[ebp+8]
  00072	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00075	75 09		 jne	 SHORT $LN121@SetMateria
  00077	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv231[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN122@SetMateria
$LN121@SetMateria:
  00080	83 65 e8 00	 and	 DWORD PTR tv231[ebp], 0
$LN122@SetMateria:
  00084	8a 45 e8	 mov	 al, BYTE PTR tv231[ebp]
  00087	88 45 f3	 mov	 BYTE PTR $T9[ebp], al

; 355  :         return !(*this == _Right);

  0008a	0f b6 45 f3	 movzx	 eax, BYTE PTR $T9[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	75 09		 jne	 SHORT $LN116@SetMateria
  00092	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv263[ebp], 1
  00099	eb 04		 jmp	 SHORT $LN117@SetMateria
$LN116@SetMateria:
  0009b	83 65 e4 00	 and	 DWORD PTR tv263[ebp], 0
$LN117@SetMateria:
  0009f	8a 45 e4	 mov	 al, BYTE PTR tv263[ebp]
  000a2	88 45 f2	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 164  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  000a5	0f b6 45 f2	 movzx	 eax, BYTE PTR $T8[ebp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 23		 je	 SHORT $LN3@SetMateria
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  000b0	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000b5	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 166  : 		CGrannyModelInstance* pkModelInst=(*i);

  000b8	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 d4	 mov	 DWORD PTR _pkModelInst$4[ebp], eax

; 167  : 		pkModelInst->SetMaterialData(c_szImageName, c_rkMaterialData);

  000c0	ff 75 0c	 push	 DWORD PTR _c_rkMaterialData$[ebp]
  000c3	ff 75 08	 push	 DWORD PTR _c_szImageName$[ebp]
  000c6	8b 4d d4	 mov	 ecx, DWORD PTR _pkModelInst$4[ebp]
  000c9	e8 00 00 00 00	 call	 ?SetMaterialData@CGrannyModelInstance@@QAEXPBDABUSMaterialData@@@Z ; CGrannyModelInstance::SetMaterialData

; 168  : 	}

  000ce	eb 83		 jmp	 SHORT $LN2@SetMateria
$LN3@SetMateria:

; 169  : }

  000d0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	c9		 leave
  000e0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetMaterialData@CGrannyLODController@@QAEXPBDABUSMaterialData@@@Z ENDP ; CGrannyLODController::SetMaterialData
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 12
$T3 = -68						; size = 12
_i$ = -56						; size = 12
_pkModelInst$4 = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv263 = -28						; size = 4
tv231 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_szImageName$ = 8					; size = 4
_pImage$ = 12						; size = 4
?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z PROC ; CGrannyLODController::SetMaterialImagePointer, COMDAT
; _this$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >

; 153  : 	std::deque<CGrannyModelInstance *>::iterator i;

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 154  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  00034	8d 45 bc	 lea	 eax, DWORD PTR $T3[ebp]
  00037	50		 push	 eax
  00038	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 c1 24	 add	 ecx, 36			; 00000024H
  0003e	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00043	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
  00046	ff 75 e0	 push	 DWORD PTR $T7[ebp]
  00049	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  0004c	e8 00 00 00 00	 call	 ??4?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
  00051	eb 07		 jmp	 SHORT $LN4@SetMateria
$LN2@SetMateria:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00053	8b 45 d0	 mov	 eax, DWORD PTR _i$[ebp+8]
  00056	40		 inc	 eax
  00057	89 45 d0	 mov	 DWORD PTR _i$[ebp+8], eax
$LN4@SetMateria:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 154  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  0005a	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 24	 add	 ecx, 36			; 00000024H
  00064	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00069	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0006f	8b 4d d0	 mov	 ecx, DWORD PTR _i$[ebp+8]
  00072	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00075	75 09		 jne	 SHORT $LN121@SetMateria
  00077	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv231[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN122@SetMateria
$LN121@SetMateria:
  00080	83 65 e8 00	 and	 DWORD PTR tv231[ebp], 0
$LN122@SetMateria:
  00084	8a 45 e8	 mov	 al, BYTE PTR tv231[ebp]
  00087	88 45 f3	 mov	 BYTE PTR $T9[ebp], al

; 355  :         return !(*this == _Right);

  0008a	0f b6 45 f3	 movzx	 eax, BYTE PTR $T9[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	75 09		 jne	 SHORT $LN116@SetMateria
  00092	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv263[ebp], 1
  00099	eb 04		 jmp	 SHORT $LN117@SetMateria
$LN116@SetMateria:
  0009b	83 65 e4 00	 and	 DWORD PTR tv263[ebp], 0
$LN117@SetMateria:
  0009f	8a 45 e4	 mov	 al, BYTE PTR tv263[ebp]
  000a2	88 45 f2	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 154  : 	for (i=m_que_pkModelInst.begin(); i!=m_que_pkModelInst.end(); ++i)

  000a5	0f b6 45 f2	 movzx	 eax, BYTE PTR $T8[ebp]
  000a9	85 c0		 test	 eax, eax
  000ab	74 23		 je	 SHORT $LN3@SetMateria
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  000b0	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QBEABQAVCGrannyModelInstance@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >::operator*
  000b5	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 156  : 		CGrannyModelInstance* pkModelInst=(*i);

  000b8	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 d4	 mov	 DWORD PTR _pkModelInst$4[ebp], eax

; 157  : 		pkModelInst->SetMaterialImagePointer(c_szImageName, pImage);

  000c0	ff 75 0c	 push	 DWORD PTR _pImage$[ebp]
  000c3	ff 75 08	 push	 DWORD PTR _c_szImageName$[ebp]
  000c6	8b 4d d4	 mov	 ecx, DWORD PTR _pkModelInst$4[ebp]
  000c9	e8 00 00 00 00	 call	 ?SetMaterialImagePointer@CGrannyModelInstance@@QAEXPBDPAVCGraphicImage@@@Z ; CGrannyModelInstance::SetMaterialImagePointer

; 158  : 	}

  000ce	eb 83		 jmp	 SHORT $LN2@SetMateria
$LN3@SetMateria:

; 159  : }

  000d0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	c9		 leave
  000e0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _i$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetMaterialImagePointer@CGrannyLODController@@QAEXPBDPAVCGraphicImage@@@Z ENDP ; CGrannyLODController::SetMaterialImagePointer
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetLODLevel@CGrannyLODController@@QAEXE@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
_bLodLevel$ = 8						; size = 1
?SetLODLevel@CGrannyLODController@@QAEXE@Z PROC		; CGrannyLODController::SetLODLevel, COMDAT
; _this$ = ecx

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 24	 add	 eax, 36			; 00000024H
  0000f	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00012	8b 45 f8	 mov	 eax, DWORD PTR $T6[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax

; 1001 :         return _Mysize();

  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 390  : 	if (m_que_pkModelInst.size() > 0)

  00023	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  00027	76 31		 jbe	 SHORT $LN1@SetLODLeve
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c0 24	 add	 eax, 36			; 00000024H
  0002f	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00035	83 c0 10	 add	 eax, 16			; 00000010H
  00038	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax

; 1001 :         return _Mysize();

  0003b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 391  : 		m_bLODLevel	= (BYTE) MIN(m_que_pkModelInst.size() - 1, bLodLevel);

  00043	0f b6 45 08	 movzx	 eax, BYTE PTR _bLodLevel$[ebp]
  00047	50		 push	 eax
  00048	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0004b	48		 dec	 eax
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ?MIN@@YAHHH@Z		; MIN
  00052	59		 pop	 ecx
  00053	59		 pop	 ecx
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	88 41 1c	 mov	 BYTE PTR [ecx+28], al
$LN1@SetLODLeve:

; 392  : }

  0005a	c9		 leave
  0005b	c2 04 00	 ret	 4
?SetLODLevel@CGrannyLODController@@QAEXE@Z ENDP		; CGrannyLODController::SetLODLevel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetLODLimits@CGrannyLODController@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
_fFarLOD$ = 12						; size = 4
?SetLODLimits@CGrannyLODController@@QAEXMM@Z PROC	; CGrannyLODController::SetLODLimits, COMDAT
; _this$ = ecx

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 383  : 	m_fLODDistance = fFarLOD;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fFarLOD$[ebp]
  0000f	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 384  : }

  00014	c9		 leave
  00015	c2 08 00	 ret	 8
?SetLODLimits@CGrannyLODController@@QAEXMM@Z ENDP	; CGrannyLODController::SetLODLimits
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?DetachModelInstance@CGrannyLODController@@QAEXPAV1@@Z
_TEXT	SEGMENT
$T1 = -76						; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
_rData$5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
___param0$ = -44					; size = 4
___param0$ = -40					; size = 4
_pDestInstance$ = -36					; size = 4
tv177 = -32						; size = 4
tv191 = -28						; size = 4
__My_data$9 = -24					; size = 4
__My_data$10 = -20					; size = 4
_pSrcInstance$ = -16					; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
_pSrcLODController$ = 8					; size = 4
?DetachModelInstance@CGrannyLODController@@QAEXPAV1@@Z PROC ; CGrannyLODController::DetachModelInstance, COMDAT
; _this$ = ecx

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 349  : 	CGrannyModelInstance * pSrcInstance = pSrcLODController->GetModelInstance();

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pSrcLODController$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00011	89 45 f0	 mov	 DWORD PTR _pSrcInstance$[ebp], eax

; 350  : 	if (!pSrcInstance)

  00014	83 7d f0 00	 cmp	 DWORD PTR _pSrcInstance$[ebp], 0
  00018	75 05		 jne	 SHORT $LN5@DetachMode

; 351  : 		return;

  0001a	e9 e8 00 00 00	 jmp	 $LN1@DetachMode
$LN5@DetachMode:

; 352  : 
; 353  : 	CGrannyModelInstance * pDestInstance = GetModelInstance();

  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00027	89 45 dc	 mov	 DWORD PTR _pDestInstance$[ebp], eax

; 354  : 	if (pDestInstance)

  0002a	83 7d dc 00	 cmp	 DWORD PTR _pDestInstance$[ebp], 0
  0002e	74 0c		 je	 SHORT $LN6@DetachMode

; 355  : 	{
; 356  : 		pSrcInstance->SetParentModelInstance(NULL, 0);

  00030	6a 00		 push	 0
  00032	6a 00		 push	 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _pSrcInstance$[ebp]
  00037	e8 00 00 00 00	 call	 ?SetParentModelInstance@CGrannyModelInstance@@QAEXPBV1@H@Z ; CGrannyModelInstance::SetParentModelInstance
$LN6@DetachMode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0003c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00042	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00048	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004b	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00053	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00056	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@DetachMode:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005f	89 45 e8	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00062	8b 45 e8	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00065	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00068	8b 45 e8	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00071	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00074	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00077	8d 45 d0	 lea	 eax, DWORD PTR $T8[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0007d	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	3b 45 f8	 cmp	 eax, DWORD PTR _itor$[ebp]
  00085	75 09		 jne	 SHORT $LN47@DetachMode
  00087	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  0008e	eb 04		 jmp	 SHORT $LN48@DetachMode
$LN47@DetachMode:
  00090	83 65 e4 00	 and	 DWORD PTR tv191[ebp], 0
$LN48@DetachMode:
  00094	8a 45 e4	 mov	 al, BYTE PTR tv191[ebp]
  00097	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  0009a	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  0009e	85 c0		 test	 eax, eax
  000a0	75 09		 jne	 SHORT $LN42@DetachMode
  000a2	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  000a9	eb 04		 jmp	 SHORT $LN43@DetachMode
$LN42@DetachMode:
  000ab	83 65 e0 00	 and	 DWORD PTR tv177[ebp], 0
$LN43@DetachMode:
  000af	8a 45 e0	 mov	 al, BYTE PTR tv177[ebp]
  000b2	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 364  : 	for (; m_AttachedModelDataVector.end() != itor;)

  000b5	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  000b9	85 c0		 test	 eax, eax
  000bb	74 43		 je	 SHORT $LN3@DetachMode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000c0	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000c3	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000c6	89 45 c4	 mov	 DWORD PTR _rData$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 367  : 		if (pSrcLODController == rData.pkLODController)

  000c9	8b 45 c4	 mov	 eax, DWORD PTR _rData$5[ebp]
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _pSrcLODController$[ebp]
  000cf	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d1	75 1f		 jne	 SHORT $LN7@DetachMode

; 368  : 		{
; 369  : 			itor = m_AttachedModelDataVector.erase(itor);

  000d3	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000d6	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000d9	ff 75 c0	 push	 DWORD PTR $T4[ebp]
  000dc	8d 45 b4	 lea	 eax, DWORD PTR $T1[ebp]
  000df	50		 push	 eax
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000e6	e8 00 00 00 00	 call	 ?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::erase
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax

; 370  : 		}

  000f0	eb 09		 jmp	 SHORT $LN8@DetachMode
$LN7@DetachMode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000f2	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000f5	83 c0 1c	 add	 eax, 28			; 0000001cH
  000f8	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN8@DetachMode:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 375  : 	}

  000fb	e9 59 ff ff ff	 jmp	 $LN4@DetachMode
$LN3@DetachMode:

; 376  : 
; 377  : 	// Unlink Parent Data
; 378  : 	pSrcLODController->m_pAttachedParentModel = NULL;

  00100	8b 45 08	 mov	 eax, DWORD PTR _pSrcLODController$[ebp]
  00103	83 60 18 00	 and	 DWORD PTR [eax+24], 0
$LN1@DetachMode:

; 379  : }

  00107	c9		 leave
  00108	c2 04 00	 ret	 4
?DetachModelInstance@CGrannyLODController@@QAEXPAV1@@Z ENDP ; CGrannyLODController::DetachModelInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z
_TEXT	SEGMENT
$T2 = -128						; size = 4
$T3 = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
$T6 = -112						; size = 4
$T7 = -108						; size = 4
_rData$8 = -104						; size = 4
$T9 = -100						; size = 4
$T10 = -96						; size = 4
$T11 = -92						; size = 4
___param0$ = -88					; size = 4
___param0$ = -84					; size = 4
tv189 = -80						; size = 4
tv203 = -76						; size = 4
__My_data$12 = -72					; size = 4
__My_data$13 = -68					; size = 4
_pSrcInstance$ = -64					; size = 4
_pDestInstance$ = -60					; size = 4
_this$ = -56						; size = 4
_itor$ = -52						; size = 4
$T14 = -46						; size = 1
$T15 = -45						; size = 1
_AttachingModelData$ = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pSrcLODController$ = 8					; size = 4
_c_szBoneName$ = 12					; size = 4
?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z PROC ; CGrannyLODController::AttachModelInstance, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 74	 sub	 esp, 116		; 00000074H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 310  : 	CGrannyModelInstance * pSrcInstance = pSrcLODController->GetModelInstance();

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _pSrcLODController$[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00033	89 45 c0	 mov	 DWORD PTR _pSrcInstance$[ebp], eax

; 311  : 	if (!pSrcInstance)

  00036	83 7d c0 00	 cmp	 DWORD PTR _pSrcInstance$[ebp], 0
  0003a	75 05		 jne	 SHORT $LN5@AttachMode

; 312  : 		return;

  0003c	e9 4a 01 00 00	 jmp	 $LN1@AttachMode
$LN5@AttachMode:

; 313  : 
; 314  : 	CGrannyModelInstance * pDestInstance = GetModelInstance();

  00041	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00049	89 45 c4	 mov	 DWORD PTR _pDestInstance$[ebp], eax

; 315  : 	if (pDestInstance)

  0004c	83 7d c4 00	 cmp	 DWORD PTR _pDestInstance$[ebp], 0
  00050	74 0e		 je	 SHORT $LN6@AttachMode

; 316  : 	{
; 317  : 		pSrcInstance->SetParentModelInstance(pDestInstance, c_szBoneName);

  00052	ff 75 0c	 push	 DWORD PTR _c_szBoneName$[ebp]
  00055	ff 75 c4	 push	 DWORD PTR _pDestInstance$[ebp]
  00058	8b 4d c0	 mov	 ecx, DWORD PTR _pSrcInstance$[ebp]
  0005b	e8 00 00 00 00	 call	 ?SetParentModelInstance@CGrannyModelInstance@@QAEXPBV1@PBD@Z ; CGrannyModelInstance::SetParentModelInstance
$LN6@AttachMode:

; 318  : 	}
; 319  : 
; 320  : 	if (!pSrcLODController->GetModelInstance())

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _pSrcLODController$[ebp]
  00063	e8 00 00 00 00	 call	 ?GetModelInstance@CGrannyLODController@@QAEPAVCGrannyModelInstance@@XZ ; CGrannyLODController::GetModelInstance
  00068	85 c0		 test	 eax, eax
  0006a	75 05		 jne	 SHORT $LN7@AttachMode

; 321  : 		return;

  0006c	e9 1a 01 00 00	 jmp	 $LN1@AttachMode
$LN7@AttachMode:

; 322  : 
; 323  : 	// Link Parent Data
; 324  : 	pSrcLODController->m_pAttachedParentModel = this;

  00071	8b 45 08	 mov	 eax, DWORD PTR _pSrcLODController$[ebp]
  00074	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	89 48 18	 mov	 DWORD PTR [eax+24], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0007a	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00080	89 45 bc	 mov	 DWORD PTR __My_data$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00083	8b 45 bc	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00086	89 45 88	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00089	8b 45 bc	 mov	 eax, DWORD PTR __My_data$13[ebp]
  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
  0008e	89 45 ac	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00091	8b 45 ac	 mov	 eax, DWORD PTR ___param0$[ebp]
  00094	89 45 cc	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@AttachMode:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00097	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0009d	89 45 b8	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a0	8b 45 b8	 mov	 eax, DWORD PTR __My_data$12[ebp]
  000a3	89 45 84	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000a6	8b 45 b8	 mov	 eax, DWORD PTR __My_data$12[ebp]
  000a9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ac	89 45 a8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000af	8b 45 a8	 mov	 eax, DWORD PTR ___param0$[ebp]
  000b2	89 45 a4	 mov	 DWORD PTR $T11[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000b5	8d 45 a4	 lea	 eax, DWORD PTR $T11[ebp]
  000b8	89 45 a0	 mov	 DWORD PTR $T10[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  000bb	8b 45 a0	 mov	 eax, DWORD PTR $T10[ebp]
  000be	8b 00		 mov	 eax, DWORD PTR [eax]
  000c0	3b 45 cc	 cmp	 eax, DWORD PTR _itor$[ebp]
  000c3	75 09		 jne	 SHORT $LN49@AttachMode
  000c5	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv203[ebp], 1
  000cc	eb 04		 jmp	 SHORT $LN50@AttachMode
$LN49@AttachMode:
  000ce	83 65 b4 00	 and	 DWORD PTR tv203[ebp], 0
$LN50@AttachMode:
  000d2	8a 45 b4	 mov	 al, BYTE PTR tv203[ebp]
  000d5	88 45 d3	 mov	 BYTE PTR $T15[ebp], al

; 153  :         return !(*this == _Right);

  000d8	0f b6 45 d3	 movzx	 eax, BYTE PTR $T15[ebp]
  000dc	85 c0		 test	 eax, eax
  000de	75 09		 jne	 SHORT $LN44@AttachMode
  000e0	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv189[ebp], 1
  000e7	eb 04		 jmp	 SHORT $LN45@AttachMode
$LN44@AttachMode:
  000e9	83 65 b0 00	 and	 DWORD PTR tv189[ebp], 0
$LN45@AttachMode:
  000ed	8a 45 b0	 mov	 al, BYTE PTR tv189[ebp]
  000f0	88 45 d2	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 328  : 	for (; m_AttachedModelDataVector.end() != itor;)

  000f3	0f b6 45 d2	 movzx	 eax, BYTE PTR $T14[ebp]
  000f7	85 c0		 test	 eax, eax
  000f9	74 43		 je	 SHORT $LN3@AttachMode
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000fb	8b 45 cc	 mov	 eax, DWORD PTR _itor$[ebp]
  000fe	89 45 9c	 mov	 DWORD PTR $T9[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00101	8b 45 9c	 mov	 eax, DWORD PTR $T9[ebp]
  00104	89 45 98	 mov	 DWORD PTR _rData$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 331  : 		if (pSrcLODController == rData.pkLODController)

  00107	8b 45 98	 mov	 eax, DWORD PTR _rData$8[ebp]
  0010a	8b 4d 08	 mov	 ecx, DWORD PTR _pSrcLODController$[ebp]
  0010d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0010f	75 1f		 jne	 SHORT $LN8@AttachMode

; 332  : 		{
; 333  : 			itor = m_AttachedModelDataVector.erase(itor);

  00111	8b 45 cc	 mov	 eax, DWORD PTR _itor$[ebp]
  00114	89 45 94	 mov	 DWORD PTR $T7[ebp], eax
  00117	ff 75 94	 push	 DWORD PTR $T7[ebp]
  0011a	8d 45 80	 lea	 eax, DWORD PTR $T2[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00124	e8 00 00 00 00	 call	 ?erase@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USAttachingModelData@CGrannyLODController@@@std@@@std@@@2@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::erase
  00129	8b 00		 mov	 eax, DWORD PTR [eax]
  0012b	89 45 cc	 mov	 DWORD PTR _itor$[ebp], eax

; 334  : 		}

  0012e	eb 09		 jmp	 SHORT $LN9@AttachMode
$LN8@AttachMode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00130	8b 45 cc	 mov	 eax, DWORD PTR _itor$[ebp]
  00133	83 c0 1c	 add	 eax, 28			; 0000001cH
  00136	89 45 cc	 mov	 DWORD PTR _itor$[ebp], eax
$LN9@AttachMode:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 339  : 	}

  00139	e9 59 ff ff ff	 jmp	 $LN4@AttachMode
$LN3@AttachMode:

; 340  : 
; 341  : 	TAttachingModelData AttachingModelData;

  0013e	8d 4d d4	 lea	 ecx, DWORD PTR _AttachingModelData$[ebp]
  00141	e8 00 00 00 00	 call	 ??0SAttachingModelData@CGrannyLODController@@QAE@XZ
  00146	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 342  : 	AttachingModelData.pkLODController = pSrcLODController;

  0014a	8b 45 08	 mov	 eax, DWORD PTR _pSrcLODController$[ebp]
  0014d	89 45 d4	 mov	 DWORD PTR _AttachingModelData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00150	ff 75 0c	 push	 DWORD PTR _c_szBoneName$[ebp]
  00153	e8 00 00 00 00	 call	 _strlen
  00158	59		 pop	 ecx
  00159	89 45 90	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0015c	8b 45 90	 mov	 eax, DWORD PTR $T6[ebp]
  0015f	89 45 8c	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00162	ff 75 8c	 push	 DWORD PTR $T5[ebp]
  00165	ff 75 0c	 push	 DWORD PTR _c_szBoneName$[ebp]
  00168	8d 4d d8	 lea	 ecx, DWORD PTR _AttachingModelData$[ebp+4]
  0016b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00170	8d 45 d4	 lea	 eax, DWORD PTR _AttachingModelData$[ebp]
  00173	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 344  : 	m_AttachedModelDataVector.push_back(AttachingModelData);

  00174	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	83 c1 0c	 add	 ecx, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0017a	e8 00 00 00 00	 call	 ??$emplace_back@ABUSAttachingModelData@CGrannyLODController@@@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXABUSAttachingModelData@CGrannyLODController@@@Z ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::emplace_back<CGrannyLODController::SAttachingModelData const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 345  : }

  0017f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00183	8d 4d d8	 lea	 ecx, DWORD PTR _AttachingModelData$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00186	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1@AttachMode:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 345  : }

  0018b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00195	59		 pop	 ecx
  00196	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00199	33 cd		 xor	 ecx, ebp
  0019b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a0	c9		 leave
  001a1	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR _AttachingModelData$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SAttachingModelData@CGrannyLODController@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AttachModelInstance@CGrannyLODController@@QAEXPAV1@PBD@Z ENDP ; CGrannyLODController::AttachModelInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?AddModel@CGrannyLODController@@QAEXPAVCGraphicThing@@HPAV1@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 4
__Xx$ = -80						; size = 4
$T2 = -76						; size = 4
__Xx$ = -72						; size = 4
$T3 = -68						; size = 4
__Xx$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
tv220 = -52						; size = 4
_pModel$ = -48						; size = 4
_pModelInstance$ = -44					; size = 4
_fSize$6 = -40						; size = 4
$T7 = -33						; size = 1
_this$ = -32						; size = 4
_vtMax$8 = -28						; size = 12
_vtMin$9 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_pThing$ = 8						; size = 4
_iSrcModel$ = 12					; size = 4
_pSkelLODController$ = 16				; size = 4
?AddModel@CGrannyLODController@@QAEXPAVCGraphicThing@@HPAV1@@Z PROC ; CGrannyLODController::AddModel, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 224  : 	if (!pThing)

  00013	83 7d 08 00	 cmp	 DWORD PTR _pThing$[ebp], 0
  00017	75 05		 jne	 SHORT $LN2@AddModel

; 225  : 		return;

  00019	e9 4d 02 00 00	 jmp	 $LN1@AddModel
$LN2@AddModel:

; 227  : 	if (pSkelLODController && pSkelLODController->m_que_pkModelInst.empty())

  0001e	83 7d 10 00	 cmp	 DWORD PTR _pSkelLODController$[ebp], 0
  00022	74 3a		 je	 SHORT $LN3@AddModel
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1534 :         return _Mypair._Myval2;

  00024	8b 45 10	 mov	 eax, DWORD PTR _pSkelLODController$[ebp]
  00027	83 c0 24	 add	 eax, 36			; 00000024H
  0002a	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  0002d	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  00030	83 c0 10	 add	 eax, 16			; 00000010H
  00033	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1010 :         return _Mysize() == 0;

  00036	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	75 09		 jne	 SHORT $LN15@AddModel
  0003e	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv220[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN16@AddModel
$LN15@AddModel:
  00047	83 65 cc 00	 and	 DWORD PTR tv220[ebp], 0
$LN16@AddModel:
  0004b	8a 45 cc	 mov	 al, BYTE PTR tv220[ebp]
  0004e	88 45 df	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 227  : 	if (pSkelLODController && pSkelLODController->m_que_pkModelInst.empty())

  00051	0f b6 45 df	 movzx	 eax, BYTE PTR $T7[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 05		 je	 SHORT $LN3@AddModel

; 228  : 	{
; 229  : 		assert(!"EMPTY SKELETON(CANNON LINK)");
; 230  : 		return;

  00059	e9 0d 02 00 00	 jmp	 $LN1@AddModel
$LN3@AddModel:

; 231  : 	}
; 232  : 
; 233  : 	assert(pThing->GetReferenceCount()>=1);
; 234  : 
; 235  : 	pThing->AddReference();	

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00061	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 236  : 	
; 237  : 	if (pThing->GetModelCount() <= iSrcModel)

  00066	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00069	e8 00 00 00 00	 call	 ?GetModelCount@CGraphicThing@@QBEHXZ ; CGraphicThing::GetModelCount
  0006e	3b 45 0c	 cmp	 eax, DWORD PTR _iSrcModel$[ebp]
  00071	7f 0d		 jg	 SHORT $LN4@AddModel

; 238  : 	{
; 239  : 		pThing->Release();

  00073	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00076	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 240  : 		return;

  0007b	e9 eb 01 00 00	 jmp	 $LN1@AddModel
$LN4@AddModel:

; 241  : 	}
; 242  : 	CGrannyModel * pModel = pThing->GetModelPointer(iSrcModel);

  00080	ff 75 0c	 push	 DWORD PTR _iSrcModel$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00086	e8 00 00 00 00	 call	 ?GetModelPointer@CGraphicThing@@QAEPAVCGrannyModel@@H@Z ; CGraphicThing::GetModelPointer
  0008b	89 45 d0	 mov	 DWORD PTR _pModel$[ebp], eax

; 243  : 	if (!pModel)

  0008e	83 7d d0 00	 cmp	 DWORD PTR _pModel$[ebp], 0
  00092	75 0d		 jne	 SHORT $LN5@AddModel

; 244  : 	{
; 245  : 		pThing->Release();

  00094	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00097	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 246  : 		return;

  0009c	e9 ca 01 00 00	 jmp	 $LN1@AddModel
$LN5@AddModel:

; 247  : 	}
; 248  : 	
; 249  : 	CGrannyModelInstance * pModelInstance = CGrannyModelInstance::New();

  000a1	e8 00 00 00 00	 call	 ?New@CGrannyModelInstance@@SAPAV1@XZ ; CGrannyModelInstance::New
  000a6	89 45 d4	 mov	 DWORD PTR _pModelInstance$[ebp], eax

; 250  : 	
; 251  : 	__ReserveSharedDeformableVertexBuffer(pModel->GetDeformVertexCount());

  000a9	8b 4d d0	 mov	 ecx, DWORD PTR _pModel$[ebp]
  000ac	e8 00 00 00 00	 call	 ?GetDeformVertexCount@CGrannyModel@@QBEHXZ ; CGrannyModel::GetDeformVertexCount
  000b1	50		 push	 eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ?__ReserveSharedDeformableVertexBuffer@CGrannyLODController@@IAEXK@Z ; CGrannyLODController::__ReserveSharedDeformableVertexBuffer

; 252  : 
; 253  : 	if (pSkelLODController)

  000ba	83 7d 10 00	 cmp	 DWORD PTR _pSkelLODController$[ebp], 0
  000be	74 1a		 je	 SHORT $LN6@AddModel

; 254  : 	{
; 255  : 		pModelInstance->SetLinkedModelPointer(pModel, m_pkSharedDeformableVertexBuffer, &pSkelLODController->m_pCurrentModelInstance);

  000c0	8b 45 10	 mov	 eax, DWORD PTR _pSkelLODController$[ebp]
  000c3	83 c0 20	 add	 eax, 32			; 00000020H
  000c6	50		 push	 eax
  000c7	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	ff 70 38	 push	 DWORD PTR [eax+56]
  000cd	ff 75 d0	 push	 DWORD PTR _pModel$[ebp]
  000d0	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  000d3	e8 00 00 00 00	 call	 ?SetLinkedModelPointer@CGrannyModelInstance@@QAEXPAVCGrannyModel@@PAVCGraphicVertexBuffer@@PAPAV1@@Z ; CGrannyModelInstance::SetLinkedModelPointer

; 256  : 	}

  000d8	eb 13		 jmp	 SHORT $LN7@AddModel
$LN6@AddModel:

; 257  : 	else
; 258  : 	{		
; 259  : 		pModelInstance->SetLinkedModelPointer(pModel, m_pkSharedDeformableVertexBuffer, NULL);

  000da	6a 00		 push	 0
  000dc	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	ff 70 38	 push	 DWORD PTR [eax+56]
  000e2	ff 75 d0	 push	 DWORD PTR _pModel$[ebp]
  000e5	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  000e8	e8 00 00 00 00	 call	 ?SetLinkedModelPointer@CGrannyModelInstance@@QAEXPAVCGrannyModel@@PAVCGraphicVertexBuffer@@PAPAV1@@Z ; CGrannyModelInstance::SetLinkedModelPointer
$LN7@AddModel:

; 260  : 	}
; 261  : 
; 262  : 	// END_OF_WORK
; 263  : 	
; 264  : 	if (!m_pCurrentModelInstance)

  000ed	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000f4	0f 85 4d 01 00
	00		 jne	 $LN8@AddModel

; 265  : 	{
; 266  : 		m_pCurrentModelInstance = pModelInstance;

  000fa	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  00100	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 267  : 		pModelInstance->DeformNoSkin(&ms_matIdentity);

  00103	68 00 00 00 00	 push	 OFFSET ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matIdentity
  00108	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  0010b	e8 00 00 00 00	 call	 ?DeformNoSkin@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyModelInstance::DeformNoSkin

; 268  : 
; 269  : 		D3DXVECTOR3 vtMin, vtMax;
; 270  : 		pModelInstance->GetBoundBox(&vtMin, &vtMax);

  00110	8d 45 e4	 lea	 eax, DWORD PTR _vtMax$8[ebp]
  00113	50		 push	 eax
  00114	8d 45 f0	 lea	 eax, DWORD PTR _vtMin$9[ebp]
  00117	50		 push	 eax
  00118	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  0011b	e8 00 00 00 00	 call	 ?GetBoundBox@CGrannyModelInstance@@QAEXPAUD3DXVECTOR3@@0@Z ; CGrannyModelInstance::GetBoundBox

; 271  : 
; 272  : 		float fSize = 0.0f;

  00120	0f 57 c0	 xorps	 xmm0, xmm0
  00123	f3 0f 11 45 d8	 movss	 DWORD PTR _fSize$6[ebp], xmm0

; 273  : 		fSize = fMAX(fSize, fabs(vtMin.x - vtMax.x));

  00128	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _vtMin$9[ebp]
  0012d	f3 0f 5c 45 e4	 subss	 xmm0, DWORD PTR _vtMax$8[ebp]
  00132	f3 0f 11 45 c0	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00137	f3 0f 5a 45 c0	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  0013c	51		 push	 ecx
  0013d	51		 push	 ecx
  0013e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00143	e8 00 00 00 00	 call	 _fabs
  00148	59		 pop	 ecx
  00149	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  0014a	d9 5d bc	 fstp	 DWORD PTR $T3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 273  : 		fSize = fMAX(fSize, fabs(vtMin.x - vtMax.x));

  0014d	51		 push	 ecx
  0014e	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR $T3[ebp]
  00153	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00158	51		 push	 ecx
  00159	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fSize$6[ebp]
  0015e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00163	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00168	59		 pop	 ecx
  00169	59		 pop	 ecx
  0016a	d9 5d d8	 fstp	 DWORD PTR _fSize$6[ebp]

; 274  : 		fSize = fMAX(fSize, fabs(vtMin.y - vtMax.y));

  0016d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _vtMin$9[ebp+4]
  00172	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _vtMax$8[ebp+4]
  00177	f3 0f 11 45 b8	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0017c	f3 0f 5a 45 b8	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00181	51		 push	 ecx
  00182	51		 push	 ecx
  00183	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00188	e8 00 00 00 00	 call	 _fabs
  0018d	59		 pop	 ecx
  0018e	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  0018f	d9 5d b4	 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 274  : 		fSize = fMAX(fSize, fabs(vtMin.y - vtMax.y));

  00192	51		 push	 ecx
  00193	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR $T2[ebp]
  00198	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019d	51		 push	 ecx
  0019e	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fSize$6[ebp]
  001a3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a8	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  001ad	59		 pop	 ecx
  001ae	59		 pop	 ecx
  001af	d9 5d d8	 fstp	 DWORD PTR _fSize$6[ebp]

; 275  : 		fSize = fMAX(fSize, fabs(vtMin.z - vtMax.z));		

  001b2	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _vtMin$9[ebp+8]
  001b7	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _vtMax$8[ebp+8]
  001bc	f3 0f 11 45 b0	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  001c1	f3 0f 5a 45 b0	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  001c6	51		 push	 ecx
  001c7	51		 push	 ecx
  001c8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001cd	e8 00 00 00 00	 call	 _fabs
  001d2	59		 pop	 ecx
  001d3	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  001d4	d9 5d ac	 fstp	 DWORD PTR $T1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 275  : 		fSize = fMAX(fSize, fabs(vtMin.z - vtMax.z));		

  001d7	51		 push	 ecx
  001d8	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR $T1[ebp]
  001dd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e2	51		 push	 ecx
  001e3	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fSize$6[ebp]
  001e8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ed	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  001f2	59		 pop	 ecx
  001f3	59		 pop	 ecx
  001f4	d9 5d d8	 fstp	 DWORD PTR _fSize$6[ebp]

; 276  : 
; 277  : 		if (fSize<LODHEIGHT_ACTOR)			

  001f7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?LODHEIGHT_ACTOR@@3MA
  001ff	0f 2f 45 d8	 comiss	 xmm0, DWORD PTR _fSize$6[ebp]
  00203	76 21		 jbe	 SHORT $LN10@AddModel

; 278  : 			SetLODLimits(0.0f, LODDISTANCE_ACTOR);

  00205	51		 push	 ecx
  00206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?LODDISTANCE_ACTOR@@3MA
  0020e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00213	51		 push	 ecx
  00214	0f 57 c0	 xorps	 xmm0, xmm0
  00217	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0021c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0021f	e8 00 00 00 00	 call	 ?SetLODLimits@CGrannyLODController@@QAEXMM@Z ; CGrannyLODController::SetLODLimits
  00224	eb 1f		 jmp	 SHORT $LN11@AddModel
$LN10@AddModel:

; 279  : 		else
; 280  : 			// 
; 281  : 			SetLODLimits(0.0f, LODDISTANCE_BUILDING);

  00226	51		 push	 ecx
  00227	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?LODDISTANCE_BUILDING@@3MA
  0022f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00234	51		 push	 ecx
  00235	0f 57 c0	 xorps	 xmm0, xmm0
  00238	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0023d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?SetLODLimits@CGrannyLODController@@QAEXMM@Z ; CGrannyLODController::SetLODLimits
$LN11@AddModel:

; 282  : 	}

  00245	eb 0d		 jmp	 SHORT $LN9@AddModel
$LN8@AddModel:

; 283  : 	else
; 284  : 	{
; 285  : 		// FIXME : CModelInstance::m_pgrnWorldPose Update ,
; 286  : 		//         Deform   NULL .    .. - [levites]
; 287  :  		pModelInstance->DeformNoSkin(&ms_matIdentity);

  00247	68 00 00 00 00	 push	 OFFSET ?ms_matIdentity@CGraphicBase@@1UD3DXMATRIX@@A ; CGraphicBase::ms_matIdentity
  0024c	8b 4d d4	 mov	 ecx, DWORD PTR _pModelInstance$[ebp]
  0024f	e8 00 00 00 00	 call	 ?DeformNoSkin@CGrannyModelInstance@@QAEXPBUD3DXMATRIX@@@Z ; CGrannyModelInstance::DeformNoSkin
$LN9@AddModel:

; 288  : 	}	
; 289  : 
; 290  : 	pThing->Release();

  00254	8b 4d 08	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00257	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 291  : 
; 292  : 	m_que_pkModelInst.push_front(pModelInstance);	

  0025c	8d 45 d4	 lea	 eax, DWORD PTR _pModelInstance$[ebp]
  0025f	50		 push	 eax
  00260	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	83 c1 24	 add	 ecx, 36			; 00000024H
  00266	e8 00 00 00 00	 call	 ?push_front@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAEXABQAVCGrannyModelInstance@@@Z ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::push_front
$LN1@AddModel:

; 293  : }

  0026b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026e	33 cd		 xor	 ecx, ebp
  00270	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00275	c9		 leave
  00276	c2 0c 00	 ret	 12			; 0000000cH
?AddModel@CGrannyLODController@@QAEXPAVCGraphicThing@@HPAV1@@Z ENDP ; CGrannyLODController::AddModel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?DestroyDeviceObjects@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 1
_this$ = -8						; size = 4
$T4 = -2						; size = 1
tv64 = -1						; size = 1
?DestroyDeviceObjects@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::DestroyDeviceObjects, COMDAT
; _this$ = ecx

; 402  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 403  : 	std::for_each(m_que_pkModelInst.begin(),

  00009	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0000c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000f	8b c4		 mov	 eax, esp
  00011	89 65 f0	 mov	 DWORD PTR $T2[ebp], esp
  00014	50		 push	 eax
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 24	 add	 ecx, 36			; 00000024H
  0001b	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00020	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00023	8b c4		 mov	 eax, esp
  00025	89 65 ec	 mov	 DWORD PTR $T1[ebp], esp
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 24	 add	 ecx, 36			; 00000024H
  0002f	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00034	e8 00 00 00 00	 call	 ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFDestroyDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFDestroyDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FDestroyDeviceObjects>
  00039	83 c4 1c	 add	 esp, 28			; 0000001cH
  0003c	88 45 ff	 mov	 BYTE PTR tv64[ebp], al
  0003f	8a 45 ff	 mov	 al, BYTE PTR tv64[ebp]
  00042	88 45 fe	 mov	 BYTE PTR $T4[ebp], al

; 404  : 				  m_que_pkModelInst.end(),
; 405  : 				  CGrannyModelInstance::FDestroyDeviceObjects());
; 406  : }

  00045	c9		 leave
  00046	c3		 ret	 0
?DestroyDeviceObjects@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::DestroyDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?CreateDeviceObjects@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 1
_this$ = -8						; size = 4
$T4 = -2						; size = 1
tv64 = -1						; size = 1
?CreateDeviceObjects@CGrannyLODController@@QAEXXZ PROC	; CGrannyLODController::CreateDeviceObjects, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	std::for_each(m_que_pkModelInst.begin(),

  00009	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0000c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0000f	8b c4		 mov	 eax, esp
  00011	89 65 f0	 mov	 DWORD PTR $T2[ebp], esp
  00014	50		 push	 eax
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 24	 add	 ecx, 36			; 00000024H
  0001b	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00020	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00023	8b c4		 mov	 eax, esp
  00025	89 65 ec	 mov	 DWORD PTR $T1[ebp], esp
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 24	 add	 ecx, 36			; 00000024H
  0002f	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  00034	e8 00 00 00 00	 call	 ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@UFCreateDeviceObjects@CGrannyModelInstance@@@std@@YA?AUFCreateDeviceObjects@CGrannyModelInstance@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@0U12@@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,CGrannyModelInstance::FCreateDeviceObjects>
  00039	83 c4 1c	 add	 esp, 28			; 0000001cH
  0003c	88 45 ff	 mov	 BYTE PTR tv64[ebp], al
  0003f	8a 45 ff	 mov	 al, BYTE PTR tv64[ebp]
  00042	88 45 fe	 mov	 BYTE PTR $T4[ebp], al

; 397  : 				  m_que_pkModelInst.end(),
; 398  : 				  CGrannyModelInstance::FCreateDeviceObjects());
; 399  : }

  00045	c9		 leave
  00046	c3		 ret	 0
?CreateDeviceObjects@CGrannyLODController@@QAEXXZ ENDP	; CGrannyLODController::CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?Clear@CGrannyLODController@@QAEXXZ
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
_rData$5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
___param0$ = -36					; size = 4
___param0$ = -32					; size = 4
tv287 = -28						; size = 4
tv301 = -24						; size = 4
__My_data$9 = -20					; size = 4
__My_data$10 = -16					; size = 4
_itor$ = -12						; size = 4
_this$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
?Clear@CGrannyLODController@@QAEXXZ PROC		; CGrannyLODController::Clear, COMDAT
; _this$ = ecx

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 201  : 	if (m_pAttachedParentModel)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 18 00	 cmp	 DWORD PTR [eax+24], 0
  00010	74 0e		 je	 SHORT $LN5@Clear

; 202  : 	{
; 203  : 		m_pAttachedParentModel->DetachModelInstance(this);

  00012	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0001b	e8 00 00 00 00	 call	 ?DetachModelInstance@CGrannyLODController@@QAEXPAV1@@Z ; CGrannyLODController::DetachModelInstance
$LN5@Clear:

; 204  : 	}
; 205  : 
; 206  : 	m_pCurrentModelInstance = NULL;

  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 207  : 	m_pAttachedParentModel = NULL;

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 18 00	 and	 DWORD PTR [eax+24], 0

; 208  : 
; 209  : 	std::for_each(m_que_pkModelInst.begin(), m_que_pkModelInst.end(), CGrannyModelInstance::Delete);

  0002e	68 00 00 00 00	 push	 OFFSET ?Delete@CGrannyModelInstance@@SAXPAV1@@Z ; CGrannyModelInstance::Delete
  00033	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00036	8b c4		 mov	 eax, esp
  00038	89 65 c8	 mov	 DWORD PTR $T4[ebp], esp
  0003b	50		 push	 eax
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 24	 add	 ecx, 36			; 00000024H
  00042	e8 00 00 00 00	 call	 ?end@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::end
  00047	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0004a	8b c4		 mov	 eax, esp
  0004c	89 65 c4	 mov	 DWORD PTR $T3[ebp], esp
  0004f	50		 push	 eax
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 24	 add	 ecx, 36			; 00000024H
  00056	e8 00 00 00 00	 call	 ?begin@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@2@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::begin
  0005b	e8 00 00 00 00	 call	 ??$for_each@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@std@@P6AXPAVCGrannyModelInstance@@@Z@std@@YAP6AXPAVCGrannyModelInstance@@@ZV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVCGrannyModelInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<CGrannyModelInstance *> > >,void (__cdecl*)(CGrannyModelInstance *)>
  00060	83 c4 1c	 add	 esp, 28			; 0000001cH

; 210  : 	m_que_pkModelInst.clear();

  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 24	 add	 ecx, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1330 :         _Tidy();

  00069	e8 00 00 00 00	 call	 ?_Tidy@?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@AAEXXZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 c0 0c	 add	 eax, 12			; 0000000cH
  00074	89 45 f0	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00077	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0007a	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0007d	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00085	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00088	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 213  : 	for (; m_AttachedModelDataVector.end() != itor; ++itor)

  0008b	eb 09		 jmp	 SHORT $LN4@Clear
$LN2@Clear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  00090	83 c0 1c	 add	 eax, 28			; 0000001cH
  00093	89 45 f4	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@Clear:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 0c	 add	 eax, 12			; 0000000cH
  0009c	89 45 ec	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0009f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  000a2	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000a5	8b 45 ec	 mov	 eax, DWORD PTR __My_data$9[ebp]
  000a8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ab	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000ae	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  000b1	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000b4	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  000b7	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  000ba	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	3b 45 f4	 cmp	 eax, DWORD PTR _itor$[ebp]
  000c2	75 09		 jne	 SHORT $LN147@Clear
  000c4	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv301[ebp], 1
  000cb	eb 04		 jmp	 SHORT $LN148@Clear
$LN147@Clear:
  000cd	83 65 e8 00	 and	 DWORD PTR tv301[ebp], 0
$LN148@Clear:
  000d1	8a 45 e8	 mov	 al, BYTE PTR tv301[ebp]
  000d4	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 153  :         return !(*this == _Right);

  000d7	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  000db	85 c0		 test	 eax, eax
  000dd	75 09		 jne	 SHORT $LN142@Clear
  000df	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv287[ebp], 1
  000e6	eb 04		 jmp	 SHORT $LN143@Clear
$LN142@Clear:
  000e8	83 65 e4 00	 and	 DWORD PTR tv287[ebp], 0
$LN143@Clear:
  000ec	8a 45 e4	 mov	 al, BYTE PTR tv287[ebp]
  000ef	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 213  : 	for (; m_AttachedModelDataVector.end() != itor; ++itor)

  000f2	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  000f6	85 c0		 test	 eax, eax
  000f8	74 1a		 je	 SHORT $LN3@Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000fa	8b 45 f4	 mov	 eax, DWORD PTR _itor$[ebp]
  000fd	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00100	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp]
  00103	89 45 cc	 mov	 DWORD PTR _rData$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 216  : 		rData.pkLODController->m_pAttachedParentModel = NULL;

  00106	8b 45 cc	 mov	 eax, DWORD PTR _rData$5[ebp]
  00109	8b 00		 mov	 eax, DWORD PTR [eax]
  0010b	83 60 18 00	 and	 DWORD PTR [eax+24], 0

; 217  : 	}

  0010f	e9 79 ff ff ff	 jmp	 $LN2@Clear
$LN3@Clear:

; 218  : 
; 219  : 	m_AttachedModelDataVector.clear();

  00114	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0011a	e8 00 00 00 00	 call	 ?clear@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAEXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::clear

; 220  : }

  0011f	c9		 leave
  00120	c3		 ret	 0
?Clear@CGrannyLODController@@QAEXXZ ENDP		; CGrannyLODController::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ??1CGrannyLODController@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGrannyLODController@@UAE@XZ PROC			; CGrannyLODController::~CGrannyLODController, COMDAT
; _this$ = ecx

; 193  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGrannyLODController@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGrannyLODController@@6B@

; 194  : 	__FreeDeformVertexBuffer(m_pkSharedDeformableVertexBuffer);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	ff 70 38	 push	 DWORD PTR [eax+56]
  00035	e8 00 00 00 00	 call	 ?__FreeDeformVertexBuffer@@YAXPAVCGraphicVertexBuffer@@@Z ; __FreeDeformVertexBuffer
  0003a	59		 pop	 ecx

; 195  : 
; 196  : 	Clear();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?Clear@CGrannyLODController@@QAEXXZ ; CGrannyLODController::Clear

; 197  : }

  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 24	 add	 ecx, 36			; 00000024H
  00049	e8 00 00 00 00	 call	 ??1?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::~deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 0c	 add	 ecx, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00054	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@AAEXXZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 197  : }

  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
  00061	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00064	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006b	59		 pop	 ecx
  0006c	c9		 leave
  0006d	c3		 ret	 0
  0006e	cc		 int	 3
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGrannyLODController@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGrannyLODController@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGrannyLODController@@UAE@XZ ENDP			; CGrannyLODController::~CGrannyLODController
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ??0CGrannyLODController@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGrannyLODController@@QAE@XZ PROC			; CGrannyLODController::CGrannyLODController, COMDAT
; _this$ = ecx

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGrannyLODController@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CGraphicBase@@QAE@XZ	; CGraphicBase::CGraphicBase
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGrannyLODController@@6B@

; 185  : 	m_fLODDistance(0.0f),

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	0f 57 c0	 xorps	 xmm0, xmm0
  00043	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 186  : 	m_dwLODAniFPS(CGrannyModelInstance::ANIFPS_MAX),

  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 40 08 78 00
	00 00		 mov	 DWORD PTR [eax+8], 120	; 00000078H

; 189  : {

  00052	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00055	83 c0 0c	 add	 eax, 12			; 0000000cH
  00058	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0005b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00061	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00064	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  0006a	83 20 00	 and	 DWORD PTR [eax], 0
  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00070	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00074	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00077	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp

; 189  : {

  0007b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 184  : 	m_pAttachedParentModel(NULL),

  0007f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 60 18 00	 and	 DWORD PTR [eax+24], 0

; 183  : 	m_bLODLevel(0),

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c6 40 1c 00	 mov	 BYTE PTR [eax+28], 0

; 182  : 	m_pCurrentModelInstance(NULL),

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00090	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 189  : {

  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	83 c1 24	 add	 ecx, 36			; 00000024H
  0009a	e8 00 00 00 00	 call	 ??0?$deque@PAVCGrannyModelInstance@@V?$allocator@PAVCGrannyModelInstance@@@std@@@std@@QAE@XZ ; std::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >::deque<CGrannyModelInstance *,std::allocator<CGrannyModelInstance *> >

; 187  : 	m_pkSharedDeformableVertexBuffer(NULL)

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	83 60 38 00	 and	 DWORD PTR [eax+56], 0

; 190  : }

  000a6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000aa	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b7	59		 pop	 ecx
  000b8	c9		 leave
  000b9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGrannyLODController@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
__unwindfunclet$??0CGrannyLODController@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@USAttachingModelData@CGrannyLODController@@V?$allocator@USAttachingModelData@CGrannyLODController@@@std@@@std@@QAE@XZ ; std::vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >::~vector<CGrannyLODController::SAttachingModelData,std::allocator<CGrannyLODController::SAttachingModelData> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0CGrannyLODController@@QAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGrannyLODController@@QAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGrannyLODController@@QAE@XZ ENDP			; CGrannyLODController::CGrannyLODController
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.cpp
;	COMDAT ?SetMinLODMode@CGrannyLODController@@SAX_N@Z
_TEXT	SEGMENT
_isEnable$ = 8						; size = 1
?SetMinLODMode@CGrannyLODController@@SAX_N@Z PROC	; CGrannyLODController::SetMinLODMode, COMDAT

; 147  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 148  : 	ms_isMinLODModeEnable=isEnable;

  00003	8a 45 08	 mov	 al, BYTE PTR _isEnable$[ebp]
  00006	a2 00 00 00 00	 mov	 BYTE PTR ?ms_isMinLODModeEnable@@3_NA, al ; ms_isMinLODModeEnable

; 149  : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
?SetMinLODMode@CGrannyLODController@@SAX_N@Z ENDP	; CGrannyLODController::SetMinLODMode
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -36					; size = 4
__Right_data_mem$2 = -32				; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2636 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2637 :         _Tidy_deallocate();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 2638 :         _Pocma(_Getal(), _Right._Getal());

  00029	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  0002c	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx

; 2639 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00036	33 c0		 xor	 eax, eax
  00038	88 45 ff	 mov	 BYTE PTR $T7[ebp], al
  0003b	8a 45 ff	 mov	 al, BYTE PTR $T7[ebp]
  0003e	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00041	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00044	89 45 dc	 mov	 DWORD PTR __My_data_mem$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00047	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	89 45 e0	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	ff 75 e0	 push	 DWORD PTR __Right_data_mem$2[ebp]
  00052	ff 75 dc	 push	 DWORD PTR __My_data_mem$1[ebp]
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2640 :     }

  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S9$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S9$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
