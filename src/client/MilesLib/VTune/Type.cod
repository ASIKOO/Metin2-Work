; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_fprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z ; NSound::LoadSoundInformationPiece
PUBLIC	?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z ; NSound::SaveSoundInformationPiece
PUBLIC	?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z ; NSound::DataToInstance
PUBLIC	?GetResultString@NSound@@YAPBDXZ		; NSound::GetResultString
PUBLIC	?SetResultString@NSound@@YAXPBD@Z		; NSound::SetResultString
PUBLIC	?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
PUBLIC	?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?deallocate@?$allocator@USSoundData@NSound@@@std@@QAEXQAUSSoundData@NSound@@I@Z ; std::allocator<NSound::SSoundData>::deallocate
PUBLIC	?clear@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::clear
PUBLIC	?_Destroy@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXPAUSSoundData@NSound@@0@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@ABEII@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXQAUSSoundData@NSound@@II@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Change_array
PUBLIC	?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
PUBLIC	?_Getal@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundData@NSound@@@2@XZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Getal
PUBLIC	?deallocate@?$allocator@USSoundInstance@NSound@@@std@@QAEXQAUSSoundInstance@NSound@@I@Z ; std::allocator<NSound::SSoundInstance>::deallocate
PUBLIC	?clear@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::clear
PUBLIC	?at@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEAAUSSoundInstance@NSound@@I@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::at
PUBLIC	?_Destroy@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXPAUSSoundInstance@NSound@@0@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@ABEII@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXQAUSSoundInstance@NSound@@II@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Change_array
PUBLIC	?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
PUBLIC	?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
PUBLIC	?_Getal@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundInstance@NSound@@@2@XZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Getal
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize<std::_Value_init_tag>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundData> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<>
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<>
PUBLIC	??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Uninitialized_move<NSound::SSoundInstance *,std::allocator<NSound::SSoundInstance> >
PUBLIC	??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Uninitialized_move<NSound::SSoundData *,std::allocator<NSound::SSoundData> >
PUBLIC	??$_Emplace_back@USSoundInstance@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEX$$QAUSSoundInstance@NSound@@@Z ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<NSound::SSoundInstance>
PUBLIC	??$_Emplace_back@USSoundData@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEX$$QAUSSoundData@NSound@@@Z ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<NSound::SSoundData>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
PUBLIC	??_C@_0BK@JGMKPCLL@?5?$MA?P?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@ ; `string'
PUBLIC	??_C@_0P@DFMHJMOB@sounddatacount@		; `string'
PUBLIC	??_C@_0CP@DLKHMJJP@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?0?5SoundDataCount@ ; `string'
PUBLIC	??_C@_0O@OOLLGPNP@sounddata?$CF02d@		; `string'
PUBLIC	??_C@_0BB@LICIAONN@?5?$LI?$KG?5?C?$KD?$MA?$LL?5?$LM?v?5?$LO?x?$MA?$LN@ ; `string'
PUBLIC	??_C@_0BC@JDLELIBL@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5@ ; `string'
PUBLIC	??_C@_0CG@EPMBHNFD@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5?$LK?$KE?E?M?5?E?$KJ?$LB?b?$LA?$KB?52?$LA@ ; `string'
PUBLIC	??_C@_07MCJGNGDG@?5?$LK?R?$LH?$KP?$LP?H@	; `string'
PUBLIC	??_C@_02BKFDOEMK@wt@				; `string'
PUBLIC	??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@ ; `string'
PUBLIC	??_C@_04LHBDKBPE@?$LP?$KB?$LH?$KP@		; `string'
PUBLIC	??_C@_0BK@IDDPDHCB@?5?$LO?$LC?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@ ; `string'
PUBLIC	??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@ ; `string'
PUBLIC	??_C@_01EEMJAFIK@?6@				; `string'
PUBLIC	??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@ ; `string'
PUBLIC	??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@ ; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3f800000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	_atof:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	__unlink:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?IsFile@@YA_NPBD@Z:PROC				; IsFile
EXTRN	?LogBox@@YAXPBD0PAUHWND__@@@Z:PROC		; LogBox
EXTRN	?Cache@CTextFileLoader@@SAPAV1@PBD@Z:PROC	; CTextFileLoader::Cache
EXTRN	?IsEmpty@CTextFileLoader@@QAE_NXZ:PROC		; CTextFileLoader::IsEmpty
EXTRN	?SetTop@CTextFileLoader@@QAEXXZ:PROC		; CTextFileLoader::SetTop
EXTRN	?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z:PROC ; CTextFileLoader::GetTokenVector
EXTRN	?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z:PROC ; CTextFileLoader::GetTokenInteger
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 018H DUP (?) ; NSound::strResult
_BSS	ENDS
CRT$XCU	SEGMENT
?strResult$initializer$@NSound@@3P6AXXZA DD FLAT:??__EstrResult@NSound@@YAXXZ ; NSound::strResult$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@ DB 'S'
	DB	'oundData%02d       %f "%s"', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@
CONST	SEGMENT
??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@ DB 'SoundDataCount    %'
	DB	'd', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@
CONST	SEGMENT
??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@ DB 'ScriptTyp'
	DB	'e        CharacterSoundInformation', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IDDPDHCB@?5?$LO?$LC?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@
CONST	SEGMENT
??_C@_0BK@IDDPDHCB@?5?$LO?$LC?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@ DB ' '
	DB	0beH, 0b2H, 0b1H, 0e2H, 0bfH, 0ebH, ' ', 0c6H, 0c4H, 0c0H, 0cfH
	DB	0c0H, 0bbH, ' ', 0bfH, 0adH, ' ', 0bcH, 0f6H, ' ', 0beH, 0f8H, 0c0H
	DB	0bdH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04LHBDKBPE@?$LP?$KB?$LH?$KP@
CONST	SEGMENT
??_C@_04LHBDKBPE@?$LP?$KB?$LH?$KP@ DB 0bfH, 0a1H, 0b7H, 0afH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@
CONST	SEGMENT
??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@ DB 'Fa'
	DB	'iled to save file (%s).', 0aH, 'Please check if it is read-on'
	DB	'ly or you have no space on the disk.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02BKFDOEMK@wt@
CONST	SEGMENT
??_C@_02BKFDOEMK@wt@ DB 'wt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07MCJGNGDG@?5?$LK?R?$LH?$KP?$LP?H@
CONST	SEGMENT
??_C@_07MCJGNGDG@?5?$LK?R?$LH?$KP?$LP?H@ DB ' ', 0baH, 0d2H, 0b7H, 0afH, 0bfH
	DB	0c8H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EPMBHNFD@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5?$LK?$KE?E?M?5?E?$KJ?$LB?b?$LA?$KB?52?$LA@
CONST	SEGMENT
??_C@_0CG@EPMBHNFD@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5?$LK?$KE?E?M?5?E?$KJ?$LB?b?$LA?$KB?52?$LA@ DB ' '
	DB	0c6H, 0c4H, 0c0H, 0cfH, ' ', 0c6H, 0f7H, 0b8H, 0e4H, ' ', 0bfH
	DB	0a1H, 0b7H, 0afH, ': ', 0baH, 0a4H, 0c5H, 0cdH, ' ', 0c5H, 0a9H
	DB	0b1H, 0e2H, 0b0H, 0a1H, ' 2', 0b0H, 0a1H, ' ', 0beH, 0c6H, 0b4H
	DB	0d4H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JDLELIBL@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5@
CONST	SEGMENT
??_C@_0BC@JDLELIBL@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5@ DB ' ', 0c6H
	DB	0c4H, 0c0H, 0cfH, ' ', 0c6H, 0f7H, 0b8H, 0e4H, ' ', 0bfH, 0a1H
	DB	0b7H, 0afH, ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LICIAONN@?5?$LI?$KG?5?C?$KD?$MA?$LL?5?$LM?v?5?$LO?x?$MA?$LN@
CONST	SEGMENT
??_C@_0BB@LICIAONN@?5?$LI?$KG?5?C?$KD?$MA?$LL?5?$LM?v?5?$LO?x?$MA?$LN@ DB ' '
	DB	0b8H, 0a6H, ' ', 0c3H, 0a3H, 0c0H, 0bbH, ' ', 0bcH, 0f6H, ' ', 0beH
	DB	0f8H, 0c0H, 0bdH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@OOLLGPNP@sounddata?$CF02d@
CONST	SEGMENT
??_C@_0O@OOLLGPNP@sounddata?$CF02d@ DB 'sounddata%02d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DLKHMJJP@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?0?5SoundDataCount@
CONST	SEGMENT
??_C@_0CP@DLKHMJJP@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?0?5SoundDataCount@ DB ' '
	DB	0c6H, 0c4H, 0c0H, 0cfH, ' ', 0c6H, 0f7H, 0b8H, 0e4H, ' ', 0bfH
	DB	0a1H, 0b7H, 0afH, ', SoundDataCount', 0b8H, 0a6H, ' ', 0c3H, 0a3H
	DB	0c0H, 0bbH, ' ', 0bcH, 0f6H, ' ', 0beH, 0f8H, 0c0H, 0bdH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DFMHJMOB@sounddatacount@
CONST	SEGMENT
??_C@_0P@DFMHJMOB@sounddatacount@ DB 'sounddatacount', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@JGMKPCLL@?5?$MA?P?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@
CONST	SEGMENT
??_C@_0BK@JGMKPCLL@?5?$MA?P?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@ DB ' '
	DB	0c0H, 0d0H, 0b1H, 0e2H, 0bfH, 0ebH, ' ', 0c6H, 0c4H, 0c0H, 0cfH
	DB	0c0H, 0bbH, ' ', 0bfH, 0adH, ' ', 0bcH, 0f6H, ' ', 0beH, 0f8H, 0c0H
	DB	0bdH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$1
__ehfuncinfo$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$7
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$8
	DD	00H
	DD	FLAT:__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@USSoundData@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEX$$QAUSSoundData@NSound@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USSoundData@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEX$$QAUSSoundData@NSound@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<NSound::SSoundData>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	50		 push	 eax
  00044	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	83 c0 1c	 add	 eax, 28			; 0000001cH
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0005e	c9		 leave
  0005f	c2 04 00	 ret	 4
??$_Emplace_back@USSoundData@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEX$$QAUSSoundData@NSound@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<NSound::SSoundData>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@USSoundInstance@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEX$$QAUSSoundInstance@NSound@@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@USSoundInstance@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEX$$QAUSSoundInstance@NSound@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<NSound::SSoundInstance>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0002a	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 4d f8	 mov	 ecx, DWORD PTR $T4[ebp]
  00039	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
  0003d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	83 c0 04	 add	 eax, 4
  00043	50		 push	 eax
  00044	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1547 :         ++_Last;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	83 c0 1c	 add	 eax, 28			; 0000001cH
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0005e	c9		 leave
  0005f	c2 04 00	 ret	 4
??$_Emplace_back@USSoundInstance@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEX$$QAUSSoundInstance@NSound@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<NSound::SSoundInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z PROC ; std::_Uninitialized_move<NSound::SSoundData *,std::allocator<NSound::SSoundData> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@USSoundData@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEX$$QAUSSoundData@NSound@@@Z ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<NSound::SSoundData>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ENDP ; std::_Uninitialized_move<NSound::SSoundData *,std::allocator<NSound::SSoundData> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z PROC ; std::_Uninitialized_move<NSound::SSoundInstance *,std::allocator<NSound::SSoundInstance> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 1c	 add	 eax, 28			; 0000001cH
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@USSoundInstance@NSound@@@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEX$$QAUSSoundInstance@NSound@@@Z ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<NSound::SSoundInstance>

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ENDP ; std::_Uninitialized_move<NSound::SSoundInstance *,std::allocator<NSound::SSoundInstance> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00013	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00022	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00025	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00028	6a 07		 push	 7
  0002a	59		 pop	 ecx
  0002b	33 c0		 xor	 eax, eax
  0002d	8b 7d f8	 mov	 edi, DWORD PTR $T2[ebp]
  00030	f3 ab		 rep stosd
  00032	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00035	83 c1 04	 add	 ecx, 4
  00038	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1547 :         ++_Last;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	83 c0 1c	 add	 eax, 28			; 0000001cH
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004c	5f		 pop	 edi
  0004d	c9		 leave
  0004e	c3		 ret	 0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	57		 push	 edi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00013	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0001f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00022	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00025	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00028	6a 07		 push	 7
  0002a	59		 pop	 ecx
  0002b	33 c0		 xor	 eax, eax
  0002d	8b 7d f8	 mov	 edi, DWORD PTR $T2[ebp]
  00030	f3 ab		 rep stosd
  00032	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00035	83 c1 04	 add	 ecx, 4
  00038	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1547 :         ++_Last;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00043	83 c0 1c	 add	 eax, 28			; 0000001cH
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004c	5f		 pop	 edi
  0004d	c9		 leave
  0004e	c3		 ret	 0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -28					; size = 12
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundData> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  00031	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1868 :         return _First + _Count;
; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1871 :         for (; 0 < _Count; --_Count) {

  0003b	eb 07		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00040	48		 dec	 eax
  00041	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 0a		 jbe	 SHORT $LN3@Uninitiali

; 1872 :             _Backout._Emplace_back();

  0004a	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  0004d	e8 00 00 00 00	 call	 ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::_Emplace_back<>

; 1873 :         }

  00052	eb e9		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00054	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00057	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  0005a	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  0005d	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1874 : 
; 1875 :         return _Backout._Release();

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00064	ff 75 ec	 push	 DWORD PTR __Backout$2[ebp+8]
  00067	ff 75 e8	 push	 DWORD PTR __Backout$2[ebp+4]
  0006a	ff 75 e4	 push	 DWORD PTR __Backout$2[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 : 
; 1875 :         return _Backout._Release();

  00075	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]

; 1876 :     }
; 1877 : }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	c9		 leave
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USSoundData@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundData> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundData> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -28					; size = 12
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundInstance> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax
  0002b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  00031	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);
; 1868 :         return _First + _Count;
; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1871 :         for (; 0 < _Count; --_Count) {

  0003b	eb 07		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00040	48		 dec	 eax
  00041	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 0a		 jbe	 SHORT $LN3@Uninitiali

; 1872 :             _Backout._Emplace_back();

  0004a	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  0004d	e8 00 00 00 00	 call	 ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::_Emplace_back<>

; 1873 :         }

  00052	eb e9		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00054	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00057	89 45 e4	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  0005a	8b 45 e8	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  0005d	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1874 : 
; 1875 :         return _Backout._Release();

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00064	ff 75 ec	 push	 DWORD PTR __Backout$2[ebp+8]
  00067	ff 75 e8	 push	 DWORD PTR __Backout$2[ebp+4]
  0006a	ff 75 e4	 push	 DWORD PTR __Backout$2[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1874 : 
; 1875 :         return _Backout._Release();

  00075	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]

; 1876 :     }
; 1877 : }

  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	c9		 leave
  00084	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >::~_Uninitialized_backout_al<std::allocator<NSound::SSoundInstance> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundInstance> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc 49 92
	24 09		 mov	 DWORD PTR $T17[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	99		 cdq
  000ac	6a 1c		 push	 28			; 0000001cH
  000ae	59		 pop	 ecx
  000af	f7 f9		 idiv	 ecx
  000b1	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b4	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@ABEII@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Calculate_growth
  000bf	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c5	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c8	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000cb	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000d1	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d5	c7 85 6c ff ff
	ff 49 92 24 09	 mov	 DWORD PTR __Max_possible$2[ebp], 153391689 ; 09249249H

; 60   :         if (_Count > _Max_possible) {

  000df	81 7d e4 49 92
	24 09		 cmp	 DWORD PTR __Newcapacity$[ebp], 153391689 ; 09249249H
  000e6	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ed	6b 45 e4 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000f1	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f4	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fc	59		 pop	 ecx
  000fd	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00100	6b 45 bc 1c	 imul	 eax, DWORD PTR __Oldsize$[ebp], 28
  00104	03 45 e0	 add	 eax, DWORD PTR __Newvec$[ebp]
  00107	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010a	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010d	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	8a 00		 mov	 al, BYTE PTR [eax]
  00119	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011f	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00122	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00125	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00128	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012e	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00131	50		 push	 eax
  00132	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundData> >
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00140	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00143	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00146	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00151	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00154	8b 00		 mov	 eax, DWORD PTR [eax]
  00156	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015c	33 c0		 xor	 eax, eax
  0015e	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00161	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00164	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00167	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016a	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016d	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00170	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00173	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00176	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00179	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Uninitialized_move<NSound::SSoundData *,std::allocator<NSound::SSoundData> >
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018d	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018f	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00192	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXPAUSSoundData@NSound@@0@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019d	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?_Getal@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundData@NSound@@@2@XZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Getal
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USSoundData@NSound@@@std@@QAEXQAUSSoundData@NSound@@I@Z ; std::allocator<NSound::SSoundData>::deallocate

; 1204 :         _RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bb	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c0	c3		 ret	 0
$LN5@Resize_rea:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c5	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cb	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001ce	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXQAUSSoundData@NSound@@II@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	c9		 leave
  001eb	c2 08 00	 ret	 8
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc 49 92
	24 09		 mov	 DWORD PTR $T17[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	99		 cdq
  000ac	6a 1c		 push	 28			; 0000001cH
  000ae	59		 pop	 ecx
  000af	f7 f9		 idiv	 ecx
  000b1	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b4	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@ABEII@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Calculate_growth
  000bf	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c5	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c8	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000cb	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000d1	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d5	c7 85 6c ff ff
	ff 49 92 24 09	 mov	 DWORD PTR __Max_possible$2[ebp], 153391689 ; 09249249H

; 60   :         if (_Count > _Max_possible) {

  000df	81 7d e4 49 92
	24 09		 cmp	 DWORD PTR __Newcapacity$[ebp], 153391689 ; 09249249H
  000e6	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e8	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ed	6b 45 e4 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000f1	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f4	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f7	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fc	59		 pop	 ecx
  000fd	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00100	6b 45 bc 1c	 imul	 eax, DWORD PTR __Oldsize$[ebp], 28
  00104	03 45 e0	 add	 eax, DWORD PTR __Newvec$[ebp]
  00107	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010a	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010d	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00110	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00117	8a 00		 mov	 al, BYTE PTR [eax]
  00119	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011f	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00122	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00125	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00128	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012e	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00131	50		 push	 eax
  00132	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00135	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundInstance> >
  0013a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013d	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00140	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00143	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00146	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00151	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00154	8b 00		 mov	 eax, DWORD PTR [eax]
  00156	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015c	33 c0		 xor	 eax, eax
  0015e	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00161	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00164	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00167	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016a	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016d	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00170	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00173	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00176	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00179	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  0017f	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@QAU12@0PAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Uninitialized_move<NSound::SSoundInstance *,std::allocator<NSound::SSoundInstance> >
  0018a	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018d	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  0018f	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00192	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00195	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00198	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXPAUSSoundInstance@NSound@@0@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019d	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a0	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a6	e8 00 00 00 00	 call	 ?_Getal@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundInstance@NSound@@@2@XZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Getal
  001ab	8b c8		 mov	 ecx, eax
  001ad	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USSoundInstance@NSound@@@std@@QAEXQAUSSoundInstance@NSound@@I@Z ; std::allocator<NSound::SSoundInstance>::deallocate

; 1204 :         _RERAISE;

  001b2	6a 00		 push	 0
  001b4	6a 00		 push	 0
  001b6	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bb	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c0	c3		 ret	 0
$LN5@Resize_rea:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c5	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cb	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001ce	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d7	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXQAUSSoundInstance@NSound@@II@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e6	59		 pop	 ecx
  001e7	5f		 pop	 edi
  001e8	5e		 pop	 esi
  001e9	5b		 pop	 ebx
  001ea	c9		 leave
  001eb	c2 08 00	 ret	 8
  001ee	cc		 int	 3
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundData> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 26		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00023	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00028	33 c0		 xor	 eax, eax
  0002a	83 e0 01	 and	 eax, 1
  0002d	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  0003b	eb c9		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 1c	 add	 eax, 28			; 0000001cH
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 26		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00023	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00028	33 c0		 xor	 eax, eax
  0002a	83 e0 01	 and	 eax, 1
  0002d	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002f	6a 1c		 push	 28			; 0000001cH
  00031	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  0003b	eb c9		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003d	c9		 leave
  0003e	c3		 ret	 0
??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 14 00	 and	 DWORD PTR [eax+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	99		 cdq
  00029	6a 1c		 push	 28			; 0000001cH
  0002b	59		 pop	 ecx
  0002c	f7 f9		 idiv	 ecx
  0002e	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00031	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00034	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00037	73 3b		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00039	6b 45 08 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00040	03 01		 add	 eax, DWORD PTR [ecx]
  00042	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00050	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00053	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00059	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005c	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005f	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00062	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00072	eb 6a		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00074	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00077	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  0007a	76 62		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	2b 01		 sub	 eax, DWORD PTR [ecx]
  00087	99		 cdq
  00088	6a 1c		 push	 28			; 0000001cH
  0008a	59		 pop	 ecx
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00096	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00098	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0009b	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a6	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000b3	8a 00		 mov	 al, BYTE PTR [eax]
  000b5	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000bb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000c1	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c4	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ca	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000cd	50		 push	 eax
  000ce	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USSoundData@NSound@@@std@@@std@@YAPAUSSoundData@NSound@@PAU12@IAAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundData> >
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	99		 cdq
  00029	6a 1c		 push	 28			; 0000001cH
  0002b	59		 pop	 ecx
  0002c	f7 f9		 idiv	 ecx
  0002e	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00031	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00034	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00037	73 3b		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00039	6b 45 08 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00040	03 01		 add	 eax, DWORD PTR [ecx]
  00042	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00050	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00053	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00059	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005c	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005f	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00062	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00072	eb 6a		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00074	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00077	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  0007a	76 62		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00082	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00085	2b 01		 sub	 eax, DWORD PTR [ecx]
  00087	99		 cdq
  00088	6a 1c		 push	 28			; 0000001cH
  0008a	59		 pop	 ecx
  0008b	f7 f9		 idiv	 ecx
  0008d	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00090	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00093	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00096	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00098	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0009b	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a6	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000b0	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000b3	8a 00		 mov	 al, BYTE PTR [eax]
  000b5	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000bb	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000be	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000c1	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c4	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c7	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000ca	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000cd	50		 push	 eax
  000ce	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000d1	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAPAUSSoundInstance@NSound@@PAU12@IAAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<NSound::SSoundInstance> >
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d9	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000de	c9		 leave
  000df	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundInstance@NSound@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundInstance@NSound@@@2@XZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundInstance@NSound@@@2@XZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange, COMDAT

; 1708 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1709 :         _Xout_of_range("invalid vector subscript");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1710 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXQAUSSoundInstance@NSound@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXQAUSSoundInstance@NSound@@II@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXQAUSSoundInstance@NSound@@II@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@ABEII@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 49 92
	24 09		 mov	 DWORD PTR $T7[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@ABEII@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXPAUSSoundInstance@NSound@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXPAUSSoundInstance@NSound@@0@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXPAUSSoundInstance@NSound@@0@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?at@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEAAUSSoundInstance@NSound@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEAAUSSoundInstance@NSound@@I@Z PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::at, COMDAT
; _this$ = ecx

; 1517 :     _NODISCARD _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1518 :         auto& _My_data = _Mypair._Myval2;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1519 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	2b 01		 sub	 eax, DWORD PTR [ecx]
  00019	99		 cdq
  0001a	6a 1c		 push	 28			; 0000001cH
  0001c	59		 pop	 ecx
  0001d	f7 f9		 idiv	 ecx
  0001f	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00022	77 05		 ja	 SHORT $LN2@at

; 1520 :             _Xrange();

  00024	e8 00 00 00 00	 call	 ?_Xrange@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@CAXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Xrange
$LN2@at:

; 1521 :         }
; 1522 : 
; 1523 :         return _My_data._Myfirst[_Pos];

  00029	6b 45 08 1c	 imul	 eax, DWORD PTR __Pos$[ebp], 28
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00030	03 01		 add	 eax, DWORD PTR [ecx]
$LN3@at:

; 1524 :     }

  00032	c9		 leave
  00033	c2 04 00	 ret	 4
?at@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEAAUSSoundInstance@NSound@@I@Z ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::at
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ PROC ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundInstance@NSound@@@std@@@std@@YAXPAUSSoundInstance@NSound@@QAU12@AAV?$allocator@USSoundInstance@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundInstance> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ENDP ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USSoundInstance@NSound@@@std@@QAEXQAUSSoundInstance@NSound@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USSoundInstance@NSound@@@std@@QAEXQAUSSoundInstance@NSound@@I@Z PROC ; std::allocator<NSound::SSoundInstance>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USSoundInstance@NSound@@@std@@QAEXQAUSSoundInstance@NSound@@I@Z ENDP ; std::allocator<NSound::SSoundInstance>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundData@NSound@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundData@NSound@@@2@XZ PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEAAV?$allocator@USSoundData@NSound@@@2@XZ ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@CAXXZ ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXQAUSSoundData@NSound@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXQAUSSoundData@NSound@@II@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 1c		 push	 28			; 0000001cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 1c	 imul	 eax, DWORD PTR __Newsize$[ebp], 28
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 1c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 28
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXQAUSSoundData@NSound@@II@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@ABEII@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 1c		 push	 28			; 0000001cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 49 92
	24 09		 mov	 DWORD PTR $T7[ebp], 153391689 ; 09249249H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@ABEII@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXPAUSSoundData@NSound@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXPAUSSoundData@NSound@@0@Z PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXPAUSSoundData@NSound@@0@Z ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ PROC ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USSoundData@NSound@@@std@@@std@@YAXPAUSSoundData@NSound@@QAU12@AAV?$allocator@USSoundData@NSound@@@0@@Z ; std::_Destroy_range<std::allocator<NSound::SSoundData> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ENDP ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USSoundData@NSound@@@std@@QAEXQAUSSoundData@NSound@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USSoundData@NSound@@@std@@QAEXQAUSSoundData@NSound@@I@Z PROC ; std::allocator<NSound::SSoundData>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 1c	 imul	 eax, DWORD PTR __Count$[ebp], 28
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USSoundData@NSound@@@std@@QAEXQAUSSoundData@NSound@@I@Z ENDP ; std::allocator<NSound::SSoundData>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4541 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	83 65 fc 00	 and	 DWORD PTR $T5[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00019	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001f	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4542 :     return _STD move(_Left.append(_Right));

  00033	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00041	83 c8 01	 or	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
  00047	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4543 : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 1
tv86 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Left_size$ = -12					; size = 4
__Right_size$ = -8					; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4480 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0

; 3770 :         return _Mypair._Myval2._Mysize;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  0000d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00010	89 45 f4	 mov	 DWORD PTR __Left_size$[ebp], eax

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00013	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 _strlen
  0001b	59		 pop	 ecx
  0001c	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0001f	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00022	89 45 f8	 mov	 DWORD PTR __Right_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4484 :     if (_Left.max_size() - _Left_size < _Right_size) {

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00028	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002d	2b 45 f4	 sub	 eax, DWORD PTR __Left_size$[ebp]
  00030	3b 45 f8	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00033	73 05		 jae	 SHORT $LN2@operator

; 4485 :         _Xlen_string();

  00035	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@operator:

; 4486 :     }
; 4487 : 
; 4488 :     return {_String_constructor_concat_tag{}, _Left, _Left.c_str(), _Left_size, _Right, _Right_size};

  0003a	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  0003d	88 45 e4	 mov	 BYTE PTR $T1[ebp], al
  00040	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00043	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00048	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0004b	ff 75 f8	 push	 DWORD PTR __Right_size$[ebp]
  0004e	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00051	ff 75 f4	 push	 DWORD PTR __Left_size$[ebp]
  00054	ff 75 e8	 push	 DWORD PTR tv86[ebp]
  00057	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0005a	ff 75 e4	 push	 DWORD PTR $T1[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00068	83 c8 01	 or	 eax, 1
  0006b	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@operator:

; 4489 : }

  00071	c9		 leave
  00072	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__FstrResult@NSound@@YAXXZ
text$yd	SEGMENT
??__FstrResult@NSound@@YAXXZ PROC			; NSound::`dynamic atexit destructor for 'strResult'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2801 :         _Tidy_deallocate();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
  00008	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__FstrResult@NSound@@YAXXZ ENDP			; NSound::`dynamic atexit destructor for 'strResult''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ??__EstrResult@NSound@@YAXXZ
text$di	SEGMENT
??__EstrResult@NSound@@YAXXZ PROC			; NSound::`dynamic initializer for 'strResult'', COMDAT

; 5    : std::string NSound::strResult;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
  00008	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000d	68 00 00 00 00	 push	 OFFSET ??__FstrResult@NSound@@YAXXZ ; NSound::`dynamic atexit destructor for 'strResult''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__EstrResult@NSound@@YAXXZ ENDP			; NSound::`dynamic initializer for 'strResult''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange, COMDAT

; 1708 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1709 :         _Xout_of_range("invalid vector subscript");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1710 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at, COMDAT
; _this$ = ecx

; 1517 :     _NODISCARD _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1518 :         auto& _My_data = _Mypair._Myval2;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1519 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  0000e	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	2b 01		 sub	 eax, DWORD PTR [ecx]
  00019	99		 cdq
  0001a	6a 18		 push	 24			; 00000018H
  0001c	59		 pop	 ecx
  0001d	f7 f9		 idiv	 ecx
  0001f	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00022	77 05		 ja	 SHORT $LN2@at

; 1520 :             _Xrange();

  00024	e8 00 00 00 00	 call	 ?_Xrange@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xrange
$LN2@at:

; 1521 :         }
; 1522 : 
; 1523 :         return _My_data._Myfirst[_Pos];

  00029	6b 45 08 18	 imul	 eax, DWORD PTR __Pos$[ebp], 24
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00030	03 01		 add	 eax, DWORD PTR [ecx]
$LN3@at:

; 1524 :     }

  00032	c9		 leave
  00033	c2 04 00	 ret	 4
?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ?SetResultString@NSound@@YAXPBD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
$T2 = -4						; size = 4
_c_pszStr$ = 8						; size = 4
?SetResultString@NSound@@YAXPBD@Z PROC			; NSound::SetResultString, COMDAT

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00005	ff 75 08	 push	 DWORD PTR _c_pszStr$[ebp]
  00008	e8 00 00 00 00	 call	 _strlen
  0000d	59		 pop	 ecx
  0000e	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00011	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00014	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00017	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001a	ff 75 08	 push	 DWORD PTR _c_pszStr$[ebp]
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
  00022	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 15   : }

  00027	c9		 leave
  00028	c3		 ret	 0
?SetResultString@NSound@@YAXPBD@Z ENDP			; NSound::SetResultString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ?GetResultString@NSound@@YAPBDXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?GetResultString@NSound@@YAPBDXZ PROC			; NSound::GetResultString, COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00004	b9 00 00 00 00	 mov	 ecx, OFFSET ?strResult@NSound@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; NSound::strResult
  00009	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0000e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 9    : 	return strResult.c_str();

  00011	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 10   : }

  00014	c9		 leave
  00015	c3		 ret	 0
?GetResultString@NSound@@YAPBDXZ ENDP			; NSound::GetResultString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z
_TEXT	SEGMENT
tv196 = -80						; size = 8
$T1 = -72						; size = 1
$T2 = -68						; size = 4
_c_fFrameTime$ = -64					; size = 4
__My_data$3 = -60					; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
_dwFPS$ = -48						; size = 4
_this$ = -44						; size = 4
__Right$ = -40						; size = 4
_rSoundInstance$6 = -36					; size = 4
_c_rSoundData$7 = -32					; size = 4
__My_data$8 = -28					; size = 4
__My_data$9 = -24					; size = 4
tv173 = -20						; size = 4
tv131 = -16						; size = 4
__My_data$10 = -12					; size = 4
_i$11 = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
_c_rSoundDataVector$ = 8				; size = 4
_pSoundInstanceVector$ = 12				; size = 4
?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z PROC ; NSound::DataToInstance, COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00006	8b 45 08	 mov	 eax, DWORD PTR _c_rSoundDataVector$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00017	75 09		 jne	 SHORT $LN9@DataToInst
  00019	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00020	eb 04		 jmp	 SHORT $LN10@DataToInst
$LN9@DataToInst:
  00022	83 65 f0 00	 and	 DWORD PTR tv131[ebp], 0
$LN10@DataToInst:
  00026	8a 45 f0	 mov	 al, BYTE PTR tv131[ebp]
  00029	88 45 ff	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 120  : 	if (c_rSoundDataVector.empty())

  0002c	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  00030	85 c0		 test	 eax, eax
  00032	74 05		 je	 SHORT $LN5@DataToInst

; 121  : 		return;

  00034	e9 0a 01 00 00	 jmp	 $LN1@DataToInst
$LN5@DataToInst:

; 122  : 
; 123  : 	DWORD dwFPS = 60;

  00039	c7 45 d0 3c 00
	00 00		 mov	 DWORD PTR _dwFPS$[ebp], 60 ; 0000003cH

; 124  : 	const float c_fFrameTime = 1.0f / float(dwFPS);

  00040	8b 45 d0	 mov	 eax, DWORD PTR _dwFPS$[ebp]
  00043	89 45 ec	 mov	 DWORD PTR tv173[ebp], eax
  00046	f2 0f 2a 45 ec	 cvtsi2sd xmm0, DWORD PTR tv173[ebp]
  0004b	8b 45 ec	 mov	 eax, DWORD PTR tv173[ebp]
  0004e	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00051	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0005a	f2 0f 11 45 b0	 movsd	 QWORD PTR tv196[ebp], xmm0
  0005f	f2 0f 5a 45 b0	 cvtsd2ss xmm0, QWORD PTR tv196[ebp]
  00064	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0006c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00070	f3 0f 11 4d c0	 movss	 DWORD PTR _c_fFrameTime$[ebp], xmm1

; 125  : 
; 126  : 	pSoundInstanceVector->clear();

  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _pSoundInstanceVector$[ebp]
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEXXZ ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _c_rSoundDataVector$[ebp]
  00080	89 45 e8	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00083	8b 45 e8	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00086	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  00089	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0008e	99		 cdq
  0008f	6a 1c		 push	 28			; 0000001cH
  00091	59		 pop	 ecx
  00092	f7 f9		 idiv	 ecx
  00094	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00097	8d 45 fe	 lea	 eax, DWORD PTR $T12[ebp]
  0009a	50		 push	 eax
  0009b	ff 75 cc	 push	 DWORD PTR $T5[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _pSoundInstanceVector$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  000a6	83 65 f8 00	 and	 DWORD PTR _i$11[ebp], 0
  000aa	eb 07		 jmp	 SHORT $LN4@DataToInst
$LN2@DataToInst:
  000ac	8b 45 f8	 mov	 eax, DWORD PTR _i$11[ebp]
  000af	40		 inc	 eax
  000b0	89 45 f8	 mov	 DWORD PTR _i$11[ebp], eax
$LN4@DataToInst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _c_rSoundDataVector$[ebp]
  000b6	89 45 e4	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  000b9	8b 45 e4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000bc	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  000bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c2	2b 01		 sub	 eax, DWORD PTR [ecx]
  000c4	99		 cdq
  000c5	6a 1c		 push	 28			; 0000001cH
  000c7	59		 pop	 ecx
  000c8	f7 f9		 idiv	 ecx
  000ca	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 128  : 	for (DWORD i = 0; i < c_rSoundDataVector.size(); ++i)

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _i$11[ebp]
  000d0	3b 45 c8	 cmp	 eax, DWORD PTR $T4[ebp]
  000d3	73 6e		 jae	 SHORT $LN3@DataToInst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  000d5	8b 45 08	 mov	 eax, DWORD PTR _c_rSoundDataVector$[ebp]
  000d8	89 45 c4	 mov	 DWORD PTR __My_data$3[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  000db	6b 45 f8 1c	 imul	 eax, DWORD PTR _i$11[ebp], 28
  000df	8b 4d c4	 mov	 ecx, DWORD PTR __My_data$3[ebp]
  000e2	03 01		 add	 eax, DWORD PTR [ecx]
  000e4	89 45 e0	 mov	 DWORD PTR _c_rSoundData$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 131  : 		TSoundInstance & rSoundInstance = pSoundInstanceVector->at(i);

  000e7	ff 75 f8	 push	 DWORD PTR _i$11[ebp]
  000ea	8b 4d 0c	 mov	 ecx, DWORD PTR _pSoundInstanceVector$[ebp]
  000ed	e8 00 00 00 00	 call	 ?at@?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@std@@QAEAAUSSoundInstance@NSound@@I@Z ; std::vector<NSound::SSoundInstance,std::allocator<NSound::SSoundInstance> >::at
  000f2	89 45 dc	 mov	 DWORD PTR _rSoundInstance$6[ebp], eax

; 132  : 
; 133  : 		rSoundInstance.dwFrame = (DWORD) (c_rSoundData.fTime / c_fFrameTime);

  000f5	8b 45 e0	 mov	 eax, DWORD PTR _c_rSoundData$7[ebp]
  000f8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000fc	f3 0f 5e 45 c0	 divss	 xmm0, DWORD PTR _c_fFrameTime$[ebp]
  00101	e8 00 00 00 00	 call	 __ftoui3
  00106	8b 4d dc	 mov	 ecx, DWORD PTR _rSoundInstance$6[ebp]
  00109	89 01		 mov	 DWORD PTR [ecx], eax

; 134  : 		rSoundInstance.strSoundFileName = c_rSoundData.strSoundFileName;

  0010b	8b 45 e0	 mov	 eax, DWORD PTR _c_rSoundData$7[ebp]
  0010e	83 c0 04	 add	 eax, 4
  00111	89 45 d8	 mov	 DWORD PTR __Right$[ebp], eax
  00114	8b 45 dc	 mov	 eax, DWORD PTR _rSoundInstance$6[ebp]
  00117	83 c0 04	 add	 eax, 4
  0011a	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0011d	8b 45 d8	 mov	 eax, DWORD PTR __Right$[ebp]
  00120	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  00123	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00126	3b 45 bc	 cmp	 eax, DWORD PTR $T2[ebp]
  00129	74 13		 je	 SHORT $LN41@DataToInst

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  0012b	33 c0		 xor	 eax, eax
  0012d	88 45 b8	 mov	 BYTE PTR $T1[ebp], al
  00130	ff 75 b8	 push	 DWORD PTR $T1[ebp]
  00133	ff 75 d8	 push	 DWORD PTR __Right$[ebp]
  00136	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN41@DataToInst:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 135  : 	}

  0013e	e9 69 ff ff ff	 jmp	 $LN2@DataToInst
$LN3@DataToInst:
$LN1@DataToInst:

; 136  : }

  00143	c9		 leave
  00144	c3		 ret	 0
?DataToInstance@NSound@@YAXABV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@PAV?$vector@USSoundInstance@NSound@@V?$allocator@USSoundInstance@NSound@@@std@@@3@@Z ENDP ; NSound::DataToInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
_TEXT	SEGMENT
__My_data$2 = -76					; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
tv159 = -64						; size = 4
tv161 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
_this$ = -48						; size = 4
_rSoundData$7 = -44					; size = 4
__My_data$8 = -40					; size = 4
__My_data$9 = -36					; size = 4
tv167 = -32						; size = 4
__My_data$10 = -28					; size = 4
_i$11 = -24						; size = 4
_File$ = -20						; size = 4
$T12 = -15						; size = 1
$T13 = -14						; size = 1
$T14 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T15 = 0						; size = 24
_strResult$ = 24					; size = 24
_szErrorText$16 = 48					; size = 257
__$ArrayPad$ = 308					; size = 4
_c_szFileName$ = 320					; size = 4
_rSoundDataVector$ = 324				; size = 4
?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z PROC ; NSound::SaveSoundInformationPiece, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8d ac 24 c8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-312]
  00008	81 ec 38 01 00
	00		 sub	 esp, 312		; 00000138H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 40	 sub	 esp, 64			; 00000040H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 34 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00036	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  0003c	89 45 e4	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  0003f	8b 45 e4	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00042	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0004a	75 09		 jne	 SHORT $LN13@SaveSoundI
  0004c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00053	eb 04		 jmp	 SHORT $LN14@SaveSoundI
$LN13@SaveSoundI:
  00055	83 65 e0 00	 and	 DWORD PTR tv167[ebp], 0
$LN14@SaveSoundI:
  00059	8a 45 e0	 mov	 al, BYTE PTR tv167[ebp]
  0005c	88 45 f3	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 80   : 	if (rSoundDataVector.empty())	//    

  0005f	0f b6 45 f3	 movzx	 eax, BYTE PTR $T14[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 26		 je	 SHORT $LN5@SaveSoundI

; 81   : 	{
; 82   : 		if (IsFile(c_szFileName))	//    

  00067	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  0006d	e8 00 00 00 00	 call	 ?IsFile@@YA_NPBD@Z	; IsFile
  00072	59		 pop	 ecx
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	74 0c		 je	 SHORT $LN6@SaveSoundI

; 83   : 		{
; 84   : 			_unlink(c_szFileName);		// .

  0007a	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00080	e8 00 00 00 00	 call	 __unlink
  00085	59		 pop	 ecx
$LN6@SaveSoundI:

; 85   : 		}
; 86   : 		return true;

  00086	b0 01		 mov	 al, 1
  00088	e9 c3 01 00 00	 jmp	 $LN1@SaveSoundI
$LN5@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0008d	8d 45 18	 lea	 eax, DWORD PTR _strResult$[ebp]
  00090	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00093	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  0009b	8d 4d 18	 lea	 ecx, DWORD PTR _strResult$[ebp]
  0009e	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 89   : 	std::string strResult;

  000a3	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000a7	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000ad	e8 00 00 00 00	 call	 _strlen
  000b2	59		 pop	 ecx
  000b3	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000b6	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  000b9	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000bc	ff 75 c8	 push	 DWORD PTR $T5[ebp]
  000bf	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000c5	8d 4d 18	 lea	 ecx, DWORD PTR _strResult$[ebp]
  000c8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 92   : 	FILE * File = fopen(c_szFileName, "wt");

  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_02BKFDOEMK@wt@
  000d2	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000d8	e8 00 00 00 00	 call	 _fopen
  000dd	59		 pop	 ecx
  000de	59		 pop	 ecx
  000df	89 45 ec	 mov	 DWORD PTR _File$[ebp], eax

; 93   : 
; 94   : 	if (!File)

  000e2	83 7d ec 00	 cmp	 DWORD PTR _File$[ebp], 0
  000e6	0f 85 84 00 00
	00		 jne	 $LN7@SaveSoundI

; 95   : 	{
; 96   : 		char szErrorText[256+1];
; 97   : 		_snprintf(szErrorText, sizeof(szErrorText), "Failed to save file (%s).\nPlease check if it is read-only or you have no space on the disk.\n", c_szFileName);

  000ec	ff b5 40 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000f2	68 00 00 00 00	 push	 OFFSET ??_C@_0FN@PJPGJAJH@Failed?5to?5save?5file?5?$CI?$CFs?$CJ?4?6Pleas@
  000f7	68 01 01 00 00	 push	 257			; 00000101H
  000fc	8d 45 30	 lea	 eax, DWORD PTR _szErrorText$16[ebp]
  000ff	50		 push	 eax
  00100	e8 00 00 00 00	 call	 __snprintf
  00105	83 c4 10	 add	 esp, 16			; 00000010H

; 98   : 		LogBox(szErrorText, "");

  00108	6a 00		 push	 0
  0010a	68 00 00 00 00	 push	 OFFSET ??_C@_04LHBDKBPE@?$LP?$KB?$LH?$KP@
  0010f	8d 45 30	 lea	 eax, DWORD PTR _szErrorText$16[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ?LogBox@@YAXPBD0PAUHWND__@@@Z ; LogBox
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH

; 99   : 		SetResultString((strResult + "     ").c_str());

  0011b	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IDDPDHCB@?5?$LO?$LC?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@
  00120	8d 45 18	 lea	 eax, DWORD PTR _strResult$[ebp]
  00123	50		 push	 eax
  00124	8d 45 00	 lea	 eax, DWORD PTR $T15[ebp]
  00127	50		 push	 eax
  00128	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0012d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00130	89 45 c4	 mov	 DWORD PTR tv161[ebp], eax
  00133	8b 45 c4	 mov	 eax, DWORD PTR tv161[ebp]
  00136	89 45 c0	 mov	 DWORD PTR tv159[ebp], eax
  00139	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0013d	8b 4d c0	 mov	 ecx, DWORD PTR tv159[ebp]
  00140	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  0014b	59		 pop	 ecx
  0014c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00150	8d 4d 00	 lea	 ecx, DWORD PTR $T15[ebp]
  00153	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 100  : 		return false;

  00158	c6 45 f2 00	 mov	 BYTE PTR $T13[ebp], 0
  0015c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00160	8d 4d 18	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00163	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 100  : 		return false;

  00168	8a 45 f2	 mov	 al, BYTE PTR $T13[ebp]
  0016b	e9 e0 00 00 00	 jmp	 $LN1@SaveSoundI
$LN7@SaveSoundI:

; 101  : 	}
; 102  : 
; 103  : 	fprintf(File, "ScriptType        CharacterSoundInformation\n");

  00170	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NJIDENFN@ScriptType?5?5?5?5?5?5?5?5CharacterSoun@
  00175	ff 75 ec	 push	 DWORD PTR _File$[ebp]
  00178	e8 00 00 00 00	 call	 _fprintf
  0017d	59		 pop	 ecx
  0017e	59		 pop	 ecx

; 104  : 	fprintf(File, "\n");

  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_01EEMJAFIK@?6@
  00184	ff 75 ec	 push	 DWORD PTR _File$[ebp]
  00187	e8 00 00 00 00	 call	 _fprintf
  0018c	59		 pop	 ecx
  0018d	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0018e	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  00194	89 45 dc	 mov	 DWORD PTR __My_data$9[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00197	8b 45 dc	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0019a	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$9[ebp]
  0019d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a0	2b 01		 sub	 eax, DWORD PTR [ecx]
  001a2	99		 cdq
  001a3	6a 1c		 push	 28			; 0000001cH
  001a5	59		 pop	 ecx
  001a6	f7 f9		 idiv	 ecx
  001a8	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 106  : 	fprintf(File, "SoundDataCount    %d\n", rSoundDataVector.size());

  001ab	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JEIKAJIN@SoundDataCount?5?5?5?5?$CFd?6@
  001b3	ff 75 ec	 push	 DWORD PTR _File$[ebp]
  001b6	e8 00 00 00 00	 call	 _fprintf
  001bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  001be	83 65 e8 00	 and	 DWORD PTR _i$11[ebp], 0
  001c2	eb 07		 jmp	 SHORT $LN4@SaveSoundI
$LN2@SaveSoundI:
  001c4	8b 45 e8	 mov	 eax, DWORD PTR _i$11[ebp]
  001c7	40		 inc	 eax
  001c8	89 45 e8	 mov	 DWORD PTR _i$11[ebp], eax
$LN4@SaveSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  001cb	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  001d1	89 45 d8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001d4	8b 45 d8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  001d7	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  001da	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001dd	2b 01		 sub	 eax, DWORD PTR [ecx]
  001df	99		 cdq
  001e0	6a 1c		 push	 28			; 0000001cH
  001e2	59		 pop	 ecx
  001e3	f7 f9		 idiv	 ecx
  001e5	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 108  : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  001e8	8b 45 e8	 mov	 eax, DWORD PTR _i$11[ebp]
  001eb	3b 45 b8	 cmp	 eax, DWORD PTR $T3[ebp]
  001ee	73 44		 jae	 SHORT $LN3@SaveSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001f0	8b 85 44 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  001f6	89 45 b4	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001f9	6b 45 e8 1c	 imul	 eax, DWORD PTR _i$11[ebp], 28
  001fd	8b 4d b4	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00200	03 01		 add	 eax, DWORD PTR [ecx]
  00202	89 45 d4	 mov	 DWORD PTR _rSoundData$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 111  : 		fprintf(File, "SoundData%02d       %f \"%s\"\n", i, rSoundData.fTime, rSoundData.strSoundFileName.c_str());

  00205	8b 4d d4	 mov	 ecx, DWORD PTR _rSoundData$7[ebp]
  00208	83 c1 04	 add	 ecx, 4
  0020b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00210	50		 push	 eax
  00211	8b 45 d4	 mov	 eax, DWORD PTR _rSoundData$7[ebp]
  00214	f3 0f 5a 00	 cvtss2sd xmm0, DWORD PTR [eax]
  00218	51		 push	 ecx
  00219	51		 push	 ecx
  0021a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0021f	ff 75 e8	 push	 DWORD PTR _i$11[ebp]
  00222	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FNDBKONF@SoundData?$CF02d?5?5?5?5?5?5?5?$CFf?5?$CC?$CFs?$CC?6@
  00227	ff 75 ec	 push	 DWORD PTR _File$[ebp]
  0022a	e8 00 00 00 00	 call	 _fprintf
  0022f	83 c4 18	 add	 esp, 24			; 00000018H

; 112  : 	}

  00232	eb 90		 jmp	 SHORT $LN2@SaveSoundI
$LN3@SaveSoundI:

; 113  : 
; 114  : 	fclose(File);

  00234	ff 75 ec	 push	 DWORD PTR _File$[ebp]
  00237	e8 00 00 00 00	 call	 _fclose
  0023c	59		 pop	 ecx

; 115  : 	return true;

  0023d	c6 45 f1 01	 mov	 BYTE PTR $T12[ebp], 1
  00241	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00245	8d 4d 18	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00248	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 115  : 	return true;

  0024d	8a 45 f1	 mov	 al, BYTE PTR $T12[ebp]
$LN1@SaveSoundI:

; 116  : }

  00250	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00253	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025a	59		 pop	 ecx
  0025b	8b 8d 34 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00261	33 cd		 xor	 ecx, ebp
  00263	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00268	81 c5 38 01 00
	00		 add	 ebp, 312		; 00000138H
  0026e	c9		 leave
  0026f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$0:
  00000	8d 4d 18	 lea	 ecx, DWORD PTR _strResult$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z$1:
  00008	8d 4d 00	 lea	 ecx, DWORD PTR $T15[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 8a 40 01 00
	00		 mov	 ecx, DWORD PTR [edx+320]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SaveSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@@Z ENDP ; NSound::SaveSoundInformationPiece
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp
;	COMDAT ?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
_TEXT	SEGMENT
$T2 = -224						; size = 1
$T3 = -220						; size = 4
$T4 = -216						; size = 4
$T5 = -212						; size = 4
_iCount$ = -208						; size = 4
__Newsize$ = -204					; size = 4
$T6 = -200						; size = 4
tv155 = -196						; size = 4
tv258 = -192						; size = 4
$T7 = -188						; size = 4
tv466 = -184						; size = 4
tv260 = -180						; size = 4
tv268 = -176						; size = 4
tv449 = -172						; size = 4
$T8 = -168						; size = 4
$T9 = -164						; size = 4
tv242 = -160						; size = 4
__My_data$10 = -156					; size = 4
$T11 = -152						; size = 4
$T12 = -148						; size = 4
$T13 = -144						; size = 4
__My_data$14 = -140					; size = 4
$T15 = -136						; size = 4
$T16 = -132						; size = 4
$T17 = -128						; size = 4
__My_data$18 = -124					; size = 4
$T19 = -120						; size = 4
__My_data$20 = -116					; size = 4
$T21 = -112						; size = 4
$T22 = -108						; size = 4
tv464 = -104						; size = 4
$T23 = -100						; size = 4
_this$ = -96						; size = 4
$T24 = -92						; size = 4
tv90 = -88						; size = 4
$T25 = -84						; size = 4
$T26 = -80						; size = 4
tv269 = -76						; size = 4
$T27 = -72						; size = 4
$T28 = -68						; size = 4
__Ptr$ = -64						; size = 4
__Ptr$ = -60						; size = 4
__My_data$29 = -56					; size = 4
tv160 = -52						; size = 4
__My_data$30 = -48					; size = 4
tv95 = -44						; size = 4
_pkTextFileLoader$ = -40				; size = 4
$T31 = -33						; size = 1
_pTokenVector$32 = -32					; size = 4
_rkTextFileLoader$ = -28				; size = 4
$T33 = -24						; size = 1
$T34 = -23						; size = 1
$T35 = -22						; size = 1
$T36 = -21						; size = 1
$T37 = -20						; size = 1
$T38 = -19						; size = 1
$T39 = -18						; size = 1
$T40 = -17						; size = 1
_i$41 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T42 = 0						; size = 24
$T43 = 24						; size = 24
$T44 = 48						; size = 24
$T45 = 72						; size = 24
$T46 = 96						; size = 24
$T47 = 120						; size = 24
$T48 = 144						; size = 24
$T49 = 168						; size = 24
$T50 = 192						; size = 24
_strResult$ = 216					; size = 24
_szSoundDataHeader$ = 240				; size = 33
__$ArrayPad$ = 276					; size = 4
_c_szFileName$ = 288					; size = 4
_rSoundDataVector$ = 292				; size = 4
_c_szPathHeader$ = 296					; size = 4
?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z PROC ; NSound::LoadSoundInformationPiece, COMDAT

; 18   : {

  00000	55		 push	 ebp
  00001	8d ac 24 e8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-280]
  00008	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 14 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00039	ff b5 20 ff ff
	ff		 push	 DWORD PTR $T2[ebp]
  0003f	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00045	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  0004a	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 19   : 	std::string strResult;

  00055	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00059	ff b5 20 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  0005f	e8 00 00 00 00	 call	 _strlen
  00064	59		 pop	 ecx
  00065	89 45 bc	 mov	 DWORD PTR $T28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00068	8b 45 bc	 mov	 eax, DWORD PTR $T28[ebp]
  0006b	89 45 b8	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006e	ff 75 b8	 push	 DWORD PTR $T27[ebp]
  00071	ff b5 20 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00077	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  0007d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 22   : 	CTextFileLoader* pkTextFileLoader=CTextFileLoader::Cache(c_szFileName);

  00082	ff b5 20 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00088	e8 00 00 00 00	 call	 ?Cache@CTextFileLoader@@SAPAV1@PBD@Z ; CTextFileLoader::Cache
  0008d	59		 pop	 ecx
  0008e	89 45 d8	 mov	 DWORD PTR _pkTextFileLoader$[ebp], eax

; 23   : 	if (!pkTextFileLoader)

  00091	83 7d d8 00	 cmp	 DWORD PTR _pkTextFileLoader$[ebp], 0
  00095	75 1b		 jne	 SHORT $LN5@LoadSoundI

; 24   : 		return false;

  00097	c6 45 ef 00	 mov	 BYTE PTR $T40[ebp], 0
  0009b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0009f	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 24   : 		return false;

  000aa	8a 45 ef	 mov	 al, BYTE PTR $T40[ebp]
  000ad	e9 43 05 00 00	 jmp	 $LN1@LoadSoundI
$LN5@LoadSoundI:

; 25   : 
; 26   : 	CTextFileLoader& rkTextFileLoader=*pkTextFileLoader;

  000b2	8b 45 d8	 mov	 eax, DWORD PTR _pkTextFileLoader$[ebp]
  000b5	89 45 e4	 mov	 DWORD PTR _rkTextFileLoader$[ebp], eax

; 27   : 	if (rkTextFileLoader.IsEmpty())

  000b8	8b 4d e4	 mov	 ecx, DWORD PTR _rkTextFileLoader$[ebp]
  000bb	e8 00 00 00 00	 call	 ?IsEmpty@CTextFileLoader@@QAE_NXZ ; CTextFileLoader::IsEmpty
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	85 c0		 test	 eax, eax
  000c5	74 60		 je	 SHORT $LN6@LoadSoundI

; 29   : 		SetResultString((strResult + "     ").c_str());

  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@JGMKPCLL@?5?$MA?P?$LB?b?$LP?k?5?F?D?$MA?O?$MA?$LL?5?$LP?$KN?5?$LM?v?5?$LO?x?$MA?$LN@
  000cc	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _strResult$[ebp]
  000d2	50		 push	 eax
  000d3	8d 45 00	 lea	 eax, DWORD PTR $T42[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000dc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000df	89 45 b4	 mov	 DWORD PTR tv269[ebp], eax
  000e2	8b 45 b4	 mov	 eax, DWORD PTR tv269[ebp]
  000e5	89 45 b0	 mov	 DWORD PTR $T26[ebp], eax
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  000ec	8b 4d b0	 mov	 ecx, DWORD PTR $T26[ebp]
  000ef	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000f4	89 45 ac	 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 29   : 		SetResultString((strResult + "     ").c_str());

  000f7	ff 75 ac	 push	 DWORD PTR $T25[ebp]
  000fa	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  000ff	59		 pop	 ecx
  00100	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00104	8d 4d 00	 lea	 ecx, DWORD PTR $T42[ebp]
  00107	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 30   : 		return false;

  0010c	c6 45 ee 00	 mov	 BYTE PTR $T39[ebp], 0
  00110	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00114	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  0011a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 30   : 		return false;

  0011f	8a 45 ee	 mov	 al, BYTE PTR $T39[ebp]
  00122	e9 ce 04 00 00	 jmp	 $LN1@LoadSoundI
$LN6@LoadSoundI:

; 31   : 	}
; 32   : 
; 33   : 	rkTextFileLoader.SetTop();

  00127	8b 4d e4	 mov	 ecx, DWORD PTR _rkTextFileLoader$[ebp]
  0012a	e8 00 00 00 00	 call	 ?SetTop@CTextFileLoader@@QAEXXZ ; CTextFileLoader::SetTop

; 36   : 	if (!rkTextFileLoader.GetTokenInteger("sounddatacount", &iCount))

  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0P@DFMHJMOB@sounddatacount@
  00134	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T49[ebp]
  0013a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0013f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00143	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _iCount$[ebp]
  00149	50		 push	 eax
  0014a	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR $T49[ebp]
  00150	50		 push	 eax
  00151	8b 4d e4	 mov	 ecx, DWORD PTR _rkTextFileLoader$[ebp]
  00154	e8 00 00 00 00	 call	 ?GetTokenInteger@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; CTextFileLoader::GetTokenInteger
  00159	85 c0		 test	 eax, eax
  0015b	75 09		 jne	 SHORT $LN13@LoadSoundI
  0015d	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  00164	eb 04		 jmp	 SHORT $LN14@LoadSoundI
$LN13@LoadSoundI:
  00166	83 65 d4 00	 and	 DWORD PTR tv95[ebp], 0
$LN14@LoadSoundI:
  0016a	8a 45 d4	 mov	 al, BYTE PTR tv95[ebp]
  0016d	88 45 ed	 mov	 BYTE PTR $T38[ebp], al
  00170	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00174	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T49[ebp]
  0017a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 36   : 	if (!rkTextFileLoader.GetTokenInteger("sounddatacount", &iCount))

  0017f	0f b6 45 ed	 movzx	 eax, BYTE PTR $T38[ebp]
  00183	85 c0		 test	 eax, eax
  00185	74 6c		 je	 SHORT $LN7@LoadSoundI

; 38   : 		SetResultString((strResult + "   , SoundDataCount   ").c_str());

  00187	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DLKHMJJP@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?0?5SoundDataCount@
  0018c	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _strResult$[ebp]
  00192	50		 push	 eax
  00193	8d 45 18	 lea	 eax, DWORD PTR $T43[ebp]
  00196	50		 push	 eax
  00197	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0019c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019f	89 45 a8	 mov	 DWORD PTR tv90[ebp], eax
  001a2	8b 45 a8	 mov	 eax, DWORD PTR tv90[ebp]
  001a5	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  001ab	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  001af	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp]
  001b5	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  001ba	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 38   : 		SetResultString((strResult + "   , SoundDataCount   ").c_str());

  001c0	ff b5 2c ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  001c6	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  001cb	59		 pop	 ecx
  001cc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001d0	8d 4d 18	 lea	 ecx, DWORD PTR $T43[ebp]
  001d3	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 39   : 		return false;

  001d8	c6 45 ec 00	 mov	 BYTE PTR $T37[ebp], 0
  001dc	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001e0	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  001e6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 39   : 		return false;

  001eb	8a 45 ec	 mov	 al, BYTE PTR $T37[ebp]
  001ee	e9 02 04 00 00	 jmp	 $LN1@LoadSoundI
$LN7@LoadSoundI:

; 40   : 	}
; 41   : 
; 42   : 	rSoundDataVector.clear();

  001f3	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR _rSoundDataVector$[ebp]
  001f9	e8 00 00 00 00	 call	 ?clear@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@QAEXXZ ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::clear

; 43   : 	rSoundDataVector.resize(iCount);

  001fe	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _iCount$[ebp]
  00204	89 85 34 ff ff
	ff		 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0020a	8d 45 df	 lea	 eax, DWORD PTR $T31[ebp]
  0020d	50		 push	 eax
  0020e	ff b5 34 ff ff
	ff		 push	 DWORD PTR __Newsize$[ebp]
  00214	8b 8d 24 01 00
	00		 mov	 ecx, DWORD PTR _rSoundDataVector$[ebp]
  0021a	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<NSound::SSoundData,std::allocator<NSound::SSoundData> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  0021f	83 65 f0 00	 and	 DWORD PTR _i$41[ebp], 0
  00223	eb 07		 jmp	 SHORT $LN4@LoadSoundI
$LN2@LoadSoundI:
  00225	8b 45 f0	 mov	 eax, DWORD PTR _i$41[ebp]
  00228	40		 inc	 eax
  00229	89 45 f0	 mov	 DWORD PTR _i$41[ebp], eax
$LN4@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0022c	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  00232	89 45 d0	 mov	 DWORD PTR __My_data$30[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00235	8b 45 d0	 mov	 eax, DWORD PTR __My_data$30[ebp]
  00238	8b 4d d0	 mov	 ecx, DWORD PTR __My_data$30[ebp]
  0023b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0023e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00240	99		 cdq
  00241	6a 1c		 push	 28			; 0000001cH
  00243	59		 pop	 ecx
  00244	f7 f9		 idiv	 ecx
  00246	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 46   : 	for (DWORD i = 0; i < rSoundDataVector.size(); ++i)

  0024c	8b 45 f0	 mov	 eax, DWORD PTR _i$41[ebp]
  0024f	3b 85 38 ff ff
	ff		 cmp	 eax, DWORD PTR $T6[ebp]
  00255	0f 83 32 03 00
	00		 jae	 $LN3@LoadSoundI

; 47   : 	{
; 48   : 		_snprintf(szSoundDataHeader, sizeof(szSoundDataHeader), "sounddata%02d", i);

  0025b	ff 75 f0	 push	 DWORD PTR _i$41[ebp]
  0025e	68 00 00 00 00	 push	 OFFSET ??_C@_0O@OOLLGPNP@sounddata?$CF02d@
  00263	6a 21		 push	 33			; 00000021H
  00265	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  0026b	50		 push	 eax
  0026c	e8 00 00 00 00	 call	 __snprintf
  00271	83 c4 10	 add	 esp, 16			; 00000010H

; 50   : 		if (!rkTextFileLoader.GetTokenVector(szSoundDataHeader, &pTokenVector))

  00274	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  0027a	50		 push	 eax
  0027b	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR $T50[ebp]
  00281	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00286	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0028a	8d 45 e0	 lea	 eax, DWORD PTR _pTokenVector$32[ebp]
  0028d	50		 push	 eax
  0028e	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR $T50[ebp]
  00294	50		 push	 eax
  00295	8b 4d e4	 mov	 ecx, DWORD PTR _rkTextFileLoader$[ebp]
  00298	e8 00 00 00 00	 call	 ?GetTokenVector@CTextFileLoader@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@3@@Z ; CTextFileLoader::GetTokenVector
  0029d	85 c0		 test	 eax, eax
  0029f	75 09		 jne	 SHORT $LN15@LoadSoundI
  002a1	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv160[ebp], 1
  002a8	eb 04		 jmp	 SHORT $LN16@LoadSoundI
$LN15@LoadSoundI:
  002aa	83 65 cc 00	 and	 DWORD PTR tv160[ebp], 0
$LN16@LoadSoundI:
  002ae	8a 45 cc	 mov	 al, BYTE PTR tv160[ebp]
  002b1	88 45 eb	 mov	 BYTE PTR $T36[ebp], al
  002b4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002b8	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR $T50[ebp]
  002be	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 50   : 		if (!rkTextFileLoader.GetTokenVector(szSoundDataHeader, &pTokenVector))

  002c3	0f b6 45 eb	 movzx	 eax, BYTE PTR $T36[ebp]
  002c7	85 c0		 test	 eax, eax
  002c9	0f 84 e0 00 00
	00		 je	 $LN8@LoadSoundI

; 52   : 			SetResultString((strResult + "   : " + szSoundDataHeader + "    ").c_str());

  002cf	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JDLELIBL@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5@
  002d4	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _strResult$[ebp]
  002da	50		 push	 eax
  002db	8d 45 60	 lea	 eax, DWORD PTR $T46[ebp]
  002de	50		 push	 eax
  002df	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  002e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e7	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv155[ebp], eax
  002ed	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv155[ebp]
  002f3	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv258[ebp], eax
  002f9	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002fd	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR _szSoundDataHeader$[ebp]
  00303	50		 push	 eax
  00304	ff b5 40 ff ff
	ff		 push	 DWORD PTR tv258[ebp]
  0030a	8d 45 48	 lea	 eax, DWORD PTR $T45[ebp]
  0030d	50		 push	 eax
  0030e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00313	83 c4 0c	 add	 esp, 12			; 0000000cH
  00316	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv466[ebp], eax
  0031c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv466[ebp]
  00322	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv260[ebp], eax
  00328	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0032c	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LICIAONN@?5?$LI?$KG?5?C?$KD?$MA?$LL?5?$LM?v?5?$LO?x?$MA?$LN@
  00331	ff b5 4c ff ff
	ff		 push	 DWORD PTR tv260[ebp]
  00337	8d 45 30	 lea	 eax, DWORD PTR $T44[ebp]
  0033a	50		 push	 eax
  0033b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00340	83 c4 0c	 add	 esp, 12			; 0000000cH
  00343	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv242[ebp], eax
  00349	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv242[ebp]
  0034f	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00355	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00359	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0035f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00364	89 45 a4	 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + "   : " + szSoundDataHeader + "    ").c_str());

  00367	ff 75 a4	 push	 DWORD PTR $T24[ebp]
  0036a	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  0036f	59		 pop	 ecx
  00370	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00374	8d 4d 30	 lea	 ecx, DWORD PTR $T44[ebp]
  00377	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + "   : " + szSoundDataHeader + "    ").c_str());

  0037c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00380	8d 4d 48	 lea	 ecx, DWORD PTR $T45[ebp]
  00383	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 52   : 			SetResultString((strResult + "   : " + szSoundDataHeader + "    ").c_str());

  00388	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0038c	8d 4d 60	 lea	 ecx, DWORD PTR $T46[ebp]
  0038f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 53   : 			return false;

  00394	c6 45 ea 00	 mov	 BYTE PTR $T35[ebp], 0
  00398	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0039c	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  003a2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 53   : 			return false;

  003a7	8a 45 ea	 mov	 al, BYTE PTR $T35[ebp]
  003aa	e9 46 02 00 00	 jmp	 $LN1@LoadSoundI
$LN8@LoadSoundI:

; 56   : 		if (2 != pTokenVector->size())

  003af	8b 45 e0	 mov	 eax, DWORD PTR _pTokenVector$32[ebp]
  003b2	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  003b5	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  003b8	89 45 c8	 mov	 DWORD PTR __My_data$29[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  003bb	8b 45 c8	 mov	 eax, DWORD PTR __My_data$29[ebp]
  003be	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$29[ebp]
  003c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003c4	2b 01		 sub	 eax, DWORD PTR [ecx]
  003c6	99		 cdq
  003c7	6a 18		 push	 24			; 00000018H
  003c9	59		 pop	 ecx
  003ca	f7 f9		 idiv	 ecx
  003cc	89 45 9c	 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 56   : 		if (2 != pTokenVector->size())

  003cf	83 7d 9c 02	 cmp	 DWORD PTR $T23[ebp], 2
  003d3	74 60		 je	 SHORT $LN9@LoadSoundI

; 58   : 			SetResultString((strResult + "   :   2 ").c_str());

  003d5	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EPMBHNFD@?5?F?D?$MA?O?5?F?w?$LI?d?5?$LP?$KB?$LH?$KP?3?5?$LK?$KE?E?M?5?E?$KJ?$LB?b?$LA?$KB?52?$LA@
  003da	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _strResult$[ebp]
  003e0	50		 push	 eax
  003e1	8d 45 78	 lea	 eax, DWORD PTR $T47[ebp]
  003e4	50		 push	 eax
  003e5	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  003ea	83 c4 0c	 add	 esp, 12			; 0000000cH
  003ed	89 45 98	 mov	 DWORD PTR tv464[ebp], eax
  003f0	8b 45 98	 mov	 eax, DWORD PTR tv464[ebp]
  003f3	89 45 94	 mov	 DWORD PTR $T22[ebp], eax
  003f6	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003fa	8b 4d 94	 mov	 ecx, DWORD PTR $T22[ebp]
  003fd	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00402	89 45 90	 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 58   : 			SetResultString((strResult + "   :   2 ").c_str());

  00405	ff 75 90	 push	 DWORD PTR $T21[ebp]
  00408	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  0040d	59		 pop	 ecx
  0040e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00412	8d 4d 78	 lea	 ecx, DWORD PTR $T47[ebp]
  00415	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 59   : 			return false;

  0041a	c6 45 e9 00	 mov	 BYTE PTR $T34[ebp], 0
  0041e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00422	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00428	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 59   : 			return false;

  0042d	8a 45 e9	 mov	 al, BYTE PTR $T34[ebp]
  00430	e9 c0 01 00 00	 jmp	 $LN1@LoadSoundI
$LN9@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00435	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  0043b	89 45 8c	 mov	 DWORD PTR __My_data$20[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0043e	6b 45 f0 1c	 imul	 eax, DWORD PTR _i$41[ebp], 28
  00442	8b 4d 8c	 mov	 ecx, DWORD PTR __My_data$20[ebp]
  00445	03 01		 add	 eax, DWORD PTR [ecx]
  00447	89 45 88	 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 62   : 		rSoundDataVector[i].fTime = (float) atof(pTokenVector->at(0).c_str());

  0044a	6a 00		 push	 0
  0044c	8b 4d e0	 mov	 ecx, DWORD PTR _pTokenVector$32[ebp]
  0044f	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  00454	8b c8		 mov	 ecx, eax
  00456	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0045b	50		 push	 eax
  0045c	e8 00 00 00 00	 call	 _atof
  00461	59		 pop	 ecx
  00462	8b 45 88	 mov	 eax, DWORD PTR $T19[ebp]
  00465	d9 18		 fstp	 DWORD PTR [eax]

; 63   : 		if (c_szPathHeader)

  00467	83 bd 28 01 00
	00 00		 cmp	 DWORD PTR _c_szPathHeader$[ebp], 0
  0046e	0f 84 b0 00 00
	00		 je	 $LN10@LoadSoundI
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00474	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  0047a	89 45 84	 mov	 DWORD PTR __My_data$18[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0047d	6b 45 f0 1c	 imul	 eax, DWORD PTR _i$41[ebp], 28
  00481	8b 4d 84	 mov	 ecx, DWORD PTR __My_data$18[ebp]
  00484	03 01		 add	 eax, DWORD PTR [ecx]
  00486	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0048c	ff b5 28 01 00
	00		 push	 DWORD PTR _c_szPathHeader$[ebp]
  00492	e8 00 00 00 00	 call	 _strlen
  00497	59		 pop	 ecx
  00498	89 45 80	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0049b	8b 45 80	 mov	 eax, DWORD PTR $T17[ebp]
  0049e	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004a4	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T16[ebp]
  004aa	ff b5 28 01 00
	00		 push	 DWORD PTR _c_szPathHeader$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 65   : 			rSoundDataVector[i].strSoundFileName = c_szPathHeader;

  004b0	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  004b6	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  004b9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  004be	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  004c4	89 85 74 ff ff
	ff		 mov	 DWORD PTR __My_data$14[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  004ca	6b 45 f0 1c	 imul	 eax, DWORD PTR _i$41[ebp], 28
  004ce	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$14[ebp]
  004d4	03 01		 add	 eax, DWORD PTR [ecx]
  004d6	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 66   : 			rSoundDataVector[i].strSoundFileName += pTokenVector->at(1).c_str();

  004dc	6a 01		 push	 1
  004de	8b 4d e0	 mov	 ecx, DWORD PTR _pTokenVector$32[ebp]
  004e1	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  004e6	8b c8		 mov	 ecx, eax
  004e8	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  004ed	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  004f0	ff 75 c4	 push	 DWORD PTR __Ptr$[ebp]
  004f3	e8 00 00 00 00	 call	 _strlen
  004f8	59		 pop	 ecx
  004f9	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  004ff	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  00505	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0050b	ff b5 6c ff ff
	ff		 push	 DWORD PTR $T12[ebp]
  00511	ff 75 c4	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 66   : 			rSoundDataVector[i].strSoundFileName += pTokenVector->at(1).c_str();

  00514	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  0051a	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0051d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 67   : 		}

  00522	eb 64		 jmp	 SHORT $LN353@LoadSoundI
$LN10@LoadSoundI:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00524	8b 85 24 01 00
	00		 mov	 eax, DWORD PTR _rSoundDataVector$[ebp]
  0052a	89 85 64 ff ff
	ff		 mov	 DWORD PTR __My_data$10[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00530	6b 45 f0 1c	 imul	 eax, DWORD PTR _i$41[ebp], 28
  00534	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$10[ebp]
  0053a	03 01		 add	 eax, DWORD PTR [ecx]
  0053c	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 70   : 			rSoundDataVector[i].strSoundFileName = pTokenVector->at(1).c_str();

  00542	6a 01		 push	 1
  00544	8b 4d e0	 mov	 ecx, DWORD PTR _pTokenVector$32[ebp]
  00547	e8 00 00 00 00	 call	 ?at@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::at
  0054c	8b c8		 mov	 ecx, eax
  0054e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00553	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00556	ff 75 c0	 push	 DWORD PTR __Ptr$[ebp]
  00559	e8 00 00 00 00	 call	 _strlen
  0055e	59		 pop	 ecx
  0055f	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00565	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0056b	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00571	ff b5 5c ff ff
	ff		 push	 DWORD PTR $T9[ebp]
  00577	ff 75 c0	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 70   : 			rSoundDataVector[i].strSoundFileName = pTokenVector->at(1).c_str();

  0057a	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  00580	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00583	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN353@LoadSoundI:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 72   : 	}

  00588	e9 98 fc ff ff	 jmp	 $LN2@LoadSoundI
$LN3@LoadSoundI:

; 73   : 
; 74   : 	SetResultString((strResult + " ").c_str());

  0058d	68 00 00 00 00	 push	 OFFSET ??_C@_07MCJGNGDG@?5?$LK?R?$LH?$KP?$LP?H@
  00592	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _strResult$[ebp]
  00598	50		 push	 eax
  00599	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR $T48[ebp]
  0059f	50		 push	 eax
  005a0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  005a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  005a8	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv449[ebp], eax
  005ae	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv449[ebp]
  005b4	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv268[ebp], eax
  005ba	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  005be	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv268[ebp]
  005c4	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  005c9	50		 push	 eax
  005ca	e8 00 00 00 00	 call	 ?SetResultString@NSound@@YAXPBD@Z ; NSound::SetResultString
  005cf	59		 pop	 ecx
  005d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005d4	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T48[ebp]
  005da	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 75   : 	return true;

  005df	c6 45 e8 01	 mov	 BYTE PTR $T33[ebp], 1
  005e3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005e7	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  005ed	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\MilesLib\Type.cpp

; 75   : 	return true;

  005f2	8a 45 e8	 mov	 al, BYTE PTR $T33[ebp]
$LN1@LoadSoundI:

; 76   : }

  005f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  005f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  005ff	59		 pop	 ecx
  00600	8b 8d 14 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00606	33 cd		 xor	 ecx, ebp
  00608	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0060d	81 c5 18 01 00
	00		 add	 ebp, 280		; 00000118H
  00613	c9		 leave
  00614	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$0:
  00000	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _strResult$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$1:
  0000b	8d 4d 00	 lea	 ecx, DWORD PTR $T42[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$2:
  00013	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T49[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$3:
  0001e	8d 4d 18	 lea	 ecx, DWORD PTR $T43[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$4:
  00026	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR $T50[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$5:
  00031	8d 4d 60	 lea	 ecx, DWORD PTR $T46[ebp]
  00034	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$6:
  00039	8d 4d 48	 lea	 ecx, DWORD PTR $T45[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$7:
  00041	8d 4d 30	 lea	 ecx, DWORD PTR $T44[ebp]
  00044	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$8:
  00049	8d 4d 78	 lea	 ecx, DWORD PTR $T47[ebp]
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z$9:
  00051	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T48[ebp]
  00057	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
__ehhandler$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z:
  00061	90		 npad	 1
  00062	90		 npad	 1
  00063	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00067	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006a	8b 8a 28 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-216]
  00070	33 c8		 xor	 ecx, eax
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b 8a 20 01 00
	00		 mov	 ecx, DWORD PTR [edx+288]
  0007d	33 c8		 xor	 ecx, eax
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z
  00089	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadSoundInformationPiece@NSound@@YA_NPBDAAV?$vector@USSoundData@NSound@@V?$allocator@USSoundData@NSound@@@std@@@std@@0@Z ENDP ; NSound::LoadSoundInformationPiece
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
__Alproxy$ = -96					; size = 4
$T3 = -92						; size = 4
__First1$ = -88						; size = 4
__Ptr$ = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
_this$ = -68						; size = 4
$T7 = -64						; size = 4
__Fancyptr$8 = -60					; size = 4
tv190 = -56						; size = 4
$T9 = -52						; size = 4
_this$ = -48						; size = 4
__Masked$10 = -44					; size = 4
__New_size$ = -40					; size = 4
__Ptr$ = -36						; size = 4
__My_data$ = -32					; size = 4
__Max$ = -28						; size = 4
_this$ = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Overflow_is_possible$11 = -15				; size = 1
_$S9$ = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2521 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Source_of_al$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  00031	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2522 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2523 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2524 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2525 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00052	8b 45 14	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00055	03 45 1c	 add	 eax, DWORD PTR __Right_size$[ebp]
  00058	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 2526 :         size_type _New_capacity = _BUF_SIZE - 1;

  0005b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __New_capacity$[ebp], 15 ; 0000000fH

; 2527 :         auto& _My_data          = _Mypair._Myval2;

  00062	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __My_data$[ebp], eax

; 2528 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2529 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0006e	8d 45 f2	 lea	 eax, DWORD PTR _$S9$[ebp]
  00071	89 45 a0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2530 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2531 :         if (_New_capacity < _New_size) {

  00074	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00077	3b 45 d8	 cmp	 eax, DWORD PTR __New_size$[ebp]
  0007a	0f 83 a8 00 00
	00		 jae	 $LN2@basic_stri

; 2532 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());

  00080	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00088	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008e	83 c8 0f	 or	 eax, 15			; 0000000fH
  00091	89 45 d4	 mov	 DWORD PTR __Masked$10[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00094	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  00097	3b 45 e4	 cmp	 eax, DWORD PTR __Max$[ebp]
  0009a	76 08		 jbe	 SHORT $LN54@basic_stri

; 4287 :             return _Max;

  0009c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0009f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000a2	eb 4c		 jmp	 SHORT $LN56@basic_stri
$LN54@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000a4	6a 0f		 push	 15			; 0000000fH
  000a6	58		 pop	 eax
  000a7	d1 e8		 shr	 eax, 1
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  000ac	2b c8		 sub	 ecx, eax
  000ae	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000b1	73 08		 jae	 SHORT $LN55@basic_stri

; 4291 :             return _Max;

  000b3	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  000b6	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000b9	eb 35		 jmp	 SHORT $LN56@basic_stri
$LN55@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000bb	6a 0f		 push	 15			; 0000000fH
  000bd	58		 pop	 eax
  000be	d1 e8		 shr	 eax, 1
  000c0	83 c0 0f	 add	 eax, 15			; 0000000fH
  000c3	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000c6	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  000c9	3b 45 cc	 cmp	 eax, DWORD PTR $T9[ebp]
  000cc	73 08		 jae	 SHORT $LN60@basic_stri
  000ce	8d 45 cc	 lea	 eax, DWORD PTR $T9[ebp]
  000d1	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
  000d4	eb 06		 jmp	 SHORT $LN61@basic_stri
$LN60@basic_stri:
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Masked$10[ebp]
  000d9	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
$LN61@basic_stri:
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv190[ebp]
  000df	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax
  000e2	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000e5	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000e8	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN56@basic_stri:

; 4409 :         return _Mypair._Get_first();

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  000f6	8b 45 b0	 mov	 eax, DWORD PTR $T4[ebp]
  000f9	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000fc	c6 45 f1 00	 mov	 BYTE PTR __Overflow_is_possible$11[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00100	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00103	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010a	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0010b	89 45 c4	 mov	 DWORD PTR __Fancyptr$8[ebp], eax

; 2534 :             _Ptr                    = _Unfancy(_Fancyptr);

  0010e	8b 45 c4	 mov	 eax, DWORD PTR __Fancyptr$8[ebp]
  00111	89 45 ac	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00114	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00117	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2535 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0011a	8d 45 c4	 lea	 eax, DWORD PTR __Fancyptr$8[ebp]
  0011d	50		 push	 eax
  0011e	ff 75 e0	 push	 DWORD PTR __My_data$[ebp]
  00121	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00126	59		 pop	 ecx
  00127	59		 pop	 ecx
$LN2@basic_stri:

; 2536 :         }
; 2537 : 
; 2538 :         _My_data._Mysize = _New_size;

  00128	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0012b	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0012e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2539 :         _My_data._Myres  = _New_capacity;

  00131	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00134	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00137	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013a	ff 75 14	 push	 DWORD PTR __Left_size$[ebp]
  0013d	ff 75 10	 push	 DWORD PTR __Left_ptr$[ebp]
  00140	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2540 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2541 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  0014b	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0014e	03 45 14	 add	 eax, DWORD PTR __Left_size$[ebp]
  00151	89 45 a8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00154	ff 75 1c	 push	 DWORD PTR __Right_size$[ebp]
  00157	ff 75 18	 push	 DWORD PTR __Right_ptr$[ebp]
  0015a	ff 75 a8	 push	 DWORD PTR __First1$[ebp]
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2542 :         _Traits::assign(_Ptr[_New_size], _Elem());

  00165	c6 45 f3 00	 mov	 BYTE PTR $T12[ebp], 0

; 428  :         _Left = _Right;

  00169	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0016c	03 45 d8	 add	 eax, DWORD PTR __New_size$[ebp]
  0016f	8a 4d f3	 mov	 cl, BYTE PTR $T12[ebp]
  00172	88 08		 mov	 BYTE PTR [eax], cl

; 2543 :         _Proxy._Release();
; 2544 :     }

  00174	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00178	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	c9		 leave
  00187	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _fprintf
_TEXT	SEGMENT
__Result$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
_fprintf PROC						; COMDAT

; 835  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 836  :         int _Result;
; 837  :         va_list _ArgList;
; 838  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00012	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __Stream$[ebp]
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	ff 70 04	 push	 DWORD PTR [eax+4]
  00025	ff 30		 push	 DWORD PTR [eax]
  00027	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  0002c	83 c4 18	 add	 esp, 24			; 00000018H

; 839  :         _Result = _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  0002f	89 45 f4	 mov	 DWORD PTR __Result$[ebp], eax

; 840  :         __crt_va_end(_ArgList);

  00032	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 841  :         return _Result;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp]

; 842  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
