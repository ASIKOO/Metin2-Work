; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	??0TPropertyBuilding@prt@@QAE@XZ		; prt::TPropertyBuilding::TPropertyBuilding
PUBLIC	??1TPropertyBuilding@prt@@QAE@XZ		; prt::TPropertyBuilding::~TPropertyBuilding
PUBLIC	??0TPropertyEffect@prt@@QAE@XZ			; prt::TPropertyEffect::TPropertyEffect
PUBLIC	??1TPropertyEffect@prt@@QAE@XZ			; prt::TPropertyEffect::~TPropertyEffect
PUBLIC	??0TPropertyAmbience@prt@@QAE@XZ		; prt::TPropertyAmbience::TPropertyAmbience
PUBLIC	??1TPropertyAmbience@prt@@QAE@XZ		; prt::TPropertyAmbience::~TPropertyAmbience
PUBLIC	??0TPropertyDungeonBlock@prt@@QAE@XZ		; prt::TPropertyDungeonBlock::TPropertyDungeonBlock
PUBLIC	??1TPropertyDungeonBlock@prt@@QAE@XZ		; prt::TPropertyDungeonBlock::~TPropertyDungeonBlock
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::max_size
PUBLIC	?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Erase_unchecked
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate
PUBLIC	?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Extract
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Insert_node
PUBLIC	??1?$map@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@@std@@QAE@XZ ; std::map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >::~map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >
PUBLIC	?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ; std::allocator<CSpeedTreeWrapper *>::deallocate
PUBLIC	??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
PUBLIC	?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >
PUBLIC	?InitializeRotation@SObjectData@CArea@@QAEXXZ	; CArea::SObjectData::InitializeRotation
PUBLIC	?deallocate@?$allocator@USObjectData@CArea@@@std@@QAEXQAUSObjectData@CArea@@I@Z ; std::allocator<CArea::SObjectData>::deallocate
PUBLIC	??1?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::~vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >
PUBLIC	?clear@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::clear
PUBLIC	?_Destroy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXPAUSObjectData@CArea@@0@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXQAUSObjectData@CArea@@II@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Change_array
PUBLIC	?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Tidy
PUBLIC	?_Xlength@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea::SObjectData> >::_Vector_val<std::_Simple_types<CArea::SObjectData> >
PUBLIC	??0SAmbienceInstance@CArea@@QAE@XZ		; CArea::SAmbienceInstance::SAmbienceInstance
PUBLIC	?__Update@SAmbienceInstance@CArea@@QAEXMMM@Z	; CArea::SAmbienceInstance::__Update
PUBLIC	?UpdateOnceSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateOnceSound
PUBLIC	?UpdateStepSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateStepSound
PUBLIC	?UpdateLoopSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateLoopSound
PUBLIC	?Render@SAmbienceInstance@CArea@@QAEXXZ		; CArea::SAmbienceInstance::Render
PUBLIC	?Picking@SAmbienceInstance@CArea@@QAE_NXZ	; CArea::SAmbienceInstance::Picking
PUBLIC	?__GetVolumeFromDistance@SAmbienceInstance@CArea@@QAEMM@Z ; CArea::SAmbienceInstance::__GetVolumeFromDistance
PUBLIC	??_GSAmbienceInstance@CArea@@UAEPAXI@Z		; CArea::SAmbienceInstance::`scalar deleting destructor'
PUBLIC	?Clear@SObjectInstance@CArea@@QAEXXZ		; CArea::SObjectInstance::Clear
PUBLIC	?SetTree@SObjectInstance@CArea@@QAEXMMMKPBD@Z	; CArea::SObjectInstance::SetTree
PUBLIC	?__Initialize@SObjectInstance@CArea@@QAEXXZ	; CArea::SObjectInstance::__Initialize
PUBLIC	??_GSObjectInstance@CArea@@UAEPAXI@Z		; CArea::SObjectInstance::`scalar deleting destructor'
PUBLIC	??0CArea@@QAE@XZ				; CArea::CArea
PUBLIC	??1CArea@@UAE@XZ				; CArea::~CArea
PUBLIC	?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ; CArea::CollectRenderingObject
PUBLIC	?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ; CArea::CollectBlendRenderingObject
PUBLIC	?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z	; CArea::SetMapOutDoor
PUBLIC	?Clear@CArea@@QAEXXZ				; CArea::Clear
PUBLIC	?Load@CArea@@QAE_NPBD@Z				; CArea::Load
PUBLIC	?GetObjectDataCount@CArea@@QAEKXZ		; CArea::GetObjectDataCount
PUBLIC	?GetObjectDataPointer@CArea@@QBE_NKPAPBUSObjectData@1@@Z ; CArea::GetObjectDataPointer
PUBLIC	?GetObjectInstanceCount@CArea@@QBE?BKXZ		; CArea::GetObjectInstanceCount
PUBLIC	?GetObjectInstancePointer@CArea@@QBE?B_NABKPAPBUSObjectInstance@1@@Z ; CArea::GetObjectInstancePointer
PUBLIC	?EnablePortal@CArea@@QAEXH@Z			; CArea::EnablePortal
PUBLIC	?ClearPortal@CArea@@QAEXXZ			; CArea::ClearPortal
PUBLIC	?AddShowingPortalID@CArea@@QAEXH@Z		; CArea::AddShowingPortalID
PUBLIC	?RefreshPortal@CArea@@QAEXXZ			; CArea::RefreshPortal
PUBLIC	?Update@CArea@@QAEXXZ				; CArea::Update
PUBLIC	?UpdateAroundAmbience@CArea@@QAEXMMM@Z		; CArea::UpdateAroundAmbience
PUBLIC	?Render@CArea@@QAEXXZ				; CArea::Render
PUBLIC	?RenderEffect@CArea@@QAEXXZ			; CArea::RenderEffect
PUBLIC	?RenderCollision@CArea@@QAEXXZ			; CArea::RenderCollision
PUBLIC	?RenderAmbience@CArea@@QAEXXZ			; CArea::RenderAmbience
PUBLIC	?RenderDungeon@CArea@@QAEXXZ			; CArea::RenderDungeon
PUBLIC	?Refresh@CArea@@QAEXXZ				; CArea::Refresh
PUBLIC	?SetCoordinate@CArea@@QAEXABG0@Z		; CArea::SetCoordinate
PUBLIC	?GetCoordinate@CArea@@QAEXPAG0@Z		; CArea::GetCoordinate
PUBLIC	?DEBUG_GetRenderedCRCNum@CArea@@QAEKXZ		; CArea::DEBUG_GetRenderedCRCNum
PUBLIC	?DEBUG_GetRenderedCRCWithNumVector@CArea@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@XZ ; CArea::DEBUG_GetRenderedCRCWithNumVector
PUBLIC	?DEBUG_GetRenderedGrapphicThingInstanceNum@CArea@@QAEKXZ ; CArea::DEBUG_GetRenderedGrapphicThingInstanceNum
PUBLIC	?CheckObjectIndex@CArea@@IBE_NK@Z		; CArea::CheckObjectIndex
PUBLIC	?__Load_LoadObject@CArea@@IAE_NPBD@Z		; CArea::__Load_LoadObject
PUBLIC	?__Load_LoadAmbience@CArea@@IAE_NPBD@Z		; CArea::__Load_LoadAmbience
PUBLIC	?__Load_BuildObjectInstances@CArea@@IAEXXZ	; CArea::__Load_BuildObjectInstances
PUBLIC	?__UpdateAniThingList@CArea@@IAEXXZ		; CArea::__UpdateAniThingList
PUBLIC	?__UpdateEffectList@CArea@@IAEXXZ		; CArea::__UpdateEffectList
PUBLIC	?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z ; CArea::__LoadAttribute
PUBLIC	?__Clear_DestroyObjectInstance@CArea@@IAEXPAUSObjectInstance@1@@Z ; CArea::__Clear_DestroyObjectInstance
PUBLIC	?__SetObjectInstance@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@@Z ; CArea::__SetObjectInstance
PUBLIC	?__SetObjectInstance_SetTree@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetTree
PUBLIC	?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetBuilding
PUBLIC	?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetEffect
PUBLIC	?__SetObjectInstance_SetAmbience@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetAmbience
PUBLIC	?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetDungeonBlock
PUBLIC	?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z ; std::allocator<CArea::SObjectInstance *>::deallocate
PUBLIC	??1?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::~vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >
PUBLIC	?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEAAV?$allocator@PAUSObjectInstance@CArea@@@2@XZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >
PUBLIC	?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXQAPAVCGraphicThingInstance@@I@Z ; std::allocator<CGraphicThingInstance *>::deallocate
PUBLIC	??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
PUBLIC	?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear
PUBLIC	?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin
PUBLIC	?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXPAPAVCGraphicThingInstance@@0@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXQAPAVCGraphicThingInstance@@II@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
PUBLIC	?deallocate@?$allocator@PAVCDungeonBlock@@@std@@QAEXQAPAVCDungeonBlock@@I@Z ; std::allocator<CDungeonBlock *>::deallocate
PUBLIC	??1?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAE@XZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::~vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >
PUBLIC	?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXPAPAVCDungeonBlock@@0@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@ABEII@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXQAPAVCDungeonBlock@@II@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@CAXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Xlength
PUBLIC	?deallocate@?$allocator@PAUSAmbienceInstance@CArea@@@std@@QAEXQAPAUSAmbienceInstance@CArea@@I@Z ; std::allocator<CArea::SAmbienceInstance *>::deallocate
PUBLIC	??1?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::~vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >
PUBLIC	?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXPAPAUSAmbienceInstance@CArea@@0@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXQAPAUSAmbienceInstance@CArea@@II@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Xlength
PUBLIC	??0?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCGraphicThingInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::max_size
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::clear
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Insert_node
PUBLIC	??1?$map@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@@std@@QAE@XZ ; std::map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >::~map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >
PUBLIC	?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXQAUSCRCWithNumber@CArea@@I@Z ; std::allocator<CArea::SCRCWithNumber>::deallocate
PUBLIC	??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
PUBLIC	?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear
PUBLIC	?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXPAUSCRCWithNumber@CArea@@0@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXQAUSCRCWithNumber@CArea@@II@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Change_array
PUBLIC	?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy
PUBLIC	?_Xlength@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlength
PUBLIC	??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@U?$_Tree_id@PAU?$_Tree_node@HPAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
PUBLIC	?DestroySystem@CArea@@SAXXZ			; CArea::DestroySystem
PUBLIC	?New@CArea@@SAPAV1@XZ				; CArea::New
PUBLIC	?Delete@CArea@@SAXPAV1@@Z			; CArea::Delete
PUBLIC	??_GCArea@@UAEPAXI@Z				; CArea::`scalar deleting destructor'
PUBLIC	??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
PUBLIC	??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
PUBLIC	??0?$CDynamicPool@USObjectInstance@CArea@@@@QAE@XZ ; CDynamicPool<CArea::SObjectInstance>::CDynamicPool<CArea::SObjectInstance>
PUBLIC	??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SObjectInstance>::~CDynamicPool<CArea::SObjectInstance>
PUBLIC	?Destroy@?$CDynamicPool@USObjectInstance@CArea@@@@QAEXXZ ; CDynamicPool<CArea::SObjectInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ ; CDynamicPool<CArea::SObjectInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@USObjectInstance@CArea@@@@KAXPAUSObjectInstance@CArea@@@Z ; CDynamicPool<CArea::SObjectInstance>::Delete
PUBLIC	??_G?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z ; CDynamicPool<CArea::SObjectInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
PUBLIC	??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ; CDynamicPool<CAttributeInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ; CDynamicPool<CAttributeInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ; CDynamicPool<CAttributeInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ; std::allocator<CAttributeInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@USAmbienceInstance@CArea@@@@QAE@XZ ; CDynamicPool<CArea::SAmbienceInstance>::CDynamicPool<CArea::SAmbienceInstance>
PUBLIC	??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SAmbienceInstance>::~CDynamicPool<CArea::SAmbienceInstance>
PUBLIC	?Destroy@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEXXZ ; CDynamicPool<CArea::SAmbienceInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ ; CDynamicPool<CArea::SAmbienceInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@USAmbienceInstance@CArea@@@@KAXPAUSAmbienceInstance@CArea@@@Z ; CDynamicPool<CArea::SAmbienceInstance>::Delete
PUBLIC	??_G?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z ; CDynamicPool<CArea::SAmbienceInstance>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCDungeonBlock@@@@QAE@XZ	; CDynamicPool<CDungeonBlock>::CDynamicPool<CDungeonBlock>
PUBLIC	??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ	; CDynamicPool<CDungeonBlock>::~CDynamicPool<CDungeonBlock>
PUBLIC	?Destroy@?$CDynamicPool@VCDungeonBlock@@@@QAEXXZ ; CDynamicPool<CDungeonBlock>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ ; CDynamicPool<CDungeonBlock>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCDungeonBlock@@@@KAXPAVCDungeonBlock@@@Z ; CDynamicPool<CDungeonBlock>::Delete
PUBLIC	??_G?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z	; CDynamicPool<CDungeonBlock>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCArea@@@@QAE@XZ		; CDynamicPool<CArea>::CDynamicPool<CArea>
PUBLIC	??1?$CDynamicPool@VCArea@@@@UAE@XZ		; CDynamicPool<CArea>::~CDynamicPool<CArea>
PUBLIC	?Destroy@?$CDynamicPool@VCArea@@@@QAEXXZ	; CDynamicPool<CArea>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ	; CDynamicPool<CArea>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCArea@@@@KAXPAVCArea@@@Z ; CDynamicPool<CArea>::Delete
PUBLIC	?deallocate@?$allocator@PAVCArea@@@std@@QAEXQAPAVCArea@@I@Z ; std::allocator<CArea *>::deallocate
PUBLIC	?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXQAPAVCArea@@II@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
PUBLIC	??_G?$CDynamicPool@VCArea@@@@UAEPAXI@Z		; CDynamicPool<CArea>::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
PUBLIC	??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > > >,0>
PUBLIC	?deallocate@?$allocator@PAVCEffectInstance@@@std@@QAEXQAPAVCEffectInstance@@I@Z ; std::allocator<CEffectInstance *>::deallocate
PUBLIC	?clear@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXPAPAVCEffectInstance@@0@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXQAPAVCEffectInstance@@II@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CEffectInstance *> >::_Vector_val<std::_Simple_types<CEffectInstance *> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@std@@UCArea_FEffectInstanceRender@@@std@@YA?AUCArea_FEffectInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectInstance *> > >,CArea_FEffectInstanceRender>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>
PUBLIC	??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@V10@UFFindIfCRC@CArea@@@Z ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::insert<0,0>
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::insert<0,0>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$to_lower@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@algorithm@boost@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVlocale@3@@Z ; boost::algorithm::to_lower<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor'
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>
PUBLIC	??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
PUBLIC	??0?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@ABU?$less@PAUSObjectInstance@CArea@@@1@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
PUBLIC	??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::~_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
PUBLIC	?max_size@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::max_size
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@2@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Insert_node
PUBLIC	??0?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >
PUBLIC	??1?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::~set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >
PUBLIC	??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::insert<0,0>
PUBLIC	??$_Find@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find<CArea::SObjectInstance *>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
PUBLIC	??$emplace_back@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXABQAVCEffectInstance@@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::emplace_back<CEffectInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXABQAVCEffectInstance@@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_back_with_unused_capacity<CEffectInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_reallocate<CEffectInstance * const &>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@std@@P6AXPAVCDungeonBlock@@@Z@std@@YAP6AXPAVCDungeonBlock@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDungeonBlock *> > >,void (__cdecl*)(CDungeonBlock *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@std@@P6AXPAUSAmbienceInstance@CArea@@@Z@std@@YAP6AXPAUSAmbienceInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SAmbienceInstance *> > >,void (__cdecl*)(CArea::SAmbienceInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@P6AXPAUSObjectInstance@CArea@@@Z@std@@YAP6AXPAUSObjectInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >,void (__cdecl*)(CArea::SObjectInstance *)>
PUBLIC	??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Find@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find<int>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$emplace_back@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::emplace_back<CArea::SCRCWithNumber const &>
PUBLIC	??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Emplace_reallocate<CArea::SCRCWithNumber const &>
PUBLIC	??$_Find@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@ABQAVCGraphicThingInstance@@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find<CGraphicThingInstance *>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
PUBLIC	??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_back_with_unused_capacity<CArea::SAmbienceInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_reallocate<CArea::SAmbienceInstance * const &>
PUBLIC	??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_back_with_unused_capacity<CDungeonBlock * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_reallocate<CDungeonBlock * const &>
PUBLIC	??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_back_with_unused_capacity<CGraphicThingInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_reallocate<CGraphicThingInstance * const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::emplace_back<CArea::SObjectData const &>
PUBLIC	??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Emplace_reallocate<CArea::SObjectData const &>
PUBLIC	??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
PUBLIC	??$_Find@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find<unsigned long>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z ; std::_Traits_find_ch<std::char_traits<char> >
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectInstance *> >
PUBLIC	??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::emplace_back<CArea * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_back_with_unused_capacity<CArea * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
PUBLIC	??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
PUBLIC	??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
PUBLIC	??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::emplace_back<CArea::SObjectInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXABQAUSObjectInstance@CArea@@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_back_with_unused_capacity<CArea::SObjectInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_reallocate<CArea::SObjectInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@@Z ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Buyheadnode<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Emplace@U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Emplace<std::pair<CGraphicThingInstance * const,unsigned long> >
PUBLIC	??$_Emplace@U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Emplace<std::pair<unsigned long const ,CEffectInstance *> >
PUBLIC	??$transform_range@V?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@boost@@U?$to_lowerF@D@detail@algorithm@2@@detail@algorithm@boost@@YAXABV?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@2@U?$to_lowerF@D@012@@Z ; boost::algorithm::detail::transform_range<boost::iterator_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >,boost::algorithm::detail::to_lowerF<char> >
PUBLIC	??$_Emplace@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@HPAX@std@@_N@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace<int const &>
PUBLIC	??$_Emplace@ABQAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Emplace<CArea::SObjectInstance * const &>
PUBLIC	??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find_lower_bound<CArea::SObjectInstance *>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Freenode0<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
PUBLIC	??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find_lower_bound<CGraphicThingInstance *>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find_lower_bound<unsigned long>
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
PUBLIC	??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >
PUBLIC	??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
PUBLIC	??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >
PUBLIC	??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CArea::SObjectInstance *> >
PUBLIC	??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >
PUBLIC	??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
PUBLIC	??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z		; std::_Refancy<char const *,0>
PUBLIC	??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
PUBLIC	??$_Insertion_sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Insertion_sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Make_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Make_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCEffectInstance@@PAPAV1@@0@PAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Partition_by_median_guess_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Insertion_sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0UCRCNumComp@2@@Z ; std::_Insertion_sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Make_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Make_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ; std::_Partition_by_median_guess_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Insertion_sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAPAUSObjectData@CArea@@QAU12@0UObjectDataComp@2@@Z ; std::_Insertion_sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Make_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ; std::_Make_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YA?AU?$pair@PAUSObjectData@CArea@@PAU12@@0@PAUSObjectData@CArea@@0UObjectDataComp@3@@Z ; std::_Partition_by_median_guess_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
PUBLIC	??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > ><std::pair<CGraphicThingInstance * const,unsigned long> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
PUBLIC	??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > ><std::pair<unsigned long const ,CEffectInstance *> >
PUBLIC	??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@U?$to_lowerF@D@detail@algorithm@boost@@@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@U?$to_lowerF@D@detail@algorithm@boost@@@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,boost::algorithm::detail::to_lowerF<char> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int const &>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
PUBLIC	??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > ><CArea::SObjectInstance * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
PUBLIC	??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
PUBLIC	??$_Copy_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectInstance * *,CEffectInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
PUBLIC	??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
PUBLIC	??$_Copy_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ; std::_Copy_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$_Copy_memmove@PAPAUSAmbienceInstance@CArea@@PAPAU12@@std@@YAPAPAUSAmbienceInstance@CArea@@PAPAU12@00@Z ; std::_Copy_memmove<CArea::SAmbienceInstance * *,CArea::SAmbienceInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCDungeonBlock@@PAPAV1@@std@@YAPAPAVCDungeonBlock@@PAPAV1@00@Z ; std::_Copy_memmove<CDungeonBlock * *,CDungeonBlock * *>
PUBLIC	??$_Copy_memmove@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicThingInstance * *,CGraphicThingInstance * *>
PUBLIC	??$_Copy_memmove@PAPAUSObjectInstance@CArea@@PAPAU12@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@00@Z ; std::_Copy_memmove<CArea::SObjectInstance * *,CArea::SObjectInstance * *>
PUBLIC	??$_Zero_range@PAPAUSObjectInstance@CArea@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0@Z ; std::_Zero_range<CArea::SObjectInstance * *>
PUBLIC	??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
PUBLIC	??$_Refancy@PAUSCRCWithNumber@CArea@@$0A@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ; std::_Refancy<CArea::SCRCWithNumber *,0>
PUBLIC	??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Pop_heap_hole_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Pop_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Pop_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Guess_median_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Guess_median_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
PUBLIC	??$_Pop_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Pop_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Guess_median_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Guess_median_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SObjectData *,CArea::SObjectData,CArea::ObjectDataComp>
PUBLIC	??$_Pop_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ; std::_Pop_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Guess_median_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Guess_median_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>
PUBLIC	??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
PUBLIC	??$tolower@D@std@@YADDABVlocale@0@@Z		; std::tolower<char>
PUBLIC	??$_Copy_backward_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ; std::_Copy_backward_memmove<CEffectInstance * *,CEffectInstance * *>
PUBLIC	??$_Push_heap_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Push_heap_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
PUBLIC	??$_Copy_backward_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ; std::_Copy_backward_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
PUBLIC	??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
PUBLIC	??$_Copy_backward_memmove@PAUSObjectData@CArea@@PAU12@@std@@YAPAUSObjectData@CArea@@PAU12@00@Z ; std::_Copy_backward_memmove<CArea::SObjectData *,CArea::SObjectData *>
PUBLIC	??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	??_7SAmbienceInstance@CArea@@6B@		; CArea::SAmbienceInstance::`vftable'
PUBLIC	??_7SObjectInstance@CArea@@6B@			; CArea::SObjectInstance::`vftable'
PUBLIC	?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A ; CArea::ms_ObjectInstancePool
PUBLIC	?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A ; CArea::ms_AttributeInstancePool
PUBLIC	?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A ; CArea::ms_AmbienceInstancePool
PUBLIC	?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A ; CArea::ms_DungeonBlockInstancePool
PUBLIC	?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A	; CArea::ms_kPool
PUBLIC	??_7CArea@@6B@					; CArea::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A ; CSingleton<CPropertyManager>::ms_singleton
PUBLIC	??_7?$CDynamicPool@USObjectInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SObjectInstance>::`vftable'
PUBLIC	??_7?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`vftable'
PUBLIC	??_7?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SAmbienceInstance>::`vftable'
PUBLIC	??_7?$CDynamicPool@VCDungeonBlock@@@@6B@	; CDynamicPool<CDungeonBlock>::`vftable'
PUBLIC	??_7?$CDynamicPool@VCArea@@@@6B@		; CDynamicPool<CArea>::`vftable'
PUBLIC	??_C@_0N@FPEBPNJJ@PropertyType@			; `string'
PUBLIC	??_C@_0CL@BOJNBGJP@CArea?3?3SetEffect?5effect?5registe@ ; `string'
PUBLIC	??_C@_08JBFACIKL@TreeFile@			; `string'
PUBLIC	??_C@_0O@NDEAKJNP@_lod_?$CF?42d?4gr2@		; `string'
PUBLIC	??_C@_04GHGHGAKN@ONCE@				; `string'
PUBLIC	??_C@_04MOOLDHHD@STEP@				; `string'
PUBLIC	??_C@_04KGNEGCGI@LOOP@				; `string'
PUBLIC	??_C@_09OLKGEJPN@?1dungeon?1@			; `string'
PUBLIC	??_C@_09PCMKFNFD@?2dungeon?2@			; `string'
PUBLIC	??_C@_0BC@NJPKAPFJ@DummyCollisionOBB@		; `string'
PUBLIC	??_C@_0N@IIOKECFB@AreaData?4txt@		; `string'
PUBLIC	??_C@_0BF@EMGBEFOB@AreaAmbienceData?4txt@	; `string'
PUBLIC	??_C@_0CA@NNOAMPKE@?5CArea?3?3Load?5File?5Load?5?$CFs?5ERROR@ ; `string'
PUBLIC	??_C@_0N@DLGDDPHB@areadatafile@			; `string'
PUBLIC	??_C@_0CM@CJHDNGEF@?5CArea?3?3__LoadObject?5File?5Forma@ ; `string'
PUBLIC	??_C@_0M@IANPHBDM@objectcount@			; `string'
PUBLIC	??_C@_0CM@CFOIFIG@?5CArea?3?3__LoadObject?5File?5Forma@ ; `string'
PUBLIC	??_C@_0L@CHFLOJFF@object?$CF03d@		; `string'
PUBLIC	??_C@_0CL@HHDKLHOE@?5CArea?3?3LoadObject?5Property?$CI?$CFu?$CJ@ ; `string'
PUBLIC	??_C@_0BF@PFPNGEBG@areaambiencedatafile@	; `string'
PUBLIC	??_C@_0CO@ECPJGBAI@?5CArea?3?3__LoadAmbience?5File?5For@ ; `string'
PUBLIC	??_C@_0CO@GJNEDCML@?5CArea?3?3__LoadAmbience?5File?5For@ ; `string'
PUBLIC	??_C@_0CN@BAHENMHD@?5CArea?3?3LoadAmbience?5Property?$CI?$CF@ ; `string'
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCAttributeInstance@@@@8	; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CArea@@6B@					; CArea::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCArea@@@8				; CArea `RTTI Type Descriptor'
PUBLIC	??_R3CArea@@8					; CArea::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CArea@@8					; CArea::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CArea@@8				; CArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SAmbienceInstance@CArea@@6B@		; CArea::SAmbienceInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUSAmbienceInstance@CArea@@@8		; CArea::SAmbienceInstance `RTTI Type Descriptor'
PUBLIC	??_R3SAmbienceInstance@CArea@@8			; CArea::SAmbienceInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SAmbienceInstance@CArea@@8			; CArea::SAmbienceInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SAmbienceInstance@CArea@@8	; CArea::SAmbienceInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	??_R4SObjectInstance@CArea@@6B@			; CArea::SObjectInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUSObjectInstance@CArea@@@8		; CArea::SObjectInstance `RTTI Type Descriptor'
PUBLIC	??_R3SObjectInstance@CArea@@8			; CArea::SObjectInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SObjectInstance@CArea@@8			; CArea::SObjectInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SObjectInstance@CArea@@8		; CArea::SObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@USObjectInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SObjectInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@USObjectInstance@CArea@@@@@8 ; CDynamicPool<CArea::SObjectInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@USObjectInstance@CArea@@@@8	; CDynamicPool<CArea::SObjectInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@USObjectInstance@CArea@@@@8	; CDynamicPool<CArea::SObjectInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@USObjectInstance@CArea@@@@8 ; CDynamicPool<CArea::SObjectInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@@8 ; CDynamicPool<CArea::SAmbienceInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@USAmbienceInstance@CArea@@@@8 ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@USAmbienceInstance@CArea@@@@8 ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@USAmbienceInstance@CArea@@@@8 ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCDungeonBlock@@@@6B@	; CDynamicPool<CDungeonBlock>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCDungeonBlock@@@@@8	; CDynamicPool<CDungeonBlock> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCDungeonBlock@@@@8		; CDynamicPool<CDungeonBlock>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCDungeonBlock@@@@8		; CDynamicPool<CDungeonBlock>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCDungeonBlock@@@@8 ; CDynamicPool<CDungeonBlock>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCArea@@@@6B@		; CDynamicPool<CArea>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCArea@@@@@8		; CDynamicPool<CArea> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCArea@@@@8			; CDynamicPool<CArea>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCArea@@@@8			; CDynamicPool<CArea>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCArea@@@@8	; CDynamicPool<CArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40490fdb
PUBLIC	__real@40800000
PUBLIC	__real@41200000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	_free:PROC
EXTRN	_atof:PROC
EXTRN	__atoi64:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	_sqrt:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	?GetCaseCRC32@@YAKPBDI@Z:PROC			; GetCaseCRC32
EXTRN	?frandom@@YAMMM@Z:PROC				; frandom
EXTRN	_D3DXMatrixRotationYawPitchRoll@16:PROC
EXTRN	_D3DXQuaternionRotationYawPitchRoll@16:PROC
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__Getctype:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z:PROC ; LoadMultipleTextData
EXTRN	?IntersectSphere@CGraphicCollisionObject@@IAE_NABUD3DXVECTOR3@@M@Z:PROC ; CGraphicCollisionObject::IntersectSphere
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?Clear@CScreen@@QAEXXZ:PROC			; CScreen::Clear
EXTRN	?RenderLine2d@CScreen@@QAEXMMMMM@Z:PROC		; CScreen::RenderLine2d
EXTRN	?RenderCircle2d@CScreen@@QAEXMMMMH@Z:PROC	; CScreen::RenderCircle2d
EXTRN	?RenderCube@CScreen@@QAEXMMMMMM@Z:PROC		; CScreen::RenderCube
EXTRN	?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z:PROC ; CScreen::RenderSphere
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?IsEmpty@CResource@@QBE_NXZ:PROC		; CResource::IsEmpty
EXTRN	?StopSound3D@CSoundManager@@QAEXH@Z:PROC	; CSoundManager::StopSound3D
EXTRN	?PlayAmbienceSound3D@CSoundManager@@QAEHMMMPBDH@Z:PROC ; CSoundManager::PlayAmbienceSound3D
EXTRN	?SetSoundVolume3D@CSoundManager@@QAEXHM@Z:PROC	; CSoundManager::SetSoundVolume3D
EXTRN	?GetPropertyType@prt@@YAKPBD@Z:PROC		; prt::GetPropertyType
EXTRN	?PropertyBuildingStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyBuilding@1@@Z:PROC ; prt::PropertyBuildingStringToData
EXTRN	?PropertyEffectStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyEffect@1@@Z:PROC ; prt::PropertyEffectStringToData
EXTRN	?PropertyAmbienceStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyAmbience@1@@Z:PROC ; prt::PropertyAmbienceStringToData
EXTRN	?PropertyDungeonBlockStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyDungeonBlock@1@@Z:PROC ; prt::PropertyDungeonBlockStringToData
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?IsFileExist@CResourceManager@@QAE_NPBD@Z:PROC	; CResourceManager::IsFileExist
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?GetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@PAK@Z:PROC ; CStateManager::GetTextureStageState
EXTRN	?GetCollisionDataVector@CAttributeData@@QBEABV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@XZ:PROC ; CAttributeData::GetCollisionDataVector
EXTRN	?AddCollisionData@CAttributeData@@QAEIABVCStaticCollisionData@@@Z:PROC ; CAttributeData::AddCollisionData
EXTRN	??0CAttributeInstance@@QAE@XZ:PROC		; CAttributeInstance::CAttributeInstance
EXTRN	?Clear@CAttributeInstance@@QAEXXZ:PROC		; CAttributeInstance::Clear
EXTRN	?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z:PROC ; CAttributeInstance::SetObjectPointer
EXTRN	?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z:PROC ; CAttributeInstance::RefreshObject
EXTRN	?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ:PROC ; CAttributeInstance::GetObjectPointer
EXTRN	?GetYaw@CGraphicObjectInstance@@QAEMXZ:PROC	; CGraphicObjectInstance::GetYaw
EXTRN	?GetPitch@CGraphicObjectInstance@@QAEMXZ:PROC	; CGraphicObjectInstance::GetPitch
EXTRN	?GetRoll@CGraphicObjectInstance@@QAEMXZ:PROC	; CGraphicObjectInstance::GetRoll
EXTRN	?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z:PROC ; CGraphicObjectInstance::SetPosition
EXTRN	?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z:PROC ; CGraphicObjectInstance::SetRotation
EXTRN	?Clear@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Clear
EXTRN	?Update@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Update
EXTRN	?Render@CGraphicObjectInstance@@QAE_NXZ:PROC	; CGraphicObjectInstance::Render
EXTRN	?Deform@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Deform
EXTRN	?Transform@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Transform
EXTRN	?Show@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Show
EXTRN	?isShow@CGraphicObjectInstance@@QAE_NXZ:PROC	; CGraphicObjectInstance::isShow
EXTRN	?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ:PROC ; CGraphicObjectInstance::GetTransform
EXTRN	?SetPortal@CGraphicObjectInstance@@QAEXKH@Z:PROC ; CGraphicObjectInstance::SetPortal
EXTRN	?Initialize@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Initialize
EXTRN	?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::UpdateBoundingSphere
EXTRN	?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::RegisterBoundingSphere
EXTRN	?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z:PROC ; CGraphicObjectInstance::UpdateCollisionData
EXTRN	?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ:PROC ; CGraphicObjectInstance::GetCollisionInstanceCount
EXTRN	?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z:PROC ; CGraphicObjectInstance::GetCollisionInstanceData
EXTRN	?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z:PROC ; CGraphicObjectInstance::UpdateHeightInstance
EXTRN	?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z:PROC ; CEffectInstance::LessRenderOrder
EXTRN	?isAlive@CEffectInstance@@QAEHXZ:PROC		; CEffectInstance::isAlive
EXTRN	?SetGlobalMatrix@CEffectInstance@@QAEXABUD3DXMATRIX@@@Z:PROC ; CEffectInstance::SetGlobalMatrix
EXTRN	?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z:PROC ; CEffectManager::RegisterEffect
EXTRN	?GetEffectData@CEffectManager@@QAE_NKPAPAVCEffectData@@@Z:PROC ; CEffectManager::GetEffectData
EXTRN	?CreateUnsafeEffectInstance@CEffectManager@@QAEXKPAPAVCEffectInstance@@@Z:PROC ; CEffectManager::CreateUnsafeEffectInstance
EXTRN	?DestroyUnsafeEffectInstance@CEffectManager@@QAE_NPAVCEffectInstance@@@Z:PROC ; CEffectManager::DestroyUnsafeEffectInstance
EXTRN	?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ:PROC	; CSpeedTreeWrapper::GetPosition
EXTRN	?CreateInstance@CSpeedTreeForest@@QAEPAVCSpeedTreeWrapper@@MMMKPBD@Z:PROC ; CSpeedTreeForest::CreateInstance
EXTRN	?DeleteInstance@CSpeedTreeForest@@QAEXPAVCSpeedTreeWrapper@@@Z:PROC ; CSpeedTreeForest::DeleteInstance
EXTRN	?GetModelCount@CGraphicThing@@QBEHXZ:PROC	; CGraphicThing::GetModelCount
EXTRN	?GetMotionCount@CGraphicThing@@QBEHXZ:PROC	; CGraphicThing::GetMotionCount
EXTRN	?UpdateLODLevel@CGraphicThingInstance@@QAEXXZ:PROC ; CGraphicThingInstance::UpdateLODLevel
EXTRN	?DeformAll@CGraphicThingInstance@@QAEXXZ:PROC	; CGraphicThingInstance::DeformAll
EXTRN	?ReserveModelInstance@CGraphicThingInstance@@QAEXH@Z:PROC ; CGraphicThingInstance::ReserveModelInstance
EXTRN	?ReserveModelThing@CGraphicThingInstance@@QAEXH@Z:PROC ; CGraphicThingInstance::ReserveModelThing
EXTRN	?IsMotionThing@CGraphicThingInstance@@QAE_NXZ:PROC ; CGraphicThingInstance::IsMotionThing
EXTRN	?RegisterModelThing@CGraphicThingInstance@@QAEXHPAVCGraphicThing@@@Z:PROC ; CGraphicThingInstance::RegisterModelThing
EXTRN	?RegisterLODThing@CGraphicThingInstance@@QAEXHPAVCGraphicThing@@@Z:PROC ; CGraphicThingInstance::RegisterLODThing
EXTRN	?RegisterMotionThing@CGraphicThingInstance@@QAEXKPAVCGraphicThing@@@Z:PROC ; CGraphicThingInstance::RegisterMotionThing
EXTRN	?SetModelInstance@CGraphicThingInstance@@QAE_NHHHH@Z:PROC ; CGraphicThingInstance::SetModelInstance
EXTRN	?SetMotion@CGraphicThingInstance@@QAE_NKMHM@Z:PROC ; CGraphicThingInstance::SetMotion
EXTRN	?BuildBoundingSphere@CGraphicThingInstance@@QAEXXZ:PROC ; CGraphicThingInstance::BuildBoundingSphere
EXTRN	?New@CGraphicThingInstance@@SAPAV1@XZ:PROC	; CGraphicThingInstance::New
EXTRN	?Delete@CGraphicThingInstance@@SAXPAV1@@Z:PROC	; CGraphicThingInstance::Delete
EXTRN	?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ:PROC ; CGraphicThingInstance::HaveBlendThing
EXTRN	??0CDungeonBlock@@QAE@XZ:PROC			; CDungeonBlock::CDungeonBlock
EXTRN	?BuildBoundingSphere@CDungeonBlock@@QAEXXZ:PROC	; CDungeonBlock::BuildBoundingSphere
EXTRN	?Load@CDungeonBlock@@QAE_NPBD@Z:PROC		; CDungeonBlock::Load
EXTRN	?Update@CDungeonBlock@@QAEXXZ:PROC		; CDungeonBlock::Update
EXTRN	?Render@CDungeonBlock@@QAEXXZ:PROC		; CDungeonBlock::Render
EXTRN	??_ESAmbienceInstance@CArea@@UAEPAXI@Z:PROC	; CArea::SAmbienceInstance::`vector deleting destructor'
EXTRN	??_ESObjectInstance@CArea@@UAEPAXI@Z:PROC	; CArea::SObjectInstance::`vector deleting destructor'
EXTRN	??_ECArea@@UAEPAXI@Z:PROC			; CArea::`vector deleting destructor'
EXTRN	?Get@CPropertyManager@@QAE_NKPAPAVCProperty@@@Z:PROC ; CPropertyManager::Get
EXTRN	?GetString@CProperty@@QAE_NPBDPAPBD@Z:PROC	; CProperty::GetString
EXTRN	??_E?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z:PROC ; CDynamicPool<CArea::SObjectInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CAttributeInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z:PROC ; CDynamicPool<CArea::SAmbienceInstance>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z:PROC ; CDynamicPool<CDungeonBlock>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCArea@@@@UAEPAXI@Z:PROC	; CDynamicPool<CArea>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__ltod3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A DD 01H DUP (?) ; CSingleton<CSoundManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A DD 01H DUP (?) ; CSingleton<CEffectManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A DB 024H DUP (?) ; CArea::ms_ObjectInstancePool
?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A DB 024H DUP (?) ; CArea::ms_AttributeInstancePool
?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A DB 024H DUP (?) ; CArea::ms_AmbienceInstancePool
?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A DB 024H DUP (?) ; CArea::ms_DungeonBlockInstancePool
?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A DB 024H DUP (?) ; CArea::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A DD 01H DUP (?) ; CSingleton<CPropertyManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
_BSS	SEGMENT
?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A DB 0cH DUP (?) ; `CArea::RenderEffect'::`9'::s_kVct_pkEftInstSort
_BSS	ENDS
;	COMDAT ?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA
_BSS	SEGMENT
?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA DD 01H DUP (?) ; `CArea::RenderEffect'::`9'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_ObjectInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ ; ??ms_ObjectInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40490fdb
CONST	SEGMENT
__real@40490fdb DD 040490fdbr			; 3.14159
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCArea@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCArea@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCArea@@@@@8 ; CDynamicPool<CArea>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCArea@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCArea@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCArea@@@@8 ; CDynamicPool<CArea>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCArea@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCArea@@@@8 DD 00H			; CDynamicPool<CArea>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCArea@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCArea@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CArea> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCArea@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCArea@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCArea@@@@6B@ DD 00H		; CDynamicPool<CArea>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCArea@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCDungeonBlock@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCDungeonBlock@@@@@8 ; CDynamicPool<CDungeonBlock>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCDungeonBlock@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCDungeonBlock@@@@8 ; CDynamicPool<CDungeonBlock>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCDungeonBlock@@@@8 DD 00H		; CDynamicPool<CDungeonBlock>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCDungeonBlock@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCDungeonBlock@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CDungeonBlock> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCDungeonBlock@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCDungeonBlock@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCDungeonBlock@@@@6B@ DD 00H	; CDynamicPool<CDungeonBlock>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCDungeonBlock@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCDungeonBlock@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@USAmbienceInstance@CArea@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@@8 ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@USAmbienceInstance@CArea@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@USAmbienceInstance@CArea@@@@8 ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@USAmbienceInstance@CArea@@@@8 DD 00H ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CArea::SAmbienceInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@ DD 00H ; CDynamicPool<CArea::SAmbienceInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@USAmbienceInstance@CArea@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@USAmbienceInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@USObjectInstance@CArea@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@USObjectInstance@CArea@@@@@8 ; CDynamicPool<CArea::SObjectInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@USObjectInstance@CArea@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@USObjectInstance@CArea@@@@8 ; CDynamicPool<CArea::SObjectInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@USObjectInstance@CArea@@@@8 DD 00H	; CDynamicPool<CArea::SObjectInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@USObjectInstance@CArea@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@USObjectInstance@CArea@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CArea::SObjectInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@USObjectInstance@CArea@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@USObjectInstance@CArea@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@USObjectInstance@CArea@@@@6B@ DD 00H ; CDynamicPool<CArea::SObjectInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@USObjectInstance@CArea@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@USObjectInstance@CArea@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SObjectInstance@CArea@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SObjectInstance@CArea@@8 DD FLAT:??_R0?AUSObjectInstance@CArea@@@8 ; CArea::SObjectInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SObjectInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R2SObjectInstance@CArea@@8
rdata$r	SEGMENT
??_R2SObjectInstance@CArea@@8 DD FLAT:??_R1A@?0A@EA@SObjectInstance@CArea@@8 ; CArea::SObjectInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SObjectInstance@CArea@@8
rdata$r	SEGMENT
??_R3SObjectInstance@CArea@@8 DD 00H			; CArea::SObjectInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SObjectInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUSObjectInstance@CArea@@@8
data$rs	SEGMENT
??_R0?AUSObjectInstance@CArea@@@8 DD FLAT:??_7type_info@@6B@ ; CArea::SObjectInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSObjectInstance@CArea@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SObjectInstance@CArea@@6B@
rdata$r	SEGMENT
??_R4SObjectInstance@CArea@@6B@ DD 00H			; CArea::SObjectInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSObjectInstance@CArea@@@8
	DD	FLAT:??_R3SObjectInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$rs	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SAmbienceInstance@CArea@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SAmbienceInstance@CArea@@8 DD FLAT:??_R0?AUSAmbienceInstance@CArea@@@8 ; CArea::SAmbienceInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SAmbienceInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R2SAmbienceInstance@CArea@@8
rdata$r	SEGMENT
??_R2SAmbienceInstance@CArea@@8 DD FLAT:??_R1A@?0A@EA@SAmbienceInstance@CArea@@8 ; CArea::SAmbienceInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3SAmbienceInstance@CArea@@8
rdata$r	SEGMENT
??_R3SAmbienceInstance@CArea@@8 DD 00H			; CArea::SAmbienceInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2SAmbienceInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUSAmbienceInstance@CArea@@@8
data$rs	SEGMENT
??_R0?AUSAmbienceInstance@CArea@@@8 DD FLAT:??_7type_info@@6B@ ; CArea::SAmbienceInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUSAmbienceInstance@CArea@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SAmbienceInstance@CArea@@6B@
rdata$r	SEGMENT
??_R4SAmbienceInstance@CArea@@6B@ DD 00H		; CArea::SAmbienceInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUSAmbienceInstance@CArea@@@8
	DD	FLAT:??_R3SAmbienceInstance@CArea@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CArea@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CArea@@8 DD FLAT:??_R0?AVCArea@@@8	; CArea::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CArea@@8
rdata$r	ENDS
;	COMDAT ??_R2CArea@@8
rdata$r	SEGMENT
??_R2CArea@@8 DD FLAT:??_R1A@?0A@EA@CArea@@8		; CArea::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CArea@@8
rdata$r	SEGMENT
??_R3CArea@@8 DD 00H					; CArea::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CArea@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCArea@@@8
data$rs	SEGMENT
??_R0?AVCArea@@@8 DD FLAT:??_7type_info@@6B@		; CArea `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCArea@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CArea@@6B@
rdata$r	SEGMENT
??_R4CArea@@6B@ DD 00H					; CArea::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCArea@@@8
	DD	FLAT:??_R3CArea@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCAttributeInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCAttributeInstance@@@@8 ; CDynamicPool<CAttributeInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCAttributeInstance@@@@8 DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CAttributeInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCAttributeInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ DD 00H	; CDynamicPool<CAttributeInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCAttributeInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCAttributeInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0CN@BAHENMHD@?5CArea?3?3LoadAmbience?5Property?$CI?$CF@
CONST	SEGMENT
??_C@_0CN@BAHENMHD@?5CArea?3?3LoadAmbience?5Property?$CI?$CF@ DB ' CArea:'
	DB	':LoadAmbience Property(%d) Load ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GJNEDCML@?5CArea?3?3__LoadAmbience?5File?5For@
CONST	SEGMENT
??_C@_0CO@GJNEDCML@?5CArea?3?3__LoadAmbience?5File?5For@ DB ' CArea::__Lo'
	DB	'adAmbience File Format %s ERROR 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@ECPJGBAI@?5CArea?3?3__LoadAmbience?5File?5For@
CONST	SEGMENT
??_C@_0CO@ECPJGBAI@?5CArea?3?3__LoadAmbience?5File?5For@ DB ' CArea::__Lo'
	DB	'adAmbience File Format %s ERROR 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PFPNGEBG@areaambiencedatafile@
CONST	SEGMENT
??_C@_0BF@PFPNGEBG@areaambiencedatafile@ DB 'areaambiencedatafile', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@HHDKLHOE@?5CArea?3?3LoadObject?5Property?$CI?$CFu?$CJ@
CONST	SEGMENT
??_C@_0CL@HHDKLHOE@?5CArea?3?3LoadObject?5Property?$CI?$CFu?$CJ@ DB ' CAr'
	DB	'ea::LoadObject Property(%u) Load ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CHFLOJFF@object?$CF03d@
CONST	SEGMENT
??_C@_0L@CHFLOJFF@object?$CF03d@ DB 'object%03d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CFOIFIG@?5CArea?3?3__LoadObject?5File?5Forma@
CONST	SEGMENT
??_C@_0CM@CFOIFIG@?5CArea?3?3__LoadObject?5File?5Forma@ DB ' CArea::__Loa'
	DB	'dObject File Format %s ERROR 2', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IANPHBDM@objectcount@
CONST	SEGMENT
??_C@_0M@IANPHBDM@objectcount@ DB 'objectcount', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@CJHDNGEF@?5CArea?3?3__LoadObject?5File?5Forma@
CONST	SEGMENT
??_C@_0CM@CJHDNGEF@?5CArea?3?3__LoadObject?5File?5Forma@ DB ' CArea::__Lo'
	DB	'adObject File Format %s ERROR 1', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLGDDPHB@areadatafile@
CONST	SEGMENT
??_C@_0N@DLGDDPHB@areadatafile@ DB 'areadatafile', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NNOAMPKE@?5CArea?3?3Load?5File?5Load?5?$CFs?5ERROR@
CONST	SEGMENT
??_C@_0CA@NNOAMPKE@?5CArea?3?3Load?5File?5Load?5?$CFs?5ERROR@ DB ' CArea:'
	DB	':Load File Load %s ERROR', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EMGBEFOB@AreaAmbienceData?4txt@
CONST	SEGMENT
??_C@_0BF@EMGBEFOB@AreaAmbienceData?4txt@ DB 'AreaAmbienceData.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@IIOKECFB@AreaData?4txt@
CONST	SEGMENT
??_C@_0N@IIOKECFB@AreaData?4txt@ DB 'AreaData.txt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@NJPKAPFJ@DummyCollisionOBB@
CONST	SEGMENT
??_C@_0BC@NJPKAPFJ@DummyCollisionOBB@ DB 'DummyCollisionOBB', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09PCMKFNFD@?2dungeon?2@
CONST	SEGMENT
??_C@_09PCMKFNFD@?2dungeon?2@ DB '\dungeon\', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09OLKGEJPN@?1dungeon?1@
CONST	SEGMENT
??_C@_09OLKGEJPN@?1dungeon?1@ DB '/dungeon/', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04KGNEGCGI@LOOP@
CONST	SEGMENT
??_C@_04KGNEGCGI@LOOP@ DB 'LOOP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MOOLDHHD@STEP@
CONST	SEGMENT
??_C@_04MOOLDHHD@STEP@ DB 'STEP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04GHGHGAKN@ONCE@
CONST	SEGMENT
??_C@_04GHGHGAKN@ONCE@ DB 'ONCE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NDEAKJNP@_lod_?$CF?42d?4gr2@
CONST	SEGMENT
??_C@_0O@NDEAKJNP@_lod_?$CF?42d?4gr2@ DB '_lod_%.2d.gr2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08JBFACIKL@TreeFile@
CONST	SEGMENT
??_C@_08JBFACIKL@TreeFile@ DB 'TreeFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BOJNBGJP@CArea?3?3SetEffect?5effect?5registe@
CONST	SEGMENT
??_C@_0CL@BOJNBGJP@CArea?3?3SetEffect?5effect?5registe@ DB 'CArea::SetEff'
	DB	'ect effect register error %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FPEBPNJJ@PropertyType@
CONST	SEGMENT
??_C@_0N@FPEBPNJJ@PropertyType@ DB 'PropertyType', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCArea@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCArea@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCArea@@@@6B@ ; CDynamicPool<CArea>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCArea@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCDungeonBlock@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCDungeonBlock@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCDungeonBlock@@@@6B@ ; CDynamicPool<CDungeonBlock>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@ DD FLAT:??_R4?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SAmbienceInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCAttributeInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCAttributeInstance@@@@6B@ ; CDynamicPool<CAttributeInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@USObjectInstance@CArea@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@USObjectInstance@CArea@@@@6B@ DD FLAT:??_R4?$CDynamicPool@USObjectInstance@CArea@@@@6B@ ; CDynamicPool<CArea::SObjectInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CArea@@6B@
CONST	SEGMENT
??_7CArea@@6B@ DD FLAT:??_R4CArea@@6B@			; CArea::`vftable'
	DD	FLAT:??_ECArea@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SObjectInstance@CArea@@6B@
CONST	SEGMENT
??_7SObjectInstance@CArea@@6B@ DD FLAT:??_R4SObjectInstance@CArea@@6B@ ; CArea::SObjectInstance::`vftable'
	DD	FLAT:??_ESObjectInstance@CArea@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SAmbienceInstance@CArea@@6B@
CONST	SEGMENT
??_7SAmbienceInstance@CArea@@6B@ DD FLAT:??_R4SAmbienceInstance@CArea@@6B@ ; CArea::SAmbienceInstance::`vftable'
	DD	FLAT:??_ESAmbienceInstance@CArea@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z$1
__ehfuncinfo$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z$1
__ehfuncinfo$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z$1
__ehfuncinfo$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z$1
__ehfuncinfo$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$0
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0
__ehfuncinfo$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0
__ehfuncinfo$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$3
__ehfuncinfo$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z$0
	DD	00H
	DD	FLAT:___std_terminate
	DD	00H
	DD	FLAT:__unwindfunclet$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z$1
__ehfuncinfo$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$9
	DD	09H
	DD	FLAT:__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__Load_LoadObject@CArea@@IAE_NPBD@Z DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?__Load_LoadObject@CArea@@IAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__Load_LoadObject@CArea@@IAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$5
	DD	00H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$7
	DD	07H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$8
	DD	08H
	DD	FLAT:__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?RefreshPortal@CArea@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?RefreshPortal@CArea@@QAEXXZ$0
__ehfuncinfo$?RefreshPortal@CArea@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?RefreshPortal@CArea@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Load@CArea@@QAE_NPBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Load@CArea@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Load@CArea@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$2
	DD	03H
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CArea@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CArea@@QAE@XZ DD 019930522H
	DD	0cH
	DD	FLAT:__unwindtable$??0CArea@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CArea@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CArea@@QAE@XZ$11
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z$9
__ehfuncinfo$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
??ms_AttributeInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; ??ms_AttributeInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??ms_AmbienceInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ ; ??ms_AmbienceInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??ms_DungeonBlockInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ ; ??ms_DungeonBlockInstancePool$initializer$@CArea@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CArea@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CArea@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z
_TEXT	SEGMENT
$T1 = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
$T7 = -68						; size = 4
$T8 = -64						; size = 4
$T9 = -60						; size = 4
tv75 = -56						; size = 4
tv67 = -52						; size = 4
tv91 = -48						; size = 4
__Tmp$10 = -44						; size = 48
__Tmp$11 = 4						; size = 48
__Tmp$12 = 52						; size = 48
__$ArrayPad$ = 100					; size = 4
__First$ = 112						; size = 4
__Mid$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z PROC ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  00017	8b 45 74	 mov	 eax, DWORD PTR __Mid$[ebp]
  0001a	8b 4d 70	 mov	 ecx, DWORD PTR __First$[ebp]
  0001d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00020	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00023	73 09		 jae	 SHORT $LN8@Med3_unche
  00025	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0002c	eb 04		 jmp	 SHORT $LN6@Med3_unche
$LN8@Med3_unche:
  0002e	83 65 d0 00	 and	 DWORD PTR tv91[ebp], 0
$LN6@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00032	0f b6 45 d0	 movzx	 eax, BYTE PTR tv91[ebp]
  00036	85 c0		 test	 eax, eax
  00038	74 33		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003a	8b 45 74	 mov	 eax, DWORD PTR __Mid$[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00040	6a 0c		 push	 12			; 0000000cH
  00042	59		 pop	 ecx
  00043	8b 75 c4	 mov	 esi, DWORD PTR $T9[ebp]
  00046	8d 7d 34	 lea	 edi, DWORD PTR __Tmp$12[ebp]
  00049	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0004b	8b 45 70	 mov	 eax, DWORD PTR __First$[ebp]
  0004e	89 45 c0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00051	6a 0c		 push	 12			; 0000000cH
  00053	59		 pop	 ecx
  00054	8b 75 c0	 mov	 esi, DWORD PTR $T8[ebp]
  00057	8b 7d 74	 mov	 edi, DWORD PTR __Mid$[ebp]
  0005a	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005c	8d 45 34	 lea	 eax, DWORD PTR __Tmp$12[ebp]
  0005f	89 45 bc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00062	6a 0c		 push	 12			; 0000000cH
  00064	59		 pop	 ecx
  00065	8b 75 bc	 mov	 esi, DWORD PTR $T7[ebp]
  00068	8b 7d 70	 mov	 edi, DWORD PTR __First$[ebp]
  0006b	f3 a5		 rep movsd
$LN2@Med3_unche:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  0006d	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00070	8b 4d 74	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00073	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00076	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00079	73 09		 jae	 SHORT $LN26@Med3_unche
  0007b	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00082	eb 04		 jmp	 SHORT $LN24@Med3_unche
$LN26@Med3_unche:
  00084	83 65 cc 00	 and	 DWORD PTR tv67[ebp], 0
$LN24@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00088	0f b6 45 cc	 movzx	 eax, BYTE PTR tv67[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	0f 84 89 00 00
	00		 je	 $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00094	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00097	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0009a	6a 0c		 push	 12			; 0000000cH
  0009c	59		 pop	 ecx
  0009d	8b 75 b8	 mov	 esi, DWORD PTR $T6[ebp]
  000a0	8d 7d 04	 lea	 edi, DWORD PTR __Tmp$11[ebp]
  000a3	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a5	8b 45 74	 mov	 eax, DWORD PTR __Mid$[ebp]
  000a8	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000ab	6a 0c		 push	 12			; 0000000cH
  000ad	59		 pop	 ecx
  000ae	8b 75 b4	 mov	 esi, DWORD PTR $T5[ebp]
  000b1	8b 7d 78	 mov	 edi, DWORD PTR __Last$[ebp]
  000b4	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000b6	8d 45 04	 lea	 eax, DWORD PTR __Tmp$11[ebp]
  000b9	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000bc	6a 0c		 push	 12			; 0000000cH
  000be	59		 pop	 ecx
  000bf	8b 75 b0	 mov	 esi, DWORD PTR $T4[ebp]
  000c2	8b 7d 74	 mov	 edi, DWORD PTR __Mid$[ebp]
  000c5	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  000c7	8b 45 74	 mov	 eax, DWORD PTR __Mid$[ebp]
  000ca	8b 4d 70	 mov	 ecx, DWORD PTR __First$[ebp]
  000cd	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000d0	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000d3	73 09		 jae	 SHORT $LN44@Med3_unche
  000d5	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  000dc	eb 04		 jmp	 SHORT $LN42@Med3_unche
$LN44@Med3_unche:
  000de	83 65 c8 00	 and	 DWORD PTR tv75[ebp], 0
$LN42@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000e2	0f b6 45 c8	 movzx	 eax, BYTE PTR tv75[ebp]
  000e6	85 c0		 test	 eax, eax
  000e8	74 33		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ea	8b 45 74	 mov	 eax, DWORD PTR __Mid$[ebp]
  000ed	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000f0	6a 0c		 push	 12			; 0000000cH
  000f2	59		 pop	 ecx
  000f3	8b 75 ac	 mov	 esi, DWORD PTR $T3[ebp]
  000f6	8d 7d d4	 lea	 edi, DWORD PTR __Tmp$10[ebp]
  000f9	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000fb	8b 45 70	 mov	 eax, DWORD PTR __First$[ebp]
  000fe	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00101	6a 0c		 push	 12			; 0000000cH
  00103	59		 pop	 ecx
  00104	8b 75 a8	 mov	 esi, DWORD PTR $T2[ebp]
  00107	8b 7d 74	 mov	 edi, DWORD PTR __Mid$[ebp]
  0010a	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0010c	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0010f	89 45 a4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00112	6a 0c		 push	 12			; 0000000cH
  00114	59		 pop	 ecx
  00115	8b 75 a4	 mov	 esi, DWORD PTR $T1[ebp]
  00118	8b 7d 70	 mov	 edi, DWORD PTR __First$[ebp]
  0011b	f3 a5		 rep movsd
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00122	33 cd		 xor	 ecx, ebp
  00124	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00129	83 c5 68	 add	 ebp, 104		; 00000068H
  0012c	c9		 leave
  0012d	c3		 ret	 0
??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ENDP ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAUSObjectData@CArea@@PAU12@@std@@YAPAUSObjectData@CArea@@PAU12@00@Z
_TEXT	SEGMENT
__Dest_ch$ = -16					; size = 4
__Last_ch$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAUSObjectData@CArea@@PAU12@@std@@YAPAUSObjectData@CArea@@PAU12@00@Z PROC ; std::_Copy_backward_memmove<CArea::SObjectData *,CArea::SObjectData *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  00021	ff 75 f8	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	8b 45 f0	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002a	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  00036	c9		 leave
  00037	c3		 ret	 0
??$_Copy_backward_memmove@PAUSObjectData@CArea@@PAU12@@std@@YAPAUSObjectData@CArea@@PAU12@00@Z ENDP ; std::_Copy_backward_memmove<CArea::SObjectData *,CArea::SObjectData *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Tmp$1 = -72						; size = 8
__Tmp$2 = -64						; size = 8
__Tmp$3 = -56						; size = 8
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
$T9 = -28						; size = 4
$T10 = -24						; size = 4
$T11 = -20						; size = 4
$T12 = -16						; size = 4
tv75 = -12						; size = 4
tv67 = -8						; size = 4
tv91 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z PROC ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00012	76 09		 jbe	 SHORT $LN8@Med3_unche
  00014	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  0001b	eb 04		 jmp	 SHORT $LN6@Med3_unche
$LN8@Med3_unche:
  0001d	83 65 fc 00	 and	 DWORD PTR tv91[ebp], 0
$LN6@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00021	0f b6 45 fc	 movzx	 eax, BYTE PTR tv91[ebp]
  00025	85 c0		 test	 eax, eax
  00027	74 40		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0002c	89 45 f0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR $T12[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	89 4d c8	 mov	 DWORD PTR __Tmp$3[ebp], ecx
  0003a	89 45 cc	 mov	 DWORD PTR __Tmp$3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00043	8b 45 ec	 mov	 eax, DWORD PTR $T11[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004b	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  0004e	89 0a		 mov	 DWORD PTR [edx], ecx
  00050	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00053	8d 45 c8	 lea	 eax, DWORD PTR __Tmp$3[ebp]
  00056	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00059	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  0005c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00064	89 0a		 mov	 DWORD PTR [edx], ecx
  00066	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN2@Med3_unche:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00069	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  0006f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00072	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00075	76 09		 jbe	 SHORT $LN26@Med3_unche
  00077	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN24@Med3_unche
$LN26@Med3_unche:
  00080	83 65 f8 00	 and	 DWORD PTR tv67[ebp], 0
$LN24@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00084	0f b6 45 f8	 movzx	 eax, BYTE PTR tv67[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	0f 84 a3 00 00
	00		 je	 $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00090	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00093	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00096	8b 45 e4	 mov	 eax, DWORD PTR $T9[ebp]
  00099	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009e	89 4d c0	 mov	 DWORD PTR __Tmp$2[ebp], ecx
  000a1	89 45 c4	 mov	 DWORD PTR __Tmp$2[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a4	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000a7	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000aa	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	8b 55 10	 mov	 edx, DWORD PTR __Last$[ebp]
  000b5	89 0a		 mov	 DWORD PTR [edx], ecx
  000b7	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ba	8d 45 c0	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  000bd	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000c0	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  000c3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  000cb	89 0a		 mov	 DWORD PTR [edx], ecx
  000cd	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000d0	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000d3	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000d6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d9	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000dc	76 09		 jbe	 SHORT $LN44@Med3_unche
  000de	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  000e5	eb 04		 jmp	 SHORT $LN42@Med3_unche
$LN44@Med3_unche:
  000e7	83 65 f4 00	 and	 DWORD PTR tv75[ebp], 0
$LN42@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000eb	0f b6 45 f4	 movzx	 eax, BYTE PTR tv75[ebp]
  000ef	85 c0		 test	 eax, eax
  000f1	74 40		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000f3	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000f6	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000f9	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  000fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fe	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00101	89 4d b8	 mov	 DWORD PTR __Tmp$1[ebp], ecx
  00104	89 45 bc	 mov	 DWORD PTR __Tmp$1[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00107	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0010a	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0010d	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00110	8b 08		 mov	 ecx, DWORD PTR [eax]
  00112	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00115	8b 55 0c	 mov	 edx, DWORD PTR __Mid$[ebp]
  00118	89 0a		 mov	 DWORD PTR [edx], ecx
  0011a	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0011d	8d 45 b8	 lea	 eax, DWORD PTR __Tmp$1[ebp]
  00120	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00123	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  00126	8b 08		 mov	 ecx, DWORD PTR [eax]
  00128	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0012e	89 0a		 mov	 DWORD PTR [edx], ecx
  00130	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  00133	c9		 leave
  00134	c3		 ret	 0
??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ENDP ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z
_TEXT	SEGMENT
__Dest_ch$ = -16					; size = 4
__Last_ch$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z PROC ; std::_Copy_backward_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  00021	ff 75 f8	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	8b 45 f0	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002a	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  00036	c9		 leave
  00037	c3		 ret	 0
??$_Copy_backward_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ENDP ; std::_Copy_backward_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
__Tmp$2 = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
_pkLeft$ = -56						; size = 4
_pkRight$ = -52						; size = 4
$T5 = -48						; size = 4
__Tmp$6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
_pkLeft$ = -32						; size = 4
_pkRight$ = -28						; size = 4
$T9 = -24						; size = 4
__Tmp$10 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
_pkLeft$ = -8						; size = 4
_pkRight$ = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 45 fc	 mov	 DWORD PTR _pkRight$[ebp], eax
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00011	8b 00		 mov	 eax, DWORD PTR [eax]
  00013	89 45 f8	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00016	ff 75 fc	 push	 DWORD PTR _pkRight$[ebp]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  0001c	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 2e		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0002e	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	89 45 ec	 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00036	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00039	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR $T11[ebp]
  00042	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00044	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00046	8d 45 ec	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  00049	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0004c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004f	8b 4d e8	 mov	 ecx, DWORD PTR $T9[ebp]
  00052	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00056	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	89 45 e4	 mov	 DWORD PTR _pkRight$[ebp], eax
  0005e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 e0	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00066	ff 75 e4	 push	 DWORD PTR _pkRight$[ebp]
  00069	8b 4d e0	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  0006c	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00071	0f b6 c0	 movzx	 eax, al
  00074	85 c0		 test	 eax, eax
  00076	74 7e		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00078	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0007b	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0007e	8b 45 dc	 mov	 eax, DWORD PTR $T8[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 45 d4	 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00086	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00089	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0008c	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0008f	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
  00092	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00094	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00096	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  00099	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0009c	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  0009f	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  000a2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a4	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000a6	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000a9	8b 00		 mov	 eax, DWORD PTR [eax]
  000ab	89 45 cc	 mov	 DWORD PTR _pkRight$[ebp], eax
  000ae	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 45 c8	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  000b6	ff 75 cc	 push	 DWORD PTR _pkRight$[ebp]
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  000bc	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000c1	0f b6 c0	 movzx	 eax, al
  000c4	85 c0		 test	 eax, eax
  000c6	74 2e		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000c8	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000cb	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000ce	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	89 45 bc	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000d6	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000d9	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000dc	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000df	8b 4d c0	 mov	 ecx, DWORD PTR $T3[ebp]
  000e2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e4	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000e6	8d 45 bc	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  000e9	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000ec	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ef	8b 4d b8	 mov	 ecx, DWORD PTR $T1[ebp]
  000f2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000f4	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  000f6	c9		 leave
  000f7	c3		 ret	 0
??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_pkLeft$ = -12						; size = 4
_pkRight$ = -8						; size = 4
__Idx$3 = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Push_heap_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 6073 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6074 :     // percolate _Hole to _Top or where _Val belongs
; 6075 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	48		 dec	 eax
  0000a	d1 f8		 sar	 eax, 1
  0000c	89 45 fc	 mov	 DWORD PTR __Idx$3[ebp], eax
  0000f	eb 09		 jmp	 SHORT $LN4@Push_heap_
$LN2@Push_heap_:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00014	48		 dec	 eax
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR __Idx$3[ebp], eax
$LN4@Push_heap_:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  0001a	8b 45 10	 mov	 eax, DWORD PTR __Top$[ebp]
  0001d	3b 45 0c	 cmp	 eax, DWORD PTR __Hole$[ebp]
  00020	7d 48		 jge	 SHORT $LN3@Push_heap_
  00022	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	89 45 f8	 mov	 DWORD PTR _pkRight$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR __Idx$3[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00030	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00033	89 45 f4	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00036	ff 75 f8	 push	 DWORD PTR _pkRight$[ebp]
  00039	8b 4d f4	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  0003c	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	74 22		 je	 SHORT $LN3@Push_heap_

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00048	8b 45 fc	 mov	 eax, DWORD PTR __Idx$3[ebp]
  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00051	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00054	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00057	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0005a	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp]
  0005d	8b 12		 mov	 edx, DWORD PTR [edx]
  0005f	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6081 :         _Hole             = _Idx;

  00062	8b 45 fc	 mov	 eax, DWORD PTR __Idx$3[ebp]
  00065	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  00068	eb a7		 jmp	 SHORT $LN2@Push_heap_
$LN3@Push_heap_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006a	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0006d	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00070	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00073	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00076	8b 55 ec	 mov	 edx, DWORD PTR $T1[ebp]
  00079	8b 12		 mov	 edx, DWORD PTR [edx]
  0007b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6085 : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Push_heap_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Push_heap_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Dest_ch$ = -16					; size = 4
__Last_ch$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z PROC ; std::_Copy_backward_memmove<CEffectInstance * *,CEffectInstance * *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  00021	ff 75 f8	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	8b 45 f0	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002a	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  00036	c9		 leave
  00037	c3		 ret	 0
??$_Copy_backward_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ENDP ; std::_Copy_backward_memmove<CEffectInstance * *,CEffectInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\locale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\locale
;	COMDAT ??$tolower@D@std@@YADDABVlocale@0@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
__Loc$ = 12						; size = 4
??$tolower@D@std@@YADDABVlocale@0@@Z PROC		; std::tolower<char>, COMDAT

; 243  : _Elem(tolower)(_Elem _Ch, const locale& _Loc) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 244  :     return _STD use_facet<ctype<_Elem>>(_Loc).tolower(_Ch);

  00004	ff 75 0c	 push	 DWORD PTR __Loc$[ebp]
  00007	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0000c	59		 pop	 ecx
  0000d	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2648 :         return do_tolower(_Ch);

  00010	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	ff 50 10	 call	 DWORD PTR [eax+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\locale

; 245  : }

  0001e	c9		 leave
  0001f	c3		 ret	 0
??$tolower@D@std@@YADDABVlocale@0@@Z ENDP		; std::tolower<char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
;	COMDAT ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$1 = -36						; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
_this$4 = -16						; size = 4
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 1
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>, COMDAT
; _this$ = ecx

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0000e	33 c0		 xor	 eax, eax
  00010	88 45 fe	 mov	 BYTE PTR $T5[ebp], al
  00013	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  00016	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  00019	8a 45 fe	 mov	 al, BYTE PTR $T5[ebp]
  0001c	88 45 f4	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001f	8d 45 0c	 lea	 eax, DWORD PTR __Val1$[ebp]
  00022	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 790  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

  00025	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 980  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

  0002d	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 18	 add	 eax, 24			; 00000018H
  0003e	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00041	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 dc	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00047	8b 45 dc	 mov	 eax, DWORD PTR _this$1[ebp]
  0004a	89 45 f0	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  00050	83 20 00	 and	 DWORD PTR [eax], 0
  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  00056	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$4[ebp]
  0005d	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00064	c9		 leave
  00065	c2 0c 00	 ret	 12			; 0000000cH
??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z PROC ; std::_Guess_median_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	99		 cdq
  0000d	6a 30		 push	 48			; 00000030H
  0000f	59		 pop	 ecx
  00010	f7 f9		 idiv	 ecx
  00012	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00015	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00019	0f 8e 94 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	40		 inc	 eax
  00023	c1 f8 03	 sar	 eax, 3
  00026	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0002c	d1 e0		 shl	 eax, 1
  0002e	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00031	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00034	6b 45 f4 30	 imul	 eax, DWORD PTR __Two_step$1[ebp], 48
  00038	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  0003b	50		 push	 eax
  0003c	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  00040	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00043	50		 push	 eax
  00044	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00047	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0004f	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00052	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  00056	03 45 0c	 add	 eax, DWORD PTR __Mid$[ebp]
  00059	50		 push	 eax
  0005a	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0005d	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00064	2b c8		 sub	 ecx, eax
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0006f	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00072	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00075	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  00079	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0007c	2b c8		 sub	 ecx, eax
  0007e	51		 push	 ecx
  0007f	6b 45 f4 30	 imul	 eax, DWORD PTR __Two_step$1[ebp], 48
  00083	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00086	2b c8		 sub	 ecx, eax
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  00091	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00094	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  00098	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0009b	2b c8		 sub	 ecx, eax
  0009d	51		 push	 ecx
  0009e	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000a1	6b 45 fc 30	 imul	 eax, DWORD PTR __Step$2[ebp], 48
  000a5	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  000ae	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000b1	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000b3	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b6	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000b9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000bc	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bf	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Med3_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000c7	c9		 leave
  000c8	c3		 ret	 0
??$_Guess_median_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ENDP ; std::_Guess_median_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
__Val$5 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z PROC ; std::_Pop_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00012	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00015	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00018	99		 cdq
  00019	6a 30		 push	 48			; 00000030H
  0001b	59		 pop	 ecx
  0001c	f7 f9		 idiv	 ecx
  0001e	83 f8 02	 cmp	 eax, 2
  00021	7c 57		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00023	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00026	83 e8 30	 sub	 eax, 48			; 00000030H
  00029	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002f	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00032	6a 0c		 push	 12			; 0000000cH
  00034	59		 pop	 ecx
  00035	8b 75 c8	 mov	 esi, DWORD PTR $T4[ebp]
  00038	8d 7d cc	 lea	 edi, DWORD PTR __Val$5[ebp]
  0003b	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003d	8d 45 cc	 lea	 eax, DWORD PTR __Val$5[ebp]
  00040	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  00043	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00046	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6219 :     *_Dest      = _STD move(*_First);

  00049	6a 0c		 push	 12			; 0000000cH
  0004b	59		 pop	 ecx
  0004c	8b 75 c4	 mov	 esi, DWORD PTR $T3[ebp]
  0004f	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  00052	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00054	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00057	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  0005a	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0005d	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  00060	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00063	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00066	99		 cdq
  00067	6a 30		 push	 48			; 00000030H
  00069	59		 pop	 ecx
  0006a	f7 f9		 idiv	 ecx
  0006c	50		 push	 eax
  0006d	6a 00		 push	 0
  0006f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00072	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SObjectData *,CArea::SObjectData,CArea::ObjectDataComp>
  00077	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Pop_heap_u:

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }
; 6233 : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007f	33 cd		 xor	 ecx, ebp
  00081	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00086	c9		 leave
  00087	c3		 ret	 0
??$_Pop_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ENDP ; std::_Pop_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
__Top$ = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
tv166 = -28						; size = 4
__Max_sequence_non_leaf$ = -24				; size = 4
tv142 = -20						; size = 4
__Idx$6 = -16						; size = 4
__Hole$ = -12						; size = 4
__Idx$ = -8						; size = 4
__Pred$ = -4						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z PROC ; std::_Pop_heap_hole_by_index<CArea::SObjectData *,CArea::SObjectData,CArea::ObjectDataComp>, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000b	89 45 d4	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00014	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00017	48		 dec	 eax
  00018	d1 f8		 sar	 eax, 1
  0001a	89 45 e8	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00020	3b 45 e8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00023	7d 62		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00025	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00028	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002c	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  0002f	6b 45 f8 30	 imul	 eax, DWORD PTR __Idx$[ebp], 48
  00033	8b 4d f8	 mov	 ecx, DWORD PTR __Idx$[ebp]
  00036	49		 dec	 ecx
  00037	6b c9 30	 imul	 ecx, ecx, 48
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  0003a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003d	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00040	8b 44 02 0c	 mov	 eax, DWORD PTR [edx+eax+12]
  00044	3b 44 0e 0c	 cmp	 eax, DWORD PTR [esi+ecx+12]
  00048	73 09		 jae	 SHORT $LN9@Pop_heap_h
  0004a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  00051	eb 04		 jmp	 SHORT $LN7@Pop_heap_h
$LN9@Pop_heap_h:
  00053	83 65 ec 00	 and	 DWORD PTR tv142[ebp], 0
$LN7@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00057	0f b6 45 ec	 movzx	 eax, BYTE PTR tv142[ebp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00062	48		 dec	 eax
  00063	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00066	6b 45 f8 30	 imul	 eax, DWORD PTR __Idx$[ebp], 48
  0006a	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0006d	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00070	6b 7d 0c 30	 imul	 edi, DWORD PTR __Hole$[ebp], 48
  00074	03 7d 08	 add	 edi, DWORD PTR __First$[ebp]
  00077	6a 0c		 push	 12			; 0000000cH
  00079	59		 pop	 ecx
  0007a	8b 75 dc	 mov	 esi, DWORD PTR $T4[ebp]
  0007d	f3 a5		 rep movsd

; 6203 :         _Hole             = _Idx;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00082	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  00085	eb 96		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00087	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0008a	3b 45 e8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0008d	75 36		 jne	 SHORT $LN5@Pop_heap_h
  0008f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00092	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00097	79 05		 jns	 SHORT $LN35@Pop_heap_h
  00099	48		 dec	 eax
  0009a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009d	40		 inc	 eax
$LN35@Pop_heap_h:
  0009e	85 c0		 test	 eax, eax
  000a0	75 23		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a2	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a5	48		 dec	 eax
  000a6	6b c0 30	 imul	 eax, eax, 48
  000a9	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ac	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000af	6b 7d 0c 30	 imul	 edi, DWORD PTR __Hole$[ebp], 48
  000b3	03 7d 08	 add	 edi, DWORD PTR __First$[ebp]
  000b6	6a 0c		 push	 12			; 0000000cH
  000b8	59		 pop	 ecx
  000b9	8b 75 d8	 mov	 esi, DWORD PTR $T3[ebp]
  000bc	f3 a5		 rep movsd

; 6208 :         _Hole             = _Bottom - 1;

  000be	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000c1	48		 dec	 eax
  000c2	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c5	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000c8	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000cb	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  000ce	88 45 fc	 mov	 BYTE PTR __Pred$[ebp], al
  000d1	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d4	89 45 f4	 mov	 DWORD PTR __Hole$[ebp], eax

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000d7	8b 45 f4	 mov	 eax, DWORD PTR __Hole$[ebp]
  000da	48		 dec	 eax
  000db	d1 f8		 sar	 eax, 1
  000dd	89 45 f0	 mov	 DWORD PTR __Idx$6[ebp], eax
  000e0	eb 09		 jmp	 SHORT $LN23@Pop_heap_h
$LN21@Pop_heap_h:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Hole$[ebp]
  000e5	48		 dec	 eax
  000e6	d1 f8		 sar	 eax, 1
  000e8	89 45 f0	 mov	 DWORD PTR __Idx$6[ebp], eax
$LN23@Pop_heap_h:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000eb	8b 45 d4	 mov	 eax, DWORD PTR __Top$[ebp]
  000ee	3b 45 f4	 cmp	 eax, DWORD PTR __Hole$[ebp]
  000f1	7d 49		 jge	 SHORT $LN22@Pop_heap_h
  000f3	6b 45 f0 30	 imul	 eax, DWORD PTR __Idx$6[ebp], 48
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  000f7	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000fa	8b 55 e0	 mov	 edx, DWORD PTR $T5[ebp]
  000fd	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00101	3b 42 0c	 cmp	 eax, DWORD PTR [edx+12]
  00104	73 09		 jae	 SHORT $LN27@Pop_heap_h
  00106	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  0010d	eb 04		 jmp	 SHORT $LN25@Pop_heap_h
$LN27@Pop_heap_h:
  0010f	83 65 e4 00	 and	 DWORD PTR tv166[ebp], 0
$LN25@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00113	0f b6 45 e4	 movzx	 eax, BYTE PTR tv166[ebp]
  00117	85 c0		 test	 eax, eax
  00119	74 21		 je	 SHORT $LN22@Pop_heap_h

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0011b	6b 45 f0 30	 imul	 eax, DWORD PTR __Idx$6[ebp], 48
  0011f	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00122	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00125	6b 7d f4 30	 imul	 edi, DWORD PTR __Hole$[ebp], 48
  00129	03 7d 08	 add	 edi, DWORD PTR __First$[ebp]
  0012c	6a 0c		 push	 12			; 0000000cH
  0012e	59		 pop	 ecx
  0012f	8b 75 d0	 mov	 esi, DWORD PTR $T2[ebp]
  00132	f3 a5		 rep movsd

; 6081 :         _Hole             = _Idx;

  00134	8b 45 f0	 mov	 eax, DWORD PTR __Idx$6[ebp]
  00137	89 45 f4	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  0013a	eb a6		 jmp	 SHORT $LN21@Pop_heap_h
$LN22@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0013f	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00142	6b 7d f4 30	 imul	 edi, DWORD PTR __Hole$[ebp], 48
  00146	03 7d 08	 add	 edi, DWORD PTR __First$[ebp]
  00149	6a 0c		 push	 12			; 0000000cH
  0014b	59		 pop	 ecx
  0014c	8b 75 cc	 mov	 esi, DWORD PTR $T1[ebp]
  0014f	f3 a5		 rep movsd

; 6212 : }

  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	c9		 leave
  00154	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z ENDP ; std::_Pop_heap_hole_by_index<CArea::SObjectData *,CArea::SObjectData,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z PROC ; std::_Guess_median_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 03	 sar	 eax, 3
  0000f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00012	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00016	0f 8e a4 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	40		 inc	 eax
  00020	c1 f8 03	 sar	 eax, 3
  00023	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00029	d1 e0		 shl	 eax, 1
  0002b	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0002e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00031	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00037	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0003a	50		 push	 eax
  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00041	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00044	50		 push	 eax
  00045	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00050	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00053	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00059	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0005c	50		 push	 eax
  0005d	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00063	c1 e0 03	 shl	 eax, 3
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00069	2b c8		 sub	 ecx, eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00074	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0007d	c1 e0 03	 shl	 eax, 3
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00083	2b c8		 sub	 ecx, eax
  00085	51		 push	 ecx
  00086	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00089	c1 e0 03	 shl	 eax, 3
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0008f	2b c8		 sub	 ecx, eax
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0009a	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000a0	c1 e0 03	 shl	 eax, 3
  000a3	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b c8		 sub	 ecx, eax
  000a8	51		 push	 ecx
  000a9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b2	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000be	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000c0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c3	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000c6	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000c9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Med3_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000d4	c9		 leave
  000d5	c3		 ret	 0
??$_Guess_median_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ENDP ; std::_Guess_median_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 8
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::_Pop_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 03	 sar	 eax, 3
  0000f	83 f8 02	 cmp	 eax, 2
  00012	7c 5c		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 e8 08	 sub	 eax, 8
  0001a	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00023	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002b	89 4d e8	 mov	 DWORD PTR __Val$1[ebp], ecx
  0002e	89 45 ec	 mov	 DWORD PTR __Val$1[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00031	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00034	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  00037	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6219 :     *_Dest      = _STD move(*_First);

  0003d	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	8b 08		 mov	 ecx, DWORD PTR [eax]
  00042	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00045	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00048	89 0a		 mov	 DWORD PTR [edx], ecx
  0004a	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0004d	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00050	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  00053	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00056	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  00059	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0005c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0005f	c1 f8 03	 sar	 eax, 3
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00068	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Pop_heap_u:

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }
; 6233 : }

  00070	c9		 leave
  00071	c3		 ret	 0
??$_Pop_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::_Pop_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
__Top$ = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
tv166 = -28						; size = 4
__Max_sequence_non_leaf$ = -24				; size = 4
tv142 = -20						; size = 4
__Idx$6 = -16						; size = 4
__Hole$ = -12						; size = 4
__Idx$ = -8						; size = 4
__Pred$ = -4						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z PROC ; std::_Pop_heap_hole_by_index<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000a	89 45 d4	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00010	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00013	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00016	48		 dec	 eax
  00017	d1 f8		 sar	 eax, 1
  00019	89 45 e8	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001f	3b 45 e8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00022	7d 65		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00024	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00027	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002b	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00034	8b 55 f8	 mov	 edx, DWORD PTR __Idx$[ebp]
  00037	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0003a	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  0003e	3b 44 d6 fc	 cmp	 eax, DWORD PTR [esi+edx*8-4]
  00042	76 09		 jbe	 SHORT $LN9@Pop_heap_h
  00044	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv142[ebp], 1
  0004b	eb 04		 jmp	 SHORT $LN7@Pop_heap_h
$LN9@Pop_heap_h:
  0004d	83 65 ec 00	 and	 DWORD PTR tv142[ebp], 0
$LN7@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00051	0f b6 45 ec	 movzx	 eax, BYTE PTR tv142[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0005c	48		 dec	 eax
  0005d	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00060	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00063	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00066	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00069	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0006c	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00074	8b 55 0c	 mov	 edx, DWORD PTR __Hole$[ebp]
  00077	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0007a	89 0c d6	 mov	 DWORD PTR [esi+edx*8], ecx
  0007d	89 44 d6 04	 mov	 DWORD PTR [esi+edx*8+4], eax

; 6203 :         _Hole             = _Idx;

  00081	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00084	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  00087	eb 93		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00089	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0008c	3b 45 e8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0008f	75 3c		 jne	 SHORT $LN5@Pop_heap_h
  00091	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00094	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00099	79 05		 jns	 SHORT $LN35@Pop_heap_h
  0009b	48		 dec	 eax
  0009c	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009f	40		 inc	 eax
$LN35@Pop_heap_h:
  000a0	85 c0		 test	 eax, eax
  000a2	75 29		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a4	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000aa	8d 44 c1 f8	 lea	 eax, DWORD PTR [ecx+eax*8-8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ae	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000b1	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b9	8b 55 0c	 mov	 edx, DWORD PTR __Hole$[ebp]
  000bc	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  000bf	89 0c d6	 mov	 DWORD PTR [esi+edx*8], ecx
  000c2	89 44 d6 04	 mov	 DWORD PTR [esi+edx*8+4], eax

; 6208 :         _Hole             = _Bottom - 1;

  000c6	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000c9	48		 dec	 eax
  000ca	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000cd	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000d0	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000d3	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  000d6	88 45 fc	 mov	 BYTE PTR __Pred$[ebp], al
  000d9	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000dc	89 45 f4	 mov	 DWORD PTR __Hole$[ebp], eax

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000df	8b 45 f4	 mov	 eax, DWORD PTR __Hole$[ebp]
  000e2	48		 dec	 eax
  000e3	d1 f8		 sar	 eax, 1
  000e5	89 45 f0	 mov	 DWORD PTR __Idx$6[ebp], eax
  000e8	eb 09		 jmp	 SHORT $LN23@Pop_heap_h
$LN21@Pop_heap_h:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000ea	8b 45 f4	 mov	 eax, DWORD PTR __Hole$[ebp]
  000ed	48		 dec	 eax
  000ee	d1 f8		 sar	 eax, 1
  000f0	89 45 f0	 mov	 DWORD PTR __Idx$6[ebp], eax
$LN23@Pop_heap_h:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000f3	8b 45 d4	 mov	 eax, DWORD PTR __Top$[ebp]
  000f6	3b 45 f4	 cmp	 eax, DWORD PTR __Hole$[ebp]
  000f9	7d 50		 jge	 SHORT $LN22@Pop_heap_h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000fb	8b 45 f0	 mov	 eax, DWORD PTR __Idx$6[ebp]
  000fe	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00101	8b 55 e0	 mov	 edx, DWORD PTR $T5[ebp]
  00104	8b 44 c1 04	 mov	 eax, DWORD PTR [ecx+eax*8+4]
  00108	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  0010b	76 09		 jbe	 SHORT $LN27@Pop_heap_h
  0010d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  00114	eb 04		 jmp	 SHORT $LN25@Pop_heap_h
$LN27@Pop_heap_h:
  00116	83 65 e4 00	 and	 DWORD PTR tv166[ebp], 0
$LN25@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  0011a	0f b6 45 e4	 movzx	 eax, BYTE PTR tv166[ebp]
  0011e	85 c0		 test	 eax, eax
  00120	74 29		 je	 SHORT $LN22@Pop_heap_h

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00122	8b 45 f0	 mov	 eax, DWORD PTR __Idx$6[ebp]
  00125	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00128	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0012b	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0012e	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00131	8b 08		 mov	 ecx, DWORD PTR [eax]
  00133	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00136	8b 55 f4	 mov	 edx, DWORD PTR __Hole$[ebp]
  00139	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0013c	89 0c d6	 mov	 DWORD PTR [esi+edx*8], ecx
  0013f	89 44 d6 04	 mov	 DWORD PTR [esi+edx*8+4], eax

; 6081 :         _Hole             = _Idx;

  00143	8b 45 f0	 mov	 eax, DWORD PTR __Idx$6[ebp]
  00146	89 45 f4	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  00149	eb 9f		 jmp	 SHORT $LN21@Pop_heap_h
$LN22@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0014b	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0014e	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00151	8b 45 cc	 mov	 eax, DWORD PTR $T1[ebp]
  00154	8b 08		 mov	 ecx, DWORD PTR [eax]
  00156	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00159	8b 55 f4	 mov	 edx, DWORD PTR __Hole$[ebp]
  0015c	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0015f	89 0c d6	 mov	 DWORD PTR [esi+edx*8], ecx
  00162	89 44 d6 04	 mov	 DWORD PTR [esi+edx*8+4], eax

; 6212 : }

  00166	5e		 pop	 esi
  00167	c9		 leave
  00168	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ENDP ; std::_Pop_heap_hole_by_index<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Guess_median_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00012	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00016	0f 8e a4 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	40		 inc	 eax
  00020	c1 f8 03	 sar	 eax, 3
  00023	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00029	d1 e0		 shl	 eax, 1
  0002b	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0002e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00031	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00037	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0003a	50		 push	 eax
  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00041	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00044	50		 push	 eax
  00045	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00050	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00053	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00059	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0005c	50		 push	 eax
  0005d	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00063	c1 e0 02	 shl	 eax, 2
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00069	2b c8		 sub	 ecx, eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00074	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0007d	c1 e0 02	 shl	 eax, 2
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00083	2b c8		 sub	 ecx, eax
  00085	51		 push	 ecx
  00086	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00089	c1 e0 02	 shl	 eax, 2
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0008f	2b c8		 sub	 ecx, eax
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0009a	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000a0	c1 e0 02	 shl	 eax, 2
  000a3	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b c8		 sub	 ecx, eax
  000a8	51		 push	 ecx
  000a9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b2	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000be	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000c0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c3	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000c6	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000c9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Med3_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000d4	c9		 leave
  000d5	c3		 ret	 0
??$_Guess_median_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Guess_median_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Val$4 = -8						; size = 4
$T5 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Pop_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 02	 cmp	 eax, 2
  00012	7c 50		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00023	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f8	 mov	 DWORD PTR __Val$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Val$4[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00031	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6219 :     *_Dest      = _STD move(*_First);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00041	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00044	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  00047	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0004a	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00050	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00053	c1 f8 02	 sar	 eax, 2
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Pop_heap_hole_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
  00061	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Pop_heap_u:

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }
; 6233 : }

  00064	c9		 leave
  00065	c3		 ret	 0
??$_Pop_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Pop_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Top$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_pkLeft$ = -16						; size = 4
_pkRight$ = -12						; size = 4
__Max_sequence_non_leaf$ = -8				; size = 4
__Idx$ = -4						; size = 4
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Pop_heap_hole_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	89 45 e0	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00012	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	48		 dec	 eax
  00016	d1 f8		 sar	 eax, 1
  00018	89 45 f8	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001e	3b 45 f8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00021	7d 5e		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00023	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  00026	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002a	89 45 fc	 mov	 DWORD PTR __Idx$[ebp], eax

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00033	8b 44 81 fc	 mov	 eax, DWORD PTR [ecx+eax*4-4]
  00037	89 45 f4	 mov	 DWORD PTR _pkRight$[ebp], eax
  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00040	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00043	89 45 f0	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00046	ff 75 f4	 push	 DWORD PTR _pkRight$[ebp]
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  0004c	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  00058	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  0005b	48		 dec	 eax
  0005c	89 45 fc	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0005f	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  00062	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00065	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00068	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0006b	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00071	8b 55 ec	 mov	 edx, DWORD PTR $T3[ebp]
  00074	8b 12		 mov	 edx, DWORD PTR [edx]
  00076	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6203 :         _Hole             = _Idx;

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  0007c	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  0007f	eb 9a		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Idx$[ebp]
  00084	3b 45 f8	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00087	75 35		 jne	 SHORT $LN5@Pop_heap_h
  00089	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0008c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00091	79 05		 jns	 SHORT $LN31@Pop_heap_h
  00093	48		 dec	 eax
  00094	83 c8 fe	 or	 eax, -2			; fffffffeH
  00097	40		 inc	 eax
$LN31@Pop_heap_h:
  00098	85 c0		 test	 eax, eax
  0009a	75 22		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  0009c	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0009f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000a2	8d 44 81 fc	 lea	 eax, DWORD PTR [ecx+eax*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a6	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a9	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000ac	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000af	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp]
  000b2	8b 12		 mov	 edx, DWORD PTR [edx]
  000b4	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6208 :         _Hole             = _Bottom - 1;

  000b7	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000ba	48		 dec	 eax
  000bb	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000be	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000c1	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000c4	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  000c7	ff 75 e4	 push	 DWORD PTR $T1[ebp]
  000ca	ff 75 e0	 push	 DWORD PTR __Top$[ebp]
  000cd	ff 75 0c	 push	 DWORD PTR __Hole$[ebp]
  000d0	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000d3	e8 00 00 00 00	 call	 ??$_Push_heap_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Push_heap_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
  000d8	83 c4 14	 add	 esp, 20			; 00000014H

; 6212 : }

  000db	c9		 leave
  000dc	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Pop_heap_hole_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4586 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4587 :     return _Left.compare(_Right) < 0;

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  0000f	85 c0		 test	 eax, eax
  00011	7d 09		 jge	 SHORT $LN3@operator
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001a	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001c	83 65 fc 00	 and	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  00020	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 4588 : }

  00023	c9		 leave
  00024	c3		 ret	 0
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAUSCRCWithNumber@CArea@@$0A@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAUSCRCWithNumber@CArea@@$0A@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z PROC ; std::_Refancy<CArea::SCRCWithNumber *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAUSCRCWithNumber@CArea@@$0A@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ENDP ; std::_Refancy<CArea::SCRCWithNumber *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUSObjectInstance@CArea@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAUSObjectInstance@CArea@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0@Z PROC ; std::_Zero_range<CArea::SObjectInstance * *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAPAUSObjectInstance@CArea@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0@Z ENDP ; std::_Zero_range<CArea::SObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSObjectInstance@CArea@@PAPAU12@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSObjectInstance@CArea@@PAPAU12@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CArea::SObjectInstance * *,CArea::SObjectInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAUSObjectInstance@CArea@@PAPAU12@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CArea::SObjectInstance * *,CArea::SObjectInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicThingInstance * *,CGraphicThingInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicThingInstance * *,CGraphicThingInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCDungeonBlock@@PAPAV1@@std@@YAPAPAVCDungeonBlock@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCDungeonBlock@@PAPAV1@@std@@YAPAPAVCDungeonBlock@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CDungeonBlock * *,CDungeonBlock * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCDungeonBlock@@PAPAV1@@std@@YAPAPAVCDungeonBlock@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CDungeonBlock * *,CDungeonBlock * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSAmbienceInstance@CArea@@PAPAU12@@std@@YAPAPAUSAmbienceInstance@CArea@@PAPAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSAmbienceInstance@CArea@@PAPAU12@@std@@YAPAPAUSAmbienceInstance@CArea@@PAPAU12@00@Z PROC ; std::_Copy_memmove<CArea::SAmbienceInstance * *,CArea::SAmbienceInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAUSAmbienceInstance@CArea@@PAPAU12@@std@@YAPAPAUSAmbienceInstance@CArea@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<CArea::SAmbienceInstance * *,CArea::SAmbienceInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z PROC ; std::_Copy_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ENDP ; std::_Copy_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CArea * *,CArea * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CEffectInstance * *,CEffectInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CEffectInstance * *,CEffectInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT

; 700  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000c	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00012	51		 push	 ecx
  00013	89 65 e8	 mov	 DWORD PTR _this$[ebp], esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00016	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00019	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001c	51		 push	 ecx
  0001d	89 65 f8	 mov	 DWORD PTR _this$[ebp], esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T4[ebp]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002a	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00030	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00033	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00036	50		 push	 eax
  00037	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$Z$$V@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAE@Upiecewise_construct_t@1@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@Z ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > ><std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>

; 702  :     }

  0003f	c9		 leave
  00040	c3		 ret	 0
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > ><CArea::SObjectInstance * const &>, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Allocate

; 786  :     }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 c0 10	 add	 eax, 16			; 00000010H
  00056	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00067	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0006a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00070	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00073	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00076	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0007d	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00080	50		 push	 eax
  00081	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00084	ff 70 04	 push	 DWORD PTR [eax+4]
  00087	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>
  0008c	59		 pop	 ecx
  0008d	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0008e	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00091	50		 push	 eax
  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00098	83 c0 04	 add	 eax, 4
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>
  000a1	59		 pop	 ecx
  000a2	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000a3	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000a6	50		 push	 eax
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	83 c0 08	 add	 eax, 8
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * &>
  000b6	59		 pop	 ecx
  000b7	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000b8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000be	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	c9		 leave
  000db	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > ><CArea::SObjectInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 14	 imul	 eax, eax, 20
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 14	 imul	 eax, eax, 20
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int const &>, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate

; 786  :     }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 c0 10	 add	 eax, 16			; 00000010H
  00056	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00067	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0006a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00070	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00073	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00076	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00079	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0007b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  0007d	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00080	50		 push	 eax
  00081	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00084	ff 70 04	 push	 DWORD PTR [eax+4]
  00087	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
  0008c	59		 pop	 ecx
  0008d	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  0008e	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00091	50		 push	 eax
  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00098	83 c0 04	 add	 eax, 4
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
  000a1	59		 pop	 ecx
  000a2	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000a3	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000a6	50		 push	 eax
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ad	83 c0 08	 add	 eax, 8
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * &>
  000b6	59		 pop	 ecx
  000b7	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000b8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000be	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	c9		 leave
  000db	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 14	 imul	 eax, eax, 20
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 14	 imul	 eax, eax, 20
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<int,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@U?$to_lowerF@D@detail@algorithm@boost@@@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@U?$to_lowerF@D@detail@algorithm@boost@@@Z
_TEXT	SEGMENT
__COff$1 = -64						; size = 4
__It$ = -60						; size = 4
_Ch$ = -56						; size = 1
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Ptr$4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
__Ptr$8 = -28						; size = 4
$T9 = -24						; size = 4
$T10 = -20						; size = 4
__Ptr$11 = -16						; size = 4
__ULast$ = -12						; size = 4
__UDest$ = -8						; size = 4
__UFirst$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
__Func$ = 24						; size = 4
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@U?$to_lowerF@D@detail@algorithm@boost@@@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@U?$to_lowerF@D@detail@algorithm@boost@@@Z PROC ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,boost::algorithm::detail::to_lowerF<char> >, COMDAT

; 3426 : _CONSTEXPR20 _OutIt transform(const _InIt _First, const _InIt _Last, _OutIt _Dest, _Fn _Func) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR __Ptr$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$11[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  00012	8b 45 ec	 mov	 eax, DWORD PTR $T10[ebp]
  00015	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 3429 :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 e4	 mov	 DWORD PTR __Ptr$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$8[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  0002a	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  0002d	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 3430 :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00033	89 45 f4	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1557 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __ULast$[ebp]
  00039	2b 45 fc	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0003c	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax

; 1413 :         const auto _COff = static_cast<_CDiff>(_Off);

  0003f	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00042	89 45 c0	 mov	 DWORD PTR __COff$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	89 45 d4	 mov	 DWORD PTR __Ptr$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004b	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  0004e	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2134 :         return const_cast<value_type*>(_Unfancy(this->_Ptr));

  00051	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00054	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 3431 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  00057	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 f8	 mov	 DWORD PTR __UDest$[ebp], eax

; 3432 :     for (; _UFirst != _ULast; ++_UFirst, (void) ++_UDest) {

  0005d	eb 0e		 jmp	 SHORT $LN4@transform
$LN2@transform:
  0005f	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00062	40		 inc	 eax
  00063	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
  00066	8b 45 f8	 mov	 eax, DWORD PTR __UDest$[ebp]
  00069	40		 inc	 eax
  0006a	89 45 f8	 mov	 DWORD PTR __UDest$[ebp], eax
$LN4@transform:
  0006d	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00070	3b 45 f4	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00073	74 1c		 je	 SHORT $LN3@transform

; 3433 :         *_UDest = _Func(*_UFirst);

  00075	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00078	8a 00		 mov	 al, BYTE PTR [eax]
  0007a	88 45 c8	 mov	 BYTE PTR _Ch$[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp

; 46   :                         return std::tolower<CharT>( Ch, *m_Loc );

  0007d	ff 75 18	 push	 DWORD PTR __Func$[ebp]
  00080	ff 75 c8	 push	 DWORD PTR _Ch$[ebp]
  00083	e8 00 00 00 00	 call	 ??$tolower@D@std@@YADDABVlocale@0@@Z ; std::tolower<char>
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 3433 :         *_UDest = _Func(*_UFirst);

  0008a	8b 4d f8	 mov	 ecx, DWORD PTR __UDest$[ebp]
  0008d	88 01		 mov	 BYTE PTR [ecx], al

; 3434 :     }

  0008f	eb ce		 jmp	 SHORT $LN2@transform
$LN3@transform:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00091	8b 45 f8	 mov	 eax, DWORD PTR __UDest$[ebp]
  00094	89 45 c4	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2015 :         _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));

  00097	ff 75 c4	 push	 DWORD PTR __It$[ebp]
  0009a	e8 00 00 00 00	 call	 ??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z ; std::_Refancy<char const *,0>
  0009f	59		 pop	 ecx
  000a0	89 45 14	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 3437 :     return _Dest;

  000a3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a6	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a9	89 08		 mov	 DWORD PTR [eax], ecx
  000ab	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3438 : }

  000ae	c9		 leave
  000af	c3		 ret	 0
??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@U?$to_lowerF@D@detail@algorithm@boost@@@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@U?$to_lowerF@D@detail@algorithm@boost@@@Z ENDP ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,boost::algorithm::detail::to_lowerF<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > ><std::pair<unsigned long const ,CEffectInstance *> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Allocate

; 786  :     }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 c0 10	 add	 eax, 16			; 00000010H
  00056	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00067	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0006a	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00070	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00073	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007b	8b 55 dc	 mov	 edx, DWORD PTR $T2[ebp]
  0007e	89 0a		 mov	 DWORD PTR [edx], ecx
  00080	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00083	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00086	50		 push	 eax
  00087	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	ff 70 04	 push	 DWORD PTR [eax+4]
  0008d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>
  00092	59		 pop	 ecx
  00093	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00094	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00097	50		 push	 eax
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009e	83 c0 04	 add	 eax, 4
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>
  000a7	59		 pop	 ecx
  000a8	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000a9	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000ac	50		 push	 eax
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b3	83 c0 08	 add	 eax, 8
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * &>
  000bc	59		 pop	 ecx
  000bd	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000be	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000c8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ce	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	c9		 leave
  000e1	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > ><std::pair<unsigned long const ,CEffectInstance *> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 18	 imul	 eax, eax, 24
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 18	 imul	 eax, eax, 24
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > ><std::pair<CGraphicThingInstance * const,unsigned long> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Allocate

; 786  :     }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 c0 10	 add	 eax, 16			; 00000010H
  00056	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00067	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0006a	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006d	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00070	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00073	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007b	8b 55 dc	 mov	 edx, DWORD PTR $T2[ebp]
  0007e	89 0a		 mov	 DWORD PTR [edx], ecx
  00080	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00083	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00086	50		 push	 eax
  00087	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	ff 70 04	 push	 DWORD PTR [eax+4]
  0008d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>
  00092	59		 pop	 ecx
  00093	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00094	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  00097	50		 push	 eax
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009e	83 c0 04	 add	 eax, 4
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>
  000a7	59		 pop	 ecx
  000a8	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000a9	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000ac	50		 push	 eax
  000ad	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b3	83 c0 08	 add	 eax, 8
  000b6	50		 push	 eax
  000b7	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * &>
  000bc	59		 pop	 ecx
  000bd	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000be	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000c8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ce	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	c9		 leave
  000e1	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > ><std::pair<CGraphicThingInstance * const,unsigned long> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 18	 imul	 eax, eax, 24
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 18	 imul	 eax, eax, 24
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YA?AU?$pair@PAUSObjectData@CArea@@PAU12@@0@PAUSObjectData@CArea@@0UObjectDataComp@3@@Z
_TEXT	SEGMENT
$T1 = -444						; size = 4
$T2 = -440						; size = 4
$T3 = -436						; size = 4
$T4 = -432						; size = 4
$T5 = -428						; size = 4
$T6 = -424						; size = 4
$T7 = -420						; size = 4
$T8 = -416						; size = 4
$T9 = -412						; size = 4
$T10 = -408						; size = 4
$T11 = -404						; size = 4
$T12 = -400						; size = 4
$T13 = -396						; size = 4
$T14 = -392						; size = 4
$T15 = -388						; size = 4
$T16 = -384						; size = 4
$T17 = -380						; size = 4
$T18 = -376						; size = 4
$T19 = -372						; size = 4
$T20 = -368						; size = 4
$T21 = -364						; size = 4
$T22 = -360						; size = 4
$T23 = -356						; size = 4
tv226 = -352						; size = 4
__Mid$ = -348						; size = 4
tv216 = -344						; size = 4
tv218 = -340						; size = 4
tv220 = -336						; size = 4
tv222 = -332						; size = 4
tv224 = -328						; size = 4
__Right$ = -324						; size = 4
__Left$ = -320						; size = 4
__Right$ = -316						; size = 4
__Left$ = -312						; size = 4
__Right$ = -308						; size = 4
__Left$ = -304						; size = 4
__Left$ = -300						; size = 4
tv231 = -296						; size = 4
tv152 = -292						; size = 4
__Left$ = -288						; size = 4
__First$ = -284						; size = 4
__First$ = -280						; size = 4
__First$ = -276						; size = 4
__First$ = -272						; size = 4
__First$ = -268						; size = 4
__First$ = -264						; size = 4
__First$ = -260						; size = 4
__First$ = -256						; size = 4
__Glast$ = -252						; size = 4
__Gfirst$ = -248					; size = 4
__Plast$ = -244						; size = 4
__Pfirst$ = -240					; size = 4
__Tmp$24 = -236						; size = 48
__Tmp$25 = -188						; size = 48
__Tmp$26 = -140						; size = 48
__Tmp$27 = -92						; size = 48
__Tmp$28 = -44						; size = 48
__Tmp$29 = 4						; size = 48
__Tmp$30 = 52						; size = 48
__$ArrayPad$ = 100					; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YA?AU?$pair@PAUSObjectData@CArea@@PAU12@@0@PAUSObjectData@CArea@@0UObjectDataComp@3@@Z PROC ; std::_Partition_by_median_guess_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 24 02 00
	00		 sub	 esp, 548		; 00000224H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00017	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0001a	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  0001d	99		 cdq
  0001e	6a 30		 push	 48			; 00000030H
  00020	59		 pop	 ecx
  00021	f7 f9		 idiv	 ecx
  00023	d1 f8		 sar	 eax, 1
  00025	6b c0 30	 imul	 eax, eax, 48
  00028	03 45 74	 add	 eax, DWORD PTR __First$[ebp]
  0002b	89 85 a4 fe ff
	ff		 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00031	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00034	89 85 fc fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0003a	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00040	83 e8 30	 sub	 eax, 48			; 00000030H
  00043	89 85 fc fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00049	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  0004c	ff b5 fc fe ff
	ff		 push	 DWORD PTR __First$[ebp]
  00052	ff b5 a4 fe ff
	ff		 push	 DWORD PTR __Mid$[ebp]
  00058	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0005b	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@00UObjectDataComp@2@@Z ; std::_Guess_median_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  00060	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00063	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR __Mid$[ebp]
  00069	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0006f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00075	89 85 f8 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0007b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00081	83 c0 30	 add	 eax, 48			; 00000030H
  00084	89 85 f8 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0008a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00090	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00096	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00099	3b 85 10 ff ff
	ff		 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  0009f	0f 83 ae 00 00
	00		 jae	 $LN4@Partition_
  000a5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000ab	89 85 f4 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  000b1	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  000b7	83 e8 30	 sub	 eax, 48			; 00000030H
  000ba	89 85 f4 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  000c0	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  000c6	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000cc	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000cf	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  000d2	73 0c		 jae	 SHORT $LN42@Partition_
  000d4	c7 85 a8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv216[ebp], 1
  000de	eb 07		 jmp	 SHORT $LN40@Partition_
$LN42@Partition_:
  000e0	83 a5 a8 fe ff
	ff 00		 and	 DWORD PTR tv216[ebp], 0
$LN40@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000e7	0f b6 85 a8 fe
	ff ff		 movzx	 eax, BYTE PTR tv216[ebp]
  000ee	85 c0		 test	 eax, eax
  000f0	75 61		 jne	 SHORT $LN4@Partition_
  000f2	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000f8	89 85 f0 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  000fe	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00104	83 e8 30	 sub	 eax, 48			; 00000030H
  00107	89 85 f0 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  0010d	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00113	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR __First$[ebp]
  00119	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011c	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0011f	73 0c		 jae	 SHORT $LN48@Partition_
  00121	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv218[ebp], 1
  0012b	eb 07		 jmp	 SHORT $LN46@Partition_
$LN48@Partition_:
  0012d	83 a5 ac fe ff
	ff 00		 and	 DWORD PTR tv218[ebp], 0
$LN46@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00134	0f b6 85 ac fe
	ff ff		 movzx	 eax, BYTE PTR tv218[ebp]
  0013b	85 c0		 test	 eax, eax
  0013d	75 14		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  0013f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00145	83 e8 30	 sub	 eax, 48			; 00000030H
  00148	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  0014e	e9 43 ff ff ff	 jmp	 $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00153	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00159	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  0015c	73 75		 jae	 SHORT $LN5@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  0015e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00164	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0016a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0016d	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00170	73 0c		 jae	 SHORT $LN52@Partition_
  00172	c7 85 b0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv220[ebp], 1
  0017c	eb 07		 jmp	 SHORT $LN50@Partition_
$LN52@Partition_:
  0017e	83 a5 b0 fe ff
	ff 00		 and	 DWORD PTR tv220[ebp], 0
$LN50@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00185	0f b6 85 b0 fe
	ff ff		 movzx	 eax, BYTE PTR tv220[ebp]
  0018c	85 c0		 test	 eax, eax
  0018e	75 43		 jne	 SHORT $LN5@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  00190	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00196	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR __Plast$[ebp]
  0019c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0019f	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  001a2	73 0c		 jae	 SHORT $LN56@Partition_
  001a4	c7 85 b4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv222[ebp], 1
  001ae	eb 07		 jmp	 SHORT $LN54@Partition_
$LN56@Partition_:
  001b0	83 a5 b4 fe ff
	ff 00		 and	 DWORD PTR tv222[ebp], 0
$LN54@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  001b7	0f b6 85 b4 fe
	ff ff		 movzx	 eax, BYTE PTR tv222[ebp]
  001be	85 c0		 test	 eax, eax
  001c0	75 11		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  001c2	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  001c8	83 c0 30	 add	 eax, 48			; 00000030H
  001cb	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  001d1	eb 80		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  001d3	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  001d9	89 85 08 ff ff
	ff		 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  001df	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  001e5	89 85 04 ff ff
	ff		 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  001eb	eb 0f		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  001ed	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001f3	83 c0 30	 add	 eax, 48			; 00000030H
  001f6	89 85 08 ff ff
	ff		 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  001fc	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00202	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00205	0f 83 0b 01 00
	00		 jae	 $LN10@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  0020b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00211	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00217	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0021a	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  0021d	73 0c		 jae	 SHORT $LN60@Partition_
  0021f	c7 85 b8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv224[ebp], 1
  00229	eb 07		 jmp	 SHORT $LN58@Partition_
$LN60@Partition_:
  0022b	83 a5 b8 fe ff
	ff 00		 and	 DWORD PTR tv224[ebp], 0
$LN58@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  00232	0f b6 85 b8 fe
	ff ff		 movzx	 eax, BYTE PTR tv224[ebp]
  00239	85 c0		 test	 eax, eax
  0023b	74 07		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  0023d	eb ae		 jmp	 SHORT $LN9@Partition_

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0023f	e9 cd 00 00 00	 jmp	 $LN16@Partition_
$LN15@Partition_:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  00244	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0024a	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00250	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00253	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00256	73 0c		 jae	 SHORT $LN64@Partition_
  00258	c7 85 a0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv226[ebp], 1
  00262	eb 07		 jmp	 SHORT $LN62@Partition_
$LN64@Partition_:
  00264	83 a5 a0 fe ff
	ff 00		 and	 DWORD PTR tv226[ebp], 0
$LN62@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0026b	0f b6 85 a0 fe
	ff ff		 movzx	 eax, BYTE PTR tv226[ebp]
  00272	85 c0		 test	 eax, eax
  00274	74 0a		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  00276	e9 9b 00 00 00	 jmp	 $LN10@Partition_
  0027b	e9 91 00 00 00	 jmp	 $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  00280	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00286	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  0028c	74 74		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  0028e	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00294	89 85 e0 fe ff
	ff		 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0029a	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR __Left$[ebp]
  002a0	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  002a6	6a 0c		 push	 12			; 0000000cH
  002a8	59		 pop	 ecx
  002a9	8b b5 7c fe ff
	ff		 mov	 esi, DWORD PTR $T15[ebp]
  002af	8d bd 74 ff ff
	ff		 lea	 edi, DWORD PTR __Tmp$26[ebp]
  002b5	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002b7	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  002bd	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  002c3	6a 0c		 push	 12			; 0000000cH
  002c5	59		 pop	 ecx
  002c6	8b b5 5c fe ff
	ff		 mov	 esi, DWORD PTR $T7[ebp]
  002cc	8b bd e0 fe ff
	ff		 mov	 edi, DWORD PTR __Left$[ebp]
  002d2	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002d4	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$26[ebp]
  002da	89 85 58 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  002e0	6a 0c		 push	 12			; 0000000cH
  002e2	59		 pop	 ecx
  002e3	8b b5 58 fe ff
	ff		 mov	 esi, DWORD PTR $T6[ebp]
  002e9	8b bd 08 ff ff
	ff		 mov	 edi, DWORD PTR __Gfirst$[ebp]
  002ef	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  002f1	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  002f7	83 c0 30	 add	 eax, 48			; 00000030H
  002fa	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  00300	eb 0f		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  00302	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00308	83 c0 30	 add	 eax, 48			; 00000030H
  0030b	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  00311	e9 d7 fe ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  00316	eb 0f		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  00318	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0031e	83 e8 30	 sub	 eax, 48			; 00000030H
  00321	89 85 04 ff ff
	ff		 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  00327	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  0032a	3b 85 04 ff ff
	ff		 cmp	 eax, DWORD PTR __Glast$[ebp]
  00330	0f 83 60 01 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00336	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0033c	89 85 ec fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00342	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00348	83 e8 30	 sub	 eax, 48			; 00000030H
  0034b	89 85 ec fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  00351	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00357	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0035d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00360	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  00363	73 0c		 jae	 SHORT $LN84@Partition_
  00365	c7 85 dc fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv152[ebp], 1
  0036f	eb 07		 jmp	 SHORT $LN82@Partition_
$LN84@Partition_:
  00371	83 a5 dc fe ff
	ff 00		 and	 DWORD PTR tv152[ebp], 0
$LN82@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00378	0f b6 85 dc fe
	ff ff		 movzx	 eax, BYTE PTR tv152[ebp]
  0037f	85 c0		 test	 eax, eax
  00381	74 07		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00383	eb 93		 jmp	 SHORT $LN12@Partition_
  00385	e9 07 01 00 00	 jmp	 $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0038a	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  00390	89 85 e8 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00396	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  0039c	83 e8 30	 sub	 eax, 48			; 00000030H
  0039f	89 85 e8 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  003a5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003ab	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR __First$[ebp]
  003b1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  003b4	3b 41 0c	 cmp	 eax, DWORD PTR [ecx+12]
  003b7	73 0c		 jae	 SHORT $LN90@Partition_
  003b9	c7 85 d8 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv231[ebp], 1
  003c3	eb 07		 jmp	 SHORT $LN88@Partition_
$LN90@Partition_:
  003c5	83 a5 d8 fe ff
	ff 00		 and	 DWORD PTR tv231[ebp], 0
$LN88@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  003cc	0f b6 85 d8 fe
	ff ff		 movzx	 eax, BYTE PTR tv231[ebp]
  003d3	85 c0		 test	 eax, eax
  003d5	74 0a		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  003d7	e9 ba 00 00 00	 jmp	 $LN13@Partition_
  003dc	e9 b0 00 00 00	 jmp	 $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  003e1	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003e7	83 e8 30	 sub	 eax, 48			; 00000030H
  003ea	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Pfirst$[ebp], eax
  003f0	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  003f6	89 85 e4 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  003fc	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00402	83 e8 30	 sub	 eax, 48			; 00000030H
  00405	89 85 e4 fe ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  0040b	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00411	3b 85 e4 fe ff
	ff		 cmp	 eax, DWORD PTR __First$[ebp]
  00417	74 78		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  00419	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0041f	89 85 00 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00425	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  0042b	83 e8 30	 sub	 eax, 48			; 00000030H
  0042e	89 85 00 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  00434	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0043a	89 85 d4 fe ff
	ff		 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00440	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR __Left$[ebp]
  00446	89 85 54 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0044c	6a 0c		 push	 12			; 0000000cH
  0044e	59		 pop	 ecx
  0044f	8b b5 54 fe ff
	ff		 mov	 esi, DWORD PTR $T5[ebp]
  00455	8d 7d a4	 lea	 edi, DWORD PTR __Tmp$27[ebp]
  00458	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0045a	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  00460	89 85 50 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00466	6a 0c		 push	 12			; 0000000cH
  00468	59		 pop	 ecx
  00469	8b b5 50 fe ff
	ff		 mov	 esi, DWORD PTR $T4[ebp]
  0046f	8b bd d4 fe ff
	ff		 mov	 edi, DWORD PTR __Left$[ebp]
  00475	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00477	8d 45 a4	 lea	 eax, DWORD PTR __Tmp$27[ebp]
  0047a	89 85 4c fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00480	6a 0c		 push	 12			; 0000000cH
  00482	59		 pop	 ecx
  00483	8b b5 4c fe ff
	ff		 mov	 esi, DWORD PTR $T3[ebp]
  00489	8b bd 00 ff ff
	ff		 mov	 edi, DWORD PTR __First$[ebp]
  0048f	f3 a5		 rep movsd
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  00491	e9 82 fe ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  00496	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0049c	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  0049f	75 46		 jne	 SHORT $LN26@Partition_
  004a1	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  004a7	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  004aa	75 3b		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  004ac	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __Pfirst$[ebp]
  004b2	89 85 48 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  004b8	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004bb	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp]
  004c1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004c3	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  004c5	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR __Plast$[ebp]
  004cb	89 85 9c fe ff
	ff		 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  004d1	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004d4	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR $T23[ebp]
  004da	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004dc	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  004df	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  004e2	e9 a7 02 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  004e7	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  004ed	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  004f0	0f 85 06 01 00
	00		 jne	 $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  004f6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  004fc	3b 85 08 ff ff
	ff		 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00502	74 69		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  00504	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  0050a	89 85 cc fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
  00510	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00516	89 85 d0 fe ff
	ff		 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0051c	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR __Left$[ebp]
  00522	89 85 98 fe ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00528	6a 0c		 push	 12			; 0000000cH
  0052a	59		 pop	 ecx
  0052b	8b b5 98 fe ff
	ff		 mov	 esi, DWORD PTR $T22[ebp]
  00531	8d 7d d4	 lea	 edi, DWORD PTR __Tmp$28[ebp]
  00534	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00536	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  0053c	89 85 94 fe ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00542	6a 0c		 push	 12			; 0000000cH
  00544	59		 pop	 ecx
  00545	8b b5 94 fe ff
	ff		 mov	 esi, DWORD PTR $T21[ebp]
  0054b	8b bd d0 fe ff
	ff		 mov	 edi, DWORD PTR __Left$[ebp]
  00551	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00553	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$28[ebp]
  00556	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0055c	6a 0c		 push	 12			; 0000000cH
  0055e	59		 pop	 ecx
  0055f	8b b5 90 fe ff
	ff		 mov	 esi, DWORD PTR $T20[ebp]
  00565	8b bd cc fe ff
	ff		 mov	 edi, DWORD PTR __Right$[ebp]
  0056b	f3 a5		 rep movsd
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  0056d	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  00573	83 c0 30	 add	 eax, 48			; 00000030H
  00576	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  0057c	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00582	89 85 c8 fe ff
	ff		 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00588	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR __Left$[ebp]
  0058e	89 85 8c fe ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00594	6a 0c		 push	 12			; 0000000cH
  00596	59		 pop	 ecx
  00597	8b b5 8c fe ff
	ff		 mov	 esi, DWORD PTR $T19[ebp]
  0059d	8d 7d 04	 lea	 edi, DWORD PTR __Tmp$29[ebp]
  005a0	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  005a2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  005a8	89 85 88 fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  005ae	6a 0c		 push	 12			; 0000000cH
  005b0	59		 pop	 ecx
  005b1	8b b5 88 fe ff
	ff		 mov	 esi, DWORD PTR $T18[ebp]
  005b7	8b bd c8 fe ff
	ff		 mov	 edi, DWORD PTR __Left$[ebp]
  005bd	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  005bf	8d 45 04	 lea	 eax, DWORD PTR __Tmp$29[ebp]
  005c2	89 85 84 fe ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  005c8	6a 0c		 push	 12			; 0000000cH
  005ca	59		 pop	 ecx
  005cb	8b b5 84 fe ff
	ff		 mov	 esi, DWORD PTR $T17[ebp]
  005d1	8b bd 08 ff ff
	ff		 mov	 edi, DWORD PTR __Gfirst$[ebp]
  005d7	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  005d9	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  005df	83 c0 30	 add	 eax, 48			; 00000030H
  005e2	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  005e8	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  005ee	83 c0 30	 add	 eax, 48			; 00000030H
  005f1	89 85 08 ff ff
	ff		 mov	 DWORD PTR __Gfirst$[ebp], eax
  005f7	e9 8d 01 00 00	 jmp	 $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  005fc	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00602	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00605	0f 85 09 01 00
	00		 jne	 $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  0060b	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  00611	83 e8 30	 sub	 eax, 48			; 00000030H
  00614	89 85 04 ff ff
	ff		 mov	 DWORD PTR __Glast$[ebp], eax
  0061a	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00620	83 e8 30	 sub	 eax, 48			; 00000030H
  00623	89 85 10 ff ff
	ff		 mov	 DWORD PTR __Pfirst$[ebp], eax
  00629	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0062f	3b 85 10 ff ff
	ff		 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00635	74 63		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  00637	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0063d	89 85 c4 fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00643	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  00649	89 85 80 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0064f	6a 0c		 push	 12			; 0000000cH
  00651	59		 pop	 ecx
  00652	8b b5 80 fe ff
	ff		 mov	 esi, DWORD PTR $T16[ebp]
  00658	8d bd 14 ff ff
	ff		 lea	 edi, DWORD PTR __Tmp$24[ebp]
  0065e	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00660	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  00666	89 85 60 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0066c	6a 0c		 push	 12			; 0000000cH
  0066e	59		 pop	 ecx
  0066f	8b b5 60 fe ff
	ff		 mov	 esi, DWORD PTR $T8[ebp]
  00675	8b bd 04 ff ff
	ff		 mov	 edi, DWORD PTR __Glast$[ebp]
  0067b	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0067d	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$24[ebp]
  00683	89 85 78 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00689	6a 0c		 push	 12			; 0000000cH
  0068b	59		 pop	 ecx
  0068c	8b b5 78 fe ff
	ff		 mov	 esi, DWORD PTR $T14[ebp]
  00692	8b bd c4 fe ff
	ff		 mov	 edi, DWORD PTR __Right$[ebp]
  00698	f3 a5		 rep movsd
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  0069a	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  006a0	83 e8 30	 sub	 eax, 48			; 00000030H
  006a3	89 85 0c ff ff
	ff		 mov	 DWORD PTR __Plast$[ebp], eax
  006a9	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR __Plast$[ebp]
  006af	89 85 bc fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
  006b5	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR __Pfirst$[ebp]
  006bb	89 85 c0 fe ff
	ff		 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  006c1	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR __Left$[ebp]
  006c7	89 85 74 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  006cd	6a 0c		 push	 12			; 0000000cH
  006cf	59		 pop	 ecx
  006d0	8b b5 74 fe ff
	ff		 mov	 esi, DWORD PTR $T13[ebp]
  006d6	8d 7d 34	 lea	 edi, DWORD PTR __Tmp$30[ebp]
  006d9	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  006db	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR __Right$[ebp]
  006e1	89 85 70 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  006e7	6a 0c		 push	 12			; 0000000cH
  006e9	59		 pop	 ecx
  006ea	8b b5 70 fe ff
	ff		 mov	 esi, DWORD PTR $T12[ebp]
  006f0	8b bd c0 fe ff
	ff		 mov	 edi, DWORD PTR __Left$[ebp]
  006f6	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  006f8	8d 45 34	 lea	 eax, DWORD PTR __Tmp$30[ebp]
  006fb	89 85 6c fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00701	6a 0c		 push	 12			; 0000000cH
  00703	59		 pop	 ecx
  00704	8b b5 6c fe ff
	ff		 mov	 esi, DWORD PTR $T11[ebp]
  0070a	8b bd bc fe ff
	ff		 mov	 edi, DWORD PTR __Right$[ebp]
  00710	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  00712	eb 75		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  00714	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  0071a	83 e8 30	 sub	 eax, 48			; 00000030H
  0071d	89 85 04 ff ff
	ff		 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00723	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00729	89 85 68 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0072f	6a 0c		 push	 12			; 0000000cH
  00731	59		 pop	 ecx
  00732	8b b5 68 fe ff
	ff		 mov	 esi, DWORD PTR $T10[ebp]
  00738	8d bd 44 ff ff
	ff		 lea	 edi, DWORD PTR __Tmp$25[ebp]
  0073e	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00740	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR __Glast$[ebp]
  00746	89 85 64 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0074c	6a 0c		 push	 12			; 0000000cH
  0074e	59		 pop	 ecx
  0074f	8b b5 64 fe ff
	ff		 mov	 esi, DWORD PTR $T9[ebp]
  00755	8b bd 08 ff ff
	ff		 mov	 edi, DWORD PTR __Gfirst$[ebp]
  0075b	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0075d	8d 85 44 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$25[ebp]
  00763	89 85 44 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00769	6a 0c		 push	 12			; 0000000cH
  0076b	59		 pop	 ecx
  0076c	8b b5 44 fe ff
	ff		 mov	 esi, DWORD PTR $T1[ebp]
  00772	8b bd 04 ff ff
	ff		 mov	 edi, DWORD PTR __Glast$[ebp]
  00778	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  0077a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00780	83 c0 30	 add	 eax, 48			; 00000030H
  00783	89 85 08 ff ff
	ff		 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  00789	e9 5d fa ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  0078e	5f		 pop	 edi
  0078f	5e		 pop	 esi
  00790	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00793	33 cd		 xor	 ecx, ebp
  00795	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0079a	83 c5 68	 add	 ebp, 104		; 00000068H
  0079d	c9		 leave
  0079e	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YA?AU?$pair@PAUSObjectData@CArea@@PAU12@@0@PAUSObjectData@CArea@@0UObjectDataComp@3@@Z ENDP ; std::_Partition_by_median_guess_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
__Bottom$ = -60						; size = 4
__Hole$3 = -56						; size = 4
__Val$4 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z PROC ; std::_Make_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00012	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00015	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00018	99		 cdq
  00019	6a 30		 push	 48			; 00000030H
  0001b	59		 pop	 ecx
  0001c	f7 f9		 idiv	 ecx
  0001e	89 45 c4	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00021	8b 45 c4	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00024	d1 f8		 sar	 eax, 1
  00026	89 45 c8	 mov	 DWORD PTR __Hole$3[ebp], eax
$LN4@Make_heap_:
  00029	83 7d c8 00	 cmp	 DWORD PTR __Hole$3[ebp], 0
  0002d	7e 3b		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  0002f	8b 45 c8	 mov	 eax, DWORD PTR __Hole$3[ebp]
  00032	48		 dec	 eax
  00033	89 45 c8	 mov	 DWORD PTR __Hole$3[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00036	6b 45 c8 30	 imul	 eax, DWORD PTR __Hole$3[ebp], 48
  0003a	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003d	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00040	6a 0c		 push	 12			; 0000000cH
  00042	59		 pop	 ecx
  00043	8b 75 c0	 mov	 esi, DWORD PTR $T2[ebp]
  00046	8d 7d cc	 lea	 edi, DWORD PTR __Val$4[ebp]
  00049	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0004b	8d 45 cc	 lea	 eax, DWORD PTR __Val$4[ebp]
  0004e	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  00051	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00054	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  00057	ff 75 c4	 push	 DWORD PTR __Bottom$[ebp]
  0005a	ff 75 c8	 push	 DWORD PTR __Hole$3[ebp]
  0005d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSObjectData@CArea@@U12@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@HH$$QAU12@UObjectDataComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SObjectData *,CArea::SObjectData,CArea::ObjectDataComp>
  00065	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  00068	eb bf		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	c9		 leave
  00077	c3		 ret	 0
??$_Make_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ENDP ; std::_Make_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAPAUSObjectData@CArea@@QAU12@0UObjectDataComp@2@@Z
_TEXT	SEGMENT
$T1 = -100						; size = 4
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
tv79 = -80						; size = 4
tv130 = -76						; size = 4
__Dest$ = -72						; size = 4
__Prev$6 = -68						; size = 4
__Last$ = -64						; size = 4
__Mid$7 = -60						; size = 4
__Hole$8 = -56						; size = 4
__Val$9 = -52						; size = 48
__$ArrayPad$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAPAUSObjectData@CArea@@QAU12@0UObjectDataComp@2@@Z PROC ; std::_Insertion_sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00012	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00015	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00018	0f 84 1a 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	89 45 c4	 mov	 DWORD PTR __Mid$7[ebp], eax
$LN4@Insertion_:
  00024	8b 45 c4	 mov	 eax, DWORD PTR __Mid$7[ebp]
  00027	83 c0 30	 add	 eax, 48			; 00000030H
  0002a	89 45 c4	 mov	 DWORD PTR __Mid$7[ebp], eax
  0002d	8b 45 c4	 mov	 eax, DWORD PTR __Mid$7[ebp]
  00030	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00033	0f 84 ff 00 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  00039	8b 45 c4	 mov	 eax, DWORD PTR __Mid$7[ebp]
  0003c	89 45 c8	 mov	 DWORD PTR __Hole$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003f	8b 45 c4	 mov	 eax, DWORD PTR __Mid$7[ebp]
  00042	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00045	6a 0c		 push	 12			; 0000000cH
  00047	59		 pop	 ecx
  00048	8b 75 ac	 mov	 esi, DWORD PTR $T5[ebp]
  0004b	8d 7d cc	 lea	 edi, DWORD PTR __Val$9[ebp]
  0004e	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  00050	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00053	8b 4d d8	 mov	 ecx, DWORD PTR __Val$9[ebp+12]
  00056	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00059	73 09		 jae	 SHORT $LN17@Insertion_
  0005b	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00062	eb 04		 jmp	 SHORT $LN15@Insertion_
$LN17@Insertion_:
  00064	83 65 b4 00	 and	 DWORD PTR tv130[ebp], 0
$LN15@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  00068	0f b6 45 b4	 movzx	 eax, BYTE PTR tv130[ebp]
  0006c	85 c0		 test	 eax, eax
  0006e	74 68		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00070	8b 45 c8	 mov	 eax, DWORD PTR __Hole$8[ebp]
  00073	83 c0 30	 add	 eax, 48			; 00000030H
  00076	89 45 c8	 mov	 DWORD PTR __Hole$8[ebp], eax
  00079	8b 45 c8	 mov	 eax, DWORD PTR __Hole$8[ebp]
  0007c	89 45 b8	 mov	 DWORD PTR __Dest$[ebp], eax
  0007f	8b 45 c4	 mov	 eax, DWORD PTR __Mid$7[ebp]
  00082	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  00085	ff 75 b8	 push	 DWORD PTR __Dest$[ebp]
  00088	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  0008b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0008e	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSObjectData@CArea@@PAU12@@std@@YAPAUSObjectData@CArea@@PAU12@00@Z ; std::_Copy_backward_memmove<CArea::SObjectData *,CArea::SObjectData *>
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
  00096	eb 2d		 jmp	 SHORT $LN19@Insertion_
$LN20@Insertion_:

; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  00098	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0009b	3b 45 c0	 cmp	 eax, DWORD PTR __Last$[ebp]
  0009e	74 25		 je	 SHORT $LN19@Insertion_

; 4701 :         *--_Dest = _STD move(*--_Last);

  000a0	8b 45 c0	 mov	 eax, DWORD PTR __Last$[ebp]
  000a3	83 e8 30	 sub	 eax, 48			; 00000030H
  000a6	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  000a9	8b 45 b8	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ac	83 e8 30	 sub	 eax, 48			; 00000030H
  000af	89 45 b8	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000b2	8b 45 c0	 mov	 eax, DWORD PTR __Last$[ebp]
  000b5	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4701 :         *--_Dest = _STD move(*--_Last);

  000b8	6a 0c		 push	 12			; 0000000cH
  000ba	59		 pop	 ecx
  000bb	8b 75 a8	 mov	 esi, DWORD PTR $T4[ebp]
  000be	8b 7d b8	 mov	 edi, DWORD PTR __Dest$[ebp]
  000c1	f3 a5		 rep movsd

; 4702 :     }

  000c3	eb d3		 jmp	 SHORT $LN20@Insertion_
$LN19@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000c5	8d 45 cc	 lea	 eax, DWORD PTR __Val$9[ebp]
  000c8	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000cb	6a 0c		 push	 12			; 0000000cH
  000cd	59		 pop	 ecx
  000ce	8b 75 a4	 mov	 esi, DWORD PTR $T3[ebp]
  000d1	8b 7d 08	 mov	 edi, DWORD PTR __First$[ebp]
  000d4	f3 a5		 rep movsd

; 7420 :             } else { // look for insertion point after first

  000d6	eb 5b		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000d8	8b 45 c8	 mov	 eax, DWORD PTR __Hole$8[ebp]
  000db	89 45 bc	 mov	 DWORD PTR __Prev$6[ebp], eax
  000de	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000e0	8b 45 bc	 mov	 eax, DWORD PTR __Prev$6[ebp]
  000e3	89 45 c8	 mov	 DWORD PTR __Hole$8[ebp], eax
$LN7@Insertion_:
  000e6	8b 45 bc	 mov	 eax, DWORD PTR __Prev$6[ebp]
  000e9	83 e8 30	 sub	 eax, 48			; 00000030H
  000ec	89 45 bc	 mov	 DWORD PTR __Prev$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 57   : 				return lhs.dwCRC < rhs.dwCRC;

  000ef	8b 45 bc	 mov	 eax, DWORD PTR __Prev$6[ebp]
  000f2	8b 4d d8	 mov	 ecx, DWORD PTR __Val$9[ebp+12]
  000f5	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000f8	73 09		 jae	 SHORT $LN31@Insertion_
  000fa	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00101	eb 04		 jmp	 SHORT $LN29@Insertion_
$LN31@Insertion_:
  00103	83 65 b0 00	 and	 DWORD PTR tv79[ebp], 0
$LN29@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00107	0f b6 45 b0	 movzx	 eax, BYTE PTR tv79[ebp]
  0010b	85 c0		 test	 eax, eax
  0010d	74 13		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0010f	8b 45 bc	 mov	 eax, DWORD PTR __Prev$6[ebp]
  00112	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  00115	6a 0c		 push	 12			; 0000000cH
  00117	59		 pop	 ecx
  00118	8b 75 a0	 mov	 esi, DWORD PTR $T2[ebp]
  0011b	8b 7d c8	 mov	 edi, DWORD PTR __Hole$8[ebp]
  0011e	f3 a5		 rep movsd

; 7423 :                 }

  00120	eb be		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00122	8d 45 cc	 lea	 eax, DWORD PTR __Val$9[ebp]
  00125	89 45 9c	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  00128	6a 0c		 push	 12			; 0000000cH
  0012a	59		 pop	 ecx
  0012b	8b 75 9c	 mov	 esi, DWORD PTR $T1[ebp]
  0012e	8b 7d c8	 mov	 edi, DWORD PTR __Hole$8[ebp]
  00131	f3 a5		 rep movsd
$LN10@Insertion_:

; 7426 :             }
; 7427 :         }

  00133	e9 ec fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  00138	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  0013b	5f		 pop	 edi
  0013c	5e		 pop	 esi
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00140	33 cd		 xor	 ecx, ebp
  00142	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00147	c9		 leave
  00148	c3		 ret	 0
??$_Insertion_sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAPAUSObjectData@CArea@@QAU12@0UObjectDataComp@2@@Z ENDP ; std::_Insertion_sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z
_TEXT	SEGMENT
__Tmp$1 = -160						; size = 8
__Tmp$2 = -152						; size = 8
__Tmp$3 = -144						; size = 8
__Tmp$4 = -136						; size = 8
__Tmp$5 = -128						; size = 8
__Tmp$6 = -120						; size = 8
__Tmp$7 = -112						; size = 8
$T8 = -104						; size = 4
$T9 = -100						; size = 4
$T10 = -96						; size = 4
$T11 = -92						; size = 4
$T12 = -88						; size = 4
$T13 = -84						; size = 4
$T14 = -80						; size = 4
$T15 = -76						; size = 4
$T16 = -72						; size = 4
$T17 = -68						; size = 4
$T18 = -64						; size = 4
$T19 = -60						; size = 4
$T20 = -56						; size = 4
$T21 = -52						; size = 4
$T22 = -48						; size = 4
$T23 = -44						; size = 4
$T24 = -40						; size = 4
$T25 = -36						; size = 4
$T26 = -32						; size = 4
$T27 = -28						; size = 4
$T28 = -24						; size = 4
$T29 = -20						; size = 4
$T30 = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
__Right$ = -4						; size = 4
__Left$ = 0						; size = 4
__Right$ = 4						; size = 4
__Left$ = 8						; size = 4
__Left$ = 12						; size = 4
tv231 = 16						; size = 4
tv152 = 20						; size = 4
__Left$ = 24						; size = 4
tv226 = 28						; size = 4
tv224 = 32						; size = 4
tv222 = 36						; size = 4
tv220 = 40						; size = 4
tv218 = 44						; size = 4
tv216 = 48						; size = 4
__Mid$ = 52						; size = 4
__First$ = 56						; size = 4
__First$ = 60						; size = 4
__First$ = 64						; size = 4
__First$ = 68						; size = 4
__First$ = 72						; size = 4
__First$ = 76						; size = 4
__First$ = 80						; size = 4
__First$ = 84						; size = 4
__Glast$ = 88						; size = 4
__Gfirst$ = 92						; size = 4
__Plast$ = 96						; size = 4
__Pfirst$ = 100						; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z PROC ; std::_Partition_by_median_guess_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000b	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  00011	c1 f8 03	 sar	 eax, 3
  00014	d1 f8		 sar	 eax, 1
  00016	8b 4d 74	 mov	 ecx, DWORD PTR __First$[ebp]
  00019	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0001c	89 45 34	 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0001f	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00022	89 45 50	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00025	8b 45 50	 mov	 eax, DWORD PTR __First$[ebp]
  00028	83 e8 08	 sub	 eax, 8
  0002b	89 45 50	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0002e	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  00031	ff 75 50	 push	 DWORD PTR __First$[ebp]
  00034	ff 75 34	 push	 DWORD PTR __Mid$[ebp]
  00037	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@00UCRCNumComp@2@@Z ; std::_Guess_median_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00042	8b 45 34	 mov	 eax, DWORD PTR __Mid$[ebp]
  00045	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00048	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0004b	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0004e	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00057	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  0005a	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0005d	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00060	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00063	73 6f		 jae	 SHORT $LN4@Partition_
  00065	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00068	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0006b	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  0006e	83 e8 08	 sub	 eax, 8
  00071	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00074	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  00077	8b 4d 64	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00080	76 09		 jbe	 SHORT $LN42@Partition_
  00082	c7 45 30 01 00
	00 00		 mov	 DWORD PTR tv216[ebp], 1
  00089	eb 04		 jmp	 SHORT $LN40@Partition_
$LN42@Partition_:
  0008b	83 65 30 00	 and	 DWORD PTR tv216[ebp], 0
$LN40@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0008f	0f b6 45 30	 movzx	 eax, BYTE PTR tv216[ebp]
  00093	85 c0		 test	 eax, eax
  00095	75 3d		 jne	 SHORT $LN4@Partition_
  00097	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0009a	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0009d	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  000a0	83 e8 08	 sub	 eax, 8
  000a3	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000a6	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000a9	8b 4d 44	 mov	 ecx, DWORD PTR __First$[ebp]
  000ac	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000af	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000b2	76 09		 jbe	 SHORT $LN48@Partition_
  000b4	c7 45 2c 01 00
	00 00		 mov	 DWORD PTR tv218[ebp], 1
  000bb	eb 04		 jmp	 SHORT $LN46@Partition_
$LN48@Partition_:
  000bd	83 65 2c 00	 and	 DWORD PTR tv218[ebp], 0
$LN46@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000c1	0f b6 45 2c	 movzx	 eax, BYTE PTR tv218[ebp]
  000c5	85 c0		 test	 eax, eax
  000c7	75 0b		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  000c9	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000cc	83 e8 08	 sub	 eax, 8
  000cf	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  000d2	eb 89		 jmp	 SHORT $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000d4	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000d7	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  000da	73 51		 jae	 SHORT $LN5@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000dc	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000df	8b 4d 64	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  000e2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e5	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000e8	76 09		 jbe	 SHORT $LN52@Partition_
  000ea	c7 45 28 01 00
	00 00		 mov	 DWORD PTR tv220[ebp], 1
  000f1	eb 04		 jmp	 SHORT $LN50@Partition_
$LN52@Partition_:
  000f3	83 65 28 00	 and	 DWORD PTR tv220[ebp], 0
$LN50@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000f7	0f b6 45 28	 movzx	 eax, BYTE PTR tv220[ebp]
  000fb	85 c0		 test	 eax, eax
  000fd	75 2e		 jne	 SHORT $LN5@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000ff	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00102	8b 4d 60	 mov	 ecx, DWORD PTR __Plast$[ebp]
  00105	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00108	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0010b	76 09		 jbe	 SHORT $LN56@Partition_
  0010d	c7 45 24 01 00
	00 00		 mov	 DWORD PTR tv222[ebp], 1
  00114	eb 04		 jmp	 SHORT $LN54@Partition_
$LN56@Partition_:
  00116	83 65 24 00	 and	 DWORD PTR tv222[ebp], 0
$LN54@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  0011a	0f b6 45 24	 movzx	 eax, BYTE PTR tv222[ebp]
  0011e	85 c0		 test	 eax, eax
  00120	75 0b		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  00122	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00125	83 c0 08	 add	 eax, 8
  00128	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  0012b	eb a7		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  0012d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00130	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  00133	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00136	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00139	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  0013b	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0013e	83 c0 08	 add	 eax, 8
  00141	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  00144	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00147	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  0014a	0f 83 b8 00 00
	00		 jae	 $LN10@Partition_
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00150	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00153	8b 4d 5c	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00156	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00159	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0015c	76 09		 jbe	 SHORT $LN60@Partition_
  0015e	c7 45 20 01 00
	00 00		 mov	 DWORD PTR tv224[ebp], 1
  00165	eb 04		 jmp	 SHORT $LN58@Partition_
$LN60@Partition_:
  00167	83 65 20 00	 and	 DWORD PTR tv224[ebp], 0
$LN58@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0016b	0f b6 45 20	 movzx	 eax, BYTE PTR tv224[ebp]
  0016f	85 c0		 test	 eax, eax
  00171	74 07		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  00173	eb c6		 jmp	 SHORT $LN9@Partition_

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  00175	e9 89 00 00 00	 jmp	 $LN16@Partition_
$LN15@Partition_:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  0017a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0017d	8b 4d 64	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00180	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00183	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00186	76 09		 jbe	 SHORT $LN64@Partition_
  00188	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv226[ebp], 1
  0018f	eb 04		 jmp	 SHORT $LN62@Partition_
$LN64@Partition_:
  00191	83 65 1c 00	 and	 DWORD PTR tv226[ebp], 0
$LN62@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  00195	0f b6 45 1c	 movzx	 eax, BYTE PTR tv226[ebp]
  00199	85 c0		 test	 eax, eax
  0019b	74 04		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  0019d	eb 69		 jmp	 SHORT $LN10@Partition_
  0019f	eb 62		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  001a1	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001a4	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  001a7	74 51		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  001a9	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001ac	89 45 18	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001af	8b 45 18	 mov	 eax, DWORD PTR __Left$[ebp]
  001b2	89 45 f0	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  001b5	8b 45 f0	 mov	 eax, DWORD PTR $T30[ebp]
  001b8	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ba	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001bd	89 4d 90	 mov	 DWORD PTR __Tmp$7[ebp], ecx
  001c0	89 45 94	 mov	 DWORD PTR __Tmp$7[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001c3	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001c6	89 45 ec	 mov	 DWORD PTR $T29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  001c9	8b 45 ec	 mov	 eax, DWORD PTR $T29[ebp]
  001cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 55 18	 mov	 edx, DWORD PTR __Left$[ebp]
  001d4	89 0a		 mov	 DWORD PTR [edx], ecx
  001d6	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001d9	8d 45 90	 lea	 eax, DWORD PTR __Tmp$7[ebp]
  001dc	89 45 e8	 mov	 DWORD PTR $T28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  001df	8b 45 e8	 mov	 eax, DWORD PTR $T28[ebp]
  001e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e7	8b 55 5c	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  001ea	89 0a		 mov	 DWORD PTR [edx], ecx
  001ec	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  001ef	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001f2	83 c0 08	 add	 eax, 8
  001f5	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  001f8	eb 09		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  001fa	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001fd	83 c0 08	 add	 eax, 8
  00200	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  00203	e9 33 ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  00208	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  0020a	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0020d	83 e8 08	 sub	 eax, 8
  00210	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  00213	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00216	3b 45 58	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00219	0f 83 e9 00 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0021f	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00222	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00225	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00228	83 e8 08	 sub	 eax, 8
  0022b	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  0022e	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00231	8b 4d 64	 mov	 ecx, DWORD PTR __Pfirst$[ebp]
  00234	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00237	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0023a	76 09		 jbe	 SHORT $LN84@Partition_
  0023c	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
  00243	eb 04		 jmp	 SHORT $LN82@Partition_
$LN84@Partition_:
  00245	83 65 14 00	 and	 DWORD PTR tv152[ebp], 0
$LN82@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00249	0f b6 45 14	 movzx	 eax, BYTE PTR tv152[ebp]
  0024d	85 c0		 test	 eax, eax
  0024f	74 07		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00251	eb b7		 jmp	 SHORT $LN12@Partition_
  00253	e9 ab 00 00 00	 jmp	 $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  00258	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0025b	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0025e	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  00261	83 e8 08	 sub	 eax, 8
  00264	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00267	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0026a	8b 4d 3c	 mov	 ecx, DWORD PTR __First$[ebp]
  0026d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00270	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00273	76 09		 jbe	 SHORT $LN90@Partition_
  00275	c7 45 10 01 00
	00 00		 mov	 DWORD PTR tv231[ebp], 1
  0027c	eb 04		 jmp	 SHORT $LN88@Partition_
$LN90@Partition_:
  0027e	83 65 10 00	 and	 DWORD PTR tv231[ebp], 0
$LN88@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  00282	0f b6 45 10	 movzx	 eax, BYTE PTR tv231[ebp]
  00286	85 c0		 test	 eax, eax
  00288	74 04		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  0028a	eb 7c		 jmp	 SHORT $LN13@Partition_
  0028c	eb 75		 jmp	 SHORT $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  0028e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00291	83 e8 08	 sub	 eax, 8
  00294	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00297	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0029a	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0029d	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  002a0	83 e8 08	 sub	 eax, 8
  002a3	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  002a6	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002a9	3b 45 38	 cmp	 eax, DWORD PTR __First$[ebp]
  002ac	74 55		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  002ae	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002b1	89 45 54	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  002b4	8b 45 54	 mov	 eax, DWORD PTR __First$[ebp]
  002b7	83 e8 08	 sub	 eax, 8
  002ba	89 45 54	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  002bd	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002c0	89 45 0c	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002c3	8b 45 0c	 mov	 eax, DWORD PTR __Left$[ebp]
  002c6	89 45 e4	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  002c9	8b 45 e4	 mov	 eax, DWORD PTR $T27[ebp]
  002cc	8b 08		 mov	 ecx, DWORD PTR [eax]
  002ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002d1	89 4d 88	 mov	 DWORD PTR __Tmp$6[ebp], ecx
  002d4	89 45 8c	 mov	 DWORD PTR __Tmp$6[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002d7	8b 45 54	 mov	 eax, DWORD PTR __First$[ebp]
  002da	89 45 e0	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  002dd	8b 45 e0	 mov	 eax, DWORD PTR $T26[ebp]
  002e0	8b 08		 mov	 ecx, DWORD PTR [eax]
  002e2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002e5	8b 55 0c	 mov	 edx, DWORD PTR __Left$[ebp]
  002e8	89 0a		 mov	 DWORD PTR [edx], ecx
  002ea	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002ed	8d 45 88	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  002f0	89 45 dc	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  002f3	8b 45 dc	 mov	 eax, DWORD PTR $T25[ebp]
  002f6	8b 08		 mov	 ecx, DWORD PTR [eax]
  002f8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002fb	8b 55 54	 mov	 edx, DWORD PTR __First$[ebp]
  002fe	89 0a		 mov	 DWORD PTR [edx], ecx
  00300	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  00303	e9 02 ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  00308	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0030b	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  0030e	75 31		 jne	 SHORT $LN26@Partition_
  00310	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00313	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00316	75 29		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00318	8d 45 64	 lea	 eax, DWORD PTR __Pfirst$[ebp]
  0031b	89 45 d8	 mov	 DWORD PTR $T24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0031e	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00321	8b 4d d8	 mov	 ecx, DWORD PTR $T24[ebp]
  00324	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00326	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00328	8d 45 60	 lea	 eax, DWORD PTR __Plast$[ebp]
  0032b	89 45 d4	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0032e	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00331	8b 4d d4	 mov	 ecx, DWORD PTR $T23[ebp]
  00334	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00336	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00339	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0033c	e9 04 02 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  00341	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00344	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  00347	0f 85 c3 00 00
	00		 jne	 $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  0034d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00350	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00353	74 4c		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  00355	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00358	89 45 04	 mov	 DWORD PTR __Right$[ebp], eax
  0035b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0035e	89 45 08	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00361	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00364	89 45 d0	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00367	8b 45 d0	 mov	 eax, DWORD PTR $T22[ebp]
  0036a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0036c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0036f	89 4d 80	 mov	 DWORD PTR __Tmp$5[ebp], ecx
  00372	89 45 84	 mov	 DWORD PTR __Tmp$5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00375	8b 45 04	 mov	 eax, DWORD PTR __Right$[ebp]
  00378	89 45 cc	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0037b	8b 45 cc	 mov	 eax, DWORD PTR $T21[ebp]
  0037e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00380	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00383	8b 55 08	 mov	 edx, DWORD PTR __Left$[ebp]
  00386	89 0a		 mov	 DWORD PTR [edx], ecx
  00388	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0038b	8d 45 80	 lea	 eax, DWORD PTR __Tmp$5[ebp]
  0038e	89 45 c8	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00391	8b 45 c8	 mov	 eax, DWORD PTR $T20[ebp]
  00394	8b 08		 mov	 ecx, DWORD PTR [eax]
  00396	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00399	8b 55 04	 mov	 edx, DWORD PTR __Right$[ebp]
  0039c	89 0a		 mov	 DWORD PTR [edx], ecx
  0039e	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  003a1	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  003a4	83 c0 08	 add	 eax, 8
  003a7	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  003aa	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003ad	89 45 00	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003b0	8b 45 00	 mov	 eax, DWORD PTR __Left$[ebp]
  003b3	89 45 c4	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003b6	8b 45 c4	 mov	 eax, DWORD PTR $T19[ebp]
  003b9	8b 08		 mov	 ecx, DWORD PTR [eax]
  003bb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003be	89 8d 78 ff ff
	ff		 mov	 DWORD PTR __Tmp$4[ebp], ecx
  003c4	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Tmp$4[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003ca	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  003cd	89 45 c0	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003d0	8b 45 c0	 mov	 eax, DWORD PTR $T18[ebp]
  003d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  003d5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003d8	8b 55 00	 mov	 edx, DWORD PTR __Left$[ebp]
  003db	89 0a		 mov	 DWORD PTR [edx], ecx
  003dd	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003e0	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$4[ebp]
  003e6	89 45 bc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  003e9	8b 45 bc	 mov	 eax, DWORD PTR $T17[ebp]
  003ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003f1	8b 55 5c	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  003f4	89 0a		 mov	 DWORD PTR [edx], ecx
  003f6	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  003f9	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003fc	83 c0 08	 add	 eax, 8
  003ff	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  00402	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00405	83 c0 08	 add	 eax, 8
  00408	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
  0040b	e9 30 01 00 00	 jmp	 $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00410	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00413	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00416	0f 85 c9 00 00
	00		 jne	 $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  0041c	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0041f	83 e8 08	 sub	 eax, 8
  00422	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
  00425	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00428	83 e8 08	 sub	 eax, 8
  0042b	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0042e	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00431	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00434	74 4f		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  00436	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00439	89 45 fc	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0043c	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0043f	89 45 b8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00442	8b 45 b8	 mov	 eax, DWORD PTR $T16[ebp]
  00445	8b 08		 mov	 ecx, DWORD PTR [eax]
  00447	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0044a	89 8d 70 ff ff
	ff		 mov	 DWORD PTR __Tmp$3[ebp], ecx
  00450	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Tmp$3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00456	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  00459	89 45 b4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0045c	8b 45 b4	 mov	 eax, DWORD PTR $T15[ebp]
  0045f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00461	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00464	8b 55 58	 mov	 edx, DWORD PTR __Glast$[ebp]
  00467	89 0a		 mov	 DWORD PTR [edx], ecx
  00469	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0046c	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$3[ebp]
  00472	89 45 b0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00475	8b 45 b0	 mov	 eax, DWORD PTR $T14[ebp]
  00478	8b 08		 mov	 ecx, DWORD PTR [eax]
  0047a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0047d	8b 55 fc	 mov	 edx, DWORD PTR __Right$[ebp]
  00480	89 0a		 mov	 DWORD PTR [edx], ecx
  00482	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  00485	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00488	83 e8 08	 sub	 eax, 8
  0048b	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
  0048e	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00491	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
  00494	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00497	89 45 f8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0049a	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  0049d	89 45 ac	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  004a0	8b 45 ac	 mov	 eax, DWORD PTR $T13[ebp]
  004a3	8b 08		 mov	 ecx, DWORD PTR [eax]
  004a5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004a8	89 8d 68 ff ff
	ff		 mov	 DWORD PTR __Tmp$2[ebp], ecx
  004ae	89 85 6c ff ff
	ff		 mov	 DWORD PTR __Tmp$2[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004b4	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  004b7	89 45 a8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  004ba	8b 45 a8	 mov	 eax, DWORD PTR $T12[ebp]
  004bd	8b 08		 mov	 ecx, DWORD PTR [eax]
  004bf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004c2	8b 55 f8	 mov	 edx, DWORD PTR __Left$[ebp]
  004c5	89 0a		 mov	 DWORD PTR [edx], ecx
  004c7	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004ca	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$2[ebp]
  004d0	89 45 a4	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  004d3	8b 45 a4	 mov	 eax, DWORD PTR $T11[ebp]
  004d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  004d8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004db	8b 55 f4	 mov	 edx, DWORD PTR __Right$[ebp]
  004de	89 0a		 mov	 DWORD PTR [edx], ecx
  004e0	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  004e3	eb 5b		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  004e5	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  004e8	83 e8 08	 sub	 eax, 8
  004eb	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004ee	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  004f1	89 45 a0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  004f4	8b 45 a0	 mov	 eax, DWORD PTR $T10[ebp]
  004f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  004fc	89 8d 60 ff ff
	ff		 mov	 DWORD PTR __Tmp$1[ebp], ecx
  00502	89 85 64 ff ff
	ff		 mov	 DWORD PTR __Tmp$1[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00508	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0050b	89 45 9c	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0050e	8b 45 9c	 mov	 eax, DWORD PTR $T9[ebp]
  00511	8b 08		 mov	 ecx, DWORD PTR [eax]
  00513	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00516	8b 55 5c	 mov	 edx, DWORD PTR __Gfirst$[ebp]
  00519	89 0a		 mov	 DWORD PTR [edx], ecx
  0051b	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0051e	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$1[ebp]
  00524	89 45 98	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00527	8b 45 98	 mov	 eax, DWORD PTR $T8[ebp]
  0052a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0052c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0052f	8b 55 58	 mov	 edx, DWORD PTR __Glast$[ebp]
  00532	89 0a		 mov	 DWORD PTR [edx], ecx
  00534	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  00537	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0053a	83 c0 08	 add	 eax, 8
  0053d	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  00540	e9 f4 fb ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  00545	83 c5 68	 add	 ebp, 104		; 00000068H
  00548	c9		 leave
  00549	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ENDP ; std::_Partition_by_median_guess_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Val$1 = -24						; size = 8
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Bottom$ = -8						; size = 4
__Hole$4 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z PROC ; std::_Make_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 03	 sar	 eax, 3
  0000f	89 45 f8	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00012	8b 45 f8	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax
$LN4@Make_heap_:
  0001a	83 7d fc 00	 cmp	 DWORD PTR __Hole$4[ebp], 0
  0001e	7e 40		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  00023	48		 dec	 eax
  00024	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00030	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	89 4d e8	 mov	 DWORD PTR __Val$1[ebp], ecx
  0003e	89 45 ec	 mov	 DWORD PTR __Val$1[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00041	8d 45 e8	 lea	 eax, DWORD PTR __Val$1[ebp]
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  00047	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0004a	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0004d	ff 75 f8	 push	 DWORD PTR __Bottom$[ebp]
  00050	ff 75 fc	 push	 DWORD PTR __Hole$4[ebp]
  00053	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00056	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAUSCRCWithNumber@CArea@@U12@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@HH$$QAU12@UCRCNumComp@2@@Z ; std::_Pop_heap_hole_by_index<CArea::SCRCWithNumber *,CArea::SCRCWithNumber,CArea::CRCNumComp>
  0005b	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  0005e	eb ba		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  00060	c9		 leave
  00061	c3		 ret	 0
??$_Make_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ENDP ; std::_Make_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0UCRCNumComp@2@@Z
_TEXT	SEGMENT
__Val$1 = -56						; size = 8
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
tv79 = -28						; size = 4
tv130 = -24						; size = 4
__Dest$ = -20						; size = 4
__Prev$7 = -16						; size = 4
__Last$ = -12						; size = 4
__Mid$8 = -8						; size = 4
__Hole$9 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0UCRCNumComp@2@@Z PROC ; std::_Insertion_sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000c	0f 84 31 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00012	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Mid$8[ebp], eax
$LN4@Insertion_:
  00018	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	89 45 f8	 mov	 DWORD PTR __Mid$8[ebp], eax
  00021	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00027	0f 84 16 01 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00030	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00036	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00039	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  0003c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	89 4d c8	 mov	 DWORD PTR __Val$1[ebp], ecx
  00044	89 45 cc	 mov	 DWORD PTR __Val$1[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004a	8b 4d cc	 mov	 ecx, DWORD PTR __Val$1[ebp+4]
  0004d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00050	76 09		 jbe	 SHORT $LN17@Insertion_
  00052	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00059	eb 04		 jmp	 SHORT $LN15@Insertion_
$LN17@Insertion_:
  0005b	83 65 e8 00	 and	 DWORD PTR tv130[ebp], 0
$LN15@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0005f	0f b6 45 e8	 movzx	 eax, BYTE PTR tv130[ebp]
  00063	85 c0		 test	 eax, eax
  00065	74 72		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00067	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  0006a	83 c0 08	 add	 eax, 8
  0006d	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
  00070	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00073	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
  00076	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00079	89 45 f4	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  0007c	ff 75 ec	 push	 DWORD PTR __Dest$[ebp]
  0007f	ff 75 f4	 push	 DWORD PTR __Last$[ebp]
  00082	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ; std::_Copy_backward_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
  0008a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008d	eb 32		 jmp	 SHORT $LN19@Insertion_
$LN20@Insertion_:

; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  0008f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00092	3b 45 f4	 cmp	 eax, DWORD PTR __Last$[ebp]
  00095	74 2a		 je	 SHORT $LN19@Insertion_

; 4701 :         *--_Dest = _STD move(*--_Last);

  00097	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  0009a	83 e8 08	 sub	 eax, 8
  0009d	89 45 f4	 mov	 DWORD PTR __Last$[ebp], eax
  000a0	8b 45 ec	 mov	 eax, DWORD PTR __Dest$[ebp]
  000a3	83 e8 08	 sub	 eax, 8
  000a6	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a9	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  000ac	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4701 :         *--_Dest = _STD move(*--_Last);

  000af	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	8b 55 ec	 mov	 edx, DWORD PTR __Dest$[ebp]
  000ba	89 0a		 mov	 DWORD PTR [edx], ecx
  000bc	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 4702 :     }

  000bf	eb ce		 jmp	 SHORT $LN20@Insertion_
$LN19@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000c1	8d 45 c8	 lea	 eax, DWORD PTR __Val$1[ebp]
  000c4	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000c7	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  000ca	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000d2	89 0a		 mov	 DWORD PTR [edx], ecx
  000d4	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 7420 :             } else { // look for insertion point after first

  000d7	eb 65		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000d9	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  000dc	89 45 f0	 mov	 DWORD PTR __Prev$7[ebp], eax
  000df	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000e4	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
$LN7@Insertion_:
  000e7	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000ea	83 e8 08	 sub	 eax, 8
  000ed	89 45 f0	 mov	 DWORD PTR __Prev$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 190  : 				return lhs.dwNumber > rhs.dwNumber;

  000f0	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR __Val$1[ebp+4]
  000f6	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000f9	76 09		 jbe	 SHORT $LN31@Insertion_
  000fb	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00102	eb 04		 jmp	 SHORT $LN29@Insertion_
$LN31@Insertion_:
  00104	83 65 e4 00	 and	 DWORD PTR tv79[ebp], 0
$LN29@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00108	0f b6 45 e4	 movzx	 eax, BYTE PTR tv79[ebp]
  0010c	85 c0		 test	 eax, eax
  0010e	74 18		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00110	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  00113	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  00116	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00119	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0011e	8b 55 fc	 mov	 edx, DWORD PTR __Hole$9[ebp]
  00121	89 0a		 mov	 DWORD PTR [edx], ecx
  00123	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 7423 :                 }

  00126	eb b9		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00128	8d 45 c8	 lea	 eax, DWORD PTR __Val$1[ebp]
  0012b	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  0012e	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00131	8b 08		 mov	 ecx, DWORD PTR [eax]
  00133	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00136	8b 55 fc	 mov	 edx, DWORD PTR __Hole$9[ebp]
  00139	89 0a		 mov	 DWORD PTR [edx], ecx
  0013b	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN10@Insertion_:

; 7426 :             }
; 7427 :         }

  0013e	e9 d5 fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  00143	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  00146	c9		 leave
  00147	c3		 ret	 0
??$_Insertion_sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0UCRCNumComp@2@@Z ENDP ; std::_Insertion_sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCEffectInstance@@PAPAV1@@0@PAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -164						; size = 4
__Tmp$2 = -160						; size = 4
$T3 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
__Tmp$6 = -144						; size = 4
$T7 = -140						; size = 4
$T8 = -136						; size = 4
$T9 = -132						; size = 4
__Tmp$10 = -128						; size = 4
$T11 = -124						; size = 4
$T12 = -120						; size = 4
$T13 = -116						; size = 4
__Tmp$14 = -112						; size = 4
$T15 = -108						; size = 4
$T16 = -104						; size = 4
$T17 = -100						; size = 4
__Tmp$18 = -96						; size = 4
$T19 = -92						; size = 4
$T20 = -88						; size = 4
$T21 = -84						; size = 4
$T22 = -80						; size = 4
$T23 = -76						; size = 4
__Tmp$24 = -72						; size = 4
$T25 = -68						; size = 4
$T26 = -64						; size = 4
_pkLeft$ = -60						; size = 4
_pkRight$ = -56						; size = 4
_pkLeft$ = -52						; size = 4
_pkRight$ = -48						; size = 4
$T27 = -44						; size = 4
__Tmp$28 = -40						; size = 4
$T29 = -36						; size = 4
$T30 = -32						; size = 4
_pkLeft$ = -28						; size = 4
_pkRight$ = -24						; size = 4
_pkLeft$ = -20						; size = 4
_pkRight$ = -16						; size = 4
_pkLeft$ = -12						; size = 4
_pkRight$ = -8						; size = 4
_pkLeft$ = -4						; size = 4
_pkRight$ = 0						; size = 4
_pkLeft$ = 4						; size = 4
_pkRight$ = 8						; size = 4
_pkLeft$ = 12						; size = 4
_pkRight$ = 16						; size = 4
__Right$ = 20						; size = 4
__Left$ = 24						; size = 4
__Right$ = 28						; size = 4
__Left$ = 32						; size = 4
__Right$ = 36						; size = 4
__Left$ = 40						; size = 4
__Left$ = 44						; size = 4
__Left$ = 48						; size = 4
__Mid$ = 52						; size = 4
__First$ = 56						; size = 4
__First$ = 60						; size = 4
__First$ = 64						; size = 4
__First$ = 68						; size = 4
__First$ = 72						; size = 4
__First$ = 76						; size = 4
__First$ = 80						; size = 4
__First$ = 84						; size = 4
__Glast$ = 88						; size = 4
__Gfirst$ = 92						; size = 4
__Plast$ = 96						; size = 4
__Pfirst$ = 100						; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCEffectInstance@@PAPAV1@@0@PAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Partition_by_median_guess_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000b	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  00011	c1 f8 02	 sar	 eax, 2
  00014	d1 f8		 sar	 eax, 1
  00016	8b 4d 74	 mov	 ecx, DWORD PTR __First$[ebp]
  00019	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0001c	89 45 34	 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0001f	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00022	89 45 50	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00025	8b 45 50	 mov	 eax, DWORD PTR __First$[ebp]
  00028	83 e8 04	 sub	 eax, 4
  0002b	89 45 50	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0002e	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  00031	ff 75 50	 push	 DWORD PTR __First$[ebp]
  00034	ff 75 34	 push	 DWORD PTR __Mid$[ebp]
  00037	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@00UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Guess_median_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00042	8b 45 34	 mov	 eax, DWORD PTR __Mid$[ebp]
  00045	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00048	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0004b	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0004e	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00057	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  0005a	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0005d	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00060	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00063	73 6d		 jae	 SHORT $LN4@Partition_
  00065	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00068	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0006b	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  0006e	83 e8 04	 sub	 eax, 4
  00071	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00074	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00077	8b 00		 mov	 eax, DWORD PTR [eax]
  00079	89 45 10	 mov	 DWORD PTR _pkRight$[ebp], eax
  0007c	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  0007f	8b 00		 mov	 eax, DWORD PTR [eax]
  00081	89 45 0c	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00084	ff 75 10	 push	 DWORD PTR _pkRight$[ebp]
  00087	8b 4d 0c	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  0008a	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0008f	0f b6 c0	 movzx	 eax, al
  00092	85 c0		 test	 eax, eax
  00094	75 3c		 jne	 SHORT $LN4@Partition_
  00096	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00099	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0009c	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  0009f	83 e8 04	 sub	 eax, 4
  000a2	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000a5	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	89 45 08	 mov	 DWORD PTR _pkRight$[ebp], eax
  000ad	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000b0	8b 00		 mov	 eax, DWORD PTR [eax]
  000b2	89 45 04	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  000b5	ff 75 08	 push	 DWORD PTR _pkRight$[ebp]
  000b8	8b 4d 04	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  000bb	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000c0	0f b6 c0	 movzx	 eax, al
  000c3	85 c0		 test	 eax, eax
  000c5	75 0b		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  000c7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000ca	83 e8 04	 sub	 eax, 4
  000cd	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  000d0	eb 8b		 jmp	 SHORT $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000d2	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000d5	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  000d8	73 4f		 jae	 SHORT $LN5@Partition_
  000da	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000dd	8b 00		 mov	 eax, DWORD PTR [eax]
  000df	89 45 00	 mov	 DWORD PTR _pkRight$[ebp], eax
  000e2	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000e5	8b 00		 mov	 eax, DWORD PTR [eax]
  000e7	89 45 fc	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  000ea	ff 75 00	 push	 DWORD PTR _pkRight$[ebp]
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  000f0	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000f5	0f b6 c0	 movzx	 eax, al
  000f8	85 c0		 test	 eax, eax
  000fa	75 2d		 jne	 SHORT $LN5@Partition_
  000fc	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	89 45 f8	 mov	 DWORD PTR _pkRight$[ebp], eax
  00104	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00107	8b 00		 mov	 eax, DWORD PTR [eax]
  00109	89 45 f4	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  0010c	ff 75 f8	 push	 DWORD PTR _pkRight$[ebp]
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00112	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00117	0f b6 c0	 movzx	 eax, al
  0011a	85 c0		 test	 eax, eax
  0011c	75 0b		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  0011e	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00121	83 c0 04	 add	 eax, 4
  00124	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  00127	eb a9		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  00129	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0012c	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  0012f	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00132	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00135	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  00137	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0013a	83 c0 04	 add	 eax, 4
  0013d	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  00140	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00143	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00146	0f 83 a1 00 00
	00		 jae	 $LN10@Partition_

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0014c	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0014f	8b 00		 mov	 eax, DWORD PTR [eax]
  00151	89 45 f0	 mov	 DWORD PTR _pkRight$[ebp], eax
  00154	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00157	8b 00		 mov	 eax, DWORD PTR [eax]
  00159	89 45 ec	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  0015c	ff 75 f0	 push	 DWORD PTR _pkRight$[ebp]
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00162	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  00167	0f b6 c0	 movzx	 eax, al
  0016a	85 c0		 test	 eax, eax
  0016c	74 04		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  0016e	eb c7		 jmp	 SHORT $LN9@Partition_
  00170	eb 76		 jmp	 SHORT $LN16@Partition_
$LN15@Partition_:

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  00172	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00175	8b 00		 mov	 eax, DWORD PTR [eax]
  00177	89 45 e8	 mov	 DWORD PTR _pkRight$[ebp], eax
  0017a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0017d	8b 00		 mov	 eax, DWORD PTR [eax]
  0017f	89 45 e4	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00182	ff 75 e8	 push	 DWORD PTR _pkRight$[ebp]
  00185	8b 4d e4	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00188	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0018d	0f b6 c0	 movzx	 eax, al
  00190	85 c0		 test	 eax, eax
  00192	74 04		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  00194	eb 57		 jmp	 SHORT $LN10@Partition_
  00196	eb 50		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  00198	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0019b	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  0019e	74 3f		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  001a0	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001a3	89 45 30	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001a6	8b 45 30	 mov	 eax, DWORD PTR __Left$[ebp]
  001a9	89 45 e0	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  001ac	8b 45 e0	 mov	 eax, DWORD PTR $T30[ebp]
  001af	8b 00		 mov	 eax, DWORD PTR [eax]
  001b1	89 45 d8	 mov	 DWORD PTR __Tmp$28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001b4	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001b7	89 45 dc	 mov	 DWORD PTR $T29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  001ba	8b 45 30	 mov	 eax, DWORD PTR __Left$[ebp]
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR $T29[ebp]
  001c0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001c2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001c4	8d 45 d8	 lea	 eax, DWORD PTR __Tmp$28[ebp]
  001c7	89 45 d4	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  001ca	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001cd	8b 4d d4	 mov	 ecx, DWORD PTR $T27[ebp]
  001d0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001d2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  001d4	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001d7	83 c0 04	 add	 eax, 4
  001da	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  001dd	eb 09		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  001df	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001e2	83 c0 04	 add	 eax, 4
  001e5	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  001e8	e9 4a ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  001ed	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  001ef	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  001f2	83 e8 04	 sub	 eax, 4
  001f5	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  001f8	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  001fb	3b 45 58	 cmp	 eax, DWORD PTR __Glast$[ebp]
  001fe	0f 83 d5 00 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00204	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00207	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0020a	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  0020d	83 e8 04	 sub	 eax, 4
  00210	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00213	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00216	8b 00		 mov	 eax, DWORD PTR [eax]
  00218	89 45 d0	 mov	 DWORD PTR _pkRight$[ebp], eax
  0021b	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  0021e	8b 00		 mov	 eax, DWORD PTR [eax]
  00220	89 45 cc	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  00223	ff 75 d0	 push	 DWORD PTR _pkRight$[ebp]
  00226	8b 4d cc	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00229	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0022e	0f b6 c0	 movzx	 eax, al
  00231	85 c0		 test	 eax, eax
  00233	74 07		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00235	eb b8		 jmp	 SHORT $LN12@Partition_
  00237	e9 98 00 00 00	 jmp	 $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0023c	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0023f	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00242	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  00245	83 e8 04	 sub	 eax, 4
  00248	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0024b	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  0024e	8b 00		 mov	 eax, DWORD PTR [eax]
  00250	89 45 c8	 mov	 DWORD PTR _pkRight$[ebp], eax
  00253	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00256	8b 00		 mov	 eax, DWORD PTR [eax]
  00258	89 45 c4	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  0025b	ff 75 c8	 push	 DWORD PTR _pkRight$[ebp]
  0025e	8b 4d c4	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00261	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  00266	0f b6 c0	 movzx	 eax, al
  00269	85 c0		 test	 eax, eax
  0026b	74 04		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  0026d	eb 6a		 jmp	 SHORT $LN13@Partition_
  0026f	eb 63		 jmp	 SHORT $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  00271	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00274	83 e8 04	 sub	 eax, 4
  00277	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0027a	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0027d	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00280	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00283	83 e8 04	 sub	 eax, 4
  00286	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  00289	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0028c	3b 45 38	 cmp	 eax, DWORD PTR __First$[ebp]
  0028f	74 43		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  00291	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00294	89 45 54	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00297	8b 45 54	 mov	 eax, DWORD PTR __First$[ebp]
  0029a	83 e8 04	 sub	 eax, 4
  0029d	89 45 54	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  002a0	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002a3	89 45 2c	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002a6	8b 45 2c	 mov	 eax, DWORD PTR __Left$[ebp]
  002a9	89 45 c0	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  002ac	8b 45 c0	 mov	 eax, DWORD PTR $T26[ebp]
  002af	8b 00		 mov	 eax, DWORD PTR [eax]
  002b1	89 45 b8	 mov	 DWORD PTR __Tmp$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002b4	8b 45 54	 mov	 eax, DWORD PTR __First$[ebp]
  002b7	89 45 bc	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  002ba	8b 45 2c	 mov	 eax, DWORD PTR __Left$[ebp]
  002bd	8b 4d bc	 mov	 ecx, DWORD PTR $T25[ebp]
  002c0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002c2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002c4	8d 45 b8	 lea	 eax, DWORD PTR __Tmp$24[ebp]
  002c7	89 45 b4	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  002ca	8b 45 54	 mov	 eax, DWORD PTR __First$[ebp]
  002cd	8b 4d b4	 mov	 ecx, DWORD PTR $T23[ebp]
  002d0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002d2	89 08		 mov	 DWORD PTR [eax], ecx
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  002d4	e9 16 ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  002d9	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002dc	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  002df	75 31		 jne	 SHORT $LN26@Partition_
  002e1	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  002e4	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  002e7	75 29		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  002e9	8d 45 64	 lea	 eax, DWORD PTR __Pfirst$[ebp]
  002ec	89 45 b0	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  002ef	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002f2	8b 4d b0	 mov	 ecx, DWORD PTR $T22[ebp]
  002f5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f7	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  002f9	8d 45 60	 lea	 eax, DWORD PTR __Plast$[ebp]
  002fc	89 45 ac	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  002ff	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00302	8b 4d ac	 mov	 ecx, DWORD PTR $T21[ebp]
  00305	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00307	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  0030a	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0030d	e9 bc 01 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  00312	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00315	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  00318	0f 85 96 00 00
	00		 jne	 $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  0031e	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00321	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00324	74 3a		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  00326	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00329	89 45 24	 mov	 DWORD PTR __Right$[ebp], eax
  0032c	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0032f	89 45 28	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00332	8b 45 28	 mov	 eax, DWORD PTR __Left$[ebp]
  00335	89 45 a8	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00338	8b 45 a8	 mov	 eax, DWORD PTR $T20[ebp]
  0033b	8b 00		 mov	 eax, DWORD PTR [eax]
  0033d	89 45 a0	 mov	 DWORD PTR __Tmp$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00340	8b 45 24	 mov	 eax, DWORD PTR __Right$[ebp]
  00343	89 45 a4	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00346	8b 45 28	 mov	 eax, DWORD PTR __Left$[ebp]
  00349	8b 4d a4	 mov	 ecx, DWORD PTR $T19[ebp]
  0034c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0034e	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00350	8d 45 a0	 lea	 eax, DWORD PTR __Tmp$18[ebp]
  00353	89 45 9c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00356	8b 45 24	 mov	 eax, DWORD PTR __Right$[ebp]
  00359	8b 4d 9c	 mov	 ecx, DWORD PTR $T17[ebp]
  0035c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0035e	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  00360	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00363	83 c0 04	 add	 eax, 4
  00366	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  00369	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0036c	89 45 20	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0036f	8b 45 20	 mov	 eax, DWORD PTR __Left$[ebp]
  00372	89 45 98	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00375	8b 45 98	 mov	 eax, DWORD PTR $T16[ebp]
  00378	8b 00		 mov	 eax, DWORD PTR [eax]
  0037a	89 45 90	 mov	 DWORD PTR __Tmp$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0037d	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00380	89 45 94	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00383	8b 45 20	 mov	 eax, DWORD PTR __Left$[ebp]
  00386	8b 4d 94	 mov	 ecx, DWORD PTR $T15[ebp]
  00389	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0038b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0038d	8d 45 90	 lea	 eax, DWORD PTR __Tmp$14[ebp]
  00390	89 45 8c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00393	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00396	8b 4d 8c	 mov	 ecx, DWORD PTR $T13[ebp]
  00399	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0039b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  0039d	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003a0	83 c0 04	 add	 eax, 4
  003a3	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  003a6	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  003a9	83 c0 04	 add	 eax, 4
  003ac	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
  003af	e9 15 01 00 00	 jmp	 $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  003b4	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  003b7	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  003ba	0f 85 b1 00 00
	00		 jne	 $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  003c0	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  003c3	83 e8 04	 sub	 eax, 4
  003c6	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
  003c9	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003cc	83 e8 04	 sub	 eax, 4
  003cf	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  003d2	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  003d5	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  003d8	74 3a		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  003da	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003dd	89 45 1c	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003e0	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  003e3	89 45 88	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003e6	8b 45 88	 mov	 eax, DWORD PTR $T12[ebp]
  003e9	8b 00		 mov	 eax, DWORD PTR [eax]
  003eb	89 45 80	 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003ee	8b 45 1c	 mov	 eax, DWORD PTR __Right$[ebp]
  003f1	89 45 84	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003f4	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  003f7	8b 4d 84	 mov	 ecx, DWORD PTR $T11[ebp]
  003fa	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003fc	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003fe	8d 45 80	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  00401	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00407	8b 45 1c	 mov	 eax, DWORD PTR __Right$[ebp]
  0040a	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00410	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00412	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  00414	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00417	83 e8 04	 sub	 eax, 4
  0041a	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
  0041d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00420	89 45 14	 mov	 DWORD PTR __Right$[ebp], eax
  00423	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00426	89 45 18	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00429	8b 45 18	 mov	 eax, DWORD PTR __Left$[ebp]
  0042c	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00432	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00438	8b 00		 mov	 eax, DWORD PTR [eax]
  0043a	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00440	8b 45 14	 mov	 eax, DWORD PTR __Right$[ebp]
  00443	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00449	8b 45 18	 mov	 eax, DWORD PTR __Left$[ebp]
  0044c	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  00452	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00454	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00456	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$6[ebp]
  0045c	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00462	8b 45 14	 mov	 eax, DWORD PTR __Right$[ebp]
  00465	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  0046b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0046d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  0046f	eb 58		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  00471	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00474	83 e8 04	 sub	 eax, 4
  00477	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0047a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0047d	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00483	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00489	8b 00		 mov	 eax, DWORD PTR [eax]
  0048b	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00491	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00494	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0049a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0049d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  004a3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004a5	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004a7	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$2[ebp]
  004ad	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  004b3	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  004b6	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  004bc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004be	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  004c0	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  004c3	83 c0 04	 add	 eax, 4
  004c6	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  004c9	e9 67 fc ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  004ce	83 c5 68	 add	 ebp, 104		; 00000068H
  004d1	c9		 leave
  004d2	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCEffectInstance@@PAPAV1@@0@PAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Partition_by_median_guess_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Val$2 = -16						; size = 4
$T3 = -12						; size = 4
__Bottom$ = -8						; size = 4
__Hole$4 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Make_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00012	8b 45 f8	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax
$LN4@Make_heap_:
  0001a	83 7d fc 00	 cmp	 DWORD PTR __Hole$4[ebp], 0
  0001e	7e 3a		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  00023	48		 dec	 eax
  00024	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00030	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 f0	 mov	 DWORD PTR __Val$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003b	8d 45 f0	 lea	 eax, DWORD PTR __Val$2[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  00041	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00044	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00047	ff 75 f8	 push	 DWORD PTR __Bottom$[ebp]
  0004a	ff 75 fc	 push	 DWORD PTR __Hole$4[ebp]
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAPAVCEffectInstance@@PAV1@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@HH$$QAPAV1@UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Pop_heap_hole_by_index<CEffectInstance * *,CEffectInstance *,CArea_LessEffectInstancePtrRenderOrder>
  00055	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  00058	eb c0		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  0005a	c9		 leave
  0005b	c3		 ret	 0
??$_Make_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Make_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0UCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
_pkLeft$ = -52						; size = 4
_pkRight$ = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
_pkLeft$ = -36						; size = 4
_pkRight$ = -32						; size = 4
$T5 = -28						; size = 4
__Val$6 = -24						; size = 4
__Dest$ = -20						; size = 4
__Prev$7 = -16						; size = 4
__Last$ = -12						; size = 4
__Mid$8 = -8						; size = 4
__Hole$9 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0UCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Insertion_sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000c	0f 84 13 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00012	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Mid$8[ebp], eax
$LN4@Insertion_:
  00018	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f8	 mov	 DWORD PTR __Mid$8[ebp], eax
  00021	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00027	0f 84 f8 00 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00030	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00033	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00036	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00039	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Val$6[ebp], eax

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 45 e0	 mov	 DWORD PTR _pkRight$[ebp], eax
  00049	8b 45 e8	 mov	 eax, DWORD PTR __Val$6[ebp]
  0004c	89 45 dc	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  0004f	ff 75 e0	 push	 DWORD PTR _pkRight$[ebp]
  00052	8b 4d dc	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  00055	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0005a	0f b6 c0	 movzx	 eax, al
  0005d	85 c0		 test	 eax, eax
  0005f	74 66		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00061	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00064	83 c0 04	 add	 eax, 4
  00067	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  0006d	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
  00070	8b 45 f8	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00073	89 45 f4	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  00076	ff 75 ec	 push	 DWORD PTR __Dest$[ebp]
  00079	ff 75 f4	 push	 DWORD PTR __Last$[ebp]
  0007c	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007f	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ; std::_Copy_backward_memmove<CEffectInstance * *,CEffectInstance * *>
  00084	83 c4 0c	 add	 esp, 12			; 0000000cH
  00087	eb 2c		 jmp	 SHORT $LN17@Insertion_
$LN18@Insertion_:

; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  00089	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0008c	3b 45 f4	 cmp	 eax, DWORD PTR __Last$[ebp]
  0008f	74 24		 je	 SHORT $LN17@Insertion_

; 4701 :         *--_Dest = _STD move(*--_Last);

  00091	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  00094	83 e8 04	 sub	 eax, 4
  00097	89 45 f4	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 ec	 mov	 eax, DWORD PTR __Dest$[ebp]
  0009d	83 e8 04	 sub	 eax, 4
  000a0	89 45 ec	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a3	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  000a6	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4701 :         *--_Dest = _STD move(*--_Last);

  000a9	8b 45 ec	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ac	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
  000af	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4702 :     }

  000b3	eb d4		 jmp	 SHORT $LN18@Insertion_
$LN17@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000b5	8d 45 e8	 lea	 eax, DWORD PTR __Val$6[ebp]
  000b8	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000bb	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000be	8b 4d d4	 mov	 ecx, DWORD PTR $T3[ebp]
  000c1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c3	89 08		 mov	 DWORD PTR [eax], ecx

; 7420 :             } else { // look for insertion point after first

  000c5	eb 59		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000c7	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  000ca	89 45 f0	 mov	 DWORD PTR __Prev$7[ebp], eax
  000cd	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000cf	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000d2	89 45 fc	 mov	 DWORD PTR __Hole$9[ebp], eax
$LN7@Insertion_:
  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000d8	83 e8 04	 sub	 eax, 4
  000db	89 45 f0	 mov	 DWORD PTR __Prev$7[ebp], eax
  000de	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000e1	8b 00		 mov	 eax, DWORD PTR [eax]
  000e3	89 45 d0	 mov	 DWORD PTR _pkRight$[ebp], eax
  000e6	8b 45 e8	 mov	 eax, DWORD PTR __Val$6[ebp]
  000e9	89 45 cc	 mov	 DWORD PTR _pkLeft$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 120  : 		return pkLeft->LessRenderOrder(pkRight);		

  000ec	ff 75 d0	 push	 DWORD PTR _pkRight$[ebp]
  000ef	8b 4d cc	 mov	 ecx, DWORD PTR _pkLeft$[ebp]
  000f2	e8 00 00 00 00	 call	 ?LessRenderOrder@CEffectInstance@@QAE_NPAV1@@Z ; CEffectInstance::LessRenderOrder
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000f7	0f b6 c0	 movzx	 eax, al
  000fa	85 c0		 test	 eax, eax
  000fc	74 12		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000fe	8b 45 f0	 mov	 eax, DWORD PTR __Prev$7[ebp]
  00101	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  00104	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00107	8b 4d c8	 mov	 ecx, DWORD PTR $T2[ebp]
  0010a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0010c	89 08		 mov	 DWORD PTR [eax], ecx

; 7423 :                 }

  0010e	eb bf		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00110	8d 45 e8	 lea	 eax, DWORD PTR __Val$6[ebp]
  00113	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  00116	8b 45 fc	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00119	8b 4d c4	 mov	 ecx, DWORD PTR $T1[ebp]
  0011c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0011e	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Insertion_:

; 7426 :             }
; 7427 :         }

  00120	e9 f3 fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  00125	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  00128	c9		 leave
  00129	c3		 ret	 0
??$_Insertion_sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Insertion_sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z
_TEXT	SEGMENT
__Al$ = -76						; size = 4
__First1$ = -72						; size = 4
__First1$ = -68						; size = 4
__First1$ = -64						; size = 4
__First1$ = -60						; size = 4
__Ptr$ = -56						; size = 4
$T1 = -52						; size = 4
__Old_ptr$ = -48					; size = 4
__Old_ptr$2 = -44					; size = 4
__Old_capacity$ = -40					; size = 4
$T3 = -36						; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
__Old_size$ = -20					; size = 4
_this$ = -16						; size = 4
__Raw_new$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 ec	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 ec	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 d8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 cc	 mov	 eax, DWORD PTR $T1[ebp]
  00065	89 45 b4	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f4	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d d8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 78		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  000a9	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000af	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  000b2	ff 75 f4	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3188 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

  000bd	8b 45 f4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]
  000c3	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 18	 push	 DWORD PTR _<_Args_2>$[ebp]
  000c9	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000cc	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3189 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  000d7	8b 45 f4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000da	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]
  000dd	03 45 18	 add	 eax, DWORD PTR _<_Args_2>$[ebp]
  000e0	89 45 c0	 mov	 DWORD PTR __First1$[ebp], eax
  000e3	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000e6	2b 45 10	 sub	 eax, DWORD PTR _<_Args_0>$[ebp]
  000e9	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ea	50		 push	 eax

; 3189 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  000eb	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  000ee	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f1	50		 push	 eax
  000f2	ff 75 c0	 push	 DWORD PTR __First1$[ebp]
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000fd	8b 45 d8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00100	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00101	50		 push	 eax
  00102	ff 75 d4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00105	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0010a	59		 pop	 ecx
  0010b	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0010f	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00112	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00114	eb 65		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  00116	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00119	89 45 d0	 mov	 DWORD PTR __Old_ptr$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011c	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  0011f	ff 75 d0	 push	 DWORD PTR __Old_ptr$[ebp]
  00122	ff 75 f4	 push	 DWORD PTR __Raw_new$[ebp]
  00125	e8 00 00 00 00	 call	 _memcpy
  0012a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3188 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);

  0012d	8b 45 f4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00130	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]
  00133	89 45 bc	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00136	ff 75 18	 push	 DWORD PTR _<_Args_2>$[ebp]
  00139	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  0013c	ff 75 bc	 push	 DWORD PTR __First1$[ebp]
  0013f	e8 00 00 00 00	 call	 _memcpy
  00144	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3189 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00147	8b 45 f4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  0014a	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]
  0014d	03 45 18	 add	 eax, DWORD PTR _<_Args_2>$[ebp]
  00150	89 45 b8	 mov	 DWORD PTR __First1$[ebp], eax
  00153	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00156	2b 45 10	 sub	 eax, DWORD PTR _<_Args_0>$[ebp]
  00159	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0015a	50		 push	 eax

; 3189 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  0015b	8b 45 d0	 mov	 eax, DWORD PTR __Old_ptr$[ebp]
  0015e	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00161	50		 push	 eax
  00162	ff 75 b8	 push	 DWORD PTR __First1$[ebp]
  00165	e8 00 00 00 00	 call	 _memcpy
  0016a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0016d	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00170	50		 push	 eax
  00171	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  00174	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00179	59		 pop	 ecx
  0017a	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0017b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  0017e	c9		 leave
  0017f	c2 14 00	 ret	 20			; 00000014H
??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z PROC		; std::_Refancy<char const *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PBD$0A@@std@@YAPBDPBD@Z ENDP		; std::_Refancy<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z PROC ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCSpeedTreeWrapper@@PAPAV1@@std@@YAPAPAVCSpeedTreeWrapper@@PAPAV1@00@Z ; std::_Copy_memmove<CSpeedTreeWrapper * *,CSpeedTreeWrapper * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ENDP ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z
_TEXT	SEGMENT
__Backout$1 = -52					; size = 12
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T7 = -12						; size = 4
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z PROC ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00014	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00017	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	89 45 d4	 mov	 DWORD PTR __Backout$1[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00026	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00028	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0002b	83 c0 30	 add	 eax, 48			; 00000030H
  0002e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00031	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00034	3b 45 f8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00037	74 40		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00039	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00042	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00045	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00048	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00051	8b 45 d4	 mov	 eax, DWORD PTR __Backout$1[ebp+8]
  00054	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00057	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  0005a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005d	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00060	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00063	6a 0c		 push	 12			; 0000000cH
  00065	59		 pop	 ecx
  00066	8b 75 e4	 mov	 esi, DWORD PTR $T4[ebp]
  00069	8b 7d e0	 mov	 edi, DWORD PTR $T3[ebp]
  0006c	f3 a5		 rep movsd

; 1547 :         ++_Last;

  0006e	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00071	83 c0 30	 add	 eax, 48			; 00000030H
  00074	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }

  00077	eb af		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00079	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0007c	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax

; 1552 :         return _Last;

  0007f	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00082	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00085	ff 75 d4	 push	 DWORD PTR __Backout$1[ebp+8]
  00088	ff 75 d0	 push	 DWORD PTR __Backout$1[ebp+4]
  0008b	ff 75 cc	 push	 DWORD PTR __Backout$1[ebp]
  0008e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  00096	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]

; 1702 :     }
; 1703 : }

  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	c9		 leave
  0009c	c3		 ret	 0
??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ENDP ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z
_TEXT	SEGMENT
__PFirst$1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<CArea::SObjectInstance *> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __PFirst$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR __PFirst$1[ebp]
  00010	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00013	50		 push	 eax
  00014	ff 75 fc	 push	 DWORD PTR __PFirst$1[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSObjectInstance@CArea@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0@Z ; std::_Zero_range<CArea::SObjectInstance * *>
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 1868 :         return _First + _Count;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00024	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00027	c9		 leave
  00028	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z PROC ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSObjectInstance@CArea@@PAPAU12@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@00@Z ; std::_Copy_memmove<CArea::SObjectInstance * *,CArea::SObjectInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ENDP ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicThingInstance@@PAPAV1@@std@@YAPAPAVCGraphicThingInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicThingInstance * *,CGraphicThingInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z PROC ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCDungeonBlock@@PAPAV1@@std@@YAPAPAVCDungeonBlock@@PAPAV1@00@Z ; std::_Copy_memmove<CDungeonBlock * *,CDungeonBlock * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ENDP ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z PROC ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSAmbienceInstance@CArea@@PAPAU12@@std@@YAPAPAUSAmbienceInstance@CArea@@PAPAU12@00@Z ; std::_Copy_memmove<CArea::SAmbienceInstance * *,CArea::SAmbienceInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ENDP ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z PROC ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSCRCWithNumber@CArea@@PAU12@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@00@Z ; std::_Copy_memmove<CArea::SCRCWithNumber *,CArea::SCRCWithNumber *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 03	 sar	 eax, 3
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ENDP ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCAttributeInstance@@PAPAV1@@std@@YAPAPAVCAttributeInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CAttributeInstance * *,CAttributeInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z PROC ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ENDP ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z PROC ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCEffectInstance@@PAPAV1@@std@@YAPAPAVCEffectInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CEffectInstance * *,CEffectInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 18	 imul	 eax, eax, 24
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find_lower_bound<unsigned long>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find_lower_bound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc ff ff
	ff 3f		 mov	 DWORD PTR $T17[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	c1 f8 02	 sar	 eax, 2
  000ae	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b1	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Calculate_growth
  000bc	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c2	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c5	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000c8	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000ce	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d2	c7 85 6c ff ff
	ff ff ff ff 3f	 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000dc	81 7d e4 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000e3	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e5	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ea	8b 45 e4	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000ed	c1 e0 02	 shl	 eax, 2
  000f0	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f3	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f6	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fb	59		 pop	 ecx
  000fc	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000ff	8b 45 bc	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  00102	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00105	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00108	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010b	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00111	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00115	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00118	8a 00		 mov	 al, BYTE PTR [eax]
  0011a	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00120	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00123	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00126	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00129	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012f	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00132	50		 push	 eax
  00133	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00136	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CArea::SObjectInstance *> >
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00141	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00144	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00147	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0014a	8b 00		 mov	 eax, DWORD PTR [eax]
  0014c	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00152	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00155	8b 00		 mov	 eax, DWORD PTR [eax]
  00157	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015d	33 c0		 xor	 eax, eax
  0015f	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00162	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00165	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00168	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016b	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016e	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00171	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00174	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00177	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  0017a	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  00180	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00186	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
  0018b	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018e	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  00190	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00193	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00196	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019e	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a7	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEAAV?$allocator@PAUSObjectInstance@CArea@@@2@XZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Getal
  001ac	8b c8		 mov	 ecx, eax
  001ae	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z ; std::allocator<CArea::SObjectInstance *>::deallocate

; 1204 :         _RERAISE;

  001b3	6a 00		 push	 0
  001b5	6a 00		 push	 0
  001b7	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bc	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c1	c3		 ret	 0
$LN5@Resize_rea:
  001c2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c6	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cc	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001cf	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e7	59		 pop	 ecx
  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	5b		 pop	 ebx
  001eb	c9		 leave
  001ec	c2 08 00	 ret	 8
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
  001f3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 18	 imul	 eax, eax, 24
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find_lower_bound<CGraphicThingInstance *>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find_lower_bound<CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 14	 imul	 eax, eax, 20
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	7d 09		 jge	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv65[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv65[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 34	 imul	 eax, eax, 52
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 4d		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00048	6a 00		 push	 0
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0004d	e8 00 00 00 00	 call	 ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00052	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00055	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0005d	59		 pop	 ecx
  0005e	59		 pop	 ecx

; 746  :         }

  0005f	eb a8		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00061	c9		 leave
  00062	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
_<_Vals_1>$ = 20					; size = 4
_<_Vals_2>$ = 24					; size = 4
??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00043	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0004a	8b 45 18	 mov	 eax, DWORD PTR _<_Vals_2>$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00050	8b 45 14	 mov	 eax, DWORD PTR _<_Vals_1>$[ebp]
  00053	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00056	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00059	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0006e	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00071	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  00074	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00077	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	ff 30		 push	 DWORD PTR [eax]
  0007f	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@ABUpiecewise_construct_t@2@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@QAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00087	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0008a	50		 push	 eax
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	ff 70 04	 push	 DWORD PTR [eax+4]
  00091	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  00096	59		 pop	 ecx
  00097	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00098	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0009b	50		 push	 eax
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a2	83 c0 04	 add	 eax, 4
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000ad	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000b0	50		 push	 eax
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	83 c0 08	 add	 eax, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * &>
  000c0	59		 pop	 ecx
  000c1	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000da	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e7	59		 pop	 ecx
  000e8	c9		 leave
  000e9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -16					; size = 4
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 50		 je	 SHORT $LN54@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	89 45 f0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 706  :         _Ptr->~_Uty();

  00058	6a 00		 push	 0
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0005d	e8 00 00 00 00	 call	 ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
$LN54@Tree_temp_:
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  0006a	c9		 leave
  0006b	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 34	 imul	 eax, eax, 52
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 34	 imul	 eax, eax, 52
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
tv78 = -4						; size = 4
__Bound$ = 8						; size = 4
__Keyval$ = 12						; size = 4
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1694 :     bool _Lower_bound_duplicate(const _Nodeptr _Bound, const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00009	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 2d		 jne	 SHORT $LN3@Lower_boun

; 2035 :         return _Mypair._Get_first();

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00017	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0001a	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0001d	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 69   :         return _Val.first;

  00020	8b 45 08	 mov	 eax, DWORD PTR __Bound$[ebp]
  00023	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00026	50		 push	 eax
  00027	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 09		 jne	 SHORT $LN3@Lower_boun
  00038	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0003f	eb 04		 jmp	 SHORT $LN4@Lower_boun
$LN3@Lower_boun:
  00041	83 65 fc 00	 and	 DWORD PTR tv78[ebp], 0
$LN4@Lower_boun:
  00045	8a 45 fc	 mov	 al, BYTE PTR tv78[ebp]

; 1696 :     }

  00048	c9		 leave
  00049	c2 08 00	 ret	 8
??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -36						; size = 12
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 dc	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 e0 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 dc	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 50		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 dc	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 69   :         return _Val.first;

  00054	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00057	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
  00060	59		 pop	 ecx
  00061	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  00062	0f b6 c0	 movzx	 eax, al
  00065	85 c0		 test	 eax, eax
  00067	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00069	83 65 e0 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00070	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00073	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00076	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00078	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00082	89 45 e4	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  00085	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  0008d	eb a5		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  0008f	8d 75 dc	 lea	 esi, DWORD PTR __Result$[ebp]
  00092	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00095	a5		 movsd
  00096	a5		 movsd
  00097	a5		 movsd
  00098	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  0009b	5f		 pop	 edi
  0009c	5e		 pop	 esi
  0009d	c9		 leave
  0009e	c2 08 00	 ret	 8
??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Freenode0<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 14	 imul	 eax, eax, 20
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Freenode0<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find_lower_bound<CArea::SObjectInstance *>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv65[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv65[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find_lower_bound<CArea::SObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@ABQAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv65 = -24						; size = 4
tv165 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@ABQAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Emplace<CArea::SObjectInstance * const &>, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1974 :         return _Val;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find_lower_bound<CArea::SObjectInstance *>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN40@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	73 09		 jae	 SHORT $LN52@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv165[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN50@Emplace
$LN52@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv165[ebp], 0
$LN50@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv165[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN40@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN38@Emplace
$LN40@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv65[ebp], 0
$LN38@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv65[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0ABQAUSObjectInstance@CArea@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > ><CArea::SObjectInstance * const &>
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@ABQAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Emplace<CArea::SObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@HPAX@std@@_N@1@ABH@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv65 = -24						; size = 4
tv165 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@HPAX@std@@_N@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace<int const &>, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1974 :         return _Val;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN40@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	7d 09		 jge	 SHORT $LN52@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv165[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN50@Emplace
$LN52@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv165[ebp], 0
$LN50@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv165[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN40@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN38@Emplace
$LN40@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv65[ebp], 0
$LN38@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv65[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0ABH@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > ><int const &>
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<int,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@U?$_Tree_id@PAU?$_Tree_node@HPAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@HPAX@std@@_N@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\iterator_range_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp
;	COMDAT ??$transform_range@V?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@boost@@U?$to_lowerF@D@detail@algorithm@2@@detail@algorithm@boost@@YAXABV?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@2@U?$to_lowerF@D@012@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
$T3 = -8						; size = 4
$T4 = -4						; size = 4
_Input$ = 8						; size = 4
_Functor$ = 12						; size = 4
??$transform_range@V?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@boost@@U?$to_lowerF@D@detail@algorithm@2@@detail@algorithm@boost@@YAXABV?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@2@U?$to_lowerF@D@012@@Z PROC ; boost::algorithm::detail::transform_range<boost::iterator_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >,boost::algorithm::detail::to_lowerF<char> >, COMDAT

; 100  :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\iterator_range_core.hpp

; 224  :         return m_Begin;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Input$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax

; 229  :         return m_End;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _Input$[ebp]
  00011	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00014	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax

; 224  :         return m_Begin;

  00017	8b 45 08	 mov	 eax, DWORD PTR _Input$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp

; 101  :                 std::transform( 

  0001f	ff 75 0c	 push	 DWORD PTR _Functor$[ebp]
  00022	ff 75 fc	 push	 DWORD PTR $T4[ebp]
  00025	ff 75 f8	 push	 DWORD PTR $T3[ebp]
  00028	ff 75 f4	 push	 DWORD PTR $T2[ebp]
  0002b	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$transform@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@U?$to_lowerF@D@detail@algorithm@boost@@@std@@YA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@V10@0V10@U?$to_lowerF@D@detail@algorithm@boost@@@Z ; std::transform<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,boost::algorithm::detail::to_lowerF<char> >
  00034	83 c4 14	 add	 esp, 20			; 00000014H

; 102  :                     ::boost::begin(Input), 
; 103  :                     ::boost::end(Input), 
; 104  :                     ::boost::begin(Input),
; 105  :                     Functor);
; 106  :             }

  00037	c9		 leave
  00038	c3		 ret	 0
??$transform_range@V?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@boost@@U?$to_lowerF@D@detail@algorithm@2@@detail@algorithm@boost@@YAXABV?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@2@U?$to_lowerF@D@012@@Z ENDP ; boost::algorithm::detail::transform_range<boost::iterator_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >,boost::algorithm::detail::to_lowerF<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv147 = -24						; size = 4
tv167 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Emplace<std::pair<unsigned long const ,CEffectInstance *> >, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2000 :         return _Val.first;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1008 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find_lower_bound<unsigned long>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN39@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	73 09		 jae	 SHORT $LN51@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN49@Emplace
$LN51@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv167[ebp], 0
$LN49@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv167[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN39@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN37@Emplace
$LN39@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv147[ebp], 0
$LN37@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv147[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > ><std::pair<unsigned long const ,CEffectInstance *> >
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Emplace<std::pair<unsigned long const ,CEffectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv147 = -24						; size = 4
tv167 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Emplace<std::pair<CGraphicThingInstance * const,unsigned long> >, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2000 :         return _Val.first;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1008 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find_lower_bound<CGraphicThingInstance *>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN39@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	73 09		 jae	 SHORT $LN51@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN49@Emplace
$LN51@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv167[ebp], 0
$LN49@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv167[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN39@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN37@Emplace
$LN39@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv147[ebp], 0
$LN37@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv147[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > ><std::pair<CGraphicThingInstance * const,unsigned long> >
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Emplace<std::pair<CGraphicThingInstance * const,unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z PROC ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000a	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000d	99		 cdq
  0000e	6a 30		 push	 48			; 00000030H
  00010	59		 pop	 ecx
  00011	f7 f9		 idiv	 ecx
  00013	83 f8 20	 cmp	 eax, 32			; 00000020H
  00016	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00018	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAPAUSObjectData@CArea@@QAU12@0UObjectDataComp@2@@Z ; std::_Insertion_sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00029	e9 cc 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002e	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00032	7f 48		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00034	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0003a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0003d	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ; std::_Make_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  0004b	eb 09		 jmp	 SHORT $LN62@Sort_unche
$LN60@Sort_unche:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00050	83 e8 30	 sub	 eax, 48			; 00000030H
  00053	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN62@Sort_unche:
  00056	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00059	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0005c	99		 cdq
  0005d	6a 30		 push	 48			; 00000030H
  0005f	59		 pop	 ecx
  00060	f7 f9		 idiv	 ecx
  00062	83 f8 02	 cmp	 eax, 2
  00065	7c 13		 jl	 SHORT $LN59@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00067	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0006a	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  0006d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00070	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0UObjectDataComp@2@@Z ; std::_Pop_heap_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00078	eb d3		 jmp	 SHORT $LN60@Sort_unche
$LN59@Sort_unche:

; 7548 :             return;

  0007a	eb 7e		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0007c	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0007f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00082	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00085	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YA?AU?$pair@PAUSObjectData@CArea@@PAU12@@0@PAUSObjectData@CArea@@0UObjectDataComp@3@@Z ; std::_Partition_by_median_guess_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  00091	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00094	d1 f8		 sar	 eax, 1
  00096	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00099	c1 f9 02	 sar	 ecx, 2
  0009c	03 c1		 add	 eax, ecx
  0009e	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  000a1	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000a4	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a7	99		 cdq
  000a8	6a 30		 push	 48			; 00000030H
  000aa	59		 pop	 ecx
  000ab	f7 f9		 idiv	 ecx
  000ad	8b c8		 mov	 ecx, eax
  000af	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  000b2	2b 45 f8	 sub	 eax, DWORD PTR __Mid$1[ebp+4]
  000b5	99		 cdq
  000b6	6a 30		 push	 48			; 00000030H
  000b8	5e		 pop	 esi
  000b9	f7 fe		 idiv	 esi
  000bb	3b c8		 cmp	 ecx, eax
  000bd	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000bf	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c2	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000c5	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000c8	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cb	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  000d0	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000d6	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000d9	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000db	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000de	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000e1	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000e4	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000e7	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  000ec	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000ef	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000f2	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000f5	e9 0d ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000fa	5e		 pop	 esi
  000fb	c9		 leave
  000fc	c3		 ret	 0
??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z ENDP ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z PROC ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 03	 sar	 eax, 3
  0000f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00012	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00014	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00017	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0UCRCNumComp@2@@Z ; std::_Insertion_sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00025	e9 c1 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002a	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  0002e	7f 45		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00030	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00036	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00039	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Make_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00044	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00047	eb 09		 jmp	 SHORT $LN62@Sort_unche
$LN60@Sort_unche:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  0004c	83 e8 08	 sub	 eax, 8
  0004f	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN62@Sort_unche:
  00052	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00055	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00058	c1 f8 03	 sar	 eax, 3
  0005b	83 f8 02	 cmp	 eax, 2
  0005e	7c 13		 jl	 SHORT $LN59@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00060	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00063	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00066	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0UCRCNumComp@2@@Z ; std::_Pop_heap_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00071	eb d6		 jmp	 SHORT $LN60@Sort_unche
$LN59@Sort_unche:

; 7548 :             return;

  00073	eb 76		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  00075	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00078	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0007b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007e	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YA?AU?$pair@PAUSCRCWithNumber@CArea@@PAU12@@0@PAUSCRCWithNumber@CArea@@0UCRCNumComp@3@@Z ; std::_Partition_by_median_guess_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0008a	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  0008d	d1 f8		 sar	 eax, 1
  0008f	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00092	c1 f9 02	 sar	 ecx, 2
  00095	03 c1		 add	 eax, ecx
  00097	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0009a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0009d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a0	c1 f8 03	 sar	 eax, 3
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b 4d f8	 sub	 ecx, DWORD PTR __Mid$1[ebp+4]
  000a9	c1 f9 03	 sar	 ecx, 3
  000ac	3b c1		 cmp	 eax, ecx
  000ae	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000b0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000b6	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000b9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000c7	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000ca	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000cc	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cf	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000d2	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000d5	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000d8	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000e0	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000e3	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000e6	e9 1b ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000eb	c9		 leave
  000ec	c3		 ret	 0
??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ENDP ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z PROC ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00012	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00014	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00017	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Insertion_sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00025	e9 c1 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002a	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  0002e	7f 45		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00030	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00036	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00039	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Make_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00044	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00047	eb 09		 jmp	 SHORT $LN58@Sort_unche
$LN56@Sort_unche:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  0004c	83 e8 04	 sub	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN58@Sort_unche:
  00052	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00055	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00058	c1 f8 02	 sar	 eax, 2
  0005b	83 f8 02	 cmp	 eax, 2
  0005e	7c 13		 jl	 SHORT $LN55@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00060	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00063	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00066	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Pop_heap_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00071	eb d6		 jmp	 SHORT $LN56@Sort_unche
$LN55@Sort_unche:

; 7548 :             return;

  00073	eb 76		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  00075	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00078	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0007b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007e	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YA?AU?$pair@PAPAVCEffectInstance@@PAPAV1@@0@PAPAVCEffectInstance@@0UCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Partition_by_median_guess_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0008a	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  0008d	d1 f8		 sar	 eax, 1
  0008f	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00092	c1 f9 02	 sar	 ecx, 2
  00095	03 c1		 add	 eax, ecx
  00097	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0009a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0009d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a0	c1 f8 02	 sar	 eax, 2
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b 4d f8	 sub	 ecx, DWORD PTR __Mid$1[ebp+4]
  000a9	c1 f9 02	 sar	 ecx, 2
  000ac	3b c1		 cmp	 eax, ecx
  000ae	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000b0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000b6	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000b9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000c7	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000ca	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000cc	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cf	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000d2	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000d5	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000d8	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000e0	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000e3	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000e6	e9 1b ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000eb	c9		 leave
  000ec	c3		 ret	 0
??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z ENDP ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 18	 add	 eax, 24			; 00000018H
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 23		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	33 c0		 xor	 eax, eax
  00027	83 e0 01	 and	 eax, 1
  0002a	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002c	6a 18		 push	 24			; 00000018H
  0002e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  00038	eb cc		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 18	 imul	 eax, eax, 24
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> *,std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 18	 imul	 eax, eax, 24
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> *,std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z PROC ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 14	 imul	 eax, eax, 20
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ENDP ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec c4 4e
	ec 04		 mov	 DWORD PTR __Max_possible$1[ebp], 82595524 ; 04ec4ec4H

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d c4 4e ec 04	 cmp	 eax, 82595524		; 04ec4ec4H
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 34	 imul	 eax, eax, 52
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CAttributeInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@@Z PROC ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Buyheadnode<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 14	 imul	 eax, eax, 20
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<CArea::SObjectInstance *,void *> *,std::_Tree_node<CArea::SObjectInstance *,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Buyheadnode<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea::SObjectData> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_reallocate<CArea::SObjectInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectInstance * *,std::allocator<CArea::SObjectInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z ; std::allocator<CArea::SObjectInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_reallocate<CArea::SObjectInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXABQAUSObjectInstance@CArea@@@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_back_with_unused_capacity<CArea::SObjectInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXABQAUSObjectInstance@CArea@@@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_back_with_unused_capacity<CArea::SObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::emplace_back<CArea::SObjectInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXABQAUSObjectInstance@CArea@@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_back_with_unused_capacity<CArea::SObjectInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAPAUSObjectInstance@CArea@@QAPAU23@ABQAU23@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Emplace_reallocate<CArea::SObjectInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::emplace_back<CArea::SObjectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CDungeonBlock *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAPAPAVCAttributeInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Uninitialized_move<CAttributeInstance * *,std::allocator<CAttributeInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ; std::allocator<CAttributeInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_back_with_unused_capacity<CAttributeInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEPAPAVCAttributeInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Emplace_reallocate<CAttributeInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@YAPAPAVCArea@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Uninitialized_move<CArea * *,std::allocator<CArea *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCArea@@@std@@QAEXQAPAVCArea@@I@Z ; std::allocator<CArea *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXQAPAVCArea@@II@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABQAVCArea@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABQAVCArea@@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_back_with_unused_capacity<CArea * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABQAVCArea@@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_back_with_unused_capacity<CArea * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::emplace_back<CArea * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_back_with_unused_capacity<CArea * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEPAPAVCArea@@QAPAV2@ABQAV2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Emplace_reallocate<CArea * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::emplace_back<CArea * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CEffectInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CEffectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Possible_matches_end$ = -8				; size = 4
__Match_try$2 = -4					; size = 4
__Haystack$ = 8						; size = 4
__Hay_size$ = 12					; size = 4
__Start_at$ = 16					; size = 4
__Needle$ = 20						; size = 4
__Needle_size$ = 24					; size = 4
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 588  :     const size_t _Needle_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 589  :     // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at
; 590  :     if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size) {

  00006	8b 45 18	 mov	 eax, DWORD PTR __Needle_size$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Hay_size$[ebp]
  0000c	77 0b		 ja	 SHORT $LN6@Traits_fin
  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  00011	2b 45 18	 sub	 eax, DWORD PTR __Needle_size$[ebp]
  00014	39 45 10	 cmp	 DWORD PTR __Start_at$[ebp], eax
  00017	76 05		 jbe	 SHORT $LN5@Traits_fin
$LN6@Traits_fin:

; 591  :         // xpos cannot exist, report failure
; 592  :         // N4659 24.3.2.7.2 [string.find]/1 says:
; 593  :         // 1. _Start_at <= xpos
; 594  :         // 2. xpos + _Needle_size <= _Hay_size;
; 595  :         // therefore:
; 596  :         // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 597  :         // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 598  :         // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 599  :         return static_cast<size_t>(-1);

  00019	83 c8 ff	 or	 eax, -1
  0001c	eb 78		 jmp	 SHORT $LN10@Traits_fin
$LN5@Traits_fin:

; 600  :     }
; 601  : 
; 602  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible

  0001e	83 7d 18 00	 cmp	 DWORD PTR __Needle_size$[ebp], 0
  00022	75 05		 jne	 SHORT $LN7@Traits_fin

; 603  :         return _Start_at;

  00024	8b 45 10	 mov	 eax, DWORD PTR __Start_at$[ebp]
  00027	eb 6d		 jmp	 SHORT $LN10@Traits_fin
$LN7@Traits_fin:

; 604  :     }
; 605  : 
; 606  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00029	8b 45 0c	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  0002c	2b 45 18	 sub	 eax, DWORD PTR __Needle_size$[ebp]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Haystack$[ebp]
  00032	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00036	89 45 f8	 mov	 DWORD PTR __Possible_matches_end$[ebp], eax

; 607  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {

  00039	8b 45 08	 mov	 eax, DWORD PTR __Haystack$[ebp]
  0003c	03 45 10	 add	 eax, DWORD PTR __Start_at$[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax
  00042	eb 07		 jmp	 SHORT $LN4@Traits_fin
$LN2@Traits_fin:
  00044	8b 45 fc	 mov	 eax, DWORD PTR __Match_try$2[ebp]
  00047	40		 inc	 eax
  00048	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax
$LN4@Traits_fin:

; 608  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __Possible_matches_end$[ebp]
  0004e	2b 45 fc	 sub	 eax, DWORD PTR __Match_try$2[ebp]

; 410  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00051	50		 push	 eax
  00052	8b 45 14	 mov	 eax, DWORD PTR __Needle$[ebp]
  00055	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00058	50		 push	 eax
  00059	ff 75 fc	 push	 DWORD PTR __Match_try$2[ebp]
  0005c	e8 00 00 00 00	 call	 _memchr
  00061	83 c4 0c	 add	 esp, 12			; 0000000cH
  00064	89 45 fc	 mov	 DWORD PTR __Match_try$2[ebp], eax

; 609  :         if (!_Match_try) { // didn't find first character; report failure

  00067	83 7d fc 00	 cmp	 DWORD PTR __Match_try$2[ebp], 0
  0006b	75 05		 jne	 SHORT $LN8@Traits_fin

; 610  :             return static_cast<size_t>(-1);

  0006d	83 c8 ff	 or	 eax, -1
  00070	eb 24		 jmp	 SHORT $LN10@Traits_fin
$LN8@Traits_fin:

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  00072	ff 75 18	 push	 DWORD PTR __Needle_size$[ebp]
  00075	ff 75 14	 push	 DWORD PTR __Needle$[ebp]
  00078	ff 75 fc	 push	 DWORD PTR __Match_try$2[ebp]
  0007b	e8 00 00 00 00	 call	 _memcmp
  00080	83 c4 0c	 add	 esp, 12			; 0000000cH
  00083	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 611  :         }
; 612  : 
; 613  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match

  00086	83 7d f4 00	 cmp	 DWORD PTR $T1[ebp], 0
  0008a	75 08		 jne	 SHORT $LN9@Traits_fin

; 614  :             return static_cast<size_t>(_Match_try - _Haystack);

  0008c	8b 45 fc	 mov	 eax, DWORD PTR __Match_try$2[ebp]
  0008f	2b 45 08	 sub	 eax, DWORD PTR __Haystack$[ebp]
  00092	eb 02		 jmp	 SHORT $LN10@Traits_fin
$LN9@Traits_fin:

; 615  :         }
; 616  :     }

  00094	eb ae		 jmp	 SHORT $LN2@Traits_fin
$LN10@Traits_fin:

; 617  : }

  00096	c9		 leave
  00097	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z
_TEXT	SEGMENT
__Found_at$1 = -4					; size = 4
__Haystack$ = 8						; size = 4
__Hay_size$ = 12					; size = 4
__Start_at$ = 16					; size = 4
__Ch$ = 20						; size = 1
??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z PROC ; std::_Traits_find_ch<std::char_traits<char> >, COMDAT

; 621  :     const size_t _Start_at, const _Traits_ch_t<_Traits> _Ch) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 622  :     // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 623  :     if (_Start_at < _Hay_size) {

  00004	8b 45 10	 mov	 eax, DWORD PTR __Start_at$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Hay_size$[ebp]
  0000a	73 2c		 jae	 SHORT $LN2@Traits_fin

; 624  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  0000f	2b 45 10	 sub	 eax, DWORD PTR __Start_at$[ebp]

; 410  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  00012	50		 push	 eax
  00013	0f be 45 14	 movsx	 eax, BYTE PTR __Ch$[ebp]
  00017	50		 push	 eax

; 624  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Haystack$[ebp]
  0001b	03 45 10	 add	 eax, DWORD PTR __Start_at$[ebp]

; 410  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 _memchr
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	89 45 fc	 mov	 DWORD PTR __Found_at$1[ebp], eax

; 625  :         if (_Found_at) {

  0002a	83 7d fc 00	 cmp	 DWORD PTR __Found_at$1[ebp], 0
  0002e	74 08		 je	 SHORT $LN2@Traits_fin

; 626  :             return static_cast<size_t>(_Found_at - _Haystack);

  00030	8b 45 fc	 mov	 eax, DWORD PTR __Found_at$1[ebp]
  00033	2b 45 08	 sub	 eax, DWORD PTR __Haystack$[ebp]
  00036	eb 03		 jmp	 SHORT $LN4@Traits_fin
$LN2@Traits_fin:

; 627  :         }
; 628  :     }
; 629  : 
; 630  :     return static_cast<size_t>(-1); // (npos) no match

  00038	83 c8 ff	 or	 eax, -1
$LN4@Traits_fin:

; 631  : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z ENDP ; std::_Traits_find_ch<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@ABK@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find<unsigned long>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find_lower_bound<unsigned long>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAPAPAVCSpeedTreeWrapper@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Uninitialized_move<CSpeedTreeWrapper * *,std::allocator<CSpeedTreeWrapper *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ; std::allocator<CSpeedTreeWrapper *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_back_with_unused_capacity<CSpeedTreeWrapper * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEPAPAVCSpeedTreeWrapper@@QAPAV2@ABQAV2@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Emplace_reallocate<CSpeedTreeWrapper * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Emplace_reallocate<CArea::SObjectData const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 30		 push	 48			; 00000030H
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 30		 push	 48			; 00000030H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 55 55
	55 05		 mov	 DWORD PTR $T22[ebp], 89478485 ; 05555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 55 55
	55 05		 mov	 DWORD PTR __Max_possible$2[ebp], 89478485 ; 05555555H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 55 55
	55 05		 cmp	 DWORD PTR __Newcapacity$[ebp], 89478485 ; 05555555H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 30	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 48
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 30	 imul	 eax, DWORD PTR __Whereoff$[ebp], 48
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 30	 lea	 eax, DWORD PTR [ecx+eax+48]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 30	 imul	 eax, DWORD PTR __Whereoff$[ebp], 48
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	6a 0c		 push	 12			; 0000000cH
  00149	59		 pop	 ecx
  0014a	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  0014d	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  00150	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	6b 45 60 30	 imul	 eax, DWORD PTR __Whereoff$[ebp], 48
  00156	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00159	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015c	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00166	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00169	8b 00		 mov	 eax, DWORD PTR [eax]
  0016b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00176	33 c0		 xor	 eax, eax
  00178	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017b	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017e	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00181	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00184	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00187	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018a	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018d	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00190	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00193	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00196	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00199	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a1	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a3	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ab	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ae	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b1	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b7	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001ba	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bd	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c0	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c3	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >
  001c8	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cb	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ce	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d1	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001dc	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001df	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e2	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e5	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	6b 45 60 30	 imul	 eax, DWORD PTR __Whereoff$[ebp], 48
  001ec	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ef	8d 44 01 30	 lea	 eax, DWORD PTR [ecx+eax+48]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f3	50		 push	 eax
  001f4	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f7	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@YAPAUSObjectData@CArea@@QAU12@0PAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SObjectData *,std::allocator<CArea::SObjectData> >
  001ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00202	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00204	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00207	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020a	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXPAUSObjectData@CArea@@0@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00212	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00215	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USObjectData@CArea@@@std@@QAEXQAUSObjectData@CArea@@I@Z ; std::allocator<CArea::SObjectData>::deallocate

; 762  :         _RERAISE;

  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00229	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022e	c3		 ret	 0
$LN7@Emplace_re:
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00239	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023c	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00242	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXQAUSObjectData@CArea@@II@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024a	6b 45 60 30	 imul	 eax, DWORD PTR __Whereoff$[ebp], 48
  0024e	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025b	59		 pop	 ecx
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	83 c5 70	 add	 ebp, 112		; 00000070H
  00262	c9		 leave
  00263	c2 08 00	 ret	 8
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
  00269	cc		 int	 3
  0026a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Emplace_reallocate<CArea::SObjectData const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::emplace_back<CArea::SObjectData const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 63		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	6a 0c		 push	 12			; 0000000cH
  0006a	59		 pop	 ecx
  0006b	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006e	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  00071	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00073	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	83 c0 30	 add	 eax, 48			; 00000030H
  00083	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00086	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00088	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008d	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00090	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00093	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00096	ff 30		 push	 DWORD PTR [eax]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEPAUSObjectData@CArea@@QAU23@ABU23@@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Emplace_reallocate<CArea::SObjectData const &>
  000a0	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	c9		 leave
  000a6	c2 04 00	 ret	 4
??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::emplace_back<CArea::SObjectData const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	c1 f8 02	 sar	 eax, 2
  0002b	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00031	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00034	73 3d		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00036	8b 45 ec	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0003e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00041	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0004f	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00052	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00055	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00058	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005b	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005e	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00061	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  00069	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006c	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00071	eb 67		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00079	76 5f		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007b	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007e	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00081	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00084	2b 01		 sub	 eax, DWORD PTR [ecx]
  00086	c1 f8 02	 sar	 eax, 2
  00089	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  0008c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008f	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00092	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00094	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00097	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a2	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000ac	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000af	8a 00		 mov	 al, BYTE PTR [eax]
  000b1	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b7	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ba	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000bd	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c0	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c6	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c9	50		 push	 eax
  000ca	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000cd	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAPAPAUSObjectInstance@CArea@@PAPAU12@IAAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<CArea::SObjectInstance *> >
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d5	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000da	c9		 leave
  000db	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_reallocate<CGraphicThingInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAPAPAVCGraphicThingInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicThingInstance * *,std::allocator<CGraphicThingInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXPAPAVCGraphicThingInstance@@0@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXQAPAVCGraphicThingInstance@@I@Z ; std::allocator<CGraphicThingInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXQAPAVCGraphicThingInstance@@II@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_reallocate<CGraphicThingInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXABQAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXABQAVCGraphicThingInstance@@@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_back_with_unused_capacity<CGraphicThingInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXABQAVCGraphicThingInstance@@@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_back_with_unused_capacity<CGraphicThingInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_back_with_unused_capacity<CGraphicThingInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEPAPAVCGraphicThingInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Emplace_reallocate<CGraphicThingInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_reallocate<CDungeonBlock * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@CAXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@ABEII@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAPAPAVCDungeonBlock@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Uninitialized_move<CDungeonBlock * *,std::allocator<CDungeonBlock *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXPAPAVCDungeonBlock@@0@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCDungeonBlock@@@std@@QAEXQAPAVCDungeonBlock@@I@Z ; std::allocator<CDungeonBlock *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXQAPAVCDungeonBlock@@II@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_reallocate<CDungeonBlock * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXABQAVCDungeonBlock@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXABQAVCDungeonBlock@@@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_back_with_unused_capacity<CDungeonBlock * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXABQAVCDungeonBlock@@@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_back_with_unused_capacity<CDungeonBlock * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_back_with_unused_capacity<CDungeonBlock * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEPAPAVCDungeonBlock@@QAPAV2@ABQAV2@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Emplace_reallocate<CDungeonBlock * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_reallocate<CArea::SAmbienceInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAPAPAUSAmbienceInstance@CArea@@QAPAU12@0PAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SAmbienceInstance * *,std::allocator<CArea::SAmbienceInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXPAPAUSAmbienceInstance@CArea@@0@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSAmbienceInstance@CArea@@@std@@QAEXQAPAUSAmbienceInstance@CArea@@I@Z ; std::allocator<CArea::SAmbienceInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXQAPAUSAmbienceInstance@CArea@@II@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_reallocate<CArea::SAmbienceInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXABQAUSAmbienceInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXABQAUSAmbienceInstance@CArea@@@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_back_with_unused_capacity<CArea::SAmbienceInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXABQAUSAmbienceInstance@CArea@@@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_back_with_unused_capacity<CArea::SAmbienceInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_back_with_unused_capacity<CArea::SAmbienceInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEPAPAUSAmbienceInstance@CArea@@QAPAU23@ABQAU23@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Emplace_reallocate<CArea::SAmbienceInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@ABQAVCGraphicThingInstance@@@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@ABQAVCGraphicThingInstance@@@Z PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find<CGraphicThingInstance *>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@ABQAVCGraphicThingInstance@@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find_lower_bound<CGraphicThingInstance *>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@ABQAVCGraphicThingInstance@@@Z ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find<CGraphicThingInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Emplace_reallocate<CArea::SCRCWithNumber const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 03	 sar	 ecx, 3
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 03	 sar	 eax, 3
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 1f		 mov	 DWORD PTR $T22[ebp], 536870911 ; 1fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@CAXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@ABEII@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$2[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 1f		 cmp	 DWORD PTR __Newcapacity$[ebp], 536870911 ; 1fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 03	 shl	 eax, 3
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014a	8b 55 00	 mov	 edx, DWORD PTR $T10[ebp]
  0014d	89 0a		 mov	 DWORD PTR [edx], ecx
  0014f	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00155	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00158	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0015b	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015e	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00161	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00164	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00166	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00168	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00170	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00173	8b 00		 mov	 eax, DWORD PTR [eax]
  00175	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00178	33 c0		 xor	 eax, eax
  0017a	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017d	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  00180	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00186	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00189	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018c	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018f	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00192	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00195	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00198	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  0019b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >
  001a0	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a3	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a5	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a8	8b 00		 mov	 eax, DWORD PTR [eax]
  001aa	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001b0	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b3	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b6	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b9	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001bc	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bf	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c2	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >
  001ca	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cd	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001d0	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d3	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d6	8b 00		 mov	 eax, DWORD PTR [eax]
  001d8	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001de	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001e1	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e4	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e7	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001ea	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001ed	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001f0	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f4	50		 push	 eax
  001f5	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f8	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fb	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAPAUSCRCWithNumber@CArea@@QAU12@0PAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Uninitialized_move<CArea::SCRCWithNumber *,std::allocator<CArea::SCRCWithNumber> >
  00200	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00203	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00205	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00208	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020b	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXPAUSCRCWithNumber@CArea@@0@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00213	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00216	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00219	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXQAUSCRCWithNumber@CArea@@I@Z ; std::allocator<CArea::SCRCWithNumber>::deallocate

; 762  :         _RERAISE;

  00221	6a 00		 push	 0
  00223	6a 00		 push	 0
  00225	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0022a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022f	c3		 ret	 0
$LN7@Emplace_re:
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00234	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00236	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0023a	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023d	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  00240	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00243	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXQAUSCRCWithNumber@CArea@@II@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024b	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0024e	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00251	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
$LN70@Emplace_re:

; 767  :     }

  00254	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00257	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025e	59		 pop	 ecx
  0025f	5f		 pop	 edi
  00260	5e		 pop	 esi
  00261	5b		 pop	 ebx
  00262	83 c5 70	 add	 ebp, 112		; 00000070H
  00265	c9		 leave
  00266	c2 08 00	 ret	 8
  00269	cc		 int	 3
  0026a	cc		 int	 3
  0026b	cc		 int	 3
  0026c	cc		 int	 3
  0026d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Emplace_reallocate<CArea::SCRCWithNumber const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::emplace_back<CArea::SCRCWithNumber const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 68		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00040	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004b	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00051	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00057	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00060	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00063	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00066	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	8b 55 d0	 mov	 edx, DWORD PTR $T4[ebp]
  00071	89 0a		 mov	 DWORD PTR [edx], ecx
  00073	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00076	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	83 c0 08	 add	 eax, 8
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00089	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0008b	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00090	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00093	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00096	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00099	ff 30		 push	 DWORD PTR [eax]
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEPAUSCRCWithNumber@CArea@@QAU23@ABU23@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Emplace_reallocate<CArea::SCRCWithNumber const &>
  000a3	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a6	c9		 leave
  000a7	c2 04 00	 ret	 4
??$emplace_back@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::emplace_back<CArea::SCRCWithNumber const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@HPAX@1@ABH@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv78 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@HPAX@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find<int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@HPAX@std@@@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find_lower_bound<int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	7d 09		 jge	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv78[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv78[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@HPAX@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Loc$ = -24						; size = 12
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 e8	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0001b	ff 75 f0	 push	 DWORD PTR __Loc$[ebp+8]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0002d	8b 45 f0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00030	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00035	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00038	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0003b	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0003e	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00043	c9		 leave
  00044	c2 04 00	 ret	 4
??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 8
__Loc$ = -120						; size = 12
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
__Inserted$ = -96					; size = 4
$T5 = -92						; size = 4
__Old_val$6 = -88					; size = 4
$T7 = -84						; size = 4
$T8 = -80						; size = 4
$T9 = -76						; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
_this$15 = -52						; size = 4
$T16 = -48						; size = 4
$T17 = -44						; size = 4
$T18 = -40						; size = 4
$T19 = -36						; size = 4
$T20 = -32						; size = 4
$T21 = -28						; size = 4
$T22 = -24						; size = 4
__Scary$ = -20						; size = 4
__Val$ = -16						; size = 4
$T23 = -9						; size = 1
_this$ = -8						; size = 4
$T24 = -2						; size = 1
$T25 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 175  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0000c	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0000f	8d 45 88	 lea	 eax, DWORD PTR __Loc$[ebp]
  00012	50		 push	 eax
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Find_lower_bound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find_lower_bound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001b	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  0001e	ff 75 90	 push	 DWORD PTR __Loc$[ebp+8]
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??$_Lower_bound_duplicate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IBE_NQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Lower_bound_duplicate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 2d		 je	 SHORT $LN2@Try_emplac

; 178  :             return {_Loc._Bound, false};

  00030	c6 45 ff 00	 mov	 BYTE PTR $T25[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00034	8d 45 90	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00037	89 45 e8	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003d	8b 4d e8	 mov	 ecx, DWORD PTR $T22[ebp]
  00040	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00042	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00044	8d 45 ff	 lea	 eax, DWORD PTR $T25[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	8b 4d e4	 mov	 ecx, DWORD PTR $T21[ebp]
  00050	8a 09		 mov	 cl, BYTE PTR [ecx]
  00052	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 178  :             return {_Loc._Bound, false};

  00055	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00058	e9 e3 00 00 00	 jmp	 $LN1@Try_emplac
$LN2@Try_emplac:

; 179  :         }
; 180  : 
; 181  :         _Mybase::_Check_grow_by_1();

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	89 45 e0	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0006b	8b 45 e0	 mov	 eax, DWORD PTR $T20[ebp]
  0006e	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  00071	8d 45 f7	 lea	 eax, DWORD PTR $T23[ebp]
  00074	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00077	8b 45 0c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0007a	89 45 dc	 mov	 DWORD PTR $T19[ebp], eax
  0007d	8b 45 dc	 mov	 eax, DWORD PTR $T19[ebp]
  00080	89 45 d8	 mov	 DWORD PTR $T18[ebp], eax
  00083	8b 45 d8	 mov	 eax, DWORD PTR $T18[ebp]
  00086	89 45 d4	 mov	 DWORD PTR $T17[ebp], eax
  00089	8b 45 d4	 mov	 eax, DWORD PTR $T17[ebp]
  0008c	89 45 d0	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 245  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  0008f	8d 45 c4	 lea	 eax, DWORD PTR $T13[ebp]
  00092	89 45 cc	 mov	 DWORD PTR _this$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00095	8b 45 d0	 mov	 eax, DWORD PTR $T16[ebp]
  00098	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  0009b	8b 45 cc	 mov	 eax, DWORD PTR _this$15[ebp]
  0009e	8b 4d c8	 mov	 ecx, DWORD PTR $T14[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000a3	8d 45 c4	 lea	 eax, DWORD PTR $T13[ebp]
  000a6	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ac	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000af	8b 45 c0	 mov	 eax, DWORD PTR $T12[ebp]
  000b2	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000b5	ff 75 bc	 push	 DWORD PTR $T11[ebp]
  000b8	ff 75 b8	 push	 DWORD PTR $T10[ebp]
  000bb	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
  000c0	8b 45 ec	 mov	 eax, DWORD PTR __Scary$[ebp]
  000c3	ff 30		 push	 DWORD PTR [eax]
  000c5	ff 75 b4	 push	 DWORD PTR $T9[ebp]
  000c8	8d 4d 80	 lea	 ecx, DWORD PTR $T1[ebp]
  000cb	e8 00 00 00 00	 call	 ??$?0ABUpiecewise_construct_t@std@@V?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > ><std::piecewise_construct_t const &,std::tuple<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &&>,std::tuple<> >
  000d0	89 45 b0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000d3	83 65 ac 00	 and	 DWORD PTR $T7[ebp], 0
  000d7	8b 45 b0	 mov	 eax, DWORD PTR $T8[ebp]
  000da	83 c0 04	 add	 eax, 4
  000dd	89 45 f0	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e0	8b 45 f0	 mov	 eax, DWORD PTR __Val$[ebp]
  000e3	8b 00		 mov	 eax, DWORD PTR [eax]
  000e5	89 45 a8	 mov	 DWORD PTR __Old_val$6[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000e8	8b 45 f0	 mov	 eax, DWORD PTR __Val$[ebp]
  000eb	8b 4d ac	 mov	 ecx, DWORD PTR $T7[ebp]
  000ee	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  000f0	8b 45 a8	 mov	 eax, DWORD PTR __Old_val$6[ebp]
  000f3	89 45 a4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000f6	8b 45 a4	 mov	 eax, DWORD PTR $T5[ebp]
  000f9	89 45 a0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000fc	8d 4d 80	 lea	 ecx, DWORD PTR $T1[ebp]
  000ff	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00104	ff 75 a0	 push	 DWORD PTR __Inserted$[ebp]
  00107	ff 75 8c	 push	 DWORD PTR __Loc$[ebp+4]
  0010a	ff 75 88	 push	 DWORD PTR __Loc$[ebp]
  0010d	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00110	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
  00115	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
  00118	c6 45 fe 01	 mov	 BYTE PTR $T24[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0011c	8d 45 9c	 lea	 eax, DWORD PTR $T4[ebp]
  0011f	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00122	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00125	8b 4d 98	 mov	 ecx, DWORD PTR $T3[ebp]
  00128	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0012a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012c	8d 45 fe	 lea	 eax, DWORD PTR $T24[ebp]
  0012f	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00132	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00135	8b 4d 94	 mov	 ecx, DWORD PTR $T2[ebp]
  00138	8a 09		 mov	 cl, BYTE PTR [ecx]
  0013a	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0013d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Try_emplac:

; 191  :     }

  00140	c9		 leave
  00141	c2 08 00	 ret	 8
??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@P6AXPAUSObjectInstance@CArea@@@Z@std@@YAP6AXPAUSObjectInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@P6AXPAUSObjectInstance@CArea@@@Z@std@@YAP6AXPAUSObjectInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >,void (__cdecl*)(CArea::SObjectInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@P6AXPAUSObjectInstance@CArea@@@Z@std@@YAP6AXPAUSObjectInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >,void (__cdecl*)(CArea::SObjectInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@std@@P6AXPAUSAmbienceInstance@CArea@@@Z@std@@YAP6AXPAUSAmbienceInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@std@@P6AXPAUSAmbienceInstance@CArea@@@Z@std@@YAP6AXPAUSAmbienceInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SAmbienceInstance *> > >,void (__cdecl*)(CArea::SAmbienceInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@std@@P6AXPAUSAmbienceInstance@CArea@@@Z@std@@YAP6AXPAUSAmbienceInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SAmbienceInstance *> > >,void (__cdecl*)(CArea::SAmbienceInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@std@@P6AXPAVCDungeonBlock@@@Z@std@@YAP6AXPAVCDungeonBlock@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@std@@P6AXPAVCDungeonBlock@@@Z@std@@YAP6AXPAVCDungeonBlock@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDungeonBlock *> > >,void (__cdecl*)(CDungeonBlock *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@std@@P6AXPAVCDungeonBlock@@@Z@std@@YAP6AXPAVCDungeonBlock@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDungeonBlock *> > >,void (__cdecl*)(CDungeonBlock *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_reallocate<CEffectInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@CAXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@ABEII@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAPAPAVCEffectInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Uninitialized_move<CEffectInstance * *,std::allocator<CEffectInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXPAPAVCEffectInstance@@0@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCEffectInstance@@@std@@QAEXQAPAVCEffectInstance@@I@Z ; std::allocator<CEffectInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXQAPAVCEffectInstance@@II@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_reallocate<CEffectInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXABQAVCEffectInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXABQAVCEffectInstance@@@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_back_with_unused_capacity<CEffectInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXABQAVCEffectInstance@@@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_back_with_unused_capacity<CEffectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXABQAVCEffectInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXABQAVCEffectInstance@@@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::emplace_back<CEffectInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXABQAVCEffectInstance@@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_back_with_unused_capacity<CEffectInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEPAPAVCEffectInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Emplace_reallocate<CEffectInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXABQAVCEffectInstance@@@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::emplace_back<CEffectInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Freenode0<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv78 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find<CArea::SObjectInstance *>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find_lower_bound<CArea::SObjectInstance *>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv78[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv78[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find<CArea::SObjectInstance *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
__Result$ = -36						; size = 8
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
___param0$ = -12					; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1332 :     pair<iterator, bool> insert(const value_type& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :         const auto _Result = _Emplace(_Val);

  00009	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0000c	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Emplace@ABQAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Emplace<CArea::SObjectInstance * const &>

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001b	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  00021	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 1334 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00024	8b 45 dc	 mov	 eax, DWORD PTR __Result$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0002a	8b 45 f4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00030	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00036	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00040	8d 45 e0	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00043	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  0004c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0004e	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1334 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1335 :     }

  00054	c9		 leave
  00055	c2 08 00	 ret	 8
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ PROC ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::~set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::~_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ ENDP ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::~set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\set
;	COMDAT ??0?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ PROC ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >, COMDAT
; _this$ = ecx

; 84   :     set() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@ABU?$less@PAUSObjectInstance@CArea@@@1@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
??0?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ ENDP ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S22$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S22$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@@Z ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Buyheadnode<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@2@ABQAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@2@ABQAUSObjectInstance@CArea@@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@PAUSObjectInstance@CArea@@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@ABEPAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Find<CArea::SObjectInstance *>
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@2@ABQAUSObjectInstance@CArea@@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc cc cc
	cc 0c		 mov	 DWORD PTR $T7[ebp], 214748364 ; 0cccccccH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::~_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU?$_Tree_node@PAUSObjectInstance@CArea@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<CArea::SObjectInstance *> >::_Erase_tree<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@std@@@?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@PAUSObjectInstance@CArea@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<CArea::SObjectInstance *,void *>::_Freenode0<std::allocator<std::_Tree_node<CArea::SObjectInstance *,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::~_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@ABU?$less@PAUSObjectInstance@CArea@@@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@ABU?$less@PAUSObjectInstance@CArea@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@ABU?$less@PAUSObjectInstance@CArea@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);
; 41   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z
_TEXT	SEGMENT
__Result$ = -36						; size = 8
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
___param0$ = -12					; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1332 :     pair<iterator, bool> insert(const value_type& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1333 :         const auto _Result = _Emplace(_Val);

  00009	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0000c	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Emplace@ABH@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@HPAX@std@@_N@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Emplace<int const &>

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001b	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  00021	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 1334 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00024	8b 45 dc	 mov	 eax, DWORD PTR __Result$[ebp]
  00027	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0002a	8b 45 f4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00030	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00036	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00040	8d 45 e0	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00043	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  0004c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0004e	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1334 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00051	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1335 :     }

  00054	c9		 leave
  00055	c2 08 00	 ret	 8
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 24		 push	 36			; 00000024H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4529 :     _In_z_ const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	83 65 fc 00	 and	 DWORD PTR $T5[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00019	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3195 :         return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001f	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00022	6a 00		 push	 0
  00024	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00027	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0002c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00032	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4530 :     return _STD move(_Right.insert(0, _Left));

  00035	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00040	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00043	83 c8 01	 or	 eax, 1
  00046	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4531 : }

  0004c	c9		 leave
  0004d	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\case_conv.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\end.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\begin.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\iterator_range_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\case_conv.hpp
;	COMDAT ??$to_lower@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@algorithm@boost@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVlocale@3@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 8
$T2 = -20						; size = 4
_last$3 = -16						; size = 4
_first$4 = -12						; size = 4
$T5 = -8						; size = 4
$T6 = -4						; size = 4
_Input$ = 8						; size = 4
_Loc$ = 12						; size = 4
??$to_lower@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@algorithm@boost@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVlocale@3@@Z PROC ; boost::algorithm::to_lower<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 94   :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\detail\case_conv.hpp

; 38   :                 to_lowerF( const std::locale& Loc ) : m_Loc( &Loc ) {}

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Loc$[ebp]
  00009	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\end.hpp

; 50   :             return c.end();

  0000c	8d 45 fc	 lea	 eax, DWORD PTR $T6[ebp]
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _Input$[ebp]
  00013	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\begin.hpp

; 49   :         return c.begin();

  00018	8d 45 f8	 lea	 eax, DWORD PTR $T5[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _Input$[ebp]
  0001f	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\range\iterator_range_core.hpp

; 520  :                 : base_type(impl::adl_begin(r), impl::adl_end(r))

  00024	8b 45 fc	 mov	 eax, DWORD PTR $T6[ebp]
  00027	89 45 f0	 mov	 DWORD PTR _last$3[ebp], eax
  0002a	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  0002d	89 45 f4	 mov	 DWORD PTR _first$4[ebp], eax

; 216  :         : m_Begin(Begin)

  00030	8b 45 f4	 mov	 eax, DWORD PTR _first$4[ebp]
  00033	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 217  :         , m_End(End)

  00036	8b 45 f0	 mov	 eax, DWORD PTR _last$3[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T1[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\algorithm\string\case_conv.hpp

; 95   :             ::boost::algorithm::detail::transform_range(

  0003c	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  0003f	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$transform_range@V?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@boost@@U?$to_lowerF@D@detail@algorithm@2@@detail@algorithm@boost@@YAXABV?$iterator_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@2@U?$to_lowerF@D@012@@Z ; boost::algorithm::detail::transform_range<boost::iterator_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >,boost::algorithm::detail::to_lowerF<char> >
  00048	59		 pop	 ecx
  00049	59		 pop	 ecx

; 96   :                 ::boost::as_literal(Input),
; 97   :                 ::boost::algorithm::detail::to_lowerF<
; 98   :                     typename range_value<WritableRangeT>::type >(Loc));
; 99   :         }

  0004a	c9		 leave
  0004b	c3		 ret	 0
??$to_lower@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@algorithm@boost@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVlocale@3@@Z ENDP ; boost::algorithm::to_lower<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4541 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	83 65 fc 00	 and	 DWORD PTR $T5[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00019	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001f	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4542 :     return _STD move(_Left.append(_Right));

  00033	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00041	83 c8 01	 or	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
  00047	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4543 : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 8
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
___param0$ = -16					; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1343 :     pair<iterator, bool> insert(value_type&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1344 :         const auto _Result = _Emplace(_STD move(_Val));

  0000f	ff 75 f8	 push	 DWORD PTR $T6[ebp]
  00012	8d 45 d8	 lea	 eax, DWORD PTR __Result$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@$$CBKPAVCEffectInstance@@@std@@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Emplace<std::pair<unsigned long const ,CEffectInstance *> >

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00021	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00024	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  0002a	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00046	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00049	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00052	8a 09		 mov	 cl, BYTE PTR [ecx]
  00054	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00057	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1346 :     }

  0005a	c9		 leave
  0005b	c2 08 00	 ret	 8
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 8
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
___param0$ = -16					; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1343 :     pair<iterator, bool> insert(value_type&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1344 :         const auto _Result = _Emplace(_STD move(_Val));

  0000f	ff 75 f8	 push	 DWORD PTR $T6[ebp]
  00012	8d 45 d8	 lea	 eax, DWORD PTR __Result$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@QAVCGraphicThingInstance@@K@std@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Emplace<std::pair<CGraphicThingInstance * const,unsigned long> >

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00021	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00024	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  0002a	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00046	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00049	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00052	8a 09		 mov	 cl, BYTE PTR [ecx]
  00054	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1345 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00057	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1346 :     }

  0005a	c9		 leave
  0005b	c2 08 00	 ret	 8
??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@V10@UFFindIfCRC@CArea@@@Z
_TEXT	SEGMENT
__It$ = -40						; size = 4
__ULast$ = -36						; size = 4
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Ptr$3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__Ptr$6 = -12						; size = 4
__UFirst$ = -8						; size = 4
$T7 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 4
??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@V10@UFFindIfCRC@CArea@@@Z PROC ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>, COMDAT

; 5787 : _NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5789 :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 e8	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5790 :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 dc	 mov	 DWORD PTR __ULast$[ebp], eax

; 5791 :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00038	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 08	 add	 eax, 8
  0003e	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@find_if:
  00041	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 dc	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 20		 je	 SHORT $LN3@find_if
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 178  : 				if (rCRCWithNumber.dwCRC == m_dwCRC)

  00049	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	3b 45 14	 cmp	 eax, DWORD PTR __Pred$[ebp]
  00051	75 06		 jne	 SHORT $LN26@find_if

; 179  : 					return true;

  00053	c6 45 ff 01	 mov	 BYTE PTR $T7[ebp], 1
  00057	eb 04		 jmp	 SHORT $LN25@find_if
$LN26@find_if:

; 180  : 				return false;

  00059	c6 45 ff 00	 mov	 BYTE PTR $T7[ebp], 0
$LN25@find_if:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5792 :         if (_Pred(*_UFirst)) {

  0005d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  00061	85 c0		 test	 eax, eax
  00063	74 02		 je	 SHORT $LN5@find_if

; 5793 :             break;

  00065	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 5794 :         }
; 5795 :     }

  00067	eb cf		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  00069	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0006c	89 45 d8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0006f	ff 75 d8	 push	 DWORD PTR __It$[ebp]
  00072	e8 00 00 00 00	 call	 ??$_Refancy@PAUSCRCWithNumber@CArea@@$0A@@std@@YAPAUSCRCWithNumber@CArea@@PAU12@@Z ; std::_Refancy<CArea::SCRCWithNumber *,0>
  00077	59		 pop	 ecx
  00078	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5798 :     return _First;

  0007b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00081	89 08		 mov	 DWORD PTR [eax], ecx
  00083	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5799 : }

  00086	c9		 leave
  00087	c3		 ret	 0
??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@V10@UFFindIfCRC@CArea@@@Z ENDP ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 40   :         this->_Adopt(_Plist);
; 41   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@std@@UCArea_FEffectInstanceRender@@@std@@YA?AUCArea_FEffectInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@0@0U1@@Z
_TEXT	SEGMENT
_pkEftInst$ = -36					; size = 4
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 1
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@std@@UCArea_FEffectInstanceRender@@@std@@YA?AUCArea_FEffectInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@0@0U1@@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectInstance *> > >,CArea_FEffectInstanceRender>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 12		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	89 45 dc	 mov	 DWORD PTR _pkEftInst$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 128  : 		pkEftInst->Render();

  00051	8b 4d dc	 mov	 ecx, DWORD PTR _pkEftInst$[ebp]
  00054	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 309  :     }

  00059	eb dd		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  0005b	8a 45 10	 mov	 al, BYTE PTR __Func$[ebp]

; 312  : }

  0005e	c9		 leave
  0005f	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@std@@UCArea_FEffectInstanceRender@@@std@@YA?AUCArea_FEffectInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@0@0U1@@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectInstance *> > >,CArea_FEffectInstanceRender>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??__Fs_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@YAXXZ
text$yd	SEGMENT
??__Fs_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@YAXXZ PROC ; `CArea::RenderEffect'::`9'::`dynamic atexit destructor for 's_kVct_pkEftInstSort'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 673  :         _Tidy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
  00008	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Tidy
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@YAXXZ ENDP ; `CArea::RenderEffect'::`9'::`dynamic atexit destructor for 's_kVct_pkEftInstSort''
text$yd	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CEffectInstance *> >::_Vector_val<std::_Simple_types<CEffectInstance *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CEffectInstance *> >::_Vector_val<std::_Simple_types<CEffectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXQAPAVCEffectInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXQAPAVCEffectInstance@@II@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXQAPAVCEffectInstance@@II@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXPAPAVCEffectInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXPAPAVCEffectInstance@@0@Z PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@AAEXPAPAVCEffectInstance@@0@Z ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCEffectInstance@@@std@@@std@@YAXPAPAVCEffectInstance@@QAPAV1@AAV?$allocator@PAVCEffectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CEffectInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCEffectInstance@@@std@@QAEXQAPAVCEffectInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCEffectInstance@@@std@@QAEXQAPAVCEffectInstance@@I@Z PROC ; std::allocator<CEffectInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCEffectInstance@@@std@@QAEXQAPAVCEffectInstance@@I@Z ENDP ; std::allocator<CEffectInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
__Scary$ = -32						; size = 4
___param0$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
___param0$ = -12					; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > > >,0>, COMDAT
; _this$ = ecx

; 1413 :     iterator erase(iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1079 :         return nullptr;

  00015	83 65 dc 00	 and	 DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 305  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001c	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 f4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00022	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 305  :         return _Tree_unchecked_iterator<_Mytree>(this->_Ptr, static_cast<const _Mytree*>(this->_Getcont()));

  00025	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  00028	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 1414 :         const auto _Scary = _Get_scary();
; 1415 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1416 :         _STL_VERIFY(_Where._Getcont() == _Scary, "map/set erase iterator from incorrect container");
; 1417 :         _STL_VERIFY(!_Where._Ptr->_Isnil, "cannot erase map/set end() iterator");
; 1418 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1419 :         return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);

  0002b	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00033	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Erase_unchecked
  0003e	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00044	8b 4d e4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 1414 :         const auto _Scary = _Get_scary();
; 1415 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1416 :         _STL_VERIFY(_Where._Getcont() == _Scary, "map/set erase iterator from incorrect container");
; 1417 :         _STL_VERIFY(!_Where._Ptr->_Isnil, "cannot erase map/set end() iterator");
; 1418 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1419 :         return iterator(_Erase_unchecked(_Where._Unwrapped()), _Scary);

  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1420 :     }

  0004c	c9		 leave
  0004d	c2 08 00	 ret	 8
??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > > >,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Pnode$ = -12						; size = 4
__Pnode$2 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00015	85 c0		 test	 eax, eax
  00017	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 f8	 mov	 DWORD PTR __Pnode$2[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$2[ebp]
  00027	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002b	85 c0		 test	 eax, eax
  0002d	75 17		 jne	 SHORT $LN3@operator
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003a	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00044	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  0004e	eb 30		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN9@operator

; 452  :             _Pnode = _Pnode->_Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  00070	eb e9		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 454  : 
; 455  :         return _Pnode;

  00072	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  00083	c9		 leave
  00084	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CArea::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A ; CArea::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCArea@@@@UAE@XZ ; CDynamicPool<CArea>::~CDynamicPool<CArea>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CArea::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??__E?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CArea::ms_kPool'', COMDAT

; 19   : CDynamicPool<CArea>						CArea::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A ; CArea::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCArea@@@@QAE@XZ ; CDynamicPool<CArea>::CDynamicPool<CArea>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CArea::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CArea::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCArea@@@@UAEPAXI@Z PROC		; CDynamicPool<CArea>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCArea@@@@UAE@XZ ; CDynamicPool<CArea>::~CDynamicPool<CArea>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCArea@@@@UAEPAXI@Z ENDP		; CDynamicPool<CArea>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXQAPAVCArea@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXQAPAVCArea@@II@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXQAPAVCArea@@II@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCArea@@@std@@QAEXQAPAVCArea@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCArea@@@std@@QAEXQAPAVCArea@@I@Z PROC ; std::allocator<CArea *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCArea@@@std@@QAEXQAPAVCArea@@I@Z ENDP ; std::allocator<CArea *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCArea@@@@KAXPAVCArea@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCArea@@@@KAXPAVCArea@@@Z PROC	; CDynamicPool<CArea>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCArea@@@@KAXPAVCArea@@@Z ENDP	; CDynamicPool<CArea>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ PROC	; CDynamicPool<CArea>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 5a		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	68 a0 00 00 00	 push	 160			; 000000a0H
  0005e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00063	59		 pop	 ecx
  00064	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006f	74 0d		 je	 SHORT $LN4@Alloc
  00071	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00074	e8 00 00 00 00	 call	 ??0CArea@@QAE@XZ	; CArea::CArea
  00079	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007e	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00082	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00085	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00092	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00095	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::emplace_back<CArea * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a7	40		 inc	 eax
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ae	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000b1	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000bc	6a 04		 push	 4
  000be	58		 pop	 eax
  000bf	6b c0 ff	 imul	 eax, eax, -1
  000c2	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c5	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000cb	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000dc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000e2	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000eb	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f6	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ff	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00102	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	83 e8 04	 sub	 eax, 4
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00115	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ$0:
  00000	68 a0 00 00 00	 push	 160			; 000000a0H
  00005	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ ENDP	; CDynamicPool<CArea>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCArea@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCArea@@@@QAEXXZ PROC		; CDynamicPool<CArea>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCArea@@@@KAXPAVCArea@@@Z ; CDynamicPool<CArea>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@std@@P6AXPAVCArea@@@Z@std@@YAP6AXPAVCArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea *> > >,void (__cdecl*)(CArea *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCArea@@@@QAEXXZ ENDP		; CDynamicPool<CArea>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCArea@@@@UAE@XZ PROC			; CDynamicPool<CArea>::~CDynamicPool<CArea>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCArea@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCArea@@@@UAE@XZ ENDP			; CDynamicPool<CArea>::~CDynamicPool<CArea>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCArea@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCArea@@@@QAE@XZ PROC			; CDynamicPool<CArea>::CDynamicPool<CArea>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCArea@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCArea@@@@QAE@XZ ENDP			; CDynamicPool<CArea>::CDynamicPool<CArea>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CArea::ms_DungeonBlockInstancePool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A ; CArea::ms_DungeonBlockInstancePool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ ; CDynamicPool<CDungeonBlock>::~CDynamicPool<CDungeonBlock>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CArea::ms_DungeonBlockInstancePool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??__E?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CArea::ms_DungeonBlockInstancePool'', COMDAT

; 18   : CDynamicPool<CDungeonBlock>				CArea::ms_DungeonBlockInstancePool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A ; CArea::ms_DungeonBlockInstancePool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCDungeonBlock@@@@QAE@XZ ; CDynamicPool<CDungeonBlock>::CDynamicPool<CDungeonBlock>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CArea::ms_DungeonBlockInstancePool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CArea::ms_DungeonBlockInstancePool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z PROC	; CDynamicPool<CDungeonBlock>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ ; CDynamicPool<CDungeonBlock>::~CDynamicPool<CDungeonBlock>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCDungeonBlock@@@@UAEPAXI@Z ENDP	; CDynamicPool<CDungeonBlock>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCDungeonBlock@@@@KAXPAVCDungeonBlock@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCDungeonBlock@@@@KAXPAVCDungeonBlock@@@Z PROC ; CDynamicPool<CDungeonBlock>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCDungeonBlock@@@@KAXPAVCDungeonBlock@@@Z ENDP ; CDynamicPool<CDungeonBlock>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ PROC ; CDynamicPool<CDungeonBlock>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 5a		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	68 bc 01 00 00	 push	 444			; 000001bcH
  0005e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00063	59		 pop	 ecx
  00064	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006f	74 0d		 je	 SHORT $LN4@Alloc
  00071	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00074	e8 00 00 00 00	 call	 ??0CDungeonBlock@@QAE@XZ ; CDungeonBlock::CDungeonBlock
  00079	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007e	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00082	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00085	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00092	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00095	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a7	40		 inc	 eax
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ae	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000b1	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000bc	6a 04		 push	 4
  000be	58		 pop	 eax
  000bf	6b c0 ff	 imul	 eax, eax, -1
  000c2	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c5	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000cb	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000dc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000e2	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000eb	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f6	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ff	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00102	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	83 e8 04	 sub	 eax, 4
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00115	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ$0:
  00000	68 bc 01 00 00	 push	 444			; 000001bcH
  00005	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ ENDP ; CDynamicPool<CDungeonBlock>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCDungeonBlock@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCDungeonBlock@@@@QAEXXZ PROC	; CDynamicPool<CDungeonBlock>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCDungeonBlock@@@@KAXPAVCDungeonBlock@@@Z ; CDynamicPool<CDungeonBlock>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@std@@P6AXPAVCDungeonBlock@@@Z@std@@YAP6AXPAVCDungeonBlock@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCDungeonBlock@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CDungeonBlock *> > >,void (__cdecl*)(CDungeonBlock *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCDungeonBlock@@@@QAEXXZ ENDP	; CDynamicPool<CDungeonBlock>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ PROC		; CDynamicPool<CDungeonBlock>::~CDynamicPool<CDungeonBlock>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCDungeonBlock@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCDungeonBlock@@@@UAE@XZ ENDP		; CDynamicPool<CDungeonBlock>::~CDynamicPool<CDungeonBlock>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCDungeonBlock@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCDungeonBlock@@@@QAE@XZ PROC		; CDynamicPool<CDungeonBlock>::CDynamicPool<CDungeonBlock>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCDungeonBlock@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCDungeonBlock@@@@QAE@XZ ENDP		; CDynamicPool<CDungeonBlock>::CDynamicPool<CDungeonBlock>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CArea::ms_AmbienceInstancePool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A ; CArea::ms_AmbienceInstancePool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SAmbienceInstance>::~CDynamicPool<CArea::SAmbienceInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CArea::ms_AmbienceInstancePool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??__E?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CArea::ms_AmbienceInstancePool'', COMDAT

; 17   : CDynamicPool<CArea::TAmbienceInstance>	CArea::ms_AmbienceInstancePool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A ; CArea::ms_AmbienceInstancePool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@USAmbienceInstance@CArea@@@@QAE@XZ ; CDynamicPool<CArea::SAmbienceInstance>::CDynamicPool<CArea::SAmbienceInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CArea::ms_AmbienceInstancePool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CArea::ms_AmbienceInstancePool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z PROC ; CDynamicPool<CArea::SAmbienceInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SAmbienceInstance>::~CDynamicPool<CArea::SAmbienceInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@USAmbienceInstance@CArea@@@@UAEPAXI@Z ENDP ; CDynamicPool<CArea::SAmbienceInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@USAmbienceInstance@CArea@@@@KAXPAUSAmbienceInstance@CArea@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@USAmbienceInstance@CArea@@@@KAXPAUSAmbienceInstance@CArea@@@Z PROC ; CDynamicPool<CArea::SAmbienceInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@USAmbienceInstance@CArea@@@@KAXPAUSAmbienceInstance@CArea@@@Z ENDP ; CDynamicPool<CArea::SAmbienceInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ PROC ; CDynamicPool<CArea::SAmbienceInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 6c		 push	 108			; 0000006cH
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0SAmbienceInstance@CArea@@QAE@XZ ; CArea::SAmbienceInstance::SAmbienceInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ$0:
  00000	6a 6c		 push	 108			; 0000006cH
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ ENDP ; CDynamicPool<CArea::SAmbienceInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEXXZ PROC ; CDynamicPool<CArea::SAmbienceInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@USAmbienceInstance@CArea@@@@KAXPAUSAmbienceInstance@CArea@@@Z ; CDynamicPool<CArea::SAmbienceInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@std@@P6AXPAUSAmbienceInstance@CArea@@@Z@std@@YAP6AXPAUSAmbienceInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSAmbienceInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SAmbienceInstance *> > >,void (__cdecl*)(CArea::SAmbienceInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEXXZ ENDP ; CDynamicPool<CArea::SAmbienceInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ PROC ; CDynamicPool<CArea::SAmbienceInstance>::~CDynamicPool<CArea::SAmbienceInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@USAmbienceInstance@CArea@@@@UAE@XZ ENDP ; CDynamicPool<CArea::SAmbienceInstance>::~CDynamicPool<CArea::SAmbienceInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@USAmbienceInstance@CArea@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@USAmbienceInstance@CArea@@@@QAE@XZ PROC ; CDynamicPool<CArea::SAmbienceInstance>::CDynamicPool<CArea::SAmbienceInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@USAmbienceInstance@CArea@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@USAmbienceInstance@CArea@@@@QAE@XZ ENDP ; CDynamicPool<CArea::SAmbienceInstance>::CDynamicPool<CArea::SAmbienceInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CArea::ms_AttributeInstancePool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A ; CArea::ms_AttributeInstancePool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CArea::ms_AttributeInstancePool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??__E?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CArea::ms_AttributeInstancePool'', COMDAT

; 16   : CDynamicPool<CAttributeInstance>		CArea::ms_AttributeInstancePool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A ; CArea::ms_AttributeInstancePool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ ; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CArea::ms_AttributeInstancePool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CArea::ms_AttributeInstancePool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCAttributeInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CAttributeInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXQAPAVCAttributeInstance@@II@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXPAPAVCAttributeInstance@@0@Z ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAttributeInstance@@@std@@@std@@YAXPAPAVCAttributeInstance@@QAPAV1@AAV?$allocator@PAVCAttributeInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CAttributeInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z PROC ; std::allocator<CAttributeInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCAttributeInstance@@@std@@QAEXQAPAVCAttributeInstance@@I@Z ENDP ; std::allocator<CAttributeInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z PROC ; CDynamicPool<CAttributeInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ENDP ; CDynamicPool<CAttributeInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ PROC ; CDynamicPool<CAttributeInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 5c		 push	 92			; 0000005cH
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CAttributeInstance@@QAE@XZ ; CAttributeInstance::CAttributeInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ$0:
  00000	6a 5c		 push	 92			; 0000005cH
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ENDP ; CDynamicPool<CAttributeInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ PROC ; CDynamicPool<CAttributeInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCAttributeInstance@@@@KAXPAVCAttributeInstance@@@Z ; CDynamicPool<CAttributeInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@std@@P6AXPAVCAttributeInstance@@@Z@std@@YAP6AXPAVCAttributeInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAttributeInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CAttributeInstance *> > >,void (__cdecl*)(CAttributeInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ENDP ; CDynamicPool<CAttributeInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ PROC	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@AAEXXZ ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCAttributeInstance@@@@UAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::~CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ PROC	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCAttributeInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCAttributeInstance@@@@QAE@XZ ENDP	; CDynamicPool<CAttributeInstance>::CDynamicPool<CAttributeInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CArea::ms_ObjectInstancePool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A ; CArea::ms_ObjectInstancePool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SObjectInstance>::~CDynamicPool<CArea::SObjectInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CArea::ms_ObjectInstancePool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??__E?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CArea::ms_ObjectInstancePool'', COMDAT

; 15   : CDynamicPool<CArea::TObjectInstance>	CArea::ms_ObjectInstancePool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A ; CArea::ms_ObjectInstancePool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@USObjectInstance@CArea@@@@QAE@XZ ; CDynamicPool<CArea::SObjectInstance>::CDynamicPool<CArea::SObjectInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CArea::ms_ObjectInstancePool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CArea::ms_ObjectInstancePool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z PROC ; CDynamicPool<CArea::SObjectInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ ; CDynamicPool<CArea::SObjectInstance>::~CDynamicPool<CArea::SObjectInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@USObjectInstance@CArea@@@@UAEPAXI@Z ENDP ; CDynamicPool<CArea::SObjectInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@USObjectInstance@CArea@@@@KAXPAUSObjectInstance@CArea@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@USObjectInstance@CArea@@@@KAXPAUSObjectInstance@CArea@@@Z PROC ; CDynamicPool<CArea::SObjectInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@USObjectInstance@CArea@@@@KAXPAUSObjectInstance@CArea@@@Z ENDP ; CDynamicPool<CArea::SObjectInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
tv130 = -36						; size = 4
__My_data$10 = -32					; size = 4
__Mylast$11 = -28					; size = 4
$T12 = -24						; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ PROC ; CDynamicPool<CArea::SObjectInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e0	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00034	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 dc 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 dc	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 63		 je	 SHORT $LN2@Alloc

; 65   : 				T* pkNewData=new T;

  00059	6a 28		 push	 40			; 00000028H
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 e8	 mov	 DWORD PTR $T12[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d e8 00	 cmp	 DWORD PTR $T12[ebp], 0
  0006c	74 19		 je	 SHORT $LN4@Alloc
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 146  : 			SObjectInstance()

  0006e	8b 45 e8	 mov	 eax, DWORD PTR $T12[ebp]
  00071	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SObjectInstance@CArea@@6B@

; 147  : 			{
; 148  : 				__Initialize();

  00077	8b 4d e8	 mov	 ecx, DWORD PTR $T12[ebp]
  0007a	e8 00 00 00 00	 call	 ?__Initialize@SObjectInstance@CArea@@QAEXXZ ; CArea::SObjectInstance::__Initialize
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 65   : 				T* pkNewData=new T;

  0007f	8b 45 e8	 mov	 eax, DWORD PTR $T12[ebp]
  00082	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00085	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  00087	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0008b	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  0008e	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00091	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00095	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  00098	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009b	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  0009e	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  000a5	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::emplace_back<CArea::SObjectInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000aa	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000b0	40		 inc	 eax
  000b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000b7	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ba	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 c0 10	 add	 eax, 16			; 00000010H
  000c2	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000c5	6a 04		 push	 4
  000c7	58		 pop	 eax
  000c8	6b c0 ff	 imul	 eax, eax, -1
  000cb	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000ce	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000d1	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000d4	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000dc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 c0 10	 add	 eax, 16			; 00000010H
  000e2	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000e5	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000eb	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000ee	83 c0 04	 add	 eax, 4
  000f1	89 45 e4	 mov	 DWORD PTR __Mylast$11[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000f4	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	83 e8 04	 sub	 eax, 4
  000fc	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ff	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00102	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00105	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00108	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0010b	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  0010e	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00111	8b 45 e4	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00114	8b 00		 mov	 eax, DWORD PTR [eax]
  00116	83 e8 04	 sub	 eax, 4
  00119	8b 4d e4	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  0011c	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  0011e	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00121	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00124	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012b	59		 pop	 ecx
  0012c	c9		 leave
  0012d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ$0:
  00000	6a 28		 push	 40			; 00000028H
  00002	ff 75 e8	 push	 DWORD PTR $T12[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ ENDP ; CDynamicPool<CArea::SObjectInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@USObjectInstance@CArea@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@USObjectInstance@CArea@@@@QAEXXZ PROC ; CDynamicPool<CArea::SObjectInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@USObjectInstance@CArea@@@@KAXPAUSObjectInstance@CArea@@@Z ; CDynamicPool<CArea::SObjectInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@P6AXPAUSObjectInstance@CArea@@@Z@std@@YAP6AXPAUSObjectInstance@CArea@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >,void (__cdecl*)(CArea::SObjectInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@USObjectInstance@CArea@@@@QAEXXZ ENDP ; CDynamicPool<CArea::SObjectInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ PROC	; CDynamicPool<CArea::SObjectInstance>::~CDynamicPool<CArea::SObjectInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@USObjectInstance@CArea@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@USObjectInstance@CArea@@@@UAE@XZ ENDP	; CDynamicPool<CArea::SObjectInstance>::~CDynamicPool<CArea::SObjectInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@USObjectInstance@CArea@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@USObjectInstance@CArea@@@@QAE@XZ PROC	; CDynamicPool<CArea::SObjectInstance>::CDynamicPool<CArea::SObjectInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@USObjectInstance@CArea@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@USObjectInstance@CArea@@@@QAE@XZ ENDP	; CDynamicPool<CArea::SObjectInstance>::CDynamicPool<CArea::SObjectInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S23$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S23$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Find<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc c4 4e
	ec 04		 mov	 DWORD PTR $T7[ebp], 82595524 ; 04ec4ec4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCArea@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCArea@@UAEPAXI@Z PROC				; CArea::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CArea@@UAE@XZ	; CArea::~CArea
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 a0 00 00 00	 push	 160			; 000000a0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCArea@@UAEPAXI@Z ENDP				; CArea::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Delete@CArea@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkArea$ = 8						; size = 4
?Delete@CArea@@SAXPAV1@@Z PROC				; CArea::Delete, COMDAT

; 32   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 33   : 	pkArea->Clear();

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _pkArea$[ebp]
  00007	e8 00 00 00 00	 call	 ?Clear@CArea@@QAEXXZ	; CArea::Clear

; 34   : 	ms_kPool.Free(pkArea);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkArea$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00015	50		 push	 eax
  00016	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A+16
  0001b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXABQAVCArea@@@Z ; std::vector<CArea *,std::allocator<CArea *> >::emplace_back<CArea * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 35   : }

  00020	c9		 leave
  00021	c3		 ret	 0
?Delete@CArea@@SAXPAV1@@Z ENDP				; CArea::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?New@CArea@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CArea@@SAPAV1@XZ PROC				; CArea::New, COMDAT

; 27   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 28   : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A ; CArea::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCArea@@@@QAEPAVCArea@@XZ ; CDynamicPool<CArea>::Alloc

; 29   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CArea@@SAPAV1@XZ ENDP				; CArea::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?DestroySystem@CArea@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CArea@@SAXXZ PROC			; CArea::DestroySystem, COMDAT

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 39   : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A ; CArea::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCArea@@@@QAEXXZ ; CDynamicPool<CArea>::Destroy

; 40   : 
; 41   : 	ms_ObjectInstancePool.Destroy();

  0000d	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A ; CArea::ms_ObjectInstancePool
  00012	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@USObjectInstance@CArea@@@@QAEXXZ ; CDynamicPool<CArea::SObjectInstance>::Destroy

; 42   : 	ms_AttributeInstancePool.Destroy();

  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A ; CArea::ms_AttributeInstancePool
  0001c	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCAttributeInstance@@@@QAEXXZ ; CDynamicPool<CAttributeInstance>::Destroy

; 43   : 	ms_AmbienceInstancePool.Destroy();

  00021	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A ; CArea::ms_AmbienceInstancePool
  00026	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEXXZ ; CDynamicPool<CArea::SAmbienceInstance>::Destroy

; 44   : 	ms_DungeonBlockInstancePool.Destroy();

  0002b	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A ; CArea::ms_DungeonBlockInstancePool
  00030	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCDungeonBlock@@@@QAEXXZ ; CDynamicPool<CDungeonBlock>::Destroy

; 45   : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?DestroySystem@CArea@@SAXXZ ENDP			; CArea::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@U?$_Tree_id@PAU?$_Tree_node@HPAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@U?$_Tree_id@PAU?$_Tree_node@HPAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEPAU?$_Tree_node@HPAX@2@U?$_Tree_id@PAU?$_Tree_node@HPAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXPAU?$_Tree_node@HPAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S24$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S24$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc cc cc
	cc 0c		 mov	 DWORD PTR $T7[ebp], 214748364 ; 0cccccccH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 03	 sar	 eax, 3
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 03	 shl	 eax, 3
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXQAUSCRCWithNumber@CArea@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXQAUSCRCWithNumber@CArea@@II@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 03	 sar	 eax, 3
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 03	 shl	 eax, 3
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXQAUSCRCWithNumber@CArea@@II@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 03	 sar	 eax, 3
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 1f		 mov	 DWORD PTR $T7[ebp], 536870911 ; 1fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXPAUSCRCWithNumber@CArea@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXPAUSCRCWithNumber@CArea@@0@Z PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXPAUSCRCWithNumber@CArea@@0@Z ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@YAXPAUSCRCWithNumber@CArea@@QAU12@AAV?$allocator@USCRCWithNumber@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SCRCWithNumber> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXQAUSCRCWithNumber@CArea@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXQAUSCRCWithNumber@CArea@@I@Z PROC ; std::allocator<CArea::SCRCWithNumber>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 03	 shl	 eax, 3
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@USCRCWithNumber@CArea@@@std@@QAEXQAUSCRCWithNumber@CArea@@I@Z ENDP ; std::allocator<CArea::SCRCWithNumber>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@@std@@QAE@XZ PROC ; std::map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >::~map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@@std@@QAE@XZ ENDP ; std::map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >::~map<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S25$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S25$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<CGraphicThingInstance * const,unsigned long>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCGraphicThingInstance@@@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCGraphicThingInstance@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCGraphicThingInstance@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXQAPAUSAmbienceInstance@CArea@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXQAPAUSAmbienceInstance@CArea@@II@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXQAPAUSAmbienceInstance@CArea@@II@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXPAPAUSAmbienceInstance@CArea@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXPAPAUSAmbienceInstance@CArea@@0@Z PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXPAPAUSAmbienceInstance@CArea@@0@Z ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@YAXPAPAUSAmbienceInstance@CArea@@QAPAU12@AAV?$allocator@PAUSAmbienceInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SAmbienceInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::~vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::~vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAUSAmbienceInstance@CArea@@@std@@QAEXQAPAUSAmbienceInstance@CArea@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUSAmbienceInstance@CArea@@@std@@QAEXQAPAUSAmbienceInstance@CArea@@I@Z PROC ; std::allocator<CArea::SAmbienceInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSAmbienceInstance@CArea@@@std@@QAEXQAPAUSAmbienceInstance@CArea@@I@Z ENDP ; std::allocator<CArea::SAmbienceInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@CAXXZ PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@CAXXZ ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXQAPAVCDungeonBlock@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXQAPAVCDungeonBlock@@II@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXQAPAVCDungeonBlock@@II@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@ABEII@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@ABEII@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXPAPAVCDungeonBlock@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXPAPAVCDungeonBlock@@0@Z PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXPAPAVCDungeonBlock@@0@Z ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCDungeonBlock@@@std@@@std@@YAXPAPAVCDungeonBlock@@QAPAV1@AAV?$allocator@PAVCDungeonBlock@@@0@@Z ; std::_Destroy_range<std::allocator<CDungeonBlock *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAE@XZ PROC ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::~vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::~vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCDungeonBlock@@@std@@QAEXQAPAVCDungeonBlock@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCDungeonBlock@@@std@@QAEXQAPAVCDungeonBlock@@I@Z PROC ; std::allocator<CDungeonBlock *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCDungeonBlock@@@std@@QAEXQAPAVCDungeonBlock@@I@Z ENDP ; std::allocator<CDungeonBlock *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXQAPAVCGraphicThingInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXQAPAVCGraphicThingInstance@@II@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXQAPAVCGraphicThingInstance@@II@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXPAPAVCGraphicThingInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXPAPAVCGraphicThingInstance@@0@Z PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXPAPAVCGraphicThingInstance@@0@Z ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@YAXPAPAVCGraphicThingInstance@@QAPAV1@AAV?$allocator@PAVCGraphicThingInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicThingInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXQAPAVCGraphicThingInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXQAPAVCGraphicThingInstance@@I@Z PROC ; std::allocator<CGraphicThingInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicThingInstance@@@std@@QAEXQAPAVCGraphicThingInstance@@I@Z ENDP ; std::allocator<CGraphicThingInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEAAV?$allocator@PAUSObjectInstance@CArea@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEAAV?$allocator@PAUSObjectInstance@CArea@@@2@XZ PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEAAV?$allocator@PAUSObjectInstance@CArea@@@2@XZ ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXQAPAUSObjectInstance@CArea@@II@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXPAPAUSObjectInstance@CArea@@0@Z ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@YAXPAPAUSObjectInstance@CArea@@QAPAU12@AAV?$allocator@PAUSObjectInstance@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::~vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::~vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z PROC ; std::allocator<CArea::SObjectInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSObjectInstance@CArea@@@std@@QAEXQAPAUSObjectInstance@CArea@@I@Z ENDP ; std::allocator<CArea::SObjectInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
_TEXT	SEGMENT
_this$ = -96						; size = 4
_j$2 = -92						; size = 4
_Data$ = -88						; size = 72
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pObjectInstance$ = 8					; size = 4
_c_pData$ = 12						; size = 4
_pProperty$ = 16					; size = 4
?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z PROC ; CArea::__SetObjectInstance_SetDungeonBlock, COMDAT
; _this$ = ecx

; 697  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d a0	 mov	 DWORD PTR _this$[ebp], ecx

; 698  : 	prt::TPropertyDungeonBlock Data;

  0002b	8d 4d a8	 lea	 ecx, DWORD PTR _Data$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0TPropertyDungeonBlock@prt@@QAE@XZ
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 699  : 	if (!prt::PropertyDungeonBlockStringToData(pProperty, &Data))

  00037	8d 45 a8	 lea	 eax, DWORD PTR _Data$[ebp]
  0003a	50		 push	 eax
  0003b	ff 75 10	 push	 DWORD PTR _pProperty$[ebp]
  0003e	e8 00 00 00 00	 call	 ?PropertyDungeonBlockStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyDungeonBlock@1@@Z ; prt::PropertyDungeonBlockStringToData
  00043	59		 pop	 ecx
  00044	59		 pop	 ecx
  00045	0f b6 c0	 movzx	 eax, al
  00048	85 c0		 test	 eax, eax
  0004a	75 11		 jne	 SHORT $LN5@SetObjectI

; 700  : 		return;

  0004c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00050	8d 4d a8	 lea	 ecx, DWORD PTR _Data$[ebp]
  00053	e8 00 00 00 00	 call	 ??1TPropertyDungeonBlock@prt@@QAE@XZ
  00058	e9 1c 01 00 00	 jmp	 $LN1@SetObjectI
$LN5@SetObjectI:

; 701  : 
; 702  : 	pObjectInstance->dwType = prt::PROPERTY_TYPE_DUNGEON_BLOCK;

  0005d	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00060	c7 40 04 05 00
	00 00		 mov	 DWORD PTR [eax+4], 5

; 703  : 	pObjectInstance->pDungeonBlock = ms_DungeonBlockInstancePool.Alloc();

  00067	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A ; CArea::ms_DungeonBlockInstancePool
  0006c	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCDungeonBlock@@@@QAEPAVCDungeonBlock@@XZ ; CDynamicPool<CDungeonBlock>::Alloc
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  00074	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 704  : 	pObjectInstance->pDungeonBlock->Load(Data.strFileName.c_str());

  00077	8d 4d c0	 lea	 ecx, DWORD PTR _Data$[ebp+24]
  0007a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0007f	50		 push	 eax
  00080	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00083	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00086	e8 00 00 00 00	 call	 ?Load@CDungeonBlock@@QAE_NPBD@Z ; CDungeonBlock::Load

; 705  : 	pObjectInstance->pDungeonBlock->SetPosition(c_pData->Position.x, c_pData->Position.y, c_pData->Position.z + c_pData->m_fHeightBias);

  0008b	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  0008e	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00091	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00096	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  0009b	51		 push	 ecx
  0009c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a1	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  000a4	51		 push	 ecx
  000a5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000af	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  000b2	51		 push	 ecx
  000b3	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bc	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000bf	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000c2	e8 00 00 00 00	 call	 ?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z ; CGraphicObjectInstance::SetPosition

; 706  : 	pObjectInstance->pDungeonBlock->SetRotation(

  000c7	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  000ca	51		 push	 ecx
  000cb	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  000d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d5	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  000d8	51		 push	 ecx
  000d9	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  000de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e3	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  000e6	51		 push	 ecx
  000e7	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  000ec	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f1	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000f4	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  000f7	e8 00 00 00 00	 call	 ?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z ; CGraphicObjectInstance::SetRotation

; 707  : 		c_pData->m_fYaw,
; 708  : 		c_pData->m_fPitch,
; 709  : 		c_pData->m_fRoll
; 710  : 	);
; 711  : 	pObjectInstance->pDungeonBlock->Update();

  000fc	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000ff	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00102	e8 00 00 00 00	 call	 ?Update@CDungeonBlock@@QAEXXZ ; CDungeonBlock::Update

; 712  : 	pObjectInstance->pDungeonBlock->BuildBoundingSphere();

  00107	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0010a	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  0010d	e8 00 00 00 00	 call	 ?BuildBoundingSphere@CDungeonBlock@@QAEXXZ ; CDungeonBlock::BuildBoundingSphere

; 713  : 	pObjectInstance->pDungeonBlock->RegisterBoundingSphere();

  00112	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00115	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00118	e8 00 00 00 00	 call	 ?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RegisterBoundingSphere

; 714  : 	for (int j = 0; j < PORTAL_ID_MAX_NUM; ++j)

  0011d	83 65 a4 00	 and	 DWORD PTR _j$2[ebp], 0
  00121	eb 07		 jmp	 SHORT $LN4@SetObjectI
$LN2@SetObjectI:
  00123	8b 45 a4	 mov	 eax, DWORD PTR _j$2[ebp]
  00126	40		 inc	 eax
  00127	89 45 a4	 mov	 DWORD PTR _j$2[ebp], eax
$LN4@SetObjectI:
  0012a	83 7d a4 08	 cmp	 DWORD PTR _j$2[ebp], 8
  0012e	7d 29		 jge	 SHORT $LN3@SetObjectI

; 715  : 		if (0 != c_pData->abyPortalID[j])

  00130	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00133	03 45 a4	 add	 eax, DWORD PTR _j$2[ebp]
  00136	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0013a	85 c0		 test	 eax, eax
  0013c	74 19		 je	 SHORT $LN6@SetObjectI

; 716  : 			pObjectInstance->pDungeonBlock->SetPortal(j, c_pData->abyPortalID[j]);

  0013e	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00141	03 45 a4	 add	 eax, DWORD PTR _j$2[ebp]
  00144	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  00148	50		 push	 eax
  00149	ff 75 a4	 push	 DWORD PTR _j$2[ebp]
  0014c	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0014f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00152	e8 00 00 00 00	 call	 ?SetPortal@CGraphicObjectInstance@@QAEXKH@Z ; CGraphicObjectInstance::SetPortal
$LN6@SetObjectI:
  00157	eb ca		 jmp	 SHORT $LN2@SetObjectI
$LN3@SetObjectI:

; 717  : 	__LoadAttribute(pObjectInstance, Data.strAttributeDataFileName.c_str());

  00159	8d 4d d8	 lea	 ecx, DWORD PTR _Data$[ebp+48]
  0015c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00161	50		 push	 eax
  00162	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  00165	8b 4d a0	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	e8 00 00 00 00	 call	 ?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z ; CArea::__LoadAttribute

; 718  : }

  0016d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00171	8d 4d a8	 lea	 ecx, DWORD PTR _Data$[ebp]
  00174	e8 00 00 00 00	 call	 ??1TPropertyDungeonBlock@prt@@QAE@XZ
$LN1@SetObjectI:
  00179	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00183	59		 pop	 ecx
  00184	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00187	33 cd		 xor	 ecx, ebp
  00189	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0018e	c9		 leave
  0018f	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR _Data$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TPropertyDungeonBlock@prt@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ENDP ; CArea::__SetObjectInstance_SetDungeonBlock
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance_SetAmbience@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pAmbienceInstance$ = -4				; size = 4
_pObjectInstance$ = 8					; size = 4
_c_pData$ = 12						; size = 4
_pProperty$ = 16					; size = 4
?__SetObjectInstance_SetAmbience@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z PROC ; CArea::__SetObjectInstance_SetAmbience, COMDAT
; _this$ = ecx

; 668  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 669  : 	pObjectInstance->pAmbienceInstance = ms_AmbienceInstancePool.Alloc();

  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A ; CArea::ms_AmbienceInstancePool
  0000d	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@USAmbienceInstance@CArea@@@@QAEPAUSAmbienceInstance@CArea@@XZ ; CDynamicPool<CArea::SAmbienceInstance>::Alloc
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  00015	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 670  :  	if (!prt::PropertyAmbienceStringToData(pProperty, &pObjectInstance->pAmbienceInstance->AmbienceData))

  00018	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0001b	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0001e	83 c0 20	 add	 eax, 32			; 00000020H
  00021	50		 push	 eax
  00022	ff 75 10	 push	 DWORD PTR _pProperty$[ebp]
  00025	e8 00 00 00 00	 call	 ?PropertyAmbienceStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyAmbience@1@@Z ; prt::PropertyAmbienceStringToData
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	75 05		 jne	 SHORT $LN2@SetObjectI

; 671  : 		return;

  00033	e9 b8 00 00 00	 jmp	 $LN1@SetObjectI
$LN2@SetObjectI:

; 672  : 
; 673  : 	pObjectInstance->dwType = prt::PROPERTY_TYPE_AMBIENCE;

  00038	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0003b	c7 40 04 04 00
	00 00		 mov	 DWORD PTR [eax+4], 4

; 674  : 
; 675  : 	TAmbienceInstance * pAmbienceInstance = pObjectInstance->pAmbienceInstance;

  00042	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00045	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00048	89 45 fc	 mov	 DWORD PTR _pAmbienceInstance$[ebp], eax

; 676  : 	pAmbienceInstance->fx = c_pData->Position.x;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 677  : 	pAmbienceInstance->fy = c_pData->Position.y;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  0005c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0005f	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 678  : 	pAmbienceInstance->fz = c_pData->Position.z + c_pData->m_fHeightBias;

  00062	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00065	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00068	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0006d	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  00072	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  00075	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 679  : 	pAmbienceInstance->dwRange = c_pData->dwRange;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00080	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00083	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 680  : 	pAmbienceInstance->fMaxVolumeAreaPercentage = c_pData->fMaxVolumeAreaPercentage;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  0008c	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0008f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 681  : 
; 682  : 	if (0 == pAmbienceInstance->AmbienceData.strPlayType.compare("ONCE"))

  00092	68 00 00 00 00	 push	 OFFSET ??_C@_04GHGHGAKN@ONCE@
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _pAmbienceInstance$[ebp]
  0009a	83 c1 38	 add	 ecx, 56			; 00000038H
  0009d	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  000a2	85 c0		 test	 eax, eax
  000a4	75 0c		 jne	 SHORT $LN3@SetObjectI

; 683  : 	{
; 684  : 		pAmbienceInstance->Update = &TAmbienceInstance::UpdateOnceSound;

  000a6	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  000a9	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET ?UpdateOnceSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateOnceSound

; 685  : 	}

  000b0	eb 3e		 jmp	 SHORT $LN7@SetObjectI
$LN3@SetObjectI:

; 686  : 	else if (0 == pAmbienceInstance->AmbienceData.strPlayType.compare("STEP"))

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_04MOOLDHHD@STEP@
  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _pAmbienceInstance$[ebp]
  000ba	83 c1 38	 add	 ecx, 56			; 00000038H
  000bd	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  000c2	85 c0		 test	 eax, eax
  000c4	75 0c		 jne	 SHORT $LN5@SetObjectI

; 687  : 	{
; 688  : 		pAmbienceInstance->Update = &TAmbienceInstance::UpdateStepSound;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  000c9	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET ?UpdateStepSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateStepSound

; 689  : 	}

  000d0	eb 1e		 jmp	 SHORT $LN7@SetObjectI
$LN5@SetObjectI:

; 690  : 	else if (0 == pAmbienceInstance->AmbienceData.strPlayType.compare("LOOP"))

  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_04KGNEGCGI@LOOP@
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _pAmbienceInstance$[ebp]
  000da	83 c1 38	 add	 ecx, 56			; 00000038H
  000dd	e8 00 00 00 00	 call	 ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
  000e2	85 c0		 test	 eax, eax
  000e4	75 0a		 jne	 SHORT $LN7@SetObjectI

; 691  : 	{
; 692  : 		pAmbienceInstance->Update = &TAmbienceInstance::UpdateLoopSound;

  000e6	8b 45 fc	 mov	 eax, DWORD PTR _pAmbienceInstance$[ebp]
  000e9	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], OFFSET ?UpdateLoopSound@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::UpdateLoopSound
$LN7@SetObjectI:
$LN1@SetObjectI:

; 693  : 	}
; 694  : }

  000f0	c9		 leave
  000f1	c2 0c 00	 ret	 12			; 0000000cH
?__SetObjectInstance_SetAmbience@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ENDP ; CArea::__SetObjectInstance_SetAmbience
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 8
_pData$ = -60						; size = 4
$T3 = -56						; size = 8
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
$T9 = -28						; size = 4
_this$ = -24						; size = 4
_pEffectInstance$ = -20					; size = 4
_rem$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_mat$ = 0						; size = 64
_Data$ = 64						; size = 48
__$ArrayPad$ = 112					; size = 4
_pObjectInstance$ = 124					; size = 4
_c_pData$ = 128						; size = 4
_pProperty$ = 132					; size = 4
?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z PROC ; CArea::__SetObjectInstance_SetEffect, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	83 ec 74	 sub	 esp, 116		; 00000074H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 38	 sub	 esp, 56			; 00000038H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 535  : 	prt::TPropertyEffect Data;

  00030	8d 4d 40	 lea	 ecx, DWORD PTR _Data$[ebp]
  00033	e8 00 00 00 00	 call	 ??0TPropertyEffect@prt@@QAE@XZ
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 536  : 	if (!prt::PropertyEffectStringToData(pProperty, &Data))

  0003c	8d 45 40	 lea	 eax, DWORD PTR _Data$[ebp]
  0003f	50		 push	 eax
  00040	ff b5 84 00 00
	00		 push	 DWORD PTR _pProperty$[ebp]
  00046	e8 00 00 00 00	 call	 ?PropertyEffectStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyEffect@1@@Z ; prt::PropertyEffectStringToData
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx
  0004d	0f b6 c0	 movzx	 eax, al
  00050	85 c0		 test	 eax, eax
  00052	75 19		 jne	 SHORT $LN2@SetObjectI

; 537  : 		return;

  00054	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00058	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00060	8d 4d 40	 lea	 ecx, DWORD PTR _Data$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 537  : 		return;

  00068	e9 b0 01 00 00	 jmp	 $LN1@SetObjectI
$LN2@SetObjectI:

; 538  : 
; 539  : 	pObjectInstance->dwType = prt::PROPERTY_TYPE_EFFECT;

  0006d	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00070	c7 40 04 03 00
	00 00		 mov	 DWORD PTR [eax+4], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00077	8b 45 68	 mov	 eax, DWORD PTR _Data$[ebp+40]
  0007a	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 540  : 	pObjectInstance->dwEffectID = GetCaseCRC32(Data.strFileName.c_str(),Data.strFileName.size());

  0007d	ff 75 e4	 push	 DWORD PTR $T9[ebp]
  00080	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
  00083	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ?GetCaseCRC32@@YAKPBDI@Z ; GetCaseCRC32
  0008e	59		 pop	 ecx
  0008f	59		 pop	 ecx
  00090	8b 4d 7c	 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  00093	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 541  : 	CEffectManager & rem = CEffectManager::Instance();

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0009b	89 45 f0	 mov	 DWORD PTR _rem$[ebp], eax

; 542  : 	CEffectData * pData;
; 543  : 	if (!rem.GetEffectData(pObjectInstance->dwEffectID,&pData))

  0009e	8d 45 c4	 lea	 eax, DWORD PTR _pData$[ebp]
  000a1	50		 push	 eax
  000a2	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000a5	ff 70 18	 push	 DWORD PTR [eax+24]
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _rem$[ebp]
  000ab	e8 00 00 00 00	 call	 ?GetEffectData@CEffectManager@@QAE_NKPAPAVCEffectData@@@Z ; CEffectManager::GetEffectData
  000b0	0f b6 c0	 movzx	 eax, al
  000b3	85 c0		 test	 eax, eax
  000b5	75 4e		 jne	 SHORT $LN4@SetObjectI

; 544  : 	{
; 545  : 		if (!rem.RegisterEffect(Data.strFileName.c_str()))

  000b7	6a 00		 push	 0
  000b9	6a 00		 push	 0
  000bb	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
  000be	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000c3	50		 push	 eax
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR _rem$[ebp]
  000c7	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect
  000cc	85 c0		 test	 eax, eax
  000ce	75 35		 jne	 SHORT $LN4@SetObjectI

; 546  : 		{
; 547  : 			pObjectInstance->dwEffectID = 0xffffffff;

  000d0	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000d3	83 48 18 ff	 or	 DWORD PTR [eax+24], -1

; 548  : 			TraceError("CArea::SetEffect effect register error %s\n",Data.strFileName.c_str());

  000d7	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
  000da	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000df	50		 push	 eax
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BOJNBGJP@CArea?3?3SetEffect?5effect?5registe@
  000e5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000ea	59		 pop	 ecx
  000eb	59		 pop	 ecx

; 549  : 			return;

  000ec	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000f0	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000f3	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  000f8	8d 4d 40	 lea	 ecx, DWORD PTR _Data$[ebp]
  000fb	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 549  : 			return;

  00100	e9 18 01 00 00	 jmp	 $LN1@SetObjectI
$LN4@SetObjectI:

; 550  : 		}
; 551  : 	}
; 552  : 
; 553  : 	CEffectInstance * pEffectInstance;
; 554  : 	rem.CreateUnsafeEffectInstance(pObjectInstance->dwEffectID, &pEffectInstance);

  00105	8d 45 ec	 lea	 eax, DWORD PTR _pEffectInstance$[ebp]
  00108	50		 push	 eax
  00109	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0010c	ff 70 18	 push	 DWORD PTR [eax+24]
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _rem$[ebp]
  00112	e8 00 00 00 00	 call	 ?CreateUnsafeEffectInstance@CEffectManager@@QAEXKPAPAVCEffectInstance@@@Z ; CEffectManager::CreateUnsafeEffectInstance

; 555  : 
; 556  : 	D3DXMATRIX mat;
; 557  : 	D3DXMatrixRotationYawPitchRoll(&mat,

  00117	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  0011d	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  00122	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  0012a	51		 push	 ecx
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00136	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  0013b	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00143	51		 push	 ecx
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  0014f	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00154	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  0015c	51		 push	 ecx
  0015d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00162	8d 45 00	 lea	 eax, DWORD PTR _mat$[ebp]
  00165	50		 push	 eax
  00166	e8 00 00 00 00	 call	 _D3DXMatrixRotationYawPitchRoll@16

; 558  : 		D3DXToRadian(c_pData->m_fYaw),
; 559  : 		D3DXToRadian(c_pData->m_fPitch),
; 560  : 		D3DXToRadian(c_pData->m_fRoll)
; 561  : 	);
; 562  : 
; 563  : 	mat._41 = c_pData->Position.x;

  0016b	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00171	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00175	f3 0f 11 45 30	 movss	 DWORD PTR _mat$[ebp+48], xmm0

; 564  : 	mat._42 = c_pData->Position.y;

  0017a	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00180	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00185	f3 0f 11 45 34	 movss	 DWORD PTR _mat$[ebp+52], xmm0

; 565  : 	mat._43 = c_pData->Position.z + c_pData->m_fHeightBias;

  0018a	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00190	8b 8d 80 00 00
	00		 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00196	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0019b	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  001a0	f3 0f 11 45 38	 movss	 DWORD PTR _mat$[ebp+56], xmm0

; 566  : 
; 567  : 	pEffectInstance->SetGlobalMatrix(mat);

  001a5	8d 45 00	 lea	 eax, DWORD PTR _mat$[ebp]
  001a8	50		 push	 eax
  001a9	8b 4d ec	 mov	 ecx, DWORD PTR _pEffectInstance$[ebp]
  001ac	e8 00 00 00 00	 call	 ?SetGlobalMatrix@CEffectInstance@@QAEXABUD3DXMATRIX@@@Z ; CEffectInstance::SetGlobalMatrix
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001b1	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001b9	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001bc	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  001bf	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax

; 1307 :         return _Get_scary()->_Mysize;

  001c2	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c8	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 569  : 	pObjectInstance->dwEffectInstanceIndex = m_EffectInstanceMap.size();

  001cb	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  001ce	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
  001d1	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 570  : 	m_EffectInstanceMap.insert(TEffectInstanceMap::value_type(pObjectInstance->dwEffectInstanceIndex, pEffectInstance));

  001d4	8b 45 7c	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  001d7	83 c0 1c	 add	 eax, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001da	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001dd	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  001e0	8b 00		 mov	 eax, DWORD PTR [eax]
  001e2	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001e5	8d 45 ec	 lea	 eax, DWORD PTR _pEffectInstance$[ebp]
  001e8	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001eb	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  001ee	8b 00		 mov	 eax, DWORD PTR [eax]
  001f0	89 45 cc	 mov	 DWORD PTR $T3[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 570  : 	m_EffectInstanceMap.insert(TEffectInstanceMap::value_type(pObjectInstance->dwEffectInstanceIndex, pEffectInstance));

  001f3	8d 45 c8	 lea	 eax, DWORD PTR $T3[ebp]
  001f6	50		 push	 eax
  001f7	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  001fa	50		 push	 eax
  001fb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00204	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@$$CBKPAVCEffectInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::insert<0,0>

; 571  : }

  00209	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0020d	8d 4d 58	 lea	 ecx, DWORD PTR _Data$[ebp+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00210	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00215	8d 4d 40	 lea	 ecx, DWORD PTR _Data$[ebp]
  00218	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1@SetObjectI:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 571  : }

  0021d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00220	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00227	59		 pop	 ecx
  00228	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0022b	33 cd		 xor	 ecx, ebp
  0022d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00232	83 c5 74	 add	 ebp, 116		; 00000074H
  00235	c9		 leave
  00236	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0:
  00000	8d 4d 40	 lea	 ecx, DWORD PTR _Data$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TPropertyEffect@prt@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a 7c	 mov	 ecx, DWORD PTR [edx+124]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ENDP ; CArea::__SetObjectInstance_SetEffect
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_this$ = -72						; size = 4
_iMotionCount$ = -68					; size = 4
$T3 = -64						; size = 1
$T4 = -60						; size = 4
tv292 = -56						; size = 4
tv170 = -52						; size = 4
_this$ = -48						; size = 4
_pLODModelThing$5 = -44					; size = 4
$T6 = -40						; size = 4
_iModelCount$ = -36					; size = 4
_rkResMgr$ = -32					; size = 4
_uLODIndex$7 = -28					; size = 4
_i$8 = -24						; size = 4
_j$9 = -20						; size = 4
_pThing$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T10 = 0						; size = 24
$T11 = 24						; size = 24
_Data$ = 48						; size = 76
_stSrcModelFileName$12 = 124				; size = 24
_stLODModelFileName$13 = 148				; size = 24
_szLODModelFileNameEnd$14 = 172				; size = 256
__$ArrayPad$ = 428					; size = 4
_pObjectInstance$ = 440					; size = 4
_c_pData$ = 444						; size = 4
_pProperty$ = 448					; size = 4
?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z PROC ; CArea::__SetObjectInstance_SetBuilding, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8d ac 24 50 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-432]
  00008	81 ec b0 01 00
	00		 sub	 esp, 432		; 000001b0H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 40	 sub	 esp, 64			; 00000040H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 ac 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx
  00039	83 65 b4 00	 and	 DWORD PTR $T2[ebp], 0

; 597  : 	prt::TPropertyBuilding Data;

  0003d	8d 4d 30	 lea	 ecx, DWORD PTR _Data$[ebp]
  00040	e8 00 00 00 00	 call	 ??0TPropertyBuilding@prt@@QAE@XZ
  00045	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 598  : 	if (!prt::PropertyBuildingStringToData(pProperty, &Data))

  00049	8d 45 30	 lea	 eax, DWORD PTR _Data$[ebp]
  0004c	50		 push	 eax
  0004d	ff b5 c0 01 00
	00		 push	 DWORD PTR _pProperty$[ebp]
  00053	e8 00 00 00 00	 call	 ?PropertyBuildingStringToData@prt@@YA_NPAVCProperty@@PAUTPropertyBuilding@1@@Z ; prt::PropertyBuildingStringToData
  00058	59		 pop	 ecx
  00059	59		 pop	 ecx
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	85 c0		 test	 eax, eax
  0005f	75 11		 jne	 SHORT $LN11@SetObjectI

; 599  : 		return;

  00061	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	8d 4d 30	 lea	 ecx, DWORD PTR _Data$[ebp]
  00068	e8 00 00 00 00	 call	 ??1TPropertyBuilding@prt@@QAE@XZ
  0006d	e9 56 03 00 00	 jmp	 $LN1@SetObjectI
$LN11@SetObjectI:

; 600  : 
; 601  : 	CResourceManager& rkResMgr=CResourceManager::Instance();

  00072	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00077	89 45 e0	 mov	 DWORD PTR _rkResMgr$[ebp], eax

; 602  : 
; 603  : 	CGraphicThing * pThing = (CGraphicThing *)rkResMgr.GetResourcePointer(Data.strFileName.c_str());

  0007a	8d 4d 48	 lea	 ecx, DWORD PTR _Data$[ebp+24]
  0007d	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00082	50		 push	 eax
  00083	8b 4d e0	 mov	 ecx, DWORD PTR _rkResMgr$[ebp]
  00086	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0008b	89 45 f0	 mov	 DWORD PTR _pThing$[ebp], eax

; 604  : 	pThing->AddReference();

  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00091	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 605  : 
; 606  : 	if (pThing->IsEmpty())

  00096	8b 4d f0	 mov	 ecx, DWORD PTR _pThing$[ebp]
  00099	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	85 c0		 test	 eax, eax
  000a3	74 11		 je	 SHORT $LN12@SetObjectI

; 607  : 	{
; 608  : #ifdef _DEBUG
; 609  : 		TraceError("CArea::SetBuilding: There is no data: %s", Data.strFileName.c_str());
; 610  : #endif
; 611  : 		return;

  000a5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a9	8d 4d 30	 lea	 ecx, DWORD PTR _Data$[ebp]
  000ac	e8 00 00 00 00	 call	 ??1TPropertyBuilding@prt@@QAE@XZ
  000b1	e9 12 03 00 00	 jmp	 $LN1@SetObjectI
$LN12@SetObjectI:

; 612  : 	}
; 613  : 
; 614  : 	int iModelCount = pThing->GetModelCount();

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _pThing$[ebp]
  000b9	e8 00 00 00 00	 call	 ?GetModelCount@CGraphicThing@@QBEHXZ ; CGraphicThing::GetModelCount
  000be	89 45 dc	 mov	 DWORD PTR _iModelCount$[ebp], eax

; 615  : 	int iMotionCount = pThing->GetMotionCount();

  000c1	8b 4d f0	 mov	 ecx, DWORD PTR _pThing$[ebp]
  000c4	e8 00 00 00 00	 call	 ?GetMotionCount@CGraphicThing@@QBEHXZ ; CGraphicThing::GetMotionCount
  000c9	89 45 bc	 mov	 DWORD PTR _iMotionCount$[ebp], eax

; 616  : 
; 617  : 	pObjectInstance->dwType = prt::PROPERTY_TYPE_BUILDING;

  000cc	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000d2	c7 40 04 02 00
	00 00		 mov	 DWORD PTR [eax+4], 2

; 618  : 	pObjectInstance->pThingInstance = CGraphicThingInstance::New();

  000d9	e8 00 00 00 00	 call	 ?New@CGraphicThingInstance@@SAPAV1@XZ ; CGraphicThingInstance::New
  000de	8b 8d b8 01 00
	00		 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  000e4	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 619  : 	pObjectInstance->pThingInstance->Initialize();

  000e7	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000ed	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000f0	e8 00 00 00 00	 call	 ?Initialize@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Initialize

; 620  : 	pObjectInstance->pThingInstance->ReserveModelThing(iModelCount);

  000f5	ff 75 dc	 push	 DWORD PTR _iModelCount$[ebp]
  000f8	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000fe	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00101	e8 00 00 00 00	 call	 ?ReserveModelThing@CGraphicThingInstance@@QAEXH@Z ; CGraphicThingInstance::ReserveModelThing

; 621  : 	pObjectInstance->pThingInstance->ReserveModelInstance(iModelCount);

  00106	ff 75 dc	 push	 DWORD PTR _iModelCount$[ebp]
  00109	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0010f	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00112	e8 00 00 00 00	 call	 ?ReserveModelInstance@CGraphicThingInstance@@QAEXH@Z ; CGraphicThingInstance::ReserveModelInstance

; 622  : 	pObjectInstance->pThingInstance->RegisterModelThing(0, pThing);

  00117	ff 75 f0	 push	 DWORD PTR _pThing$[ebp]
  0011a	6a 00		 push	 0
  0011c	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00122	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00125	e8 00 00 00 00	 call	 ?RegisterModelThing@CGraphicThingInstance@@QAEXHPAVCGraphicThing@@@Z ; CGraphicThingInstance::RegisterModelThing

; 623  : 	for (int j = 0; j < PORTAL_ID_MAX_NUM; ++j)

  0012a	83 65 ec 00	 and	 DWORD PTR _j$9[ebp], 0
  0012e	eb 07		 jmp	 SHORT $LN4@SetObjectI
$LN2@SetObjectI:
  00130	8b 45 ec	 mov	 eax, DWORD PTR _j$9[ebp]
  00133	40		 inc	 eax
  00134	89 45 ec	 mov	 DWORD PTR _j$9[ebp], eax
$LN4@SetObjectI:
  00137	83 7d ec 08	 cmp	 DWORD PTR _j$9[ebp], 8
  0013b	7d 32		 jge	 SHORT $LN3@SetObjectI

; 624  : 		if (0 != c_pData->abyPortalID[j])

  0013d	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00143	03 45 ec	 add	 eax, DWORD PTR _j$9[ebp]
  00146	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0014a	85 c0		 test	 eax, eax
  0014c	74 1f		 je	 SHORT $LN13@SetObjectI

; 625  : 			pObjectInstance->pThingInstance->SetPortal(j, c_pData->abyPortalID[j]);

  0014e	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00154	03 45 ec	 add	 eax, DWORD PTR _j$9[ebp]
  00157	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0015b	50		 push	 eax
  0015c	ff 75 ec	 push	 DWORD PTR _j$9[ebp]
  0015f	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00165	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00168	e8 00 00 00 00	 call	 ?SetPortal@CGraphicObjectInstance@@QAEXKH@Z ; CGraphicObjectInstance::SetPortal
$LN13@SetObjectI:
  0016d	eb c1		 jmp	 SHORT $LN2@SetObjectI
$LN3@SetObjectI:

; 626  : 
; 627  : 	{
; 628  : 		std::string stSrcModelFileName=Data.strFileName;

  0016f	8d 45 48	 lea	 eax, DWORD PTR _Data$[ebp+24]
  00172	50		 push	 eax
  00173	8d 4d 7c	 lea	 ecx, DWORD PTR _stSrcModelFileName$12[ebp]
  00176	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0017b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0017f	8d 85 94 00 00
	00		 lea	 eax, DWORD PTR _stLODModelFileName$13[ebp]
  00185	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00188	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00190	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  00196	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 629  : 		std::string stLODModelFileName;

  0019b	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 630  : 
; 631  : 		char szLODModelFileNameEnd[256];
; 632  : 		for (UINT uLODIndex=1; uLODIndex<=3; ++uLODIndex)

  0019f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR _uLODIndex$7[ebp], 1
  001a6	eb 07		 jmp	 SHORT $LN7@SetObjectI
$LN5@SetObjectI:
  001a8	8b 45 e4	 mov	 eax, DWORD PTR _uLODIndex$7[ebp]
  001ab	40		 inc	 eax
  001ac	89 45 e4	 mov	 DWORD PTR _uLODIndex$7[ebp], eax
$LN7@SetObjectI:
  001af	83 7d e4 03	 cmp	 DWORD PTR _uLODIndex$7[ebp], 3
  001b3	0f 87 db 00 00
	00		 ja	 $LN6@SetObjectI

; 633  : 		{
; 634  : 			sprintf(szLODModelFileNameEnd, "_lod_%.2d.gr2", uLODIndex);

  001b9	ff 75 e4	 push	 DWORD PTR _uLODIndex$7[ebp]
  001bc	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NDEAKJNP@_lod_?$CF?42d?4gr2@
  001c1	8d 85 ac 00 00
	00		 lea	 eax, DWORD PTR _szLODModelFileNameEnd$14[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 _sprintf
  001cd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 635  : 			stLODModelFileName = CFileNameHelper::NoExtension(stSrcModelFileName) + szLODModelFileNameEnd;

  001d0	8d 45 7c	 lea	 eax, DWORD PTR _stSrcModelFileName$12[ebp]
  001d3	50		 push	 eax
  001d4	8d 45 00	 lea	 eax, DWORD PTR $T10[ebp]
  001d7	50		 push	 eax
  001d8	e8 00 00 00 00	 call	 ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ; CFileNameHelper::NoExtension
  001dd	59		 pop	 ecx
  001de	59		 pop	 ecx
  001df	89 45 cc	 mov	 DWORD PTR tv170[ebp], eax
  001e2	8b 45 cc	 mov	 eax, DWORD PTR tv170[ebp]
  001e5	89 45 c8	 mov	 DWORD PTR tv292[ebp], eax
  001e8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  001ec	8d 85 ac 00 00
	00		 lea	 eax, DWORD PTR _szLODModelFileNameEnd$14[ebp]
  001f2	50		 push	 eax
  001f3	ff 75 c8	 push	 DWORD PTR tv292[ebp]
  001f6	8d 45 18	 lea	 eax, DWORD PTR $T11[ebp]
  001f9	50		 push	 eax
  001fa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  001ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00202	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00205	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00208	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  0020b	8d 85 94 00 00
	00		 lea	 eax, DWORD PTR _stLODModelFileName$13[ebp]
  00211	3b 45 c4	 cmp	 eax, DWORD PTR $T4[ebp]
  00214	74 16		 je	 SHORT $LN168@SetObjectI

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00216	33 c0		 xor	 eax, eax
  00218	88 45 c0	 mov	 BYTE PTR $T3[ebp], al
  0021b	ff 75 c0	 push	 DWORD PTR $T3[ebp]
  0021e	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  00221	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  00227	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
$LN168@SetObjectI:

; 2801 :         _Tidy_deallocate();

  0022c	8d 4d 18	 lea	 ecx, DWORD PTR $T11[ebp]
  0022f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 635  : 			stLODModelFileName = CFileNameHelper::NoExtension(stSrcModelFileName) + szLODModelFileNameEnd;

  00234	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00238	8d 4d 00	 lea	 ecx, DWORD PTR $T10[ebp]
  0023b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 636  : 			if (!rkResMgr.IsFileExist(stLODModelFileName.c_str()))

  00240	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  00246	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0024b	50		 push	 eax
  0024c	8b 4d e0	 mov	 ecx, DWORD PTR _rkResMgr$[ebp]
  0024f	e8 00 00 00 00	 call	 ?IsFileExist@CResourceManager@@QAE_NPBD@Z ; CResourceManager::IsFileExist
  00254	0f b6 c0	 movzx	 eax, al
  00257	85 c0		 test	 eax, eax
  00259	75 02		 jne	 SHORT $LN14@SetObjectI

; 637  : 				break;

  0025b	eb 37		 jmp	 SHORT $LN6@SetObjectI
$LN14@SetObjectI:

; 638  : 
; 639  : 			CGraphicThing* pLODModelThing = (CGraphicThing *)rkResMgr.GetResourcePointer(stLODModelFileName.c_str());

  0025d	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  00263	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00268	50		 push	 eax
  00269	8b 4d e0	 mov	 ecx, DWORD PTR _rkResMgr$[ebp]
  0026c	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00271	89 45 d4	 mov	 DWORD PTR _pLODModelThing$5[ebp], eax

; 640  : 			if (!pLODModelThing)

  00274	83 7d d4 00	 cmp	 DWORD PTR _pLODModelThing$5[ebp], 0
  00278	75 02		 jne	 SHORT $LN15@SetObjectI

; 641  : 				break;

  0027a	eb 18		 jmp	 SHORT $LN6@SetObjectI
$LN15@SetObjectI:

; 642  : 
; 643  : 			pObjectInstance->pThingInstance->RegisterLODThing(0, pLODModelThing);

  0027c	ff 75 d4	 push	 DWORD PTR _pLODModelThing$5[ebp]
  0027f	6a 00		 push	 0
  00281	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00287	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0028a	e8 00 00 00 00	 call	 ?RegisterLODThing@CGraphicThingInstance@@QAEXHPAVCGraphicThing@@@Z ; CGraphicThingInstance::RegisterLODThing

; 644  : 		}

  0028f	e9 14 ff ff ff	 jmp	 $LN5@SetObjectI
$LN6@SetObjectI:

; 645  : 	}

  00294	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00298	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  0029e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 645  : 	}

  002a3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002a7	8d 4d 7c	 lea	 ecx, DWORD PTR _stSrcModelFileName$12[ebp]
  002aa	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 647  : 	for (int i = 0; i < iModelCount; ++i)

  002af	83 65 e8 00	 and	 DWORD PTR _i$8[ebp], 0
  002b3	eb 07		 jmp	 SHORT $LN10@SetObjectI
$LN8@SetObjectI:
  002b5	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  002b8	40		 inc	 eax
  002b9	89 45 e8	 mov	 DWORD PTR _i$8[ebp], eax
$LN10@SetObjectI:
  002bc	8b 45 e8	 mov	 eax, DWORD PTR _i$8[ebp]
  002bf	3b 45 dc	 cmp	 eax, DWORD PTR _iModelCount$[ebp]
  002c2	7d 1a		 jge	 SHORT $LN9@SetObjectI

; 648  : 		pObjectInstance->pThingInstance->SetModelInstance(i, 0, i);

  002c4	6a ff		 push	 -1
  002c6	ff 75 e8	 push	 DWORD PTR _i$8[ebp]
  002c9	6a 00		 push	 0
  002cb	ff 75 e8	 push	 DWORD PTR _i$8[ebp]
  002ce	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  002d4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002d7	e8 00 00 00 00	 call	 ?SetModelInstance@CGraphicThingInstance@@QAE_NHHHH@Z ; CGraphicThingInstance::SetModelInstance
  002dc	eb d7		 jmp	 SHORT $LN8@SetObjectI
$LN9@SetObjectI:

; 649  : 
; 650  : 	if (iMotionCount)

  002de	83 7d bc 00	 cmp	 DWORD PTR _iMotionCount$[ebp], 0
  002e2	74 13		 je	 SHORT $LN16@SetObjectI

; 651  : 	{
; 652  : 		pObjectInstance->pThingInstance->RegisterMotionThing(0, pThing);

  002e4	ff 75 f0	 push	 DWORD PTR _pThing$[ebp]
  002e7	6a 00		 push	 0
  002e9	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  002ef	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002f2	e8 00 00 00 00	 call	 ?RegisterMotionThing@CGraphicThingInstance@@QAEXKPAVCGraphicThing@@@Z ; CGraphicThingInstance::RegisterMotionThing
$LN16@SetObjectI:

; 653  : 	}
; 654  : 
; 655  : 	pObjectInstance->pThingInstance->SetPosition(c_pData->Position.x, c_pData->Position.y, c_pData->Position.z + c_pData->m_fHeightBias);

  002f7	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  002fd	8b 8d bc 01 00
	00		 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00303	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00308	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  0030d	51		 push	 ecx
  0030e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00313	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00319	51		 push	 ecx
  0031a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0031f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00324	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  0032a	51		 push	 ecx
  0032b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0032f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00334	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0033a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0033d	e8 00 00 00 00	 call	 ?SetPosition@CGraphicObjectInstance@@QAEXMMM@Z ; CGraphicObjectInstance::SetPosition

; 656  : 	pObjectInstance->pThingInstance->SetRotation(

  00342	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00348	51		 push	 ecx
  00349	f3 0f 10 40 20	 movss	 xmm0, DWORD PTR [eax+32]
  0034e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00353	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  00359	51		 push	 ecx
  0035a	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  0035f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00364	8b 85 bc 01 00
	00		 mov	 eax, DWORD PTR _c_pData$[ebp]
  0036a	51		 push	 ecx
  0036b	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00370	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00375	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0037b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0037e	e8 00 00 00 00	 call	 ?SetRotation@CGraphicObjectInstance@@QAEXMMM@Z ; CGraphicObjectInstance::SetRotation

; 657  : 		c_pData->m_fYaw,
; 658  : 		c_pData->m_fPitch,
; 659  : 		c_pData->m_fRoll
; 660  : 	);
; 661  : 	pObjectInstance->isShadowFlag = Data.isShadowFlag;

  00383	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00389	8b 4d 78	 mov	 ecx, DWORD PTR _Data$[ebp+72]
  0038c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 662  : 	pObjectInstance->pThingInstance->RegisterBoundingSphere();

  0038f	8b 85 b8 01 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00395	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00398	e8 00 00 00 00	 call	 ?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RegisterBoundingSphere

; 663  : 	__LoadAttribute(pObjectInstance, Data.strAttributeDataFileName.c_str());

  0039d	8d 4d 60	 lea	 ecx, DWORD PTR _Data$[ebp+48]
  003a0	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  003a5	50		 push	 eax
  003a6	ff b5 b8 01 00
	00		 push	 DWORD PTR _pObjectInstance$[ebp]
  003ac	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  003af	e8 00 00 00 00	 call	 ?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z ; CArea::__LoadAttribute

; 664  : 	pThing->Release();

  003b4	8b 4d f0	 mov	 ecx, DWORD PTR _pThing$[ebp]
  003b7	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 665  : }

  003bc	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  003c0	8d 4d 30	 lea	 ecx, DWORD PTR _Data$[ebp]
  003c3	e8 00 00 00 00	 call	 ??1TPropertyBuilding@prt@@QAE@XZ
$LN1@SetObjectI:
  003c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003d2	59		 pop	 ecx
  003d3	8b 8d ac 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003d9	33 cd		 xor	 ecx, ebp
  003db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003e0	81 c5 b0 01 00
	00		 add	 ebp, 432		; 000001b0H
  003e6	c9		 leave
  003e7	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$0:
  00000	8d 4d 30	 lea	 ecx, DWORD PTR _Data$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1TPropertyBuilding@prt@@QAE@XZ
__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$1:
  00008	8d 4d 7c	 lea	 ecx, DWORD PTR _stSrcModelFileName$12[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$2:
  00010	8d 8d 94 00 00
	00		 lea	 ecx, DWORD PTR _stLODModelFileName$13[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z$3:
  0001b	8d 4d 00	 lea	 ecx, DWORD PTR $T10[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
  00026	cc		 int	 3
  00027	cc		 int	 3
__ehhandler$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z:
  00028	90		 npad	 1
  00029	90		 npad	 1
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	8b 8a b8 01 00
	00		 mov	 ecx, DWORD PTR [edx+440]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ENDP ; CArea::__SetObjectInstance_SetBuilding
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance_SetTree@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c_szTreeName$ = -4					; size = 4
_pObjectInstance$ = 8					; size = 4
_c_pData$ = 12						; size = 4
_pProperty$ = 16					; size = 4
?__SetObjectInstance_SetTree@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z PROC ; CArea::__SetObjectInstance_SetTree, COMDAT
; _this$ = ecx

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 575  : 	const char * c_szTreeName;
; 576  : 	if (!pProperty->GetString("TreeFile", &c_szTreeName))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _c_szTreeName$[ebp]
  0000b	50		 push	 eax
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_08JBFACIKL@TreeFile@
  00011	8b 4d 10	 mov	 ecx, DWORD PTR _pProperty$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetString@CProperty@@QAE_NPBDPAPBD@Z ; CProperty::GetString
  00019	0f b6 c0	 movzx	 eax, al
  0001c	85 c0		 test	 eax, eax
  0001e	75 02		 jne	 SHORT $LN2@SetObjectI

; 577  : 		return;

  00020	eb 42		 jmp	 SHORT $LN1@SetObjectI
$LN2@SetObjectI:

; 578  : 
; 579  : 	pObjectInstance->SetTree(		

  00022	ff 75 fc	 push	 DWORD PTR _c_szTreeName$[ebp]
  00025	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00028	ff 70 0c	 push	 DWORD PTR [eax+12]
  0002b	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _c_pData$[ebp]
  00031	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00036	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  0003b	51		 push	 ecx
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00044	51		 push	 ecx
  00045	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00052	51		 push	 ecx
  00053	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00057	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  0005f	e8 00 00 00 00	 call	 ?SetTree@SObjectInstance@CArea@@QAEXMMMKPBD@Z ; CArea::SObjectInstance::SetTree
$LN1@SetObjectI:

; 580  : 		c_pData->Position.x,
; 581  : 		c_pData->Position.y,
; 582  : 		c_pData->Position.z + c_pData->m_fHeightBias,
; 583  : 		c_pData->dwCRC,
; 584  : 		c_szTreeName
; 585  : 	);
; 586  : }

  00064	c9		 leave
  00065	c2 0c 00	 ret	 12			; 0000000cH
?__SetObjectInstance_SetTree@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ENDP ; CArea::__SetObjectInstance_SetTree
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__SetObjectInstance@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@@Z
_TEXT	SEGMENT
_c_szPropertyType$ = -20				; size = 4
$T1 = -16						; size = 4
_this$ = -12						; size = 4
tv80 = -8						; size = 4
_pProperty$ = -4					; size = 4
_pObjectInstance$ = 8					; size = 4
_c_pData$ = 12						; size = 4
?__SetObjectInstance@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@@Z PROC ; CArea::__SetObjectInstance, COMDAT
; _this$ = ecx

; 499  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A ; CSingleton<CPropertyManager>::ms_singleton
  0000e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 501  : 	if (!CPropertyManager::Instance().Get(c_pData->dwCRC, &pProperty))

  00011	8d 45 fc	 lea	 eax, DWORD PTR _pProperty$[ebp]
  00014	50		 push	 eax
  00015	8b 45 0c	 mov	 eax, DWORD PTR _c_pData$[ebp]
  00018	ff 70 0c	 push	 DWORD PTR [eax+12]
  0001b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	e8 00 00 00 00	 call	 ?Get@CPropertyManager@@QAE_NKPAPAVCProperty@@@Z ; CPropertyManager::Get
  00023	0f b6 c0	 movzx	 eax, al
  00026	85 c0		 test	 eax, eax
  00028	75 05		 jne	 SHORT $LN4@SetObjectI

; 502  : 		return;

  0002a	e9 a6 00 00 00	 jmp	 $LN1@SetObjectI
$LN4@SetObjectI:

; 503  : 
; 504  : 	const char * c_szPropertyType;
; 505  : 
; 506  : 	if (!pProperty->GetString("PropertyType", &c_szPropertyType))

  0002f	8d 45 ec	 lea	 eax, DWORD PTR _c_szPropertyType$[ebp]
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FPEBPNJJ@PropertyType@
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _pProperty$[ebp]
  0003b	e8 00 00 00 00	 call	 ?GetString@CProperty@@QAE_NPBDPAPBD@Z ; CProperty::GetString
  00040	0f b6 c0	 movzx	 eax, al
  00043	85 c0		 test	 eax, eax
  00045	75 05		 jne	 SHORT $LN5@SetObjectI

; 507  : 		return;

  00047	e9 89 00 00 00	 jmp	 $LN1@SetObjectI
$LN5@SetObjectI:

; 508  : 
; 509  : 	switch (prt::GetPropertyType(c_szPropertyType))

  0004c	ff 75 ec	 push	 DWORD PTR _c_szPropertyType$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetPropertyType@prt@@YAKPBD@Z ; prt::GetPropertyType
  00054	59		 pop	 ecx
  00055	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
  00058	83 7d f8 01	 cmp	 DWORD PTR tv80[ebp], 1
  0005c	74 1a		 je	 SHORT $LN6@SetObjectI
  0005e	83 7d f8 02	 cmp	 DWORD PTR tv80[ebp], 2
  00062	74 27		 je	 SHORT $LN7@SetObjectI
  00064	83 7d f8 03	 cmp	 DWORD PTR tv80[ebp], 3
  00068	74 34		 je	 SHORT $LN8@SetObjectI
  0006a	83 7d f8 04	 cmp	 DWORD PTR tv80[ebp], 4
  0006e	74 41		 je	 SHORT $LN9@SetObjectI
  00070	83 7d f8 05	 cmp	 DWORD PTR tv80[ebp], 5
  00074	74 4e		 je	 SHORT $LN10@SetObjectI
  00076	eb 5d		 jmp	 SHORT $LN1@SetObjectI
$LN6@SetObjectI:

; 510  : 	{
; 511  : 		case prt::PROPERTY_TYPE_TREE:
; 512  : 			__SetObjectInstance_SetTree(pObjectInstance, c_pData, pProperty);

  00078	ff 75 fc	 push	 DWORD PTR _pProperty$[ebp]
  0007b	ff 75 0c	 push	 DWORD PTR _c_pData$[ebp]
  0007e	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  00081	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?__SetObjectInstance_SetTree@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetTree

; 513  : 			break;

  00089	eb 4a		 jmp	 SHORT $LN1@SetObjectI
$LN7@SetObjectI:

; 514  : 
; 515  : 		case prt::PROPERTY_TYPE_BUILDING:
; 516  : 			__SetObjectInstance_SetBuilding(pObjectInstance, c_pData, pProperty);

  0008b	ff 75 fc	 push	 DWORD PTR _pProperty$[ebp]
  0008e	ff 75 0c	 push	 DWORD PTR _c_pData$[ebp]
  00091	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  00094	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?__SetObjectInstance_SetBuilding@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetBuilding

; 517  : 			break;

  0009c	eb 37		 jmp	 SHORT $LN1@SetObjectI
$LN8@SetObjectI:

; 518  : 
; 519  : 		case prt::PROPERTY_TYPE_EFFECT:
; 520  : 			__SetObjectInstance_SetEffect(pObjectInstance, c_pData, pProperty);

  0009e	ff 75 fc	 push	 DWORD PTR _pProperty$[ebp]
  000a1	ff 75 0c	 push	 DWORD PTR _c_pData$[ebp]
  000a4	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?__SetObjectInstance_SetEffect@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetEffect

; 521  : 			break;

  000af	eb 24		 jmp	 SHORT $LN1@SetObjectI
$LN9@SetObjectI:

; 522  : 
; 523  : 		case prt::PROPERTY_TYPE_AMBIENCE:
; 524  : 			__SetObjectInstance_SetAmbience(pObjectInstance, c_pData, pProperty);

  000b1	ff 75 fc	 push	 DWORD PTR _pProperty$[ebp]
  000b4	ff 75 0c	 push	 DWORD PTR _c_pData$[ebp]
  000b7	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  000ba	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?__SetObjectInstance_SetAmbience@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetAmbience

; 525  : 			break;

  000c2	eb 11		 jmp	 SHORT $LN1@SetObjectI
$LN10@SetObjectI:

; 526  : 
; 527  : 		case prt::PROPERTY_TYPE_DUNGEON_BLOCK:
; 528  : 			__SetObjectInstance_SetDungeonBlock(pObjectInstance, c_pData, pProperty);

  000c4	ff 75 fc	 push	 DWORD PTR _pProperty$[ebp]
  000c7	ff 75 0c	 push	 DWORD PTR _c_pData$[ebp]
  000ca	ff 75 08	 push	 DWORD PTR _pObjectInstance$[ebp]
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	e8 00 00 00 00	 call	 ?__SetObjectInstance_SetDungeonBlock@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@PAVCProperty@@@Z ; CArea::__SetObjectInstance_SetDungeonBlock
$LN1@SetObjectI:

; 529  : 			break;
; 530  : 	}
; 531  : }

  000d5	c9		 leave
  000d6	c2 08 00	 ret	 8
?__SetObjectInstance@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@@Z ENDP ; CArea::__SetObjectInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__Clear_DestroyObjectInstance@CArea@@IAEXPAUSObjectInstance@1@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 4
_pkData$ = -80						; size = 4
_pkData$ = -76						; size = 4
_pkData$ = -72						; size = 4
_pkData$ = -68						; size = 4
_pEffectInstance$2 = -64				; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
___param0$ = -32					; size = 4
__Scary$10 = -28					; size = 4
$T11 = -24						; size = 4
tv209 = -20						; size = 4
tv249 = -16						; size = 4
_this$ = -12						; size = 4
_f$12 = -8						; size = 4
$T13 = -2						; size = 1
$T14 = -1						; size = 1
_pObjectInstance$ = 8					; size = 4
?__Clear_DestroyObjectInstance@CArea@@IAEXPAUSObjectInstance@1@@Z PROC ; CArea::__Clear_DestroyObjectInstance, COMDAT
; _this$ = ecx

; 1222 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1223 : 	if (pObjectInstance->dwEffectInstanceIndex!=0xffffffff)

  00009	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0000c	83 78 1c ff	 cmp	 DWORD PTR [eax+28], -1
  00010	0f 84 db 00 00
	00		 je	 $LN2@Clear_Dest

; 1224 : 	{
; 1225 : 		TEffectInstanceIterator f= m_EffectInstanceMap.find(pObjectInstance->dwEffectInstanceIndex);

  00016	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00019	83 c0 1c	 add	 eax, 28			; 0000001cH
  0001c	50		 push	 eax
  0001d	8d 45 f8	 lea	 eax, DWORD PTR _f$12[ebp]
  00020	50		 push	 eax
  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0002a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00037	89 45 e8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR $T11[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR __Scary$10[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00040	8b 45 e4	 mov	 eax, DWORD PTR __Scary$10[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00048	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0004b	89 45 dc	 mov	 DWORD PTR $T9[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0004e	8d 45 dc	 lea	 eax, DWORD PTR $T9[ebp]
  00051	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00054	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	3b 45 f8	 cmp	 eax, DWORD PTR _f$12[ebp]
  0005c	75 09		 jne	 SHORT $LN78@Clear_Dest
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv249[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN79@Clear_Dest
$LN78@Clear_Dest:
  00067	83 65 f0 00	 and	 DWORD PTR tv249[ebp], 0
$LN79@Clear_Dest:
  0006b	8a 45 f0	 mov	 al, BYTE PTR tv249[ebp]
  0006e	88 45 ff	 mov	 BYTE PTR $T14[ebp], al

; 236  :         return !(*this == _Right);

  00071	0f b6 45 ff	 movzx	 eax, BYTE PTR $T14[ebp]
  00075	85 c0		 test	 eax, eax
  00077	75 09		 jne	 SHORT $LN73@Clear_Dest
  00079	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv209[ebp], 1
  00080	eb 04		 jmp	 SHORT $LN74@Clear_Dest
$LN73@Clear_Dest:
  00082	83 65 ec 00	 and	 DWORD PTR tv209[ebp], 0
$LN74@Clear_Dest:
  00086	8a 45 ec	 mov	 al, BYTE PTR tv209[ebp]
  00089	88 45 fe	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1226 : 		if (m_EffectInstanceMap.end()!=f)

  0008c	0f b6 45 fe	 movzx	 eax, BYTE PTR $T13[ebp]
  00090	85 c0		 test	 eax, eax
  00092	74 56		 je	 SHORT $LN3@Clear_Dest
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  00094	8b 45 f8	 mov	 eax, DWORD PTR _f$12[ebp]
  00097	83 c0 10	 add	 eax, 16			; 00000010H
  0009a	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0009d	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  000a0	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a3	8b 45 d0	 mov	 eax, DWORD PTR $T6[ebp]
  000a6	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000a9	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  000ac	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  000af	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
  000b2	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1228 : 			CEffectInstance * pEffectInstance = f->second;

  000b5	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000b8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000bb	89 45 c0	 mov	 DWORD PTR _pEffectInstance$2[ebp], eax

; 1229 : 			m_EffectInstanceMap.erase(f);

  000be	ff 75 f8	 push	 DWORD PTR _f$12[ebp]
  000c1	8d 45 ac	 lea	 eax, DWORD PTR $T1[ebp]
  000c4	50		 push	 eax
  000c5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  000ce	e8 00 00 00 00	 call	 ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > > >,0>

; 1230 : 
; 1231 : 			if (CEffectManager::InstancePtr())

  000d3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A, 0 ; CSingleton<CEffectManager>::ms_singleton
  000da	74 0e		 je	 SHORT $LN3@Clear_Dest

; 1232 : 				CEffectManager::Instance().DestroyUnsafeEffectInstance(pEffectInstance);

  000dc	ff 75 c0	 push	 DWORD PTR _pEffectInstance$2[ebp]
  000df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  000e5	e8 00 00 00 00	 call	 ?DestroyUnsafeEffectInstance@CEffectManager@@QAE_NPAVCEffectInstance@@@Z ; CEffectManager::DestroyUnsafeEffectInstance
$LN3@Clear_Dest:

; 1233 : 		}
; 1234 : 		pObjectInstance->dwEffectInstanceIndex = 0xffffffff;

  000ea	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000ed	83 48 1c ff	 or	 DWORD PTR [eax+28], -1
$LN2@Clear_Dest:

; 1235 : 	}
; 1236 : 
; 1237 : 	if (pObjectInstance->pAttributeInstance)

  000f1	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000f4	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000f8	74 29		 je	 SHORT $LN5@Clear_Dest

; 1238 : 	{
; 1239 : 		pObjectInstance->pAttributeInstance->Clear();

  000fa	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  000fd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00100	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear

; 1240 : 		ms_AttributeInstancePool.Free(pObjectInstance->pAttributeInstance);

  00105	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00108	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0010b	89 45 bc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0010e	8d 45 bc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00111	50		 push	 eax
  00112	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A+16
  00117	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1241 : 		pObjectInstance->pAttributeInstance = NULL;

  0011c	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0011f	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN5@Clear_Dest:

; 1242 : 	}
; 1243 : 
; 1244 : 	if (pObjectInstance->pTree)

  00123	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00126	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0012a	74 23		 je	 SHORT $LN6@Clear_Dest

; 1245 : 	{
; 1246 : 		pObjectInstance->pTree->Clear();

  0012c	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0012f	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00132	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear

; 1247 : 		CSpeedTreeForestDirectX8::Instance().DeleteInstance(pObjectInstance->pTree);

  00137	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0013a	ff 70 0c	 push	 DWORD PTR [eax+12]
  0013d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00143	e8 00 00 00 00	 call	 ?DeleteInstance@CSpeedTreeForest@@QAEXPAVCSpeedTreeWrapper@@@Z ; CSpeedTreeForest::DeleteInstance

; 1248 : 		pObjectInstance->pTree = NULL;

  00148	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0014b	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
$LN6@Clear_Dest:

; 1249 : 	}
; 1250 : 
; 1251 : 	if (pObjectInstance->pThingInstance)

  0014f	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00152	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00156	74 13		 je	 SHORT $LN7@Clear_Dest

; 1252 : 	{
; 1253 : 		CGraphicThingInstance::Delete(pObjectInstance->pThingInstance);

  00158	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0015b	ff 70 14	 push	 DWORD PTR [eax+20]
  0015e	e8 00 00 00 00	 call	 ?Delete@CGraphicThingInstance@@SAXPAV1@@Z ; CGraphicThingInstance::Delete
  00163	59		 pop	 ecx

; 1254 : 		pObjectInstance->pThingInstance = NULL;

  00164	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00167	83 60 14 00	 and	 DWORD PTR [eax+20], 0
$LN7@Clear_Dest:

; 1255 : 	}
; 1256 : 
; 1257 : 	if (pObjectInstance->pAmbienceInstance)

  0016b	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0016e	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00172	74 1e		 je	 SHORT $LN8@Clear_Dest

; 1258 : 	{
; 1259 : 		ms_AmbienceInstancePool.Free(pObjectInstance->pAmbienceInstance);

  00174	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00177	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0017a	89 45 b8	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0017d	8d 45 b8	 lea	 eax, DWORD PTR _pkData$[ebp]
  00180	50		 push	 eax
  00181	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_AmbienceInstancePool@CArea@@1V?$CDynamicPool@USAmbienceInstance@CArea@@@@A+16
  00186	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1260 : 		pObjectInstance->pAmbienceInstance = NULL;

  0018b	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0018e	83 60 20 00	 and	 DWORD PTR [eax+32], 0
$LN8@Clear_Dest:

; 1261 : 	}
; 1262 : 
; 1263 : 	if (pObjectInstance->pDungeonBlock)

  00192	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  00195	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  00199	74 1e		 je	 SHORT $LN9@Clear_Dest

; 1264 : 	{
; 1265 : 		ms_DungeonBlockInstancePool.Free(pObjectInstance->pDungeonBlock);

  0019b	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0019e	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001a1	89 45 b4	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001a4	8d 45 b4	 lea	 eax, DWORD PTR _pkData$[ebp]
  001a7	50		 push	 eax
  001a8	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_DungeonBlockInstancePool@CArea@@1V?$CDynamicPool@VCDungeonBlock@@@@A+16
  001ad	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1266 : 		pObjectInstance->pDungeonBlock = NULL;

  001b2	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  001b5	83 60 24 00	 and	 DWORD PTR [eax+36], 0
$LN9@Clear_Dest:

; 1267 : 	}
; 1268 : 
; 1269 : 	pObjectInstance->Clear();

  001b9	8b 4d 08	 mov	 ecx, DWORD PTR _pObjectInstance$[ebp]
  001bc	e8 00 00 00 00	 call	 ?Clear@SObjectInstance@CArea@@QAEXXZ ; CArea::SObjectInstance::Clear

; 1270 : 	
; 1271 : 	ms_ObjectInstancePool.Free(pObjectInstance);

  001c1	8b 45 08	 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  001c4	89 45 b0	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001c7	8d 45 b0	 lea	 eax, DWORD PTR _pkData$[ebp]
  001ca	50		 push	 eax
  001cb	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A+16
  001d0	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSObjectInstance@CArea@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXABQAUSObjectInstance@CArea@@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::emplace_back<CArea::SObjectInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1272 : }

  001d5	c9		 leave
  001d6	c2 04 00	 ret	 4
?__Clear_DestroyObjectInstance@CArea@@IAEXPAUSObjectInstance@1@@Z ENDP ; CArea::__Clear_DestroyObjectInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T2 = -88						; size = 8
_pkData$ = -80						; size = 4
_fz$ = -76						; size = 4
_fy$ = -72						; size = 4
_fx$ = -68						; size = 4
_fz$ = -64						; size = 4
_fy$ = -60						; size = 4
_fx$ = -56						; size = 4
_fz$ = -52						; size = 4
_fy$ = -48						; size = 4
_fx$ = -44						; size = 4
tv234 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
_pAttributeData$ = -28					; size = 4
_pAttrInstance$ = -24					; size = 4
_object$5 = -20						; size = 4
_bIsDungeonObject$6 = -15				; size = 1
_bFileExist$ = -14					; size = 1
tv135 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_collision$7 = 0					; size = 80
_attrFileName$8 = 80					; size = 24
$T9 = 104						; size = 12
_vDelta$10 = 116					; size = 12
$T11 = 128						; size = 12
_v3Min$12 = 140						; size = 12
_v3Max$13 = 152						; size = 12
__$ArrayPad$ = 164					; size = 4
_pObjectInstance$ = 176					; size = 4
_c_szAttributeFileName$ = 180				; size = 4
?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z PROC ; CArea::__LoadAttribute, COMDAT
; _this$ = ecx

; 722  : {

  00000	55		 push	 ebp
  00001	8d ac 24 58 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-168]
  00008	81 ec a8 00 00
	00		 sub	 esp, 168		; 000000a8H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 50	 sub	 esp, 80			; 00000050H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 a4 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	56		 push	 esi
  0002d	57		 push	 edi
  0002e	50		 push	 eax
  0002f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00032	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00038	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00040	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 724  : 	const bool bFileExist = CResourceManager::Instance().IsFileExist(c_szAttributeFileName);

  00043	ff b5 b4 00 00
	00		 push	 DWORD PTR _c_szAttributeFileName$[ebp]
  00049	8b 4d e0	 mov	 ecx, DWORD PTR $T4[ebp]
  0004c	e8 00 00 00 00	 call	 ?IsFileExist@CResourceManager@@QAE_NPBD@Z ; CResourceManager::IsFileExist
  00051	88 45 f2	 mov	 BYTE PTR _bFileExist$[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00059	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 726  : 	CAttributeData * pAttributeData = (CAttributeData *) CResourceManager::Instance().GetResourcePointer(c_szAttributeFileName);

  0005c	ff b5 b4 00 00
	00		 push	 DWORD PTR _c_szAttributeFileName$[ebp]
  00062	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp]
  00065	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0006a	89 45 e4	 mov	 DWORD PTR _pAttributeData$[ebp], eax

; 727  : 
; 728  : 	CAttributeInstance * pAttrInstance = ms_AttributeInstancePool.Alloc();

  0006d	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A
  00072	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCAttributeInstance@@@@QAEPAVCAttributeInstance@@XZ ; CDynamicPool<CAttributeInstance>::Alloc
  00077	89 45 e8	 mov	 DWORD PTR _pAttrInstance$[ebp], eax

; 729  : 	pAttrInstance->Clear();

  0007a	8b 4d e8	 mov	 ecx, DWORD PTR _pAttrInstance$[ebp]
  0007d	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear

; 730  : 	pAttrInstance->SetObjectPointer(pAttributeData);

  00082	ff 75 e4	 push	 DWORD PTR _pAttributeData$[ebp]
  00085	8b 4d e8	 mov	 ecx, DWORD PTR _pAttrInstance$[ebp]
  00088	e8 00 00 00 00	 call	 ?SetObjectPointer@CAttributeInstance@@QAEXPAVCAttributeData@@@Z ; CAttributeInstance::SetObjectPointer

; 731  : 
; 732  : 	if (false == bFileExist)

  0008d	0f b6 45 f2	 movzx	 eax, BYTE PTR _bFileExist$[ebp]
  00091	85 c0		 test	 eax, eax
  00093	0f 85 b0 02 00
	00		 jne	 $LN177@LoadAttrib

; 733  : 	{
; 734  : 		std::string attrFileName(c_szAttributeFileName);

  00099	ff b5 b4 00 00
	00		 push	 DWORD PTR _c_szAttributeFileName$[ebp]
  0009f	8d 4d 50	 lea	 ecx, DWORD PTR _attrFileName$8[ebp]
  000a2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 271  :     locale() noexcept : _Ptr(_Init(true)) {}

  000a7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  000ae	6a 01		 push	 1
  000b0	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  000b5	59		 pop	 ecx
  000b6	89 45 ac	 mov	 DWORD PTR $T2[ebp+4], eax
  000b9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 735  : 		boost::algorithm::to_lower(attrFileName);

  000bd	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  000c0	89 45 d8	 mov	 DWORD PTR tv234[ebp], eax
  000c3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c7	ff 75 d8	 push	 DWORD PTR tv234[ebp]
  000ca	8d 45 50	 lea	 eax, DWORD PTR _attrFileName$8[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$to_lower@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@algorithm@boost@@YAXAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVlocale@3@@Z ; boost::algorithm::to_lower<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  000d3	59		 pop	 ecx
  000d4	59		 pop	 ecx
  000d5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d9	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000dc	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 736  : 		const bool bIsDungeonObject = (std::string::npos != attrFileName.find("/dungeon/")) || (std::string::npos != attrFileName.find("\\dungeon\\"));

  000e1	6a 00		 push	 0
  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_09OLKGEJPN@?1dungeon?1@
  000e8	8d 4d 50	 lea	 ecx, DWORD PTR _attrFileName$8[ebp]
  000eb	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  000f0	83 f8 ff	 cmp	 eax, -1
  000f3	75 1a		 jne	 SHORT $LN8@LoadAttrib
  000f5	6a 00		 push	 0
  000f7	68 00 00 00 00	 push	 OFFSET ??_C@_09PCMKFNFD@?2dungeon?2@
  000fc	8d 4d 50	 lea	 ecx, DWORD PTR _attrFileName$8[ebp]
  000ff	e8 00 00 00 00	 call	 ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
  00104	83 f8 ff	 cmp	 eax, -1
  00107	75 06		 jne	 SHORT $LN8@LoadAttrib
  00109	c6 45 f3 00	 mov	 BYTE PTR tv135[ebp], 0
  0010d	eb 04		 jmp	 SHORT $LN9@LoadAttrib
$LN8@LoadAttrib:
  0010f	c6 45 f3 01	 mov	 BYTE PTR tv135[ebp], 1
$LN9@LoadAttrib:
  00113	8a 45 f3	 mov	 al, BYTE PTR tv135[ebp]
  00116	88 45 f1	 mov	 BYTE PTR _bIsDungeonObject$6[ebp], al

; 737  : 
; 738  : 		// NOTE: dungeon  Dummy Collision     (        .      )
; 739  : 		if (pAttributeData->IsEmpty() && false == bIsDungeonObject)

  00119	8b 4d e4	 mov	 ecx, DWORD PTR _pAttributeData$[ebp]
  0011c	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  00121	0f b6 c0	 movzx	 eax, al
  00124	85 c0		 test	 eax, eax
  00126	0f 84 11 02 00
	00		 je	 $LN4@LoadAttrib
  0012c	0f b6 45 f1	 movzx	 eax, BYTE PTR _bIsDungeonObject$6[ebp]
  00130	85 c0		 test	 eax, eax
  00132	0f 85 05 02 00
	00		 jne	 $LN4@LoadAttrib

; 740  : 		{
; 741  : 			if (NULL != pObjectInstance && NULL != pObjectInstance->pThingInstance)

  00138	83 bd b0 00 00
	00 00		 cmp	 DWORD PTR _pObjectInstance$[ebp], 0
  0013f	0f 84 f8 01 00
	00		 je	 $LN4@LoadAttrib
  00145	8b 85 b0 00 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0014b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0014f	0f 84 e8 01 00
	00		 je	 $LN4@LoadAttrib

; 742  : 			{
; 743  : 				CGraphicThingInstance* object = pObjectInstance->pThingInstance;

  00155	8b 85 b0 00 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0015b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0015e	89 45 ec	 mov	 DWORD PTR _object$5[ebp], eax

; 744  : 
; 745  : 				D3DXVECTOR3 v3Min, v3Max;
; 746  : 
; 747  : 				object->GetBoundingAABB(v3Min, v3Max);

  00161	8d 85 98 00 00
	00		 lea	 eax, DWORD PTR _v3Max$13[ebp]
  00167	50		 push	 eax
  00168	8d 85 8c 00 00
	00		 lea	 eax, DWORD PTR _v3Min$12[ebp]
  0016e	50		 push	 eax
  0016f	8b 45 ec	 mov	 eax, DWORD PTR _object$5[ebp]
  00172	8b 00		 mov	 eax, DWORD PTR [eax]
  00174	8b 4d ec	 mov	 ecx, DWORD PTR _object$5[ebp]
  00177	ff 50 40	 call	 DWORD PTR [eax+64]

; 748  : 				
; 749  : 				CStaticCollisionData collision;
; 750  : 				collision.dwType = COLLISION_TYPE_OBB;

  0017a	c7 45 00 05 00
	00 00		 mov	 DWORD PTR _collision$7[ebp], 5

; 751  : 				D3DXQuaternionRotationYawPitchRoll(&collision.quatRotation, object->GetYaw(), object->GetPitch(), object->GetRoll());

  00181	8b 4d ec	 mov	 ecx, DWORD PTR _object$5[ebp]
  00184	e8 00 00 00 00	 call	 ?GetRoll@CGraphicObjectInstance@@QAEMXZ ; CGraphicObjectInstance::GetRoll
  00189	51		 push	 ecx
  0018a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0018d	8b 4d ec	 mov	 ecx, DWORD PTR _object$5[ebp]
  00190	e8 00 00 00 00	 call	 ?GetPitch@CGraphicObjectInstance@@QAEMXZ ; CGraphicObjectInstance::GetPitch
  00195	51		 push	 ecx
  00196	d9 1c 24	 fstp	 DWORD PTR [esp]
  00199	8b 4d ec	 mov	 ecx, DWORD PTR _object$5[ebp]
  0019c	e8 00 00 00 00	 call	 ?GetYaw@CGraphicObjectInstance@@QAEMXZ ; CGraphicObjectInstance::GetYaw
  001a1	51		 push	 ecx
  001a2	d9 1c 24	 fstp	 DWORD PTR [esp]
  001a5	8d 45 40	 lea	 eax, DWORD PTR _collision$7[ebp+64]
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _D3DXQuaternionRotationYawPitchRoll@16

; 752  : 				strcpy(collision.szName, "DummyCollisionOBB");

  001ae	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@NJPKAPFJ@DummyCollisionOBB@
  001b3	8d 45 04	 lea	 eax, DWORD PTR _collision$7[ebp+4]
  001b6	50		 push	 eax
  001b7	e8 00 00 00 00	 call	 _strcpy
  001bc	59		 pop	 ecx
  001bd	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001be	f3 0f 10 85 8c
	00 00 00	 movss	 xmm0, DWORD PTR _v3Min$12[ebp]
  001c6	f3 0f 58 85 98
	00 00 00	 addss	 xmm0, DWORD PTR _v3Max$13[ebp]
  001ce	f3 0f 11 45 d4	 movss	 DWORD PTR _fx$[ebp], xmm0
  001d3	f3 0f 10 85 90
	00 00 00	 movss	 xmm0, DWORD PTR _v3Min$12[ebp+4]
  001db	f3 0f 58 85 9c
	00 00 00	 addss	 xmm0, DWORD PTR _v3Max$13[ebp+4]
  001e3	f3 0f 11 45 d0	 movss	 DWORD PTR _fy$[ebp], xmm0
  001e8	f3 0f 10 85 94
	00 00 00	 movss	 xmm0, DWORD PTR _v3Min$12[ebp+8]
  001f0	f3 0f 58 85 a0
	00 00 00	 addss	 xmm0, DWORD PTR _v3Max$13[ebp+8]
  001f8	f3 0f 11 45 cc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001fd	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00202	f3 0f 11 85 80
	00 00 00	 movss	 DWORD PTR $T11[ebp], xmm0

; 181  :     y = fy;

  0020a	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0020f	f3 0f 11 85 84
	00 00 00	 movss	 DWORD PTR $T11[ebp+4], xmm0

; 182  :     z = fz;

  00217	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0021c	f3 0f 11 85 88
	00 00 00	 movss	 DWORD PTR $T11[ebp+8], xmm0

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00224	f3 0f 10 85 80
	00 00 00	 movss	 xmm0, DWORD PTR $T11[ebp]
  0022c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00234	f3 0f 11 45 c8	 movss	 DWORD PTR _fx$[ebp], xmm0
  00239	f3 0f 10 85 84
	00 00 00	 movss	 xmm0, DWORD PTR $T11[ebp+4]
  00241	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00249	f3 0f 11 45 c4	 movss	 DWORD PTR _fy$[ebp], xmm0
  0024e	f3 0f 10 85 88
	00 00 00	 movss	 xmm0, DWORD PTR $T11[ebp+8]
  00256	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0025e	f3 0f 11 45 c0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00263	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00268	f3 0f 11 45 68	 movss	 DWORD PTR $T9[ebp], xmm0

; 181  :     y = fy;

  0026d	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00272	f3 0f 11 45 6c	 movss	 DWORD PTR $T9[ebp+4], xmm0

; 182  :     z = fz;

  00277	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0027c	f3 0f 11 45 70	 movss	 DWORD PTR $T9[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 753  : 				collision.v3Position = (v3Min + v3Max) * 0.5f;

  00281	8d 75 68	 lea	 esi, DWORD PTR $T9[ebp]
  00284	8d 7d 28	 lea	 edi, DWORD PTR _collision$7[ebp+40]
  00287	a5		 movsd
  00288	a5		 movsd
  00289	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0028a	f3 0f 10 85 98
	00 00 00	 movss	 xmm0, DWORD PTR _v3Max$13[ebp]
  00292	f3 0f 5c 85 8c
	00 00 00	 subss	 xmm0, DWORD PTR _v3Min$12[ebp]
  0029a	f3 0f 11 45 bc	 movss	 DWORD PTR _fx$[ebp], xmm0
  0029f	f3 0f 10 85 9c
	00 00 00	 movss	 xmm0, DWORD PTR _v3Max$13[ebp+4]
  002a7	f3 0f 5c 85 90
	00 00 00	 subss	 xmm0, DWORD PTR _v3Min$12[ebp+4]
  002af	f3 0f 11 45 b8	 movss	 DWORD PTR _fy$[ebp], xmm0
  002b4	f3 0f 10 85 a0
	00 00 00	 movss	 xmm0, DWORD PTR _v3Max$13[ebp+8]
  002bc	f3 0f 5c 85 94
	00 00 00	 subss	 xmm0, DWORD PTR _v3Min$12[ebp+8]
  002c4	f3 0f 11 45 b4	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002c9	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002ce	f3 0f 11 45 74	 movss	 DWORD PTR _vDelta$10[ebp], xmm0

; 181  :     y = fy;

  002d3	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002d8	f3 0f 11 45 78	 movss	 DWORD PTR _vDelta$10[ebp+4], xmm0

; 182  :     z = fz;

  002dd	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002e2	f3 0f 11 45 7c	 movss	 DWORD PTR _vDelta$10[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 756  : 				collision.fDimensions[0] = vDelta.x * 0.5f;

  002e7	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _vDelta$10[ebp]
  002ec	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  002f4	6a 04		 push	 4
  002f6	58		 pop	 eax
  002f7	6b c0 00	 imul	 eax, eax, 0
  002fa	f3 0f 11 44 05
	34		 movss	 DWORD PTR _collision$7[ebp+eax+52], xmm0

; 757  : 				collision.fDimensions[1] = vDelta.y * 0.5f;

  00300	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _vDelta$10[ebp+4]
  00305	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  0030d	6a 04		 push	 4
  0030f	58		 pop	 eax
  00310	c1 e0 00	 shl	 eax, 0
  00313	f3 0f 11 44 05
	34		 movss	 DWORD PTR _collision$7[ebp+eax+52], xmm0

; 758  : 				collision.fDimensions[2] = vDelta.z * 0.5f;

  00319	f3 0f 10 45 7c	 movss	 xmm0, DWORD PTR _vDelta$10[ebp+8]
  0031e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  00326	6a 04		 push	 4
  00328	58		 pop	 eax
  00329	d1 e0		 shl	 eax, 1
  0032b	f3 0f 11 44 05
	34		 movss	 DWORD PTR _collision$7[ebp+eax+52], xmm0

; 759  : 
; 760  : 				pAttributeData->AddCollisionData(collision);

  00331	8d 45 00	 lea	 eax, DWORD PTR _collision$7[ebp]
  00334	50		 push	 eax
  00335	8b 4d e4	 mov	 ecx, DWORD PTR _pAttributeData$[ebp]
  00338	e8 00 00 00 00	 call	 ?AddCollisionData@CAttributeData@@QAEIABVCStaticCollisionData@@@Z ; CAttributeData::AddCollisionData
$LN4@LoadAttrib:

; 761  : 			}
; 762  : 		}
; 763  : 	}

  0033d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00341	8d 4d 50	 lea	 ecx, DWORD PTR _attrFileName$8[ebp]
  00344	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN177@LoadAttrib:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 765  : 	if (!pAttributeData->IsEmpty())

  00349	8b 4d e4	 mov	 ecx, DWORD PTR _pAttributeData$[ebp]
  0034c	e8 00 00 00 00	 call	 ?IsEmpty@CResource@@QBE_NXZ ; CResource::IsEmpty
  00351	0f b6 c0	 movzx	 eax, al
  00354	85 c0		 test	 eax, eax
  00356	75 0e		 jne	 SHORT $LN5@LoadAttrib

; 766  : 	{
; 767  : 		pObjectInstance->pAttributeInstance = pAttrInstance;

  00358	8b 85 b0 00 00
	00		 mov	 eax, DWORD PTR _pObjectInstance$[ebp]
  0035e	8b 4d e8	 mov	 ecx, DWORD PTR _pAttrInstance$[ebp]
  00361	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 768  : 	}

  00364	eb 1c		 jmp	 SHORT $LN180@LoadAttrib
$LN5@LoadAttrib:

; 769  : 	else
; 770  : 	{
; 771  : 		pAttrInstance->Clear();

  00366	8b 4d e8	 mov	 ecx, DWORD PTR _pAttrInstance$[ebp]
  00369	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear

; 772  : 		ms_AttributeInstancePool.Free(pAttrInstance);

  0036e	8b 45 e8	 mov	 eax, DWORD PTR _pAttrInstance$[ebp]
  00371	89 45 b0	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00374	8d 45 b0	 lea	 eax, DWORD PTR _pkData$[ebp]
  00377	50		 push	 eax
  00378	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_AttributeInstancePool@CArea@@1V?$CDynamicPool@VCAttributeInstance@@@@A+16
  0037d	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCAttributeInstance@@@?$vector@PAVCAttributeInstance@@V?$allocator@PAVCAttributeInstance@@@std@@@std@@QAEXABQAVCAttributeInstance@@@Z ; std::vector<CAttributeInstance *,std::allocator<CAttributeInstance *> >::emplace_back<CAttributeInstance * const &>
$LN180@LoadAttrib:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 774  : }

  00382	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00385	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0038c	59		 pop	 ecx
  0038d	5f		 pop	 edi
  0038e	5e		 pop	 esi
  0038f	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00395	33 cd		 xor	 ecx, ebp
  00397	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0039c	81 c5 a8 00 00
	00		 add	 ebp, 168		; 000000a8H
  003a2	c9		 leave
  003a3	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z$0:
  00000	8d 4d 50	 lea	 ecx, DWORD PTR _attrFileName$8[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 8a b0 00 00
	00		 mov	 ecx, DWORD PTR [edx+176]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__LoadAttribute@CArea@@IAEXPAUSObjectInstance@1@PBD@Z ENDP ; CArea::__LoadAttribute
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__UpdateEffectList@CArea@@IAEXXZ
_TEXT	SEGMENT
$T1 = -92						; size = 4
_rkEftMgr$ = -88					; size = 4
$T2 = -84						; size = 4
$T3 = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
$T6 = -68						; size = 4
$T7 = -64						; size = 4
$T8 = -60						; size = 4
___param0$ = -56					; size = 4
__Scary$9 = -52						; size = 4
$T10 = -48						; size = 4
$T11 = -44						; size = 4
$T12 = -40						; size = 4
___param0$ = -36					; size = 4
__Scary$13 = -32					; size = 4
$T14 = -28						; size = 4
tv199 = -24						; size = 4
tv223 = -20						; size = 4
_pEffectInstance$15 = -16				; size = 4
_this$ = -12						; size = 4
_i$ = -8						; size = 4
$T16 = -2						; size = 1
$T17 = -1						; size = 1
?__UpdateEffectList@CArea@@IAEXXZ PROC			; CArea::__UpdateEffectList, COMDAT
; _this$ = ecx

; 76   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 77   : 	//if (!CEffectManager::InstancePtr())
; 78   : 	//	return;
; 79   : 
; 80   : 	CEffectManager& rkEftMgr=CEffectManager::Instance();

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0000e	89 45 a8	 mov	 DWORD PTR _rkEftMgr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  00011	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00015	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00018	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001d	89 45 e4	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00020	8b 45 e4	 mov	 eax, DWORD PTR $T14[ebp]
  00023	89 45 e0	 mov	 DWORD PTR __Scary$13[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00026	8b 45 e0	 mov	 eax, DWORD PTR __Scary$13[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 d8	 mov	 DWORD PTR $T12[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00036	8d 45 d8	 lea	 eax, DWORD PTR $T12[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 84   : 	for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end();)

  0003c	8b 45 d4	 mov	 eax, DWORD PTR $T11[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@UpdateEffe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00044	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004c	89 45 d0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0004f	8b 45 d0	 mov	 eax, DWORD PTR $T10[ebp]
  00052	89 45 cc	 mov	 DWORD PTR __Scary$9[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00055	8b 45 cc	 mov	 eax, DWORD PTR __Scary$9[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0005d	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR $T8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00063	8d 45 c4	 lea	 eax, DWORD PTR $T8[ebp]
  00066	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00069	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00071	75 09		 jne	 SHORT $LN68@UpdateEffe
  00073	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv223[ebp], 1
  0007a	eb 04		 jmp	 SHORT $LN69@UpdateEffe
$LN68@UpdateEffe:
  0007c	83 65 ec 00	 and	 DWORD PTR tv223[ebp], 0
$LN69@UpdateEffe:
  00080	8a 45 ec	 mov	 al, BYTE PTR tv223[ebp]
  00083	88 45 ff	 mov	 BYTE PTR $T17[ebp], al

; 236  :         return !(*this == _Right);

  00086	0f b6 45 ff	 movzx	 eax, BYTE PTR $T17[ebp]
  0008a	85 c0		 test	 eax, eax
  0008c	75 09		 jne	 SHORT $LN63@UpdateEffe
  0008e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv199[ebp], 1
  00095	eb 04		 jmp	 SHORT $LN64@UpdateEffe
$LN63@UpdateEffe:
  00097	83 65 e8 00	 and	 DWORD PTR tv199[ebp], 0
$LN64@UpdateEffe:
  0009b	8a 45 e8	 mov	 al, BYTE PTR tv199[ebp]
  0009e	88 45 fe	 mov	 BYTE PTR $T16[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 84   : 	for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end();)

  000a1	0f b6 45 fe	 movzx	 eax, BYTE PTR $T16[ebp]
  000a5	85 c0		 test	 eax, eax
  000a7	74 72		 je	 SHORT $LN1@UpdateEffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000ac	83 c0 10	 add	 eax, 16			; 00000010H
  000af	89 45 bc	 mov	 DWORD PTR $T6[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  000b2	8b 45 bc	 mov	 eax, DWORD PTR $T6[ebp]
  000b5	89 45 b8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000b8	8b 45 b8	 mov	 eax, DWORD PTR $T5[ebp]
  000bb	89 45 b4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000be	8b 45 b4	 mov	 eax, DWORD PTR $T4[ebp]
  000c1	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  000c4	8b 45 b0	 mov	 eax, DWORD PTR $T3[ebp]
  000c7	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 86   : 		CEffectInstance * pEffectInstance = i->second;

  000ca	8b 45 ac	 mov	 eax, DWORD PTR $T2[ebp]
  000cd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d0	89 45 f0	 mov	 DWORD PTR _pEffectInstance$15[ebp], eax

; 87   : 
; 88   : 		pEffectInstance->Update();

  000d3	8b 4d f0	 mov	 ecx, DWORD PTR _pEffectInstance$15[ebp]
  000d6	e8 00 00 00 00	 call	 ?Update@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Update

; 89   : 
; 90   : 		if (!pEffectInstance->isAlive())

  000db	8b 4d f0	 mov	 ecx, DWORD PTR _pEffectInstance$15[ebp]
  000de	e8 00 00 00 00	 call	 ?isAlive@CEffectInstance@@QAEHXZ ; CEffectInstance::isAlive
  000e3	85 c0		 test	 eax, eax
  000e5	75 27		 jne	 SHORT $LN5@UpdateEffe

; 91   : 		{
; 92   : 			i = m_EffectInstanceMap.erase(i);

  000e7	ff 75 f8	 push	 DWORD PTR _i$[ebp]
  000ea	8d 45 a4	 lea	 eax, DWORD PTR $T1[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  000f7	e8 00 00 00 00	 call	 ??$erase@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@std@@$0A@@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@1@V21@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::erase<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > > >,0>
  000fc	8b 00		 mov	 eax, DWORD PTR [eax]
  000fe	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax

; 93   : 			rkEftMgr.DestroyUnsafeEffectInstance(pEffectInstance);

  00101	ff 75 f0	 push	 DWORD PTR _pEffectInstance$15[ebp]
  00104	8b 4d a8	 mov	 ecx, DWORD PTR _rkEftMgr$[ebp]
  00107	e8 00 00 00 00	 call	 ?DestroyUnsafeEffectInstance@CEffectManager@@QAE_NPAVCEffectInstance@@@Z ; CEffectManager::DestroyUnsafeEffectInstance

; 94   : 		}

  0010c	eb 08		 jmp	 SHORT $LN6@UpdateEffe
$LN5@UpdateEffe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  0010e	8d 4d f8	 lea	 ecx, DWORD PTR _i$[ebp]
  00111	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
$LN6@UpdateEffe:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 97   : 	}

  00116	e9 29 ff ff ff	 jmp	 $LN4@UpdateEffe
$LN1@UpdateEffe:

; 98   : }

  0011b	c9		 leave
  0011c	c3		 ret	 0
?__UpdateEffectList@CArea@@IAEXXZ ENDP			; CArea::__UpdateEffectList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__UpdateAniThingList@CArea@@IAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
_pkThingInst$5 = -8					; size = 4
$T6 = -4						; size = 4
$T7 = 0							; size = 4
$T8 = 4							; size = 4
$T9 = 8							; size = 4
__Tmp$10 = 12						; size = 4
$T11 = 16						; size = 4
$T12 = 20						; size = 4
___param0$ = 24						; size = 4
___param0$ = 28						; size = 4
$T13 = 32						; size = 4
$T14 = 36						; size = 4
$T15 = 40						; size = 4
$T16 = 44						; size = 4
__Tmp$17 = 48						; size = 4
$T18 = 52						; size = 4
$T19 = 56						; size = 4
___param0$ = 60						; size = 4
___param0$ = 64						; size = 4
tv254 = 68						; size = 4
tv300 = 72						; size = 4
__My_data$20 = 76					; size = 4
__My_data$21 = 80					; size = 4
_pkThingInst$22 = 84					; size = 4
tv198 = 88						; size = 4
tv212 = 92						; size = 4
__My_data$23 = 96					; size = 4
__My_data$24 = 100					; size = 4
_i$25 = 104						; size = 4
_this$ = 108						; size = 4
_i$26 = 112						; size = 4
$T27 = 116						; size = 1
$T28 = 117						; size = 1
$T29 = 118						; size = 1
$T30 = 119						; size = 1
?__UpdateAniThingList@CArea@@IAEXXZ PROC		; CArea::__UpdateAniThingList, COMDAT
; _this$ = ecx

; 48   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0000b	89 4d 6c	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000e	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 28	 add	 eax, 40			; 00000028H
  00014	89 45 64	 mov	 DWORD PTR __My_data$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00017	8b 45 64	 mov	 eax, DWORD PTR __My_data$24[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001d	8b 45 64	 mov	 eax, DWORD PTR __My_data$24[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 40	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00025	8b 45 40	 mov	 eax, DWORD PTR ___param0$[ebp]
  00028	89 45 70	 mov	 DWORD PTR _i$26[ebp], eax
$LN2@UpdateAniT:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0002b	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 28	 add	 eax, 40			; 00000028H
  00031	89 45 60	 mov	 DWORD PTR __My_data$23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00034	8b 45 60	 mov	 eax, DWORD PTR __My_data$23[ebp]
  00037	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0003a	8b 45 60	 mov	 eax, DWORD PTR __My_data$23[ebp]
  0003d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00040	89 45 3c	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00043	8b 45 3c	 mov	 eax, DWORD PTR ___param0$[ebp]
  00046	89 45 38	 mov	 DWORD PTR $T19[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00049	8d 45 38	 lea	 eax, DWORD PTR $T19[ebp]
  0004c	89 45 34	 mov	 DWORD PTR $T18[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0004f	8b 45 34	 mov	 eax, DWORD PTR $T18[ebp]
  00052	8b 4d 70	 mov	 ecx, DWORD PTR _i$26[ebp]
  00055	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00057	75 09		 jne	 SHORT $LN45@UpdateAniT
  00059	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR tv212[ebp], 1
  00060	eb 04		 jmp	 SHORT $LN46@UpdateAniT
$LN45@UpdateAniT:
  00062	83 65 5c 00	 and	 DWORD PTR tv212[ebp], 0
$LN46@UpdateAniT:
  00066	8a 45 5c	 mov	 al, BYTE PTR tv212[ebp]
  00069	88 45 77	 mov	 BYTE PTR $T30[ebp], al

; 153  :         return !(*this == _Right);

  0006c	0f b6 45 77	 movzx	 eax, BYTE PTR $T30[ebp]
  00070	85 c0		 test	 eax, eax
  00072	75 09		 jne	 SHORT $LN40@UpdateAniT
  00074	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv198[ebp], 1
  0007b	eb 04		 jmp	 SHORT $LN41@UpdateAniT
$LN40@UpdateAniT:
  0007d	83 65 58 00	 and	 DWORD PTR tv198[ebp], 0
$LN41@UpdateAniT:
  00081	8a 45 58	 mov	 al, BYTE PTR tv198[ebp]
  00084	88 45 76	 mov	 BYTE PTR $T29[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 53   : 		while (i!=m_ThingCloneInstaceVector.end())

  00087	0f b6 45 76	 movzx	 eax, BYTE PTR $T29[ebp]
  0008b	85 c0		 test	 eax, eax
  0008d	74 4d		 je	 SHORT $LN3@UpdateAniT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 265  :         _Vector_iterator _Tmp = *this;

  0008f	8b 45 70	 mov	 eax, DWORD PTR _i$26[ebp]
  00092	89 45 30	 mov	 DWORD PTR __Tmp$17[ebp], eax

; 75   :         ++_Ptr;

  00095	8b 45 70	 mov	 eax, DWORD PTR _i$26[ebp]
  00098	83 c0 04	 add	 eax, 4
  0009b	89 45 70	 mov	 DWORD PTR _i$26[ebp], eax

; 267  :         return _Tmp;

  0009e	8b 45 30	 mov	 eax, DWORD PTR __Tmp$17[ebp]
  000a1	89 45 2c	 mov	 DWORD PTR $T16[ebp], eax
  000a4	8d 45 2c	 lea	 eax, DWORD PTR $T16[ebp]
  000a7	89 45 28	 mov	 DWORD PTR $T15[ebp], eax

; 54   :         return *_Ptr;

  000aa	8b 45 28	 mov	 eax, DWORD PTR $T15[ebp]
  000ad	8b 00		 mov	 eax, DWORD PTR [eax]
  000af	89 45 24	 mov	 DWORD PTR $T14[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000b2	8b 45 24	 mov	 eax, DWORD PTR $T14[ebp]
  000b5	89 45 20	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 55   : 			pkThingInst=*i++;

  000b8	8b 45 20	 mov	 eax, DWORD PTR $T13[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 54	 mov	 DWORD PTR _pkThingInst$22[ebp], eax

; 56   : 			if (pkThingInst->isShow())

  000c0	8b 4d 54	 mov	 ecx, DWORD PTR _pkThingInst$22[ebp]
  000c3	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  000c8	0f b6 c0	 movzx	 eax, al
  000cb	85 c0		 test	 eax, eax
  000cd	74 08		 je	 SHORT $LN6@UpdateAniT

; 57   : 			{
; 58   : 				pkThingInst->UpdateLODLevel();

  000cf	8b 4d 54	 mov	 ecx, DWORD PTR _pkThingInst$22[ebp]
  000d2	e8 00 00 00 00	 call	 ?UpdateLODLevel@CGraphicThingInstance@@QAEXXZ ; CGraphicThingInstance::UpdateLODLevel
$LN6@UpdateAniT:

; 59   : 			}
; 60   : 		}

  000d7	e9 4f ff ff ff	 jmp	 $LN2@UpdateAniT
$LN3@UpdateAniT:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  000dc	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 c0 40	 add	 eax, 64			; 00000040H
  000e2	89 45 50	 mov	 DWORD PTR __My_data$21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000e5	8b 45 50	 mov	 eax, DWORD PTR __My_data$21[ebp]
  000e8	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  000eb	8b 45 50	 mov	 eax, DWORD PTR __My_data$21[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	89 45 1c	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000f3	8b 45 1c	 mov	 eax, DWORD PTR ___param0$[ebp]
  000f6	89 45 68	 mov	 DWORD PTR _i$25[ebp], eax
$LN4@UpdateAniT:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  000f9	8b 45 6c	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	83 c0 40	 add	 eax, 64			; 00000040H
  000ff	89 45 4c	 mov	 DWORD PTR __My_data$20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00102	8b 45 4c	 mov	 eax, DWORD PTR __My_data$20[ebp]
  00105	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00108	8b 45 4c	 mov	 eax, DWORD PTR __My_data$20[ebp]
  0010b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0010e	89 45 18	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00111	8b 45 18	 mov	 eax, DWORD PTR ___param0$[ebp]
  00114	89 45 14	 mov	 DWORD PTR $T12[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00117	8d 45 14	 lea	 eax, DWORD PTR $T12[ebp]
  0011a	89 45 10	 mov	 DWORD PTR $T11[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0011d	8b 45 10	 mov	 eax, DWORD PTR $T11[ebp]
  00120	8b 4d 68	 mov	 ecx, DWORD PTR _i$25[ebp]
  00123	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00125	75 09		 jne	 SHORT $LN100@UpdateAniT
  00127	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv300[ebp], 1
  0012e	eb 04		 jmp	 SHORT $LN101@UpdateAniT
$LN100@UpdateAniT:
  00130	83 65 48 00	 and	 DWORD PTR tv300[ebp], 0
$LN101@UpdateAniT:
  00134	8a 45 48	 mov	 al, BYTE PTR tv300[ebp]
  00137	88 45 75	 mov	 BYTE PTR $T28[ebp], al

; 153  :         return !(*this == _Right);

  0013a	0f b6 45 75	 movzx	 eax, BYTE PTR $T28[ebp]
  0013e	85 c0		 test	 eax, eax
  00140	75 09		 jne	 SHORT $LN95@UpdateAniT
  00142	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv254[ebp], 1
  00149	eb 04		 jmp	 SHORT $LN96@UpdateAniT
$LN95@UpdateAniT:
  0014b	83 65 44 00	 and	 DWORD PTR tv254[ebp], 0
$LN96@UpdateAniT:
  0014f	8a 45 44	 mov	 al, BYTE PTR tv254[ebp]
  00152	88 45 74	 mov	 BYTE PTR $T27[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 67   : 		while (i!=m_AniThingCloneInstanceVector.end())

  00155	0f b6 45 74	 movzx	 eax, BYTE PTR $T27[ebp]
  00159	85 c0		 test	 eax, eax
  0015b	74 3e		 je	 SHORT $LN1@UpdateAniT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 265  :         _Vector_iterator _Tmp = *this;

  0015d	8b 45 68	 mov	 eax, DWORD PTR _i$25[ebp]
  00160	89 45 0c	 mov	 DWORD PTR __Tmp$10[ebp], eax

; 75   :         ++_Ptr;

  00163	8b 45 68	 mov	 eax, DWORD PTR _i$25[ebp]
  00166	83 c0 04	 add	 eax, 4
  00169	89 45 68	 mov	 DWORD PTR _i$25[ebp], eax

; 267  :         return _Tmp;

  0016c	8b 45 0c	 mov	 eax, DWORD PTR __Tmp$10[ebp]
  0016f	89 45 08	 mov	 DWORD PTR $T9[ebp], eax
  00172	8d 45 08	 lea	 eax, DWORD PTR $T9[ebp]
  00175	89 45 04	 mov	 DWORD PTR $T8[ebp], eax

; 54   :         return *_Ptr;

  00178	8b 45 04	 mov	 eax, DWORD PTR $T8[ebp]
  0017b	8b 00		 mov	 eax, DWORD PTR [eax]
  0017d	89 45 00	 mov	 DWORD PTR $T7[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00180	8b 45 00	 mov	 eax, DWORD PTR $T7[ebp]
  00183	89 45 fc	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 69   : 			pkThingInst=*i++;

  00186	8b 45 fc	 mov	 eax, DWORD PTR $T6[ebp]
  00189	8b 00		 mov	 eax, DWORD PTR [eax]
  0018b	89 45 f8	 mov	 DWORD PTR _pkThingInst$5[ebp], eax

; 70   : 			pkThingInst->Update();

  0018e	8b 4d f8	 mov	 ecx, DWORD PTR _pkThingInst$5[ebp]
  00191	e8 00 00 00 00	 call	 ?Update@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Update

; 71   : 		}

  00196	e9 5e ff ff ff	 jmp	 $LN4@UpdateAniT
$LN1@UpdateAniT:

; 72   : 	}	
; 73   : }

  0019b	83 c5 78	 add	 ebp, 120		; 00000078H
  0019e	c9		 leave
  0019f	c3		 ret	 0
?__UpdateAniThingList@CArea@@IAEXXZ ENDP		; CArea::__UpdateAniThingList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__Load_BuildObjectInstances@CArea@@IAEXXZ
_TEXT	SEGMENT
$T1 = -108						; size = 8
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 8
$T5 = -84						; size = 4
__Val2$ = -80						; size = 4
$T6 = -76						; size = 4
__Val1$ = -72						; size = 4
$T7 = -68						; size = 4
$T8 = -64						; size = 4
$T9 = -60						; size = 4
$T10 = -56						; size = 4
$T11 = -52						; size = 4
$T12 = -48						; size = 4
$T13 = -44						; size = 4
$T14 = -40						; size = 4
$T15 = -36						; size = 4
$T16 = -32						; size = 4
$T17 = -28						; size = 4
$T18 = -24						; size = 4
___param0$ = -20					; size = 4
$T19 = -16						; size = 4
$T20 = -12						; size = 4
___param0$ = -8						; size = 4
$T21 = -4						; size = 1
$T22 = 0						; size = 4
$T23 = 4						; size = 4
__Ptr$24 = 8						; size = 4
__Last$ = 12						; size = 4
$T25 = 16						; size = 4
$T26 = 20						; size = 4
__Ptr$27 = 24						; size = 4
__First$ = 28						; size = 4
$T28 = 32						; size = 4
$T29 = 36						; size = 4
$T30 = 40						; size = 4
___param0$ = 44						; size = 4
$T31 = 48						; size = 4
$T32 = 52						; size = 4
___param0$ = 56						; size = 4
$T33 = 60						; size = 4
__Newsize$ = 64						; size = 4
_c_pObjectData$34 = 68					; size = 4
tv332 = 72						; size = 4
tv346 = 76						; size = 4
__My_data$35 = 80					; size = 4
__My_data$36 = 84					; size = 4
__UFirst$37 = 88					; size = 4
__ULast$38 = 92						; size = 4
__My_data$39 = 96					; size = 4
__My_data$40 = 100					; size = 4
_i$ = 104						; size = 4
$T41 = 108						; size = 1
$T42 = 109						; size = 1
$T43 = 110						; size = 1
$T44 = 111						; size = 1
_it$ = 112						; size = 4
_this$ = 116						; size = 4
?__Load_BuildObjectInstances@CArea@@IAEXXZ PROC		; CArea::__Load_BuildObjectInstances, COMDAT
; _this$ = ecx

; 466  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  0000b	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx

; 467  : 	m_ObjectInstanceVector.clear();

  0000e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 10	 add	 ecx, 16			; 00000010H
  00014	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear

; 468  : 	m_ObjectInstanceVector.resize(GetObjectDataCount());

  00019	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GetObjectDataCount@CArea@@QAEKXZ ; CArea::GetObjectDataCount
  00021	89 45 40	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00024	8d 45 6d	 lea	 eax, DWORD PTR $T42[ebp]
  00027	50		 push	 eax
  00028	ff 75 40	 push	 DWORD PTR __Newsize$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 468  : 	m_ObjectInstanceVector.resize(GetObjectDataCount());

  0002b	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00031	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 470  : 	m_GraphicThingInstanceCRCMap.clear();

  00036	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 64	 add	 ecx, 100		; 00000064H
  0003c	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00041	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 04	 add	 eax, 4
  00047	89 45 64	 mov	 DWORD PTR __My_data$40[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 64	 mov	 eax, DWORD PTR __My_data$40[ebp]
  0004d	89 45 3c	 mov	 DWORD PTR $T33[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00050	8b 45 64	 mov	 eax, DWORD PTR __My_data$40[ebp]
  00053	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00056	89 45 38	 mov	 DWORD PTR ___param0$[ebp], eax
  00059	ff 75 3c	 push	 DWORD PTR $T33[ebp]
  0005c	ff 75 38	 push	 DWORD PTR ___param0$[ebp]
  0005f	8d 4d 34	 lea	 ecx, DWORD PTR $T32[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >
  00067	8d 45 34	 lea	 eax, DWORD PTR $T32[ebp]
  0006a	89 45 24	 mov	 DWORD PTR $T29[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0006d	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00070	83 c0 04	 add	 eax, 4
  00073	89 45 60	 mov	 DWORD PTR __My_data$39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00076	8b 45 60	 mov	 eax, DWORD PTR __My_data$39[ebp]
  00079	89 45 30	 mov	 DWORD PTR $T31[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0007c	8b 45 60	 mov	 eax, DWORD PTR __My_data$39[ebp]
  0007f	8b 00		 mov	 eax, DWORD PTR [eax]
  00081	89 45 2c	 mov	 DWORD PTR ___param0$[ebp], eax
  00084	ff 75 30	 push	 DWORD PTR $T31[ebp]
  00087	ff 75 2c	 push	 DWORD PTR ___param0$[ebp]
  0008a	8d 4d 28	 lea	 ecx, DWORD PTR $T30[ebp]
  0008d	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@@std@@QAE@PAUSObjectData@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectData> > >
  00092	8d 45 28	 lea	 eax, DWORD PTR $T30[ebp]
  00095	89 45 20	 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 472  :  	std::sort(m_ObjectDataVector.begin(), m_ObjectDataVector.end(), ObjectDataComp());

  00098	8b 45 24	 mov	 eax, DWORD PTR $T29[ebp]
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
  000a0	8b 45 20	 mov	 eax, DWORD PTR $T28[ebp]
  000a3	8b 00		 mov	 eax, DWORD PTR [eax]
  000a5	89 45 1c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  000a8	8b 45 1c	 mov	 eax, DWORD PTR __First$[ebp]
  000ab	89 45 18	 mov	 DWORD PTR __Ptr$27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ae	8b 45 18	 mov	 eax, DWORD PTR __Ptr$27[ebp]
  000b1	89 45 14	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  000b4	8b 45 14	 mov	 eax, DWORD PTR $T26[ebp]
  000b7	89 45 10	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  000ba	8b 45 10	 mov	 eax, DWORD PTR $T25[ebp]
  000bd	89 45 58	 mov	 DWORD PTR __UFirst$37[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  000c3	89 45 08	 mov	 DWORD PTR __Ptr$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000c6	8b 45 08	 mov	 eax, DWORD PTR __Ptr$24[ebp]
  000c9	89 45 04	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  000cc	8b 45 04	 mov	 eax, DWORD PTR $T23[ebp]
  000cf	89 45 00	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  000d2	8b 45 00	 mov	 eax, DWORD PTR $T22[ebp]
  000d5	89 45 5c	 mov	 DWORD PTR __ULast$38[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  000d8	8a 45 6c	 mov	 al, BYTE PTR $T41[ebp]
  000db	88 45 fc	 mov	 BYTE PTR $T21[ebp], al
  000de	ff 75 fc	 push	 DWORD PTR $T21[ebp]
  000e1	8b 45 5c	 mov	 eax, DWORD PTR __ULast$38[ebp]
  000e4	2b 45 58	 sub	 eax, DWORD PTR __UFirst$37[ebp]
  000e7	99		 cdq
  000e8	6a 30		 push	 48			; 00000030H
  000ea	59		 pop	 ecx
  000eb	f7 f9		 idiv	 ecx
  000ed	50		 push	 eax
  000ee	ff 75 5c	 push	 DWORD PTR __ULast$38[ebp]
  000f1	ff 75 58	 push	 DWORD PTR __UFirst$37[ebp]
  000f4	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSObjectData@CArea@@UObjectDataComp@2@@std@@YAXPAUSObjectData@CArea@@0HUObjectDataComp@2@@Z ; std::_Sort_unchecked<CArea::SObjectData *,CArea::ObjectDataComp>
  000f9	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 474  : 	DWORD i=0;

  000fc	83 65 68 00	 and	 DWORD PTR _i$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00100	83 65 70 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00104	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00107	83 c0 10	 add	 eax, 16			; 00000010H
  0010a	89 45 54	 mov	 DWORD PTR __My_data$36[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0010d	8b 45 54	 mov	 eax, DWORD PTR __My_data$36[ebp]
  00110	89 45 a0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00113	8b 45 54	 mov	 eax, DWORD PTR __My_data$36[ebp]
  00116	8b 00		 mov	 eax, DWORD PTR [eax]
  00118	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0011b	8b 45 f8	 mov	 eax, DWORD PTR ___param0$[ebp]
  0011e	89 45 f4	 mov	 DWORD PTR $T20[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00121	8d 45 f4	 lea	 eax, DWORD PTR $T20[ebp]
  00124	89 45 f0	 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 476  : 	for (it = m_ObjectInstanceVector.begin(); it!=m_ObjectInstanceVector.end();++it,++i)

  00127	8b 45 f0	 mov	 eax, DWORD PTR $T19[ebp]
  0012a	8b 00		 mov	 eax, DWORD PTR [eax]
  0012c	89 45 70	 mov	 DWORD PTR _it$[ebp], eax
  0012f	eb 10		 jmp	 SHORT $LN4@Load_Build
$LN2@Load_Build:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00131	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  00134	83 c0 04	 add	 eax, 4
  00137	89 45 70	 mov	 DWORD PTR _it$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 476  : 	for (it = m_ObjectInstanceVector.begin(); it!=m_ObjectInstanceVector.end();++it,++i)

  0013a	8b 45 68	 mov	 eax, DWORD PTR _i$[ebp]
  0013d	40		 inc	 eax
  0013e	89 45 68	 mov	 DWORD PTR _i$[ebp], eax
$LN4@Load_Build:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00141	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00144	83 c0 10	 add	 eax, 16			; 00000010H
  00147	89 45 50	 mov	 DWORD PTR __My_data$35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0014a	8b 45 50	 mov	 eax, DWORD PTR __My_data$35[ebp]
  0014d	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00150	8b 45 50	 mov	 eax, DWORD PTR __My_data$35[ebp]
  00153	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00156	89 45 ec	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00159	8b 45 ec	 mov	 eax, DWORD PTR ___param0$[ebp]
  0015c	89 45 e8	 mov	 DWORD PTR $T18[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0015f	8d 45 e8	 lea	 eax, DWORD PTR $T18[ebp]
  00162	89 45 e4	 mov	 DWORD PTR $T17[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00165	8b 45 e4	 mov	 eax, DWORD PTR $T17[ebp]
  00168	8b 4d 70	 mov	 ecx, DWORD PTR _it$[ebp]
  0016b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0016d	75 09		 jne	 SHORT $LN147@Load_Build
  0016f	c7 45 4c 01 00
	00 00		 mov	 DWORD PTR tv346[ebp], 1
  00176	eb 04		 jmp	 SHORT $LN148@Load_Build
$LN147@Load_Build:
  00178	83 65 4c 00	 and	 DWORD PTR tv346[ebp], 0
$LN148@Load_Build:
  0017c	8a 45 4c	 mov	 al, BYTE PTR tv346[ebp]
  0017f	88 45 6f	 mov	 BYTE PTR $T44[ebp], al

; 153  :         return !(*this == _Right);

  00182	0f b6 45 6f	 movzx	 eax, BYTE PTR $T44[ebp]
  00186	85 c0		 test	 eax, eax
  00188	75 09		 jne	 SHORT $LN142@Load_Build
  0018a	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv332[ebp], 1
  00191	eb 04		 jmp	 SHORT $LN143@Load_Build
$LN142@Load_Build:
  00193	83 65 48 00	 and	 DWORD PTR tv332[ebp], 0
$LN143@Load_Build:
  00197	8a 45 48	 mov	 al, BYTE PTR tv332[ebp]
  0019a	88 45 6e	 mov	 BYTE PTR $T43[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 476  : 	for (it = m_ObjectInstanceVector.begin(); it!=m_ObjectInstanceVector.end();++it,++i)

  0019d	0f b6 45 6e	 movzx	 eax, BYTE PTR $T43[ebp]
  001a1	85 c0		 test	 eax, eax
  001a3	0f 84 d3 00 00
	00		 je	 $LN3@Load_Build
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  001a9	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  001ac	89 45 e0	 mov	 DWORD PTR $T16[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  001af	8b 45 e0	 mov	 eax, DWORD PTR $T16[ebp]
  001b2	89 45 dc	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 478  : 		*it = ms_ObjectInstancePool.Alloc();

  001b5	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_ObjectInstancePool@CArea@@1V?$CDynamicPool@USObjectInstance@CArea@@@@A ; CArea::ms_ObjectInstancePool
  001ba	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@USObjectInstance@CArea@@@@QAEPAUSObjectInstance@CArea@@XZ ; CDynamicPool<CArea::SObjectInstance>::Alloc
  001bf	8b 4d dc	 mov	 ecx, DWORD PTR $T15[ebp]
  001c2	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  001c4	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  001c7	89 45 d8	 mov	 DWORD PTR $T14[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  001ca	8b 45 d8	 mov	 eax, DWORD PTR $T14[ebp]
  001cd	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 479  : 		(*it)->Clear();

  001d0	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp]
  001d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d5	e8 00 00 00 00	 call	 ?Clear@SObjectInstance@CArea@@QAEXXZ ; CArea::SObjectInstance::Clear

; 480  : 
; 481  : 		const TObjectData * c_pObjectData;
; 482  : 
; 483  : 		if (!GetObjectDataPointer(i, &c_pObjectData))

  001da	8d 45 44	 lea	 eax, DWORD PTR _c_pObjectData$34[ebp]
  001dd	50		 push	 eax
  001de	ff 75 68	 push	 DWORD PTR _i$[ebp]
  001e1	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?GetObjectDataPointer@CArea@@QBE_NKPAPBUSObjectData@1@@Z ; CArea::GetObjectDataPointer
  001e9	0f b6 c0	 movzx	 eax, al
  001ec	85 c0		 test	 eax, eax
  001ee	75 05		 jne	 SHORT $LN5@Load_Build

; 484  : 			continue;

  001f0	e9 3c ff ff ff	 jmp	 $LN2@Load_Build
$LN5@Load_Build:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  001f5	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  001f8	89 45 d0	 mov	 DWORD PTR $T12[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  001fb	8b 45 d0	 mov	 eax, DWORD PTR $T12[ebp]
  001fe	89 45 cc	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 486  : 		__SetObjectInstance(*it, c_pObjectData);

  00201	ff 75 44	 push	 DWORD PTR _c_pObjectData$34[ebp]
  00204	8b 45 cc	 mov	 eax, DWORD PTR $T11[ebp]
  00207	ff 30		 push	 DWORD PTR [eax]
  00209	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	e8 00 00 00 00	 call	 ?__SetObjectInstance@CArea@@IAEXPAUSObjectInstance@1@PBUSObjectData@1@@Z ; CArea::__SetObjectInstance
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00211	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  00214	89 45 c8	 mov	 DWORD PTR $T10[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00217	8b 45 c8	 mov	 eax, DWORD PTR $T10[ebp]
  0021a	89 45 c4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 489  : 		if ((*it)->dwType == prt::PROPERTY_TYPE_BUILDING)

  0021d	8b 45 c4	 mov	 eax, DWORD PTR $T9[ebp]
  00220	8b 00		 mov	 eax, DWORD PTR [eax]
  00222	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00226	75 4f		 jne	 SHORT $LN6@Load_Build
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00228	8b 45 70	 mov	 eax, DWORD PTR _it$[ebp]
  0022b	89 45 c0	 mov	 DWORD PTR $T8[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0022e	8b 45 c0	 mov	 eax, DWORD PTR $T8[ebp]
  00231	89 45 bc	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 490  : 			m_GraphicThingInstanceCRCMap.insert(TGraphicThingInstanceCRCMap::value_type( (*it)->pThingInstance, c_pObjectData->dwCRC ) );

  00234	8b 45 44	 mov	 eax, DWORD PTR _c_pObjectData$34[ebp]
  00237	83 c0 0c	 add	 eax, 12			; 0000000cH
  0023a	89 45 b0	 mov	 DWORD PTR __Val2$[ebp], eax
  0023d	8b 45 bc	 mov	 eax, DWORD PTR $T7[ebp]
  00240	8b 00		 mov	 eax, DWORD PTR [eax]
  00242	83 c0 14	 add	 eax, 20			; 00000014H
  00245	89 45 b8	 mov	 DWORD PTR __Val1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00248	8b 45 b8	 mov	 eax, DWORD PTR __Val1$[ebp]
  0024b	89 45 b4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0024e	8b 45 b4	 mov	 eax, DWORD PTR $T6[ebp]
  00251	8b 00		 mov	 eax, DWORD PTR [eax]
  00253	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00256	8b 45 b0	 mov	 eax, DWORD PTR __Val2$[ebp]
  00259	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0025c	8b 45 ac	 mov	 eax, DWORD PTR $T5[ebp]
  0025f	8b 00		 mov	 eax, DWORD PTR [eax]
  00261	89 45 a8	 mov	 DWORD PTR $T4[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 490  : 			m_GraphicThingInstanceCRCMap.insert(TGraphicThingInstanceCRCMap::value_type( (*it)->pThingInstance, c_pObjectData->dwCRC ) );

  00264	8d 45 a4	 lea	 eax, DWORD PTR $T4[ebp]
  00267	50		 push	 eax
  00268	8d 45 94	 lea	 eax, DWORD PTR $T1[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	83 c1 64	 add	 ecx, 100		; 00000064H
  00272	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@QAVCGraphicThingInstance@@K@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::insert<0,0>
$LN6@Load_Build:

; 491  : 	}

  00277	e9 b5 fe ff ff	 jmp	 $LN2@Load_Build
$LN3@Load_Build:

; 492  : 
; 493  : 	//////////
; 494  : 	Refresh();

  0027c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0027f	e8 00 00 00 00	 call	 ?Refresh@CArea@@QAEXXZ	; CArea::Refresh

; 495  : 	//////////
; 496  : }

  00284	83 c5 78	 add	 ebp, 120		; 00000078H
  00287	c9		 leave
  00288	c3		 ret	 0
?__Load_BuildObjectInstances@CArea@@IAEXXZ ENDP		; CArea::__Load_BuildObjectInstances
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__Load_LoadAmbience@CArea@@IAE_NPBD@Z
_TEXT	SEGMENT
$T2 = -272						; size = 8
$T3 = -264						; size = 8
$T4 = -256						; size = 4
$T5 = -252						; size = 4
$T6 = -248						; size = 4
$T7 = -244						; size = 4
$T8 = -240						; size = 4
$T9 = -236						; size = 4
_pProperty$10 = -232					; size = 4
$T11 = -228						; size = 4
$T12 = -224						; size = 4
__My_data$13 = -220					; size = 4
$T14 = -216						; size = 4
$T15 = -212						; size = 4
__My_data$16 = -208					; size = 4
$T17 = -204						; size = 4
$T18 = -200						; size = 4
__My_data$19 = -196					; size = 4
$T20 = -192						; size = 4
$T21 = -188						; size = 4
$T22 = -184						; size = 4
__My_data$23 = -180					; size = 4
$T24 = -176						; size = 4
_this$ = -172						; size = 4
$T25 = -168						; size = 4
_c_rstrPercentage$26 = -164				; size = 4
$T27 = -160						; size = 4
__My_data$28 = -156					; size = 4
$T29 = -152						; size = 4
$T30 = -148						; size = 4
_c_rstrRange$31 = -144					; size = 4
$T32 = -140						; size = 4
_c_rstrCRC$33 = -136					; size = 4
$T34 = -132						; size = 4
_c_rstrzPosition$35 = -128				; size = 4
$T36 = -124						; size = 4
_c_rstryPosition$37 = -120				; size = 4
$T38 = -116						; size = 4
_c_rstrxPosition$39 = -112				; size = 4
__My_data$40 = -108					; size = 4
$T41 = -104						; size = 4
__Right$ = -100						; size = 4
_this$ = -96						; size = 4
_dwCount$ = -92						; size = 4
$T42 = -88						; size = 4
_c_rstrCount$ = -84					; size = 4
__My_data$43 = -80					; size = 4
$T44 = -76						; size = 4
$T45 = -72						; size = 4
__Right$ = -68						; size = 4
_this$ = -64						; size = 4
__Right$ = -60						; size = 4
_this$ = -56						; size = 4
tv543 = -52						; size = 4
__My_data$46 = -48					; size = 4
tv614 = -44						; size = 4
tv461 = -40						; size = 4
_i$47 = -36						; size = 4
_stTokenVectorMap$ = -32				; size = 8
_rVector$48 = -24					; size = 4
$T49 = -19						; size = 1
$T50 = -18						; size = 1
$T51 = -17						; size = 1
$T52 = -16						; size = 1
$T53 = -15						; size = 1
$T54 = -14						; size = 1
$T55 = -13						; size = 1
__$EHRec$ = -12						; size = 12
$T56 = 0						; size = 24
$T57 = 24						; size = 24
$T58 = 48						; size = 24
$T59 = 72						; size = 24
$T60 = 96						; size = 24
_$S21$61 = 120						; size = 24
_$S17$62 = 144						; size = 24
_$S16$63 = 168						; size = 24
_$S20$64 = 192						; size = 24
_$S18$65 = 216						; size = 24
_$S19$66 = 240						; size = 24
_ObjectData$67 = 264					; size = 48
_szObjectName$ = 312					; size = 33
__$ArrayPad$ = 348					; size = 4
_c_szFileName$ = 360					; size = 4
?__Load_LoadAmbience@CArea@@IAE_NPBD@Z PROC		; CArea::__Load_LoadAmbience, COMDAT
; _this$ = ecx

; 992  : {

  00000	55		 push	 ebp
  00001	8d ac 24 a0 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-352]
  00008	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 5c 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 8d 54 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 993  : 	CTokenVectorMap stTokenVectorMap;

  0003f	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
  00047	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 994  : 
; 995  : 	if (!LoadMultipleTextData(c_szFileName, stTokenVectorMap))

  0004b	8d 45 e0	 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  0004e	50		 push	 eax
  0004f	ff b5 68 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00055	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  0005a	59		 pop	 ecx
  0005b	59		 pop	 ecx
  0005c	0f b6 c0	 movzx	 eax, al
  0005f	85 c0		 test	 eax, eax
  00061	75 2a		 jne	 SHORT $LN5@Load_LoadA

; 996  : 	{
; 997  : 		TraceError(" CArea::Load File Load %s ERROR", c_szFileName);

  00063	ff b5 68 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NNOAMPKE@?5CArea?3?3Load?5File?5Load?5?$CFs?5ERROR@
  0006e	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00073	59		 pop	 ecx
  00074	59		 pop	 ecx

; 998  : 		return false;

  00075	c6 45 f3 00	 mov	 BYTE PTR $T55[ebp], 0
  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00080	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00085	8a 45 f3	 mov	 al, BYTE PTR $T55[ebp]
  00088	e9 44 06 00 00	 jmp	 $LN1@Load_LoadA
$LN5@Load_LoadA:

; 1001 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaambiencedatafile"))

  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PFPNGEBG@areaambiencedatafile@
  00092	8d 4d 00	 lea	 ecx, DWORD PTR $T56[ebp]
  00095	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0009a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0009e	8d 45 00	 lea	 eax, DWORD PTR $T56[ebp]
  000a1	50		 push	 eax
  000a2	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  000a8	50		 push	 eax
  000a9	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000ac	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  000b1	89 45 c4	 mov	 DWORD PTR __Right$[ebp], eax
  000b4	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  000ba	50		 push	 eax
  000bb	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000be	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  000c3	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  000c6	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	8b 4d c4	 mov	 ecx, DWORD PTR __Right$[ebp]
  000cc	8b 00		 mov	 eax, DWORD PTR [eax]
  000ce	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000d0	75 09		 jne	 SHORT $LN95@Load_LoadA
  000d2	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv461[ebp], 1
  000d9	eb 04		 jmp	 SHORT $LN96@Load_LoadA
$LN95@Load_LoadA:
  000db	83 65 d8 00	 and	 DWORD PTR tv461[ebp], 0
$LN96@Load_LoadA:
  000df	8a 45 d8	 mov	 al, BYTE PTR tv461[ebp]
  000e2	88 45 f2	 mov	 BYTE PTR $T54[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1001 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaambiencedatafile"))

  000e5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000e9	8d 4d 00	 lea	 ecx, DWORD PTR $T56[ebp]
  000ec	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1001 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areaambiencedatafile"))

  000f1	0f b6 45 f2	 movzx	 eax, BYTE PTR $T54[ebp]
  000f5	85 c0		 test	 eax, eax
  000f7	74 2a		 je	 SHORT $LN6@Load_LoadA

; 1002 : 	{
; 1003 : 		TraceError(" CArea::__LoadAmbience File Format %s ERROR 1", c_szFileName);

  000f9	ff b5 68 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@ECPJGBAI@?5CArea?3?3__LoadAmbience?5File?5For@
  00104	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00109	59		 pop	 ecx
  0010a	59		 pop	 ecx

; 1004 : 		return false;

  0010b	c6 45 f1 00	 mov	 BYTE PTR $T53[ebp], 0
  0010f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00113	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00116	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  0011b	8a 45 f1	 mov	 al, BYTE PTR $T53[ebp]
  0011e	e9 ae 05 00 00	 jmp	 $LN1@Load_LoadA
$LN6@Load_LoadA:

; 1007 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  00123	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IANPHBDM@objectcount@
  00128	8d 4d 18	 lea	 ecx, DWORD PTR $T57[ebp]
  0012b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00130	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00134	8d 45 18	 lea	 eax, DWORD PTR $T57[ebp]
  00137	50		 push	 eax
  00138	8d 85 00 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0013e	50		 push	 eax
  0013f	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00142	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00147	89 45 bc	 mov	 DWORD PTR __Right$[ebp], eax
  0014a	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00150	50		 push	 eax
  00151	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00154	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  00159	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  0015c	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	8b 4d bc	 mov	 ecx, DWORD PTR __Right$[ebp]
  00162	8b 00		 mov	 eax, DWORD PTR [eax]
  00164	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00166	75 09		 jne	 SHORT $LN176@Load_LoadA
  00168	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv543[ebp], 1
  0016f	eb 04		 jmp	 SHORT $LN177@Load_LoadA
$LN176@Load_LoadA:
  00171	83 65 cc 00	 and	 DWORD PTR tv543[ebp], 0
$LN177@Load_LoadA:
  00175	8a 45 cc	 mov	 al, BYTE PTR tv543[ebp]
  00178	88 45 f0	 mov	 BYTE PTR $T52[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1007 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  0017b	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0017f	8d 4d 18	 lea	 ecx, DWORD PTR $T57[ebp]
  00182	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1007 : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  00187	0f b6 45 f0	 movzx	 eax, BYTE PTR $T52[ebp]
  0018b	85 c0		 test	 eax, eax
  0018d	74 2a		 je	 SHORT $LN7@Load_LoadA

; 1008 : 	{
; 1009 : 		TraceError(" CArea::__LoadAmbience File Format %s ERROR 2", c_szFileName);

  0018f	ff b5 68 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00195	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GJNEDCML@?5CArea?3?3__LoadAmbience?5File?5For@
  0019a	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0019f	59		 pop	 ecx
  001a0	59		 pop	 ecx

; 1010 : 		return false;

  001a1	c6 45 ef 00	 mov	 BYTE PTR $T51[ebp], 0
  001a5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001a9	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001ac	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  001b1	8a 45 ef	 mov	 al, BYTE PTR $T51[ebp]
  001b4	e9 18 05 00 00	 jmp	 $LN1@Load_LoadA
$LN7@Load_LoadA:

; 1013 : 	const std::string & c_rstrCount = stTokenVectorMap["objectcount"][0];

  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IANPHBDM@objectcount@
  001be	8d 4d 30	 lea	 ecx, DWORD PTR $T58[ebp]
  001c1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001c6	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001ca	8d 45 30	 lea	 eax, DWORD PTR $T58[ebp]
  001cd	89 45 b8	 mov	 DWORD PTR $T45[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 154  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  001d0	ff 75 b8	 push	 DWORD PTR $T45[ebp]
  001d3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  001d9	50		 push	 eax
  001da	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001dd	e8 00 00 00 00	 call	 ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  001e2	8b 00		 mov	 eax, DWORD PTR [eax]
  001e4	83 c0 28	 add	 eax, 40			; 00000028H
  001e7	89 45 b4	 mov	 DWORD PTR $T44[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001ea	8b 45 b4	 mov	 eax, DWORD PTR $T44[ebp]
  001ed	89 45 b0	 mov	 DWORD PTR __My_data$43[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001f0	33 c0		 xor	 eax, eax
  001f2	6b c0 18	 imul	 eax, eax, 24
  001f5	8b 4d b0	 mov	 ecx, DWORD PTR __My_data$43[ebp]
  001f8	03 01		 add	 eax, DWORD PTR [ecx]
  001fa	89 45 ac	 mov	 DWORD PTR _c_rstrCount$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1013 : 	const std::string & c_rstrCount = stTokenVectorMap["objectcount"][0];

  001fd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00201	8d 4d 30	 lea	 ecx, DWORD PTR $T58[ebp]
  00204	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3752 :         return _Mypair._Myval2._Myptr();

  00209	8b 4d ac	 mov	 ecx, DWORD PTR _c_rstrCount$[ebp]
  0020c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00211	89 45 a8	 mov	 DWORD PTR $T42[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1015 : 	DWORD dwCount = atoi(c_rstrCount.c_str());

  00214	ff 75 a8	 push	 DWORD PTR $T42[ebp]
  00217	e8 00 00 00 00	 call	 __atoi64
  0021c	59		 pop	 ecx
  0021d	89 45 a4	 mov	 DWORD PTR _dwCount$[ebp], eax

; 1016 : 
; 1017 : 	char szObjectName[32+1];
; 1018 : 
; 1019 : 	for (DWORD i = 0; i < dwCount; ++i)

  00220	83 65 dc 00	 and	 DWORD PTR _i$47[ebp], 0
  00224	eb 07		 jmp	 SHORT $LN4@Load_LoadA
$LN2@Load_LoadA:
  00226	8b 45 dc	 mov	 eax, DWORD PTR _i$47[ebp]
  00229	40		 inc	 eax
  0022a	89 45 dc	 mov	 DWORD PTR _i$47[ebp], eax
$LN4@Load_LoadA:
  0022d	8b 45 dc	 mov	 eax, DWORD PTR _i$47[ebp]
  00230	3b 45 a4	 cmp	 eax, DWORD PTR _dwCount$[ebp]
  00233	0f 83 85 04 00
	00		 jae	 $LN3@Load_LoadA

; 1020 : 	{
; 1021 : 		_snprintf(szObjectName, sizeof(szObjectName), "object%03d", i);

  00239	ff 75 dc	 push	 DWORD PTR _i$47[ebp]
  0023c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CHFLOJFF@object?$CF03d@
  00241	6a 21		 push	 33			; 00000021H
  00243	8d 85 38 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 __snprintf
  0024f	83 c4 10	 add	 esp, 16			; 00000010H

; 1023 : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  00252	8d 85 38 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  00258	50		 push	 eax
  00259	8d 4d 48	 lea	 ecx, DWORD PTR $T59[ebp]
  0025c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00261	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00265	8d 45 48	 lea	 eax, DWORD PTR $T59[ebp]
  00268	50		 push	 eax
  00269	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0026f	50		 push	 eax
  00270	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00273	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00278	89 45 9c	 mov	 DWORD PTR __Right$[ebp], eax
  0027b	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00281	50		 push	 eax
  00282	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00285	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  0028a	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  0028d	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  00290	8b 4d 9c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00293	8b 00		 mov	 eax, DWORD PTR [eax]
  00295	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00297	75 09		 jne	 SHORT $LN297@Load_LoadA
  00299	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv614[ebp], 1
  002a0	eb 04		 jmp	 SHORT $LN298@Load_LoadA
$LN297@Load_LoadA:
  002a2	83 65 d4 00	 and	 DWORD PTR tv614[ebp], 0
$LN298@Load_LoadA:
  002a6	8a 45 d4	 mov	 al, BYTE PTR tv614[ebp]
  002a9	88 45 ee	 mov	 BYTE PTR $T50[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1023 : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  002ac	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002b0	8d 4d 48	 lea	 ecx, DWORD PTR $T59[ebp]
  002b3	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1023 : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  002b8	0f b6 45 ee	 movzx	 eax, BYTE PTR $T50[ebp]
  002bc	85 c0		 test	 eax, eax
  002be	74 05		 je	 SHORT $LN8@Load_LoadA

; 1024 : 			continue;

  002c0	e9 61 ff ff ff	 jmp	 $LN2@Load_LoadA
$LN8@Load_LoadA:

; 1026 : 		const CTokenVector & rVector = stTokenVectorMap[szObjectName];

  002c5	8d 85 38 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  002cb	50		 push	 eax
  002cc	8d 4d 60	 lea	 ecx, DWORD PTR $T60[ebp]
  002cf	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002d4	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  002d8	8d 45 60	 lea	 eax, DWORD PTR $T60[ebp]
  002db	89 45 98	 mov	 DWORD PTR $T41[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 154  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  002de	ff 75 98	 push	 DWORD PTR $T41[ebp]
  002e1	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  002e7	50		 push	 eax
  002e8	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  002eb	e8 00 00 00 00	 call	 ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  002f0	8b 00		 mov	 eax, DWORD PTR [eax]
  002f2	83 c0 28	 add	 eax, 40			; 00000028H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1026 : 		const CTokenVector & rVector = stTokenVectorMap[szObjectName];

  002f5	89 45 e8	 mov	 DWORD PTR _rVector$48[ebp], eax
  002f8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002fc	8d 4d 60	 lea	 ecx, DWORD PTR $T60[ebp]
  002ff	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00304	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  00307	89 45 94	 mov	 DWORD PTR __My_data$40[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  0030a	33 c0		 xor	 eax, eax
  0030c	6b c0 18	 imul	 eax, eax, 24
  0030f	8b 4d 94	 mov	 ecx, DWORD PTR __My_data$40[ebp]
  00312	03 01		 add	 eax, DWORD PTR [ecx]
  00314	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0031a	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  00320	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00325	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1028 : 		const std::string & c_rstrxPosition = rVector[0].c_str();

  0032b	ff b5 20 ff ff
	ff		 push	 DWORD PTR $T12[ebp]
  00331	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _$S16$63[ebp]
  00337	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0033c	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00340	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR _$S16$63[ebp]
  00346	89 45 90	 mov	 DWORD PTR _c_rstrxPosition$39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00349	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  0034c	89 85 24 ff ff
	ff		 mov	 DWORD PTR __My_data$13[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00352	33 c0		 xor	 eax, eax
  00354	40		 inc	 eax
  00355	6b c0 18	 imul	 eax, eax, 24
  00358	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$13[ebp]
  0035e	03 01		 add	 eax, DWORD PTR [ecx]
  00360	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00366	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T14[ebp]
  0036c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00371	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1029 : 		const std::string & c_rstryPosition = rVector[1].c_str();

  00377	ff b5 2c ff ff
	ff		 push	 DWORD PTR $T15[ebp]
  0037d	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _$S17$62[ebp]
  00383	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00388	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0038c	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR _$S17$62[ebp]
  00392	89 45 88	 mov	 DWORD PTR _c_rstryPosition$37[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00395	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  00398	89 85 30 ff ff
	ff		 mov	 DWORD PTR __My_data$16[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  0039e	6a 02		 push	 2
  003a0	58		 pop	 eax
  003a1	6b c0 18	 imul	 eax, eax, 24
  003a4	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$16[ebp]
  003aa	03 01		 add	 eax, DWORD PTR [ecx]
  003ac	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003b2	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR $T17[ebp]
  003b8	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  003bd	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1030 : 		const std::string & c_rstrzPosition = rVector[2].c_str();

  003c3	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T18[ebp]
  003c9	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S18$65[ebp]
  003cf	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003d4	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  003d8	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _$S18$65[ebp]
  003de	89 45 80	 mov	 DWORD PTR _c_rstrzPosition$35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  003e1	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  003e4	89 85 3c ff ff
	ff		 mov	 DWORD PTR __My_data$19[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  003ea	6a 03		 push	 3
  003ec	58		 pop	 eax
  003ed	6b c0 18	 imul	 eax, eax, 24
  003f0	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$19[ebp]
  003f6	03 01		 add	 eax, DWORD PTR [ecx]
  003f8	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003fe	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR $T21[ebp]
  00404	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00409	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1031 : 		const std::string & c_rstrCRC = rVector[3].c_str();

  0040f	ff b5 48 ff ff
	ff		 push	 DWORD PTR $T22[ebp]
  00415	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S19$66[ebp]
  0041b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00420	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00424	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR _$S19$66[ebp]
  0042a	89 85 78 ff ff
	ff		 mov	 DWORD PTR _c_rstrCRC$33[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00430	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  00433	89 85 4c ff ff
	ff		 mov	 DWORD PTR __My_data$23[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00439	6a 04		 push	 4
  0043b	58		 pop	 eax
  0043c	6b c0 18	 imul	 eax, eax, 24
  0043f	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$23[ebp]
  00445	03 01		 add	 eax, DWORD PTR [ecx]
  00447	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0044d	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR $T24[ebp]
  00453	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00458	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1032 : 		const std::string & c_rstrRange = rVector[4].c_str();

  0045e	ff b5 40 ff ff
	ff		 push	 DWORD PTR $T20[ebp]
  00464	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S20$64[ebp]
  0046a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0046f	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00473	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _$S20$64[ebp]
  00479	89 85 70 ff ff
	ff		 mov	 DWORD PTR _c_rstrRange$31[ebp], eax

; 1033 : 
; 1034 : 		TObjectData ObjectData;
; 1035 : 		ZeroMemory(&ObjectData, sizeof(ObjectData));

  0047f	6a 30		 push	 48			; 00000030H
  00481	6a 00		 push	 0
  00483	8d 85 08 01 00
	00		 lea	 eax, DWORD PTR _ObjectData$67[ebp]
  00489	50		 push	 eax
  0048a	e8 00 00 00 00	 call	 _memset
  0048f	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00492	8b 4d 90	 mov	 ecx, DWORD PTR _c_rstrxPosition$39[ebp]
  00495	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0049a	89 45 8c	 mov	 DWORD PTR $T38[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1036 : 		ObjectData.Position.x = atof(c_rstrxPosition.c_str());

  0049d	ff 75 8c	 push	 DWORD PTR $T38[ebp]
  004a0	e8 00 00 00 00	 call	 _atof
  004a5	59		 pop	 ecx
  004a6	d9 9d 08 01 00
	00		 fstp	 DWORD PTR _ObjectData$67[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004ac	8b 4d 88	 mov	 ecx, DWORD PTR _c_rstryPosition$37[ebp]
  004af	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004b4	89 45 84	 mov	 DWORD PTR $T36[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1037 : 		ObjectData.Position.y = atof(c_rstryPosition.c_str());

  004b7	ff 75 84	 push	 DWORD PTR $T36[ebp]
  004ba	e8 00 00 00 00	 call	 _atof
  004bf	59		 pop	 ecx
  004c0	d9 9d 0c 01 00
	00		 fstp	 DWORD PTR _ObjectData$67[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004c6	8b 4d 80	 mov	 ecx, DWORD PTR _c_rstrzPosition$35[ebp]
  004c9	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004ce	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T34[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1038 : 		ObjectData.Position.z = atof(c_rstrzPosition.c_str());

  004d4	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T34[ebp]
  004da	e8 00 00 00 00	 call	 _atof
  004df	59		 pop	 ecx
  004e0	d9 9d 10 01 00
	00		 fstp	 DWORD PTR _ObjectData$67[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004e6	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrCRC$33[ebp]
  004ec	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004f1	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T32[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1039 : 		ObjectData.dwCRC = atoi	(c_rstrCRC.c_str());

  004f7	ff b5 74 ff ff
	ff		 push	 DWORD PTR $T32[ebp]
  004fd	e8 00 00 00 00	 call	 __atoi64
  00502	59		 pop	 ecx
  00503	89 85 14 01 00
	00		 mov	 DWORD PTR _ObjectData$67[ebp+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00509	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrRange$31[ebp]
  0050f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00514	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1040 : 		ObjectData.dwRange = atoi(c_rstrRange.c_str());

  0051a	ff b5 6c ff ff
	ff		 push	 DWORD PTR $T30[ebp]
  00520	e8 00 00 00 00	 call	 __atoi64
  00525	59		 pop	 ecx
  00526	89 85 30 01 00
	00		 mov	 DWORD PTR _ObjectData$67[ebp+40], eax

; 1041 : 
; 1042 : 		// 20041217.myevan. 
; 1043 : 		ObjectData.InitializeRotation();

  0052c	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR _ObjectData$67[ebp]
  00532	e8 00 00 00 00	 call	 ?InitializeRotation@SObjectData@CArea@@QAEXXZ ; CArea::SObjectData::InitializeRotation

; 1044 : 		ObjectData.m_fHeightBias = 0.0f;

  00537	0f 57 c0	 xorps	 xmm0, xmm0
  0053a	f3 0f 11 85 2c
	01 00 00	 movss	 DWORD PTR _ObjectData$67[ebp+36], xmm0

; 1045 : 		ObjectData.fMaxVolumeAreaPercentage = 0.0f;

  00542	0f 57 c0	 xorps	 xmm0, xmm0
  00545	f3 0f 11 85 34
	01 00 00	 movss	 DWORD PTR _ObjectData$67[ebp+44], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0054d	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  00550	89 45 d0	 mov	 DWORD PTR __My_data$46[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00553	8b 45 d0	 mov	 eax, DWORD PTR __My_data$46[ebp]
  00556	8b 4d d0	 mov	 ecx, DWORD PTR __My_data$46[ebp]
  00559	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0055c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0055e	99		 cdq
  0055f	6a 18		 push	 24			; 00000018H
  00561	59		 pop	 ecx
  00562	f7 f9		 idiv	 ecx
  00564	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T29[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1047 : 		if (rVector.size() >= 6)

  0056a	83 bd 68 ff ff
	ff 06		 cmp	 DWORD PTR $T29[ebp], 6
  00571	72 5a		 jb	 SHORT $LN542@Load_LoadA
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00573	8b 45 e8	 mov	 eax, DWORD PTR _rVector$48[ebp]
  00576	89 85 64 ff ff
	ff		 mov	 DWORD PTR __My_data$28[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  0057c	6a 05		 push	 5
  0057e	58		 pop	 eax
  0057f	6b c0 18	 imul	 eax, eax, 24
  00582	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$28[ebp]
  00588	03 01		 add	 eax, DWORD PTR [ecx]
  0058a	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T27[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1049 : 			const std::string & c_rstrPercentage = rVector[5].c_str();

  00590	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR $T27[ebp]
  00596	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0059b	50		 push	 eax
  0059c	8d 4d 78	 lea	 ecx, DWORD PTR _$S21$61[ebp]
  0059f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005a4	8d 45 78	 lea	 eax, DWORD PTR _$S21$61[ebp]
  005a7	89 85 5c ff ff
	ff		 mov	 DWORD PTR _c_rstrPercentage$26[ebp], eax

; 1050 : 			ObjectData.fMaxVolumeAreaPercentage = atof(c_rstrPercentage.c_str());

  005ad	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrPercentage$26[ebp]
  005b3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  005b8	50		 push	 eax
  005b9	e8 00 00 00 00	 call	 _atof
  005be	59		 pop	 ecx
  005bf	d9 9d 34 01 00
	00		 fstp	 DWORD PTR _ObjectData$67[ebp+44]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005c5	8d 4d 78	 lea	 ecx, DWORD PTR _$S21$61[ebp]
  005c8	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN542@Load_LoadA:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  005cd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A ; CSingleton<CPropertyManager>::ms_singleton
  005d2	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1055 : 		if (!CPropertyManager::Instance().Get(ObjectData.dwCRC, &pProperty))

  005d8	8d 85 18 ff ff
	ff		 lea	 eax, DWORD PTR _pProperty$10[ebp]
  005de	50		 push	 eax
  005df	ff b5 14 01 00
	00		 push	 DWORD PTR _ObjectData$67[ebp+12]
  005e5	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR $T25[ebp]
  005eb	e8 00 00 00 00	 call	 ?Get@CPropertyManager@@QAE_NKPAPAVCProperty@@@Z ; CPropertyManager::Get
  005f0	0f b6 c0	 movzx	 eax, al
  005f3	85 c0		 test	 eax, eax
  005f5	75 62		 jne	 SHORT $LN10@Load_LoadA

; 1056 : 		{
; 1057 : 			TraceError(" CArea::LoadAmbience Property(%d) Load ERROR", ObjectData.dwCRC);

  005f7	ff b5 14 01 00
	00		 push	 DWORD PTR _ObjectData$67[ebp+12]
  005fd	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@BAHENMHD@?5CArea?3?3LoadAmbience?5Property?$CI?$CF@
  00602	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00607	59		 pop	 ecx
  00608	59		 pop	 ecx

; 1058 : 			continue;

  00609	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0060d	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S20$64[ebp]
  00613	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1058 : 			continue;

  00618	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0061c	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S19$66[ebp]
  00622	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1058 : 			continue;

  00627	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0062b	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S18$65[ebp]
  00631	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1058 : 			continue;

  00636	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0063a	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _$S17$62[ebp]
  00640	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1058 : 			continue;

  00645	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00649	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _$S16$63[ebp]
  0064f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1058 : 			continue;

  00654	e9 cd fb ff ff	 jmp	 $LN2@Load_LoadA
$LN10@Load_LoadA:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00659	8d 85 08 01 00
	00		 lea	 eax, DWORD PTR _ObjectData$67[ebp]
  0065f	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1061 : 		m_ObjectDataVector.push_back(ObjectData);

  00660	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00666	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00669	e8 00 00 00 00	 call	 ??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::emplace_back<CArea::SObjectData const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  0066e	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00672	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S20$64[ebp]
  00678	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  0067d	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00681	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S19$66[ebp]
  00687	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  0068c	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00690	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S18$65[ebp]
  00696	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  0069b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0069f	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _$S17$62[ebp]
  006a5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  006aa	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  006ae	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _$S16$63[ebp]
  006b4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1062 : 	}

  006b9	e9 68 fb ff ff	 jmp	 $LN2@Load_LoadA
$LN3@Load_LoadA:

; 1063 : 
; 1064 : 	return true;

  006be	c6 45 ed 01	 mov	 BYTE PTR $T49[ebp], 1
  006c2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  006c6	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  006c9	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  006ce	8a 45 ed	 mov	 al, BYTE PTR $T49[ebp]
$LN1@Load_LoadA:

; 1065 : }

  006d1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  006d4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006db	59		 pop	 ecx
  006dc	8b 8d 5c 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006e2	33 cd		 xor	 ecx, ebp
  006e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  006e9	81 c5 60 01 00
	00		 add	 ebp, 352		; 00000160H
  006ef	c9		 leave
  006f0	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$1:
  00008	8d 4d 00	 lea	 ecx, DWORD PTR $T56[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$2:
  00010	8d 4d 18	 lea	 ecx, DWORD PTR $T57[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$3:
  00018	8d 4d 30	 lea	 ecx, DWORD PTR $T58[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$4:
  00020	8d 4d 48	 lea	 ecx, DWORD PTR $T59[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$5:
  00028	8d 4d 60	 lea	 ecx, DWORD PTR $T60[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$6:
  00030	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR _$S16$63[ebp]
  00036	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$7:
  0003b	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR _$S17$62[ebp]
  00041	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$8:
  00046	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S18$65[ebp]
  0004c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$9:
  00051	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S19$66[ebp]
  00057	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z$10:
  0005c	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S20$64[ebp]
  00062	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
__ehhandler$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z:
  0006c	90		 npad	 1
  0006d	90		 npad	 1
  0006e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00072	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00075	8b 8a f8 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-264]
  0007b	33 c8		 xor	 ecx, eax
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	8b 8a 68 01 00
	00		 mov	 ecx, DWORD PTR [edx+360]
  00088	33 c8		 xor	 ecx, eax
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__Load_LoadAmbience@CArea@@IAE_NPBD@Z
  00094	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__Load_LoadAmbience@CArea@@IAE_NPBD@Z ENDP		; CArea::__Load_LoadAmbience
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__Load_LoadObject@CArea@@IAE_NPBD@Z
_TEXT	SEGMENT
$T2 = -408						; size = 8
$T3 = -400						; size = 8
$T4 = -392						; size = 4
$T5 = -388						; size = 4
$T6 = -384						; size = 4
_pProperty$7 = -380					; size = 4
$T8 = -376						; size = 4
$T9 = -372						; size = 4
$T10 = -368						; size = 4
__My_data$11 = -364					; size = 4
$T12 = -360						; size = 4
$T13 = -356						; size = 4
$T14 = -352						; size = 4
$T15 = -348						; size = 4
__My_data$16 = -344					; size = 4
$T17 = -340						; size = 4
__Right$ = -336						; size = 4
_this$ = -332						; size = 4
_dwCount$ = -328					; size = 4
$T18 = -324						; size = 4
_c_rstrCount$ = -320					; size = 4
__My_data$19 = -316					; size = 4
$T20 = -312						; size = 4
$T21 = -308						; size = 4
__Right$ = -304						; size = 4
_this$ = -300						; size = 4
_this$ = -296						; size = 4
__Right$ = -292						; size = 4
_this$ = -288						; size = 4
$T22 = -284						; size = 4
$T23 = -280						; size = 4
__My_data$24 = -276					; size = 4
$T25 = -272						; size = 4
$T26 = -268						; size = 4
$T27 = -264						; size = 4
$T28 = -260						; size = 4
__My_data$29 = -256					; size = 4
$T30 = -252						; size = 4
$T31 = -248						; size = 4
__My_data$32 = -244					; size = 4
tv486 = -240						; size = 4
$T33 = -236						; size = 4
__My_data$34 = -232					; size = 4
tv484 = -228						; size = 4
$T35 = -224						; size = 4
__My_data$36 = -220					; size = 4
__My_data$37 = -216					; size = 4
$T38 = -212						; size = 4
$T39 = -208						; size = 4
$T40 = -204						; size = 4
__My_data$41 = -200					; size = 4
__My_data$42 = -196					; size = 4
$T43 = -192						; size = 4
$T44 = -188						; size = 4
_c_rstrCRC$45 = -184					; size = 4
$T46 = -180						; size = 4
_c_rstrzPosition$47 = -176				; size = 4
$T48 = -172						; size = 4
_c_rstryPosition$49 = -168				; size = 4
$T50 = -164						; size = 4
_c_rstrxPosition$51 = -160				; size = 4
$T52 = -156						; size = 4
$T53 = -152						; size = 4
__My_data$54 = -148					; size = 4
$T55 = -144						; size = 4
$T56 = -140						; size = 4
__My_data$57 = -136					; size = 4
$T58 = -132						; size = 4
$T59 = -128						; size = 4
__My_data$60 = -124					; size = 4
$T61 = -120						; size = 4
$T62 = -116						; size = 4
tv579 = -112						; size = 4
tv629 = -108						; size = 4
tv700 = -104						; size = 4
__My_data$63 = -100					; size = 4
$T64 = -96						; size = 4
$T65 = -92						; size = 4
tv443 = -88						; size = 4
__My_data$66 = -84					; size = 4
__My_data$67 = -80					; size = 4
__My_data$68 = -76					; size = 4
__My_data$69 = -72					; size = 4
$T70 = -68						; size = 4
$T71 = -64						; size = 4
$T72 = -58						; size = 1
$T73 = -57						; size = 1
_p$74 = -56						; size = 4
$T75 = -49						; size = 1
_i$76 = -48						; size = 4
_portalIdx$77 = -44					; size = 4
_s$78 = -40						; size = 4
$T79 = -36						; size = 4
_stTokenVectorMap$ = -32				; size = 8
$T80 = -23						; size = 1
$T81 = -22						; size = 1
$T82 = -21						; size = 1
$T83 = -20						; size = 1
$T84 = -19						; size = 1
$T85 = -18						; size = 1
$T86 = -17						; size = 1
_rVector$87 = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T88 = 0						; size = 24
$T89 = 24						; size = 24
$T90 = 48						; size = 24
$T91 = 72						; size = 24
$T92 = 96						; size = 24
$T93 = 120						; size = 24
$T94 = 144						; size = 24
$T95 = 168						; size = 24
_$S15$96 = 192						; size = 24
_$S14$97 = 216						; size = 24
_$S13$98 = 240						; size = 24
_$S12$99 = 264						; size = 24
_ObjectData$100 = 288					; size = 48
_szObjectName$ = 336					; size = 33
__$ArrayPad$ = 372					; size = 4
_c_szFileName$ = 384					; size = 4
?__Load_LoadObject@CArea@@IAE_NPBD@Z PROC		; CArea::__Load_LoadObject, COMDAT
; _this$ = ecx

; 894  : {

  00000	55		 push	 ebp
  00001	8d ac 24 88 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-376]
  00008	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__Load_LoadObject@CArea@@IAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 74 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 8d d8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0003f	83 65 dc 00	 and	 DWORD PTR $T79[ebp], 0

; 895  : 	CTokenVectorMap stTokenVectorMap;

  00043	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 896  : 
; 897  : 	if (!LoadMultipleTextData(c_szFileName, stTokenVectorMap))

  0004f	8d 45 e0	 lea	 eax, DWORD PTR _stTokenVectorMap$[ebp]
  00052	50		 push	 eax
  00053	ff b5 80 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00059	e8 00 00 00 00	 call	 ?LoadMultipleTextData@@YA_NPBDAAV?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@@Z ; LoadMultipleTextData
  0005e	59		 pop	 ecx
  0005f	59		 pop	 ecx
  00060	0f b6 c0	 movzx	 eax, al
  00063	85 c0		 test	 eax, eax
  00065	75 2a		 jne	 SHORT $LN8@Load_LoadO

; 898  : 	{
; 899  : 		TraceError(" CArea::Load File Load %s ERROR", c_szFileName);

  00067	ff b5 80 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NNOAMPKE@?5CArea?3?3Load?5File?5Load?5?$CFs?5ERROR@
  00072	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00077	59		 pop	 ecx
  00078	59		 pop	 ecx

; 900  : 		return false;

  00079	c6 45 ea 00	 mov	 BYTE PTR $T81[ebp], 0
  0007d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00081	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00084	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00089	8a 45 ea	 mov	 al, BYTE PTR $T81[ebp]
  0008c	e9 7b 09 00 00	 jmp	 $LN1@Load_LoadO
$LN8@Load_LoadO:

; 903  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areadatafile"))

  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0N@DLGDDPHB@areadatafile@
  00096	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T94[ebp]
  0009c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a5	8d 85 90 00 00
	00		 lea	 eax, DWORD PTR $T94[ebp]
  000ab	50		 push	 eax
  000ac	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  000b2	50		 push	 eax
  000b3	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000b6	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  000bb	89 85 dc fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
  000c1	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000c7	50		 push	 eax
  000c8	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  000cb	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  000d0	89 85 e0 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  000d6	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000dc	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR __Right$[ebp]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000e6	75 09		 jne	 SHORT $LN105@Load_LoadO
  000e8	c7 45 90 01 00
	00 00		 mov	 DWORD PTR tv579[ebp], 1
  000ef	eb 04		 jmp	 SHORT $LN106@Load_LoadO
$LN105@Load_LoadO:
  000f1	83 65 90 00	 and	 DWORD PTR tv579[ebp], 0
$LN106@Load_LoadO:
  000f5	8a 45 90	 mov	 al, BYTE PTR tv579[ebp]
  000f8	88 45 ef	 mov	 BYTE PTR $T86[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 903  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areadatafile"))

  000fb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ff	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T94[ebp]
  00105	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 903  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("areadatafile"))

  0010a	0f b6 45 ef	 movzx	 eax, BYTE PTR $T86[ebp]
  0010e	85 c0		 test	 eax, eax
  00110	74 2a		 je	 SHORT $LN9@Load_LoadO

; 904  : 	{
; 905  : 		TraceError(" CArea::__LoadObject File Format %s ERROR 1", c_szFileName);

  00112	ff b5 80 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00118	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CJHDNGEF@?5CArea?3?3__LoadObject?5File?5Forma@
  0011d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00122	59		 pop	 ecx
  00123	59		 pop	 ecx

; 906  : 		return false;

  00124	c6 45 ee 00	 mov	 BYTE PTR $T85[ebp], 0
  00128	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0012c	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0012f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00134	8a 45 ee	 mov	 al, BYTE PTR $T85[ebp]
  00137	e9 d0 08 00 00	 jmp	 $LN1@Load_LoadO
$LN9@Load_LoadO:

; 909  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IANPHBDM@objectcount@
  00141	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T95[ebp]
  00147	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0014c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00150	8d 85 a8 00 00
	00		 lea	 eax, DWORD PTR $T95[ebp]
  00156	50		 push	 eax
  00157	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0015d	50		 push	 eax
  0015e	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00161	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  00166	89 85 d0 fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
  0016c	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00172	50		 push	 eax
  00173	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00176	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  0017b	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  00181	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00187	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR __Right$[ebp]
  0018d	8b 00		 mov	 eax, DWORD PTR [eax]
  0018f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00191	75 09		 jne	 SHORT $LN186@Load_LoadO
  00193	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv629[ebp], 1
  0019a	eb 04		 jmp	 SHORT $LN187@Load_LoadO
$LN186@Load_LoadO:
  0019c	83 65 94 00	 and	 DWORD PTR tv629[ebp], 0
$LN187@Load_LoadO:
  001a0	8a 45 94	 mov	 al, BYTE PTR tv629[ebp]
  001a3	88 45 ed	 mov	 BYTE PTR $T84[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 909  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  001a6	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001aa	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T95[ebp]
  001b0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 909  : 	if (stTokenVectorMap.end() == stTokenVectorMap.find("objectcount"))

  001b5	0f b6 45 ed	 movzx	 eax, BYTE PTR $T84[ebp]
  001b9	85 c0		 test	 eax, eax
  001bb	74 2a		 je	 SHORT $LN10@Load_LoadO

; 910  : 	{
; 911  : 		TraceError(" CArea::__LoadObject File Format %s ERROR 2", c_szFileName);

  001bd	ff b5 80 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@CFOIFIG@?5CArea?3?3__LoadObject?5File?5Forma@
  001c8	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001cd	59		 pop	 ecx
  001ce	59		 pop	 ecx

; 912  : 		return false;

  001cf	c6 45 ec 00	 mov	 BYTE PTR $T83[ebp], 0
  001d3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001d7	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  001da	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  001df	8a 45 ec	 mov	 al, BYTE PTR $T83[ebp]
  001e2	e9 25 08 00 00	 jmp	 $LN1@Load_LoadO
$LN10@Load_LoadO:

; 915  : 	const std::string & c_rstrCount = stTokenVectorMap["objectcount"][0];

  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IANPHBDM@objectcount@
  001ec	8d 4d 00	 lea	 ecx, DWORD PTR $T88[ebp]
  001ef	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001f4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001f8	8d 45 00	 lea	 eax, DWORD PTR $T88[ebp]
  001fb	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 154  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  00201	ff b5 cc fe ff
	ff		 push	 DWORD PTR $T21[ebp]
  00207	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0020d	50		 push	 eax
  0020e	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00211	e8 00 00 00 00	 call	 ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00216	8b 00		 mov	 eax, DWORD PTR [eax]
  00218	83 c0 28	 add	 eax, 40			; 00000028H
  0021b	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00221	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00227	89 85 c4 fe ff
	ff		 mov	 DWORD PTR __My_data$19[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0022d	33 c0		 xor	 eax, eax
  0022f	6b c0 18	 imul	 eax, eax, 24
  00232	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$19[ebp]
  00238	03 01		 add	 eax, DWORD PTR [ecx]
  0023a	89 85 c0 fe ff
	ff		 mov	 DWORD PTR _c_rstrCount$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 915  : 	const std::string & c_rstrCount = stTokenVectorMap["objectcount"][0];

  00240	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00244	8d 4d 00	 lea	 ecx, DWORD PTR $T88[ebp]
  00247	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3752 :         return _Mypair._Myval2._Myptr();

  0024c	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR _c_rstrCount$[ebp]
  00252	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00257	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 917  : 	DWORD dwCount = atoi(c_rstrCount.c_str());

  0025d	ff b5 bc fe ff
	ff		 push	 DWORD PTR $T18[ebp]
  00263	e8 00 00 00 00	 call	 __atoi64
  00268	59		 pop	 ecx
  00269	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _dwCount$[ebp], eax

; 918  : 
; 919  : 	char szObjectName[32+1];
; 920  : 
; 921  : 	for (DWORD i = 0; i < dwCount; ++i)

  0026f	83 65 d0 00	 and	 DWORD PTR _i$76[ebp], 0
  00273	eb 07		 jmp	 SHORT $LN4@Load_LoadO
$LN2@Load_LoadO:
  00275	8b 45 d0	 mov	 eax, DWORD PTR _i$76[ebp]
  00278	40		 inc	 eax
  00279	89 45 d0	 mov	 DWORD PTR _i$76[ebp], eax
$LN4@Load_LoadO:
  0027c	8b 45 d0	 mov	 eax, DWORD PTR _i$76[ebp]
  0027f	3b 85 b8 fe ff
	ff		 cmp	 eax, DWORD PTR _dwCount$[ebp]
  00285	0f 83 6e 07 00
	00		 jae	 $LN3@Load_LoadO

; 922  : 	{
; 923  : 		_snprintf(szObjectName, sizeof(szObjectName), "object%03d", i);

  0028b	ff 75 d0	 push	 DWORD PTR _i$76[ebp]
  0028e	68 00 00 00 00	 push	 OFFSET ??_C@_0L@CHFLOJFF@object?$CF03d@
  00293	6a 21		 push	 33			; 00000021H
  00295	8d 85 50 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 __snprintf
  002a1	83 c4 10	 add	 esp, 16			; 00000010H

; 925  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  002a4	8d 85 50 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  002aa	50		 push	 eax
  002ab	8d 4d 78	 lea	 ecx, DWORD PTR $T93[ebp]
  002ae	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  002b3	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  002b7	8d 45 78	 lea	 eax, DWORD PTR $T93[ebp]
  002ba	50		 push	 eax
  002bb	8d 85 9c fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  002c1	50		 push	 eax
  002c2	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  002c5	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::find
  002ca	89 85 b0 fe ff
	ff		 mov	 DWORD PTR __Right$[ebp], eax
  002d0	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  002d6	50		 push	 eax
  002d7	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  002da	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::end
  002df	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  002e5	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002eb	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR __Right$[ebp]
  002f1	8b 00		 mov	 eax, DWORD PTR [eax]
  002f3	3b 01		 cmp	 eax, DWORD PTR [ecx]
  002f5	75 09		 jne	 SHORT $LN307@Load_LoadO
  002f7	c7 45 98 01 00
	00 00		 mov	 DWORD PTR tv700[ebp], 1
  002fe	eb 04		 jmp	 SHORT $LN308@Load_LoadO
$LN307@Load_LoadO:
  00300	83 65 98 00	 and	 DWORD PTR tv700[ebp], 0
$LN308@Load_LoadO:
  00304	8a 45 98	 mov	 al, BYTE PTR tv700[ebp]
  00307	88 45 e9	 mov	 BYTE PTR $T80[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 925  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  0030a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0030e	8d 4d 78	 lea	 ecx, DWORD PTR $T93[ebp]
  00311	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 925  : 		if (stTokenVectorMap.end() == stTokenVectorMap.find(szObjectName))

  00316	0f b6 45 e9	 movzx	 eax, BYTE PTR $T80[ebp]
  0031a	85 c0		 test	 eax, eax
  0031c	74 05		 je	 SHORT $LN11@Load_LoadO

; 926  : 			continue;

  0031e	e9 52 ff ff ff	 jmp	 $LN2@Load_LoadO
$LN11@Load_LoadO:

; 928  : 		const CTokenVector & rVector = stTokenVectorMap[szObjectName];

  00323	8d 85 50 01 00
	00		 lea	 eax, DWORD PTR _szObjectName$[ebp]
  00329	50		 push	 eax
  0032a	8d 4d 18	 lea	 ecx, DWORD PTR $T89[ebp]
  0032d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00332	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00336	8d 45 18	 lea	 eax, DWORD PTR $T89[ebp]
  00339	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 154  :         return _Try_emplace(_STD move(_Keyval)).first->_Myval.second;

  0033f	ff b5 ac fe ff
	ff		 push	 DWORD PTR $T17[ebp]
  00345	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0034b	50		 push	 eax
  0034c	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  0034f	e8 00 00 00 00	 call	 ??$_Try_emplace@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$$V@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@PAX@std@@_N@1@$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > > >::_Try_emplace<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00354	8b 00		 mov	 eax, DWORD PTR [eax]
  00356	83 c0 28	 add	 eax, 40			; 00000028H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 928  : 		const CTokenVector & rVector = stTokenVectorMap[szObjectName];

  00359	89 45 f0	 mov	 DWORD PTR _rVector$87[ebp], eax
  0035c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00360	8d 4d 18	 lea	 ecx, DWORD PTR $T89[ebp]
  00363	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00368	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  0036b	89 85 a8 fe ff
	ff		 mov	 DWORD PTR __My_data$16[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  00371	33 c0		 xor	 eax, eax
  00373	6b c0 18	 imul	 eax, eax, 24
  00376	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$16[ebp]
  0037c	03 01		 add	 eax, DWORD PTR [ecx]
  0037e	89 85 a4 fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00384	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR $T15[ebp]
  0038a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0038f	89 45 88	 mov	 DWORD PTR $T61[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 930  : 		const std::string & c_rstrxPosition = rVector[0].c_str();

  00392	ff 75 88	 push	 DWORD PTR $T61[ebp]
  00395	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR _$S12$99[ebp]
  0039b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003a0	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  003a4	8d 85 08 01 00
	00		 lea	 eax, DWORD PTR _$S12$99[ebp]
  003aa	89 85 60 ff ff
	ff		 mov	 DWORD PTR _c_rstrxPosition$51[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  003b0	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  003b3	89 45 84	 mov	 DWORD PTR __My_data$60[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  003b6	33 c0		 xor	 eax, eax
  003b8	40		 inc	 eax
  003b9	6b c0 18	 imul	 eax, eax, 24
  003bc	8b 4d 84	 mov	 ecx, DWORD PTR __My_data$60[ebp]
  003bf	03 01		 add	 eax, DWORD PTR [ecx]
  003c1	89 45 80	 mov	 DWORD PTR $T59[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  003c4	8b 4d 80	 mov	 ecx, DWORD PTR $T59[ebp]
  003c7	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  003cc	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T58[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 931  : 		const std::string & c_rstryPosition = rVector[1].c_str();

  003d2	ff b5 7c ff ff
	ff		 push	 DWORD PTR $T58[ebp]
  003d8	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S13$98[ebp]
  003de	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003e3	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  003e7	8d 85 f0 00 00
	00		 lea	 eax, DWORD PTR _$S13$98[ebp]
  003ed	89 85 58 ff ff
	ff		 mov	 DWORD PTR _c_rstryPosition$49[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  003f3	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  003f6	89 85 78 ff ff
	ff		 mov	 DWORD PTR __My_data$57[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  003fc	6a 02		 push	 2
  003fe	58		 pop	 eax
  003ff	6b c0 18	 imul	 eax, eax, 24
  00402	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$57[ebp]
  00408	03 01		 add	 eax, DWORD PTR [ecx]
  0040a	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00410	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T56[ebp]
  00416	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0041b	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T55[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 932  : 		const std::string & c_rstrzPosition = rVector[2].c_str();

  00421	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T55[ebp]
  00427	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S14$97[ebp]
  0042d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00432	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00436	8d 85 d8 00 00
	00		 lea	 eax, DWORD PTR _$S14$97[ebp]
  0043c	89 85 50 ff ff
	ff		 mov	 DWORD PTR _c_rstrzPosition$47[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00442	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00445	89 85 6c ff ff
	ff		 mov	 DWORD PTR __My_data$54[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  0044b	6a 03		 push	 3
  0044d	58		 pop	 eax
  0044e	6b c0 18	 imul	 eax, eax, 24
  00451	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$54[ebp]
  00457	03 01		 add	 eax, DWORD PTR [ecx]
  00459	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T53[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0045f	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T53[ebp]
  00465	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0046a	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T52[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 933  : 		const std::string & c_rstrCRC = rVector[3].c_str();

  00470	ff b5 64 ff ff
	ff		 push	 DWORD PTR $T52[ebp]
  00476	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S15$96[ebp]
  0047c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00481	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00485	8d 85 c0 00 00
	00		 lea	 eax, DWORD PTR _$S15$96[ebp]
  0048b	89 85 48 ff ff
	ff		 mov	 DWORD PTR _c_rstrCRC$45[ebp], eax

; 934  : 
; 935  : 		TObjectData ObjectData;
; 936  : 		ZeroMemory(&ObjectData, sizeof(ObjectData));

  00491	6a 30		 push	 48			; 00000030H
  00493	6a 00		 push	 0
  00495	8d 85 20 01 00
	00		 lea	 eax, DWORD PTR _ObjectData$100[ebp]
  0049b	50		 push	 eax
  0049c	e8 00 00 00 00	 call	 _memset
  004a1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004a4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrxPosition$51[ebp]
  004aa	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004af	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T50[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 937  : 		ObjectData.Position.x = atof(c_rstrxPosition.c_str());

  004b5	ff b5 5c ff ff
	ff		 push	 DWORD PTR $T50[ebp]
  004bb	e8 00 00 00 00	 call	 _atof
  004c0	59		 pop	 ecx
  004c1	d9 9d 20 01 00
	00		 fstp	 DWORD PTR _ObjectData$100[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004c7	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstryPosition$49[ebp]
  004cd	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004d2	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T48[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 938  : 		ObjectData.Position.y = atof(c_rstryPosition.c_str());

  004d8	ff b5 54 ff ff
	ff		 push	 DWORD PTR $T48[ebp]
  004de	e8 00 00 00 00	 call	 _atof
  004e3	59		 pop	 ecx
  004e4	d9 9d 24 01 00
	00		 fstp	 DWORD PTR _ObjectData$100[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  004ea	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrzPosition$47[ebp]
  004f0	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  004f5	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T46[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 939  : 		ObjectData.Position.z = atof(c_rstrzPosition.c_str());

  004fb	ff b5 4c ff ff
	ff		 push	 DWORD PTR $T46[ebp]
  00501	e8 00 00 00 00	 call	 _atof
  00506	59		 pop	 ecx
  00507	d9 9d 28 01 00
	00		 fstp	 DWORD PTR _ObjectData$100[ebp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  0050d	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _c_rstrCRC$45[ebp]
  00513	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00518	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T44[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 940  : 		ObjectData.dwCRC = atoi	(c_rstrCRC.c_str());

  0051e	ff b5 44 ff ff
	ff		 push	 DWORD PTR $T44[ebp]
  00524	e8 00 00 00 00	 call	 __atoi64
  00529	59		 pop	 ecx
  0052a	89 85 2c 01 00
	00		 mov	 DWORD PTR _ObjectData$100[ebp+12], eax

; 941  : 
; 942  : 		// 20041217.myevan.  
; 943  : 		ObjectData.InitializeRotation(); //ObjectData.m_fYaw = ObjectData.m_fPitch = ObjectData.m_fRoll = 0;

  00530	8d 8d 20 01 00
	00		 lea	 ecx, DWORD PTR _ObjectData$100[ebp]
  00536	e8 00 00 00 00	 call	 ?InitializeRotation@SObjectData@CArea@@QAEXXZ ; CArea::SObjectData::InitializeRotation
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0053b	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  0053e	89 45 9c	 mov	 DWORD PTR __My_data$63[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00541	8b 45 9c	 mov	 eax, DWORD PTR __My_data$63[ebp]
  00544	8b 4d 9c	 mov	 ecx, DWORD PTR __My_data$63[ebp]
  00547	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0054a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0054c	99		 cdq
  0054d	6a 18		 push	 24			; 00000018H
  0054f	59		 pop	 ecx
  00550	f7 f9		 idiv	 ecx
  00552	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T43[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 944  : 		if (rVector.size() > 4)

  00558	83 bd 40 ff ff
	ff 04		 cmp	 DWORD PTR $T43[ebp], 4
  0055f	0f 86 7e 02 00
	00		 jbe	 $LN14@Load_LoadO
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00565	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00568	89 85 3c ff ff
	ff		 mov	 DWORD PTR __My_data$42[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  0056e	6a 04		 push	 4
  00570	58		 pop	 eax
  00571	6b c0 18	 imul	 eax, eax, 24
  00574	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$42[ebp]
  0057a	03 01		 add	 eax, DWORD PTR [ecx]
  0057c	89 45 a0	 mov	 DWORD PTR $T64[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3971 :         return static_cast<size_type>(

  0057f	6a 23		 push	 35			; 00000023H
  00581	6a 00		 push	 0
  00583	8b 45 a0	 mov	 eax, DWORD PTR $T64[ebp]
  00586	ff 70 10	 push	 DWORD PTR [eax+16]
  00589	8b 4d a0	 mov	 ecx, DWORD PTR $T64[ebp]
  0058c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00591	50		 push	 eax
  00592	e8 00 00 00 00	 call	 ??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z ; std::_Traits_find_ch<std::char_traits<char> >
  00597	83 c4 10	 add	 esp, 16			; 00000010H
  0059a	89 45 d8	 mov	 DWORD PTR _s$78[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  0059d	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  005a0	89 85 94 fe ff
	ff		 mov	 DWORD PTR __My_data$11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 947  : 			if (s!=rVector[4].npos)

  005a6	83 7d d8 ff	 cmp	 DWORD PTR _s$78[ebp], -1
  005aa	0f 84 db 01 00
	00		 je	 $LN13@Load_LoadO
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  005b0	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  005b3	89 85 38 ff ff
	ff		 mov	 DWORD PTR __My_data$41[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  005b9	6a 04		 push	 4
  005bb	58		 pop	 eax
  005bc	6b c0 18	 imul	 eax, eax, 24
  005bf	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$41[ebp]
  005c5	03 01		 add	 eax, DWORD PTR [ecx]
  005c7	89 45 a4	 mov	 DWORD PTR $T65[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  005ca	8b 45 a4	 mov	 eax, DWORD PTR $T65[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  005cd	89 85 90 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4279 :         return static_cast<allocator_type>(_Getal());

  005d3	8d 45 cf	 lea	 eax, DWORD PTR $T75[ebp]
  005d6	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T40[ebp], eax

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  005dc	ff b5 34 ff ff
	ff		 push	 DWORD PTR $T40[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 949  : 				ObjectData.m_fYaw = atoi(rVector[4].substr(0,s-1).c_str());

  005e2	8b 45 d8	 mov	 eax, DWORD PTR _s$78[ebp]
  005e5	48		 dec	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  005e6	50		 push	 eax
  005e7	6a 00		 push	 0
  005e9	ff 75 a4	 push	 DWORD PTR $T65[ebp]
  005ec	8d 4d 30	 lea	 ecx, DWORD PTR $T90[ebp]
  005ef	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005f4	8b 45 dc	 mov	 eax, DWORD PTR $T79[ebp]
  005f7	83 c8 01	 or	 eax, 1
  005fa	89 45 dc	 mov	 DWORD PTR $T79[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 949  : 				ObjectData.m_fYaw = atoi(rVector[4].substr(0,s-1).c_str());

  005fd	8d 45 30	 lea	 eax, DWORD PTR $T90[ebp]
  00600	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00606	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR $T39[ebp]
  0060c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00611	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T38[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 949  : 				ObjectData.m_fYaw = atoi(rVector[4].substr(0,s-1).c_str());

  00617	ff b5 2c ff ff
	ff		 push	 DWORD PTR $T38[ebp]
  0061d	e8 00 00 00 00	 call	 __atoi64
  00622	59		 pop	 ecx
  00623	8b c8		 mov	 ecx, eax
  00625	e8 00 00 00 00	 call	 __ltod3
  0062a	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  0062e	f3 0f 11 85 38
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+24], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00636	8d 4d 30	 lea	 ecx, DWORD PTR $T90[ebp]
  00639	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 950  : 				int p = s+1;

  0063e	8b 45 d8	 mov	 eax, DWORD PTR _s$78[ebp]
  00641	40		 inc	 eax
  00642	89 45 c8	 mov	 DWORD PTR _p$74[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00645	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00648	89 85 28 ff ff
	ff		 mov	 DWORD PTR __My_data$37[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  0064e	6a 04		 push	 4
  00650	58		 pop	 eax
  00651	6b c0 18	 imul	 eax, eax, 24
  00654	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$37[ebp]
  0065a	03 01		 add	 eax, DWORD PTR [ecx]
  0065c	89 45 8c	 mov	 DWORD PTR $T62[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3971 :         return static_cast<size_type>(

  0065f	6a 23		 push	 35			; 00000023H
  00661	ff 75 c8	 push	 DWORD PTR _p$74[ebp]
  00664	8b 45 8c	 mov	 eax, DWORD PTR $T62[ebp]
  00667	ff 70 10	 push	 DWORD PTR [eax+16]
  0066a	8b 4d 8c	 mov	 ecx, DWORD PTR $T62[ebp]
  0066d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00672	50		 push	 eax
  00673	e8 00 00 00 00	 call	 ??$_Traits_find_ch@U?$char_traits@D@std@@@std@@YAIQBDIID@Z ; std::_Traits_find_ch<std::char_traits<char> >
  00678	83 c4 10	 add	 esp, 16			; 00000010H
  0067b	89 45 d8	 mov	 DWORD PTR _s$78[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  0067e	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00681	89 85 24 ff ff
	ff		 mov	 DWORD PTR __My_data$36[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  00687	6a 04		 push	 4
  00689	58		 pop	 eax
  0068a	6b c0 18	 imul	 eax, eax, 24
  0068d	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$36[ebp]
  00693	03 01		 add	 eax, DWORD PTR [ecx]
  00695	89 45 c0	 mov	 DWORD PTR $T71[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  00698	8b 45 c0	 mov	 eax, DWORD PTR $T71[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0069b	89 85 8c fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4279 :         return static_cast<allocator_type>(_Getal());

  006a1	8d 45 c6	 lea	 eax, DWORD PTR $T72[ebp]
  006a4	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T35[ebp], eax

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  006aa	ff b5 20 ff ff
	ff		 push	 DWORD PTR $T35[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 952  : 				ObjectData.m_fPitch = atoi(rVector[4].substr(p,s-1-p+1).c_str());

  006b0	8b 45 d8	 mov	 eax, DWORD PTR _s$78[ebp]
  006b3	48		 dec	 eax
  006b4	2b 45 c8	 sub	 eax, DWORD PTR _p$74[ebp]
  006b7	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  006b8	50		 push	 eax
  006b9	ff 75 c8	 push	 DWORD PTR _p$74[ebp]
  006bc	ff 75 c0	 push	 DWORD PTR $T71[ebp]
  006bf	8d 4d 48	 lea	 ecx, DWORD PTR $T91[ebp]
  006c2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  006c7	8b 45 dc	 mov	 eax, DWORD PTR $T79[ebp]
  006ca	83 c8 02	 or	 eax, 2
  006cd	89 45 dc	 mov	 DWORD PTR $T79[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 952  : 				ObjectData.m_fPitch = atoi(rVector[4].substr(p,s-1-p+1).c_str());

  006d0	8d 45 48	 lea	 eax, DWORD PTR $T91[ebp]
  006d3	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv484[ebp], eax
  006d9	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv484[ebp]
  006df	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  006e4	50		 push	 eax
  006e5	e8 00 00 00 00	 call	 __atoi64
  006ea	59		 pop	 ecx
  006eb	8b c8		 mov	 ecx, eax
  006ed	e8 00 00 00 00	 call	 __ltod3
  006f2	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  006f6	f3 0f 11 85 3c
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+28], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  006fe	8d 4d 48	 lea	 ecx, DWORD PTR $T91[ebp]
  00701	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00706	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00709	89 85 18 ff ff
	ff		 mov	 DWORD PTR __My_data$34[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  0070f	6a 04		 push	 4
  00711	58		 pop	 eax
  00712	6b c0 18	 imul	 eax, eax, 24
  00715	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$34[ebp]
  0071b	03 01		 add	 eax, DWORD PTR [ecx]
  0071d	89 45 bc	 mov	 DWORD PTR $T70[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  00720	8b 45 bc	 mov	 eax, DWORD PTR $T70[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00723	89 85 88 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4279 :         return static_cast<allocator_type>(_Getal());

  00729	8d 45 c7	 lea	 eax, DWORD PTR $T73[ebp]
  0072c	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T33[ebp], eax

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  00732	ff b5 14 ff ff
	ff		 push	 DWORD PTR $T33[ebp]
  00738	6a ff		 push	 -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 953  : 				ObjectData.m_fRoll = atoi(rVector[4].substr(s+1).c_str());

  0073a	8b 45 d8	 mov	 eax, DWORD PTR _s$78[ebp]
  0073d	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4171 :         return basic_string(*this, _Off, _Count, get_allocator());

  0073e	50		 push	 eax
  0073f	ff 75 bc	 push	 DWORD PTR $T70[ebp]
  00742	8d 4d 60	 lea	 ecx, DWORD PTR $T92[ebp]
  00745	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0074a	8b 45 dc	 mov	 eax, DWORD PTR $T79[ebp]
  0074d	83 c8 04	 or	 eax, 4
  00750	89 45 dc	 mov	 DWORD PTR $T79[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 953  : 				ObjectData.m_fRoll = atoi(rVector[4].substr(s+1).c_str());

  00753	8d 45 60	 lea	 eax, DWORD PTR $T92[ebp]
  00756	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv486[ebp], eax
  0075c	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv486[ebp]
  00762	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00767	50		 push	 eax
  00768	e8 00 00 00 00	 call	 __atoi64
  0076d	59		 pop	 ecx
  0076e	8b c8		 mov	 ecx, eax
  00770	e8 00 00 00 00	 call	 __ltod3
  00775	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  00779	f3 0f 11 85 40
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+32], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00781	8d 4d 60	 lea	 ecx, DWORD PTR $T92[ebp]
  00784	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 954  : 			}

  00789	eb 58		 jmp	 SHORT $LN14@Load_LoadO
$LN13@Load_LoadO:

; 955  : 			else
; 956  : 			{
; 957  : 				ObjectData.m_fYaw = 0.0f;

  0078b	0f 57 c0	 xorps	 xmm0, xmm0
  0078e	f3 0f 11 85 38
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+24], xmm0

; 958  : 				ObjectData.m_fPitch = 0.0f;

  00796	0f 57 c0	 xorps	 xmm0, xmm0
  00799	f3 0f 11 85 3c
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+28], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  007a1	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  007a4	89 85 0c ff ff
	ff		 mov	 DWORD PTR __My_data$32[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  007aa	6a 04		 push	 4
  007ac	58		 pop	 eax
  007ad	6b c0 18	 imul	 eax, eax, 24
  007b0	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$32[ebp]
  007b6	03 01		 add	 eax, DWORD PTR [ecx]
  007b8	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T31[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 959  : 				ObjectData.m_fRoll = atoi(rVector[4].c_str());

  007be	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR $T31[ebp]
  007c4	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  007c9	50		 push	 eax
  007ca	e8 00 00 00 00	 call	 __atoi64
  007cf	59		 pop	 ecx
  007d0	8b c8		 mov	 ecx, eax
  007d2	e8 00 00 00 00	 call	 __ltod3
  007d7	f2 0f 5a c0	 cvtsd2ss xmm0, xmm0
  007db	f3 0f 11 85 40
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+32], xmm0
$LN14@Load_LoadO:

; 960  : 			}
; 961  : 		}
; 962  : 		
; 963  : 		ObjectData.m_fHeightBias = 0.0f;

  007e3	0f 57 c0	 xorps	 xmm0, xmm0
  007e6	f3 0f 11 85 44
	01 00 00	 movss	 DWORD PTR _ObjectData$100[ebp+36], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  007ee	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  007f1	89 45 b8	 mov	 DWORD PTR __My_data$69[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  007f4	8b 45 b8	 mov	 eax, DWORD PTR __My_data$69[ebp]
  007f7	8b 4d b8	 mov	 ecx, DWORD PTR __My_data$69[ebp]
  007fa	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  007fd	2b 01		 sub	 eax, DWORD PTR [ecx]
  007ff	99		 cdq
  00800	6a 18		 push	 24			; 00000018H
  00802	59		 pop	 ecx
  00803	f7 f9		 idiv	 ecx
  00805	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 964  : 		if (rVector.size() > 5)

  0080b	83 bd 04 ff ff
	ff 05		 cmp	 DWORD PTR $T30[ebp], 5
  00812	76 35		 jbe	 SHORT $LN15@Load_LoadO
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00814	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00817	89 85 00 ff ff
	ff		 mov	 DWORD PTR __My_data$29[ebp], eax

; 1514 :         return _My_data._Myfirst[_Pos];

  0081d	6a 05		 push	 5
  0081f	58		 pop	 eax
  00820	6b c0 18	 imul	 eax, eax, 24
  00823	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR __My_data$29[ebp]
  00829	03 01		 add	 eax, DWORD PTR [ecx]
  0082b	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 966  : 			ObjectData.m_fHeightBias = atof(rVector[5].c_str());

  00831	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR $T28[ebp]
  00837	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0083c	50		 push	 eax
  0083d	e8 00 00 00 00	 call	 _atof
  00842	59		 pop	 ecx
  00843	d9 9d 44 01 00
	00		 fstp	 DWORD PTR _ObjectData$100[ebp+36]
$LN15@Load_LoadO:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00849	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  0084c	89 45 b4	 mov	 DWORD PTR __My_data$68[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0084f	8b 45 b4	 mov	 eax, DWORD PTR __My_data$68[ebp]
  00852	8b 4d b4	 mov	 ecx, DWORD PTR __My_data$68[ebp]
  00855	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00858	2b 01		 sub	 eax, DWORD PTR [ecx]
  0085a	99		 cdq
  0085b	6a 18		 push	 24			; 00000018H
  0085d	59		 pop	 ecx
  0085e	f7 f9		 idiv	 ecx
  00860	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T27[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 969  : 		if (rVector.size() > 6)

  00866	83 bd f8 fe ff
	ff 06		 cmp	 DWORD PTR $T27[ebp], 6
  0086d	0f 86 b3 00 00
	00		 jbe	 $LN6@Load_LoadO

; 971  : 			for (int portalIdx = 0; portalIdx < min(rVector.size()-6, PORTAL_ID_MAX_NUM); ++portalIdx)

  00873	83 65 d4 00	 and	 DWORD PTR _portalIdx$77[ebp], 0
  00877	eb 07		 jmp	 SHORT $LN7@Load_LoadO
$LN5@Load_LoadO:
  00879	8b 45 d4	 mov	 eax, DWORD PTR _portalIdx$77[ebp]
  0087c	40		 inc	 eax
  0087d	89 45 d4	 mov	 DWORD PTR _portalIdx$77[ebp], eax
$LN7@Load_LoadO:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00880	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  00883	89 45 b0	 mov	 DWORD PTR __My_data$67[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00886	8b 45 b0	 mov	 eax, DWORD PTR __My_data$67[ebp]
  00889	8b 4d b0	 mov	 ecx, DWORD PTR __My_data$67[ebp]
  0088c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0088f	2b 01		 sub	 eax, DWORD PTR [ecx]
  00891	99		 cdq
  00892	6a 18		 push	 24			; 00000018H
  00894	59		 pop	 ecx
  00895	f7 f9		 idiv	 ecx
  00897	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T26[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 971  : 			for (int portalIdx = 0; portalIdx < min(rVector.size()-6, PORTAL_ID_MAX_NUM); ++portalIdx)

  0089d	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  008a3	83 e8 06	 sub	 eax, 6
  008a6	83 f8 08	 cmp	 eax, 8
  008a9	73 2b		 jae	 SHORT $LN19@Load_LoadO
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  008ab	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  008ae	89 45 ac	 mov	 DWORD PTR __My_data$66[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  008b1	8b 45 ac	 mov	 eax, DWORD PTR __My_data$66[ebp]
  008b4	8b 4d ac	 mov	 ecx, DWORD PTR __My_data$66[ebp]
  008b7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  008ba	2b 01		 sub	 eax, DWORD PTR [ecx]
  008bc	99		 cdq
  008bd	6a 18		 push	 24			; 00000018H
  008bf	59		 pop	 ecx
  008c0	f7 f9		 idiv	 ecx
  008c2	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 971  : 			for (int portalIdx = 0; portalIdx < min(rVector.size()-6, PORTAL_ID_MAX_NUM); ++portalIdx)

  008c8	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  008ce	83 e8 06	 sub	 eax, 6
  008d1	89 45 a8	 mov	 DWORD PTR tv443[ebp], eax
  008d4	eb 07		 jmp	 SHORT $LN20@Load_LoadO
$LN19@Load_LoadO:
  008d6	c7 45 a8 08 00
	00 00		 mov	 DWORD PTR tv443[ebp], 8
$LN20@Load_LoadO:
  008dd	8b 45 d4	 mov	 eax, DWORD PTR _portalIdx$77[ebp]
  008e0	3b 45 a8	 cmp	 eax, DWORD PTR tv443[ebp]
  008e3	73 41		 jae	 SHORT $LN6@Load_LoadO
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  008e5	8b 45 f0	 mov	 eax, DWORD PTR _rVector$87[ebp]
  008e8	89 85 ec fe ff
	ff		 mov	 DWORD PTR __My_data$24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 973  : 				ObjectData.abyPortalID[portalIdx] = atoi(rVector[6+portalIdx].c_str());

  008ee	8b 45 d4	 mov	 eax, DWORD PTR _portalIdx$77[ebp]
  008f1	83 c0 06	 add	 eax, 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1514 :         return _My_data._Myfirst[_Pos];

  008f4	6b c0 18	 imul	 eax, eax, 24
  008f7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$24[ebp]
  008fd	03 01		 add	 eax, DWORD PTR [ecx]
  008ff	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 973  : 				ObjectData.abyPortalID[portalIdx] = atoi(rVector[6+portalIdx].c_str());

  00905	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T23[ebp]
  0090b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00910	50		 push	 eax
  00911	e8 00 00 00 00	 call	 __atoi64
  00916	59		 pop	 ecx
  00917	8b 4d d4	 mov	 ecx, DWORD PTR _portalIdx$77[ebp]
  0091a	88 84 0d 30 01
	00 00		 mov	 BYTE PTR _ObjectData$100[ebp+ecx+16], al

; 974  : 			}

  00921	e9 53 ff ff ff	 jmp	 $LN5@Load_LoadO
$LN6@Load_LoadO:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00926	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPropertyManager@@@@0PAVCPropertyManager@@A ; CSingleton<CPropertyManager>::ms_singleton
  0092b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 979  : 		if (!CPropertyManager::Instance().Get(ObjectData.dwCRC, &pProperty))

  00931	8d 85 84 fe ff
	ff		 lea	 eax, DWORD PTR _pProperty$7[ebp]
  00937	50		 push	 eax
  00938	ff b5 2c 01 00
	00		 push	 DWORD PTR _ObjectData$100[ebp+12]
  0093e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp]
  00944	e8 00 00 00 00	 call	 ?Get@CPropertyManager@@QAE_NKPAPAVCProperty@@@Z ; CPropertyManager::Get
  00949	0f b6 c0	 movzx	 eax, al
  0094c	85 c0		 test	 eax, eax
  0094e	75 53		 jne	 SHORT $LN17@Load_LoadO

; 980  : 		{
; 981  : 			TraceError(" CArea::LoadObject Property(%u) Load ERROR", ObjectData.dwCRC);

  00950	ff b5 2c 01 00
	00		 push	 DWORD PTR _ObjectData$100[ebp+12]
  00956	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@HHDKLHOE@?5CArea?3?3LoadObject?5Property?$CI?$CFu?$CJ@
  0095b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00960	59		 pop	 ecx
  00961	59		 pop	 ecx

; 982  : 			continue;

  00962	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00966	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S15$96[ebp]
  0096c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 982  : 			continue;

  00971	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00975	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S14$97[ebp]
  0097b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 982  : 			continue;

  00980	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00984	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S13$98[ebp]
  0098a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 982  : 			continue;

  0098f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00993	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR _$S12$99[ebp]
  00999	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 982  : 			continue;

  0099e	e9 d2 f8 ff ff	 jmp	 $LN2@Load_LoadO
$LN17@Load_LoadO:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  009a3	8d 85 20 01 00
	00		 lea	 eax, DWORD PTR _ObjectData$100[ebp]
  009a9	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 985  : 		m_ObjectDataVector.push_back(ObjectData);

  009aa	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009b0	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  009b3	e8 00 00 00 00	 call	 ??$emplace_back@ABUSObjectData@CArea@@@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXABUSObjectData@CArea@@@Z ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::emplace_back<CArea::SObjectData const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 986  : 	}

  009b8	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  009bc	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S15$96[ebp]
  009c2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 986  : 	}

  009c7	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  009cb	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S14$97[ebp]
  009d1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 986  : 	}

  009d6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  009da	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S13$98[ebp]
  009e0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 986  : 	}

  009e5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  009e9	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR _$S12$99[ebp]
  009ef	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 986  : 	}

  009f4	e9 7c f8 ff ff	 jmp	 $LN2@Load_LoadO
$LN3@Load_LoadO:

; 987  : 
; 988  : 	return true;

  009f9	c6 45 eb 01	 mov	 BYTE PTR $T82[ebp], 1
  009fd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00a01	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00a04	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > > >,0> >
  00a09	8a 45 eb	 mov	 al, BYTE PTR $T82[ebp]
$LN1@Load_LoadO:

; 989  : }

  00a0c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00a0f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00a16	59		 pop	 ecx
  00a17	8b 8d 74 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00a1d	33 cd		 xor	 ecx, ebp
  00a1f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00a24	81 c5 78 01 00
	00		 add	 ebp, 376		; 00000178H
  00a2a	c9		 leave
  00a2b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR _stTokenVectorMap$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@@std@@@2@@std@@QAE@XZ
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$1:
  00008	8d 8d 90 00 00
	00		 lea	 ecx, DWORD PTR $T94[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$2:
  00013	8d 8d a8 00 00
	00		 lea	 ecx, DWORD PTR $T95[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$3:
  0001e	8d 4d 00	 lea	 ecx, DWORD PTR $T88[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$4:
  00026	8d 4d 78	 lea	 ecx, DWORD PTR $T93[ebp]
  00029	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$5:
  0002e	8d 4d 18	 lea	 ecx, DWORD PTR $T89[ebp]
  00031	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$6:
  00036	8d 8d 08 01 00
	00		 lea	 ecx, DWORD PTR _$S12$99[ebp]
  0003c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$7:
  00041	8d 8d f0 00 00
	00		 lea	 ecx, DWORD PTR _$S13$98[ebp]
  00047	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$8:
  0004c	8d 8d d8 00 00
	00		 lea	 ecx, DWORD PTR _$S14$97[ebp]
  00052	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Load_LoadObject@CArea@@IAE_NPBD@Z$9:
  00057	8d 8d c0 00 00
	00		 lea	 ecx, DWORD PTR _$S15$96[ebp]
  0005d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
  00066	cc		 int	 3
__ehhandler$?__Load_LoadObject@CArea@@IAE_NPBD@Z:
  00067	90		 npad	 1
  00068	90		 npad	 1
  00069	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0006d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00070	8b 8a 70 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-400]
  00076	33 c8		 xor	 ecx, eax
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	8b 8a 80 01 00
	00		 mov	 ecx, DWORD PTR [edx+384]
  00083	33 c8		 xor	 ecx, eax
  00085	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__Load_LoadObject@CArea@@IAE_NPBD@Z
  0008f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__Load_LoadObject@CArea@@IAE_NPBD@Z ENDP		; CArea::__Load_LoadObject
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?CheckObjectIndex@CArea@@IBE_NK@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
_dwIndex$ = 8						; size = 4
?CheckObjectIndex@CArea@@IBE_NK@Z PROC			; CArea::CheckObjectIndex, COMDAT
; _this$ = ecx

; 1070 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	6a 30		 push	 48			; 00000030H
  00020	59		 pop	 ecx
  00021	f7 f9		 idiv	 ecx
  00023	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1071 : 	if (dwIndex >= m_ObjectDataVector.size())

  00026	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00029	3b 45 f4	 cmp	 eax, DWORD PTR $T1[ebp]
  0002c	72 04		 jb	 SHORT $LN2@CheckObjec

; 1072 : 		return false;

  0002e	32 c0		 xor	 al, al
  00030	eb 02		 jmp	 SHORT $LN1@CheckObjec
$LN2@CheckObjec:

; 1073 : 
; 1074 : 	return true;

  00032	b0 01		 mov	 al, 1
$LN1@CheckObjec:

; 1075 : }

  00034	c9		 leave
  00035	c2 04 00	 ret	 4
?CheckObjectIndex@CArea@@IBE_NK@Z ENDP			; CArea::CheckObjectIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?DEBUG_GetRenderedGrapphicThingInstanceNum@CArea@@QAEKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
?DEBUG_GetRenderedGrapphicThingInstanceNum@CArea@@QAEKXZ PROC ; CArea::DEBUG_GetRenderedGrapphicThingInstanceNum, COMDAT
; _this$ = ecx

; 175  : { return m_kRenderedGrapphicThingInstanceVector.size(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 78	 add	 eax, 120		; 00000078H
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 02	 sar	 eax, 2
  00020	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 175  : { return m_kRenderedGrapphicThingInstanceVector.size(); }

  00023	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00026	c9		 leave
  00027	c3		 ret	 0
?DEBUG_GetRenderedGrapphicThingInstanceNum@CArea@@QAEKXZ ENDP ; CArea::DEBUG_GetRenderedGrapphicThingInstanceNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?DEBUG_GetRenderedCRCWithNumVector@CArea@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DEBUG_GetRenderedCRCWithNumVector@CArea@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@XZ PROC ; CArea::DEBUG_GetRenderedCRCWithNumVector, COMDAT
; _this$ = ecx

; 172  : { return m_kRenderedThingInstanceCRCWithNumberVector; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 6c	 add	 eax, 108		; 0000006cH
  0000d	c9		 leave
  0000e	c3		 ret	 0
?DEBUG_GetRenderedCRCWithNumVector@CArea@@QAEAAV?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@XZ ENDP ; CArea::DEBUG_GetRenderedCRCWithNumVector
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?DEBUG_GetRenderedCRCNum@CArea@@QAEKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
?DEBUG_GetRenderedCRCNum@CArea@@QAEKXZ PROC		; CArea::DEBUG_GetRenderedCRCNum, COMDAT
; _this$ = ecx

; 169  : { return m_kRenderedThingInstanceCRCWithNumberVector.size(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 6c	 add	 eax, 108		; 0000006cH
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 03	 sar	 eax, 3
  00020	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 169  : { return m_kRenderedThingInstanceCRCWithNumberVector.size(); }

  00023	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00026	c9		 leave
  00027	c3		 ret	 0
?DEBUG_GetRenderedCRCNum@CArea@@QAEKXZ ENDP		; CArea::DEBUG_GetRenderedCRCNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?GetCoordinate@CArea@@QAEXPAG0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usCoordX$ = 8						; size = 4
_usCoordY$ = 12						; size = 4
?GetCoordinate@CArea@@QAEXPAG0@Z PROC			; CArea::GetCoordinate, COMDAT
; _this$ = ecx

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1279 : 	*usCoordX = m_wX;

  00007	8b 45 08	 mov	 eax, DWORD PTR _usCoordX$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	66 8b 89 84 00
	00 00		 mov	 cx, WORD PTR [ecx+132]
  00014	66 89 08	 mov	 WORD PTR [eax], cx

; 1280 : 	*usCoordY = m_wY;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _usCoordY$[ebp]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	66 8b 89 86 00
	00 00		 mov	 cx, WORD PTR [ecx+134]
  00024	66 89 08	 mov	 WORD PTR [eax], cx

; 1281 : }

  00027	c9		 leave
  00028	c2 08 00	 ret	 8
?GetCoordinate@CArea@@QAEXPAG0@Z ENDP			; CArea::GetCoordinate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?SetCoordinate@CArea@@QAEXABG0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_usCoordX$ = 8						; size = 4
_usCoordY$ = 12						; size = 4
?SetCoordinate@CArea@@QAEXABG0@Z PROC			; CArea::SetCoordinate, COMDAT
; _this$ = ecx

; 1284 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1285 : 	m_wX = usCoordX;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _usCoordX$[ebp]
  0000d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00010	66 89 88 84 00
	00 00		 mov	 WORD PTR [eax+132], cx

; 1286 : 	m_wY = usCoordY;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 0c	 mov	 ecx, DWORD PTR _usCoordY$[ebp]
  0001d	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00020	66 89 88 86 00
	00 00		 mov	 WORD PTR [eax+134], cx

; 1287 : }

  00027	c9		 leave
  00028	c2 08 00	 ret	 8
?SetCoordinate@CArea@@QAEXABG0@Z ENDP			; CArea::SetCoordinate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Refresh@CArea@@QAEXXZ
_TEXT	SEGMENT
_pfPosition$1 = -76					; size = 4
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
$T5 = -60						; size = 4
$T6 = -56						; size = 4
$T7 = -52						; size = 4
___param0$ = -48					; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
___param0$ = -36					; size = 4
tv415 = -32						; size = 4
tv429 = -28						; size = 4
__My_data$10 = -24					; size = 4
__My_data$11 = -20					; size = 4
_it$ = -16						; size = 4
_this$ = -12						; size = 4
_pObjectInstance$12 = -8				; size = 4
$T13 = -2						; size = 1
$T14 = -1						; size = 1
?Refresh@CArea@@QAEXXZ PROC				; CArea::Refresh, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 387  : 	m_TreeCloneInstaceVector.clear();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000f	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear

; 388  : 	m_ThingCloneInstaceVector.clear();

  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 28	 add	 ecx, 40			; 00000028H
  0001a	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 389  : 	m_DungeonBlockCloneInstanceVector.clear();

  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 c1 34	 add	 ecx, 52			; 00000034H
  00025	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear

; 390  : 	m_AniThingCloneInstanceVector.clear();

  0002a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 40	 add	 ecx, 64			; 00000040H
  00030	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 391  : 	m_ShadowThingCloneInstaceVector.clear();

  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0003b	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 392  : 	m_AmbienceCloneInstanceVector.clear();

  00040	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	83 c1 58	 add	 ecx, 88			; 00000058H
  00046	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  0004b	83 65 f0 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0004f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 10	 add	 eax, 16			; 00000010H
  00055	89 45 ec	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00058	8b 45 ec	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0005b	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0005e	8b 45 ec	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00066	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00069	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0006c	8d 45 d8	 lea	 eax, DWORD PTR $T9[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 396  : 	for(it = m_ObjectInstanceVector.begin();it!=m_ObjectInstanceVector.end();++it)

  00072	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp]
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	89 45 f0	 mov	 DWORD PTR _it$[ebp], eax
  0007a	eb 09		 jmp	 SHORT $LN125@Refresh
$LN2@Refresh:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0007c	8b 45 f0	 mov	 eax, DWORD PTR _it$[ebp]
  0007f	83 c0 04	 add	 eax, 4
  00082	89 45 f0	 mov	 DWORD PTR _it$[ebp], eax
$LN125@Refresh:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00085	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00088	83 c0 10	 add	 eax, 16			; 00000010H
  0008b	89 45 e8	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0008e	8b 45 e8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00091	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00094	8b 45 e8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00097	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009a	89 45 d0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0009d	8b 45 d0	 mov	 eax, DWORD PTR ___param0$[ebp]
  000a0	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000a3	8d 45 cc	 lea	 eax, DWORD PTR $T7[ebp]
  000a6	89 45 c8	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  000a9	8b 45 c8	 mov	 eax, DWORD PTR $T6[ebp]
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR _it$[ebp]
  000af	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000b1	75 09		 jne	 SHORT $LN153@Refresh
  000b3	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv429[ebp], 1
  000ba	eb 04		 jmp	 SHORT $LN154@Refresh
$LN153@Refresh:
  000bc	83 65 e4 00	 and	 DWORD PTR tv429[ebp], 0
$LN154@Refresh:
  000c0	8a 45 e4	 mov	 al, BYTE PTR tv429[ebp]
  000c3	88 45 ff	 mov	 BYTE PTR $T14[ebp], al

; 153  :         return !(*this == _Right);

  000c6	0f b6 45 ff	 movzx	 eax, BYTE PTR $T14[ebp]
  000ca	85 c0		 test	 eax, eax
  000cc	75 09		 jne	 SHORT $LN148@Refresh
  000ce	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv415[ebp], 1
  000d5	eb 04		 jmp	 SHORT $LN149@Refresh
$LN148@Refresh:
  000d7	83 65 e0 00	 and	 DWORD PTR tv415[ebp], 0
$LN149@Refresh:
  000db	8a 45 e0	 mov	 al, BYTE PTR tv415[ebp]
  000de	88 45 fe	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 396  : 	for(it = m_ObjectInstanceVector.begin();it!=m_ObjectInstanceVector.end();++it)

  000e1	0f b6 45 fe	 movzx	 eax, BYTE PTR $T13[ebp]
  000e5	85 c0		 test	 eax, eax
  000e7	0f 84 3f 02 00
	00		 je	 $LN3@Refresh
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000ed	8b 45 f0	 mov	 eax, DWORD PTR _it$[ebp]
  000f0	89 45 c4	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000f3	8b 45 c4	 mov	 eax, DWORD PTR $T5[ebp]
  000f6	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 398  : 		TObjectInstance * pObjectInstance = *it;

  000f9	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  000fc	8b 00		 mov	 eax, DWORD PTR [eax]
  000fe	89 45 f8	 mov	 DWORD PTR _pObjectInstance$12[ebp], eax

; 399  : 
; 400  : 		if (prt::PROPERTY_TYPE_TREE == pObjectInstance->dwType)

  00101	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00104	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  00108	75 46		 jne	 SHORT $LN5@Refresh

; 401  : 		{
; 402  : 			if (pObjectInstance->pTree)

  0010a	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0010d	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00111	74 38		 je	 SHORT $LN7@Refresh

; 404  : 				m_TreeCloneInstaceVector.push_back(pObjectInstance->pTree);

  00113	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00116	83 c0 0c	 add	 eax, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00119	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 404  : 				m_TreeCloneInstaceVector.push_back(pObjectInstance->pTree);

  0011a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	83 c1 1c	 add	 ecx, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00120	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 407  : 				pfPosition = pObjectInstance->pTree->GetPosition();

  00125	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00128	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0012b	e8 00 00 00 00	 call	 ?GetPosition@CSpeedTreeWrapper@@QAEPBMXZ ; CSpeedTreeWrapper::GetPosition
  00130	89 45 b4	 mov	 DWORD PTR _pfPosition$1[ebp], eax

; 408  : 				pObjectInstance->pTree->UpdateBoundingSphere();

  00133	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00136	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00139	e8 00 00 00 00	 call	 ?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::UpdateBoundingSphere

; 409  : 				pObjectInstance->pTree->UpdateCollisionData();

  0013e	6a 00		 push	 0
  00140	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00143	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00146	e8 00 00 00 00	 call	 ?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ; CGraphicObjectInstance::UpdateCollisionData
$LN7@Refresh:

; 410  : 			}
; 411  : 		}

  0014b	e9 d7 01 00 00	 jmp	 $LN18@Refresh
$LN5@Refresh:

; 412  : 		else if (prt::PROPERTY_TYPE_BUILDING == pObjectInstance->dwType)

  00150	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00153	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  00157	0f 85 0d 01 00
	00		 jne	 $LN8@Refresh

; 413  : 		{
; 414  : 			pObjectInstance->pThingInstance->Update();

  0015d	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00160	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00163	e8 00 00 00 00	 call	 ?Update@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Update

; 415  : 			pObjectInstance->pThingInstance->Transform();

  00168	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0016b	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0016e	e8 00 00 00 00	 call	 ?Transform@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Transform

; 416  : 			pObjectInstance->pThingInstance->Show();

  00173	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00176	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00179	e8 00 00 00 00	 call	 ?Show@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Show

; 417  : 			pObjectInstance->pThingInstance->DeformAll();

  0017e	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00181	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00184	e8 00 00 00 00	 call	 ?DeformAll@CGraphicThingInstance@@QAEXXZ ; CGraphicThingInstance::DeformAll

; 418  : 			m_ThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  00189	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0018c	83 c0 14	 add	 eax, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0018f	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 418  : 			m_ThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  00190	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00193	83 c1 28	 add	 ecx, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00196	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 420  : 			pObjectInstance->pThingInstance->BuildBoundingSphere();

  0019b	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0019e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001a1	e8 00 00 00 00	 call	 ?BuildBoundingSphere@CGraphicThingInstance@@QAEXXZ ; CGraphicThingInstance::BuildBoundingSphere

; 421  : 			pObjectInstance->pThingInstance->UpdateBoundingSphere();

  001a6	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  001a9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001ac	e8 00 00 00 00	 call	 ?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::UpdateBoundingSphere

; 422  : 
; 423  : 			if (pObjectInstance->pThingInstance->IsMotionThing())

  001b1	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  001b4	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001b7	e8 00 00 00 00	 call	 ?IsMotionThing@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::IsMotionThing
  001bc	0f b6 c0	 movzx	 eax, al
  001bf	85 c0		 test	 eax, eax
  001c1	74 38		 je	 SHORT $LN10@Refresh

; 425  : 				m_AniThingCloneInstanceVector.push_back(pObjectInstance->pThingInstance);

  001c3	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  001c6	83 c0 14	 add	 eax, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001c9	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 425  : 				m_AniThingCloneInstanceVector.push_back(pObjectInstance->pThingInstance);

  001ca	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	83 c1 40	 add	 ecx, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001d0	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 426  : 				pObjectInstance->pThingInstance->SetMotion(0);

  001d5	51		 push	 ecx
  001d6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001de	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e3	6a 00		 push	 0
  001e5	51		 push	 ecx
  001e6	0f 57 c0	 xorps	 xmm0, xmm0
  001e9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ee	6a 00		 push	 0
  001f0	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  001f3	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  001f6	e8 00 00 00 00	 call	 ?SetMotion@CGraphicThingInstance@@QAE_NKMHM@Z ; CGraphicThingInstance::SetMotion
$LN10@Refresh:

; 427  : 			}
; 428  : 
; 429  : 			if (pObjectInstance->isShadowFlag)

  001fb	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  001fe	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00202	74 12		 je	 SHORT $LN198@Refresh

; 431  : 				m_ShadowThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  00204	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00207	83 c0 14	 add	 eax, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0020a	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 431  : 				m_ShadowThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  0020b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00211	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
$LN198@Refresh:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 434  : 			if (pObjectInstance->pAttributeInstance)

  00216	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00219	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0021d	74 46		 je	 SHORT $LN12@Refresh

; 435  : 			{
; 436  : 				pObjectInstance->pThingInstance->UpdateCollisionData(&pObjectInstance->pAttributeInstance->GetObjectPointer()->GetCollisionDataVector());

  0021f	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00222	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00225	e8 00 00 00 00	 call	 ?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ; CAttributeInstance::GetObjectPointer
  0022a	8b c8		 mov	 ecx, eax
  0022c	e8 00 00 00 00	 call	 ?GetCollisionDataVector@CAttributeData@@QBEABV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@XZ ; CAttributeData::GetCollisionDataVector
  00231	50		 push	 eax
  00232	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00235	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00238	e8 00 00 00 00	 call	 ?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ; CGraphicObjectInstance::UpdateCollisionData

; 437  :   				pObjectInstance->pAttributeInstance->RefreshObject(pObjectInstance->pThingInstance->GetTransform());

  0023d	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00240	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00243	e8 00 00 00 00	 call	 ?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ ; CGraphicObjectInstance::GetTransform
  00248	50		 push	 eax
  00249	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0024c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0024f	e8 00 00 00 00	 call	 ?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ; CAttributeInstance::RefreshObject

; 438  : 				pObjectInstance->pThingInstance->UpdateHeightInstance(pObjectInstance->pAttributeInstance);

  00254	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00257	ff 70 08	 push	 DWORD PTR [eax+8]
  0025a	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0025d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00260	e8 00 00 00 00	 call	 ?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ; CGraphicObjectInstance::UpdateHeightInstance
$LN12@Refresh:

; 439  : 			}
; 440  : 		}

  00265	e9 bd 00 00 00	 jmp	 $LN18@Refresh
$LN8@Refresh:

; 441  : 		else if (prt::PROPERTY_TYPE_EFFECT == pObjectInstance->dwType)

  0026a	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0026d	83 78 04 03	 cmp	 DWORD PTR [eax+4], 3
  00271	75 05		 jne	 SHORT $LN13@Refresh

; 442  : 		{
; 443  : 		}

  00273	e9 af 00 00 00	 jmp	 $LN18@Refresh
$LN13@Refresh:

; 444  : 		else if (prt::PROPERTY_TYPE_AMBIENCE == pObjectInstance->dwType)

  00278	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0027b	83 78 04 04	 cmp	 DWORD PTR [eax+4], 4
  0027f	75 17		 jne	 SHORT $LN15@Refresh

; 446  : 			m_AmbienceCloneInstanceVector.push_back(pObjectInstance->pAmbienceInstance);

  00281	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00284	83 c0 20	 add	 eax, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00287	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 446  : 			m_AmbienceCloneInstanceVector.push_back(pObjectInstance->pAmbienceInstance);

  00288	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0028b	83 c1 58	 add	 ecx, 88			; 00000058H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0028e	e8 00 00 00 00	 call	 ??$emplace_back@ABQAUSAmbienceInstance@CArea@@@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXABQAUSAmbienceInstance@CArea@@@Z ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::emplace_back<CArea::SAmbienceInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 447  : 		}

  00293	e9 8f 00 00 00	 jmp	 $LN18@Refresh
$LN15@Refresh:

; 448  : 		else if (prt::PROPERTY_TYPE_DUNGEON_BLOCK == pObjectInstance->dwType)

  00298	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0029b	83 78 04 05	 cmp	 DWORD PTR [eax+4], 5
  0029f	0f 85 82 00 00
	00		 jne	 $LN18@Refresh

; 449  : 		{
; 450  : 			pObjectInstance->pDungeonBlock->Update();

  002a5	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002a8	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002ab	e8 00 00 00 00	 call	 ?Update@CDungeonBlock@@QAEXXZ ; CDungeonBlock::Update

; 451  : 			pObjectInstance->pDungeonBlock->Deform();

  002b0	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002b3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002b6	e8 00 00 00 00	 call	 ?Deform@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Deform

; 452  : 			pObjectInstance->pDungeonBlock->UpdateBoundingSphere();

  002bb	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002be	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002c1	e8 00 00 00 00	 call	 ?UpdateBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::UpdateBoundingSphere

; 453  : 			m_DungeonBlockCloneInstanceVector.push_back(pObjectInstance->pDungeonBlock);

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002c9	83 c0 24	 add	 eax, 36			; 00000024H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002cc	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 453  : 			m_DungeonBlockCloneInstanceVector.push_back(pObjectInstance->pDungeonBlock);

  002cd	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  002d0	83 c1 34	 add	 ecx, 52			; 00000034H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002d3	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 455  : 			if (pObjectInstance->pAttributeInstance)

  002d8	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002db	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  002df	74 46		 je	 SHORT $LN18@Refresh

; 456  : 			{
; 457  : 				pObjectInstance->pDungeonBlock->UpdateCollisionData(&pObjectInstance->pAttributeInstance->GetObjectPointer()->GetCollisionDataVector());

  002e1	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002e4	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  002e7	e8 00 00 00 00	 call	 ?GetObjectPointer@CAttributeInstance@@QBEPAVCAttributeData@@XZ ; CAttributeInstance::GetObjectPointer
  002ec	8b c8		 mov	 ecx, eax
  002ee	e8 00 00 00 00	 call	 ?GetCollisionDataVector@CAttributeData@@QBEABV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@XZ ; CAttributeData::GetCollisionDataVector
  002f3	50		 push	 eax
  002f4	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  002f7	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  002fa	e8 00 00 00 00	 call	 ?UpdateCollisionData@CGraphicObjectInstance@@QAEXPBV?$vector@VCStaticCollisionData@@V?$allocator@VCStaticCollisionData@@@std@@@std@@@Z ; CGraphicObjectInstance::UpdateCollisionData

; 458  :   				pObjectInstance->pAttributeInstance->RefreshObject(pObjectInstance->pDungeonBlock->GetTransform());

  002ff	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00302	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00305	e8 00 00 00 00	 call	 ?GetTransform@CGraphicObjectInstance@@QAEAAUD3DXMATRIX@@XZ ; CGraphicObjectInstance::GetTransform
  0030a	50		 push	 eax
  0030b	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0030e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00311	e8 00 00 00 00	 call	 ?RefreshObject@CAttributeInstance@@QAEXABUD3DXMATRIX@@@Z ; CAttributeInstance::RefreshObject

; 459  : 				pObjectInstance->pDungeonBlock->UpdateHeightInstance(pObjectInstance->pAttributeInstance);

  00316	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  00319	ff 70 08	 push	 DWORD PTR [eax+8]
  0031c	8b 45 f8	 mov	 eax, DWORD PTR _pObjectInstance$12[ebp]
  0031f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00322	e8 00 00 00 00	 call	 ?UpdateHeightInstance@CGraphicObjectInstance@@QAEXPAVCAttributeInstance@@@Z ; CGraphicObjectInstance::UpdateHeightInstance
$LN18@Refresh:

; 460  : 			}
; 461  : 		}
; 462  : 	}

  00327	e9 50 fd ff ff	 jmp	 $LN2@Refresh
$LN3@Refresh:

; 463  : }

  0032c	c9		 leave
  0032d	c3		 ret	 0
?Refresh@CArea@@QAEXXZ ENDP				; CArea::Refresh
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?RenderDungeon@CArea@@QAEXXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
___param0$ = -36					; size = 4
___param0$ = -32					; size = 4
tv222 = -28						; size = 4
tv236 = -24						; size = 4
__My_data$7 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$8 = -12					; size = 4
_itor$ = -8						; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
?RenderDungeon@CArea@@QAEXXZ PROC			; CArea::RenderDungeon, COMDAT
; _this$ = ecx

; 328  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 329  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  00009	6a 02		 push	 2
  0000b	6a 02		 push	 2
  0000d	6a 00		 push	 0
  0000f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00015	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 330  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  0001a	6a 02		 push	 2
  0001c	6a 01		 push	 1
  0001e	6a 00		 push	 0
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00026	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 331  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  0002b	6a 02		 push	 2
  0002d	6a 05		 push	 5
  0002f	6a 00		 push	 0
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00037	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 332  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  0003c	6a 02		 push	 2
  0003e	6a 01		 push	 1
  00040	6a 00		 push	 0
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00048	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 333  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  0004d	6a 02		 push	 2
  0004f	6a 02		 push	 2
  00051	6a 01		 push	 1
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00059	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 334  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2,	D3DTA_CURRENT);

  0005e	6a 01		 push	 1
  00060	6a 03		 push	 3
  00062	6a 01		 push	 1
  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 335  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,	D3DTOP_MODULATE);

  0006f	6a 04		 push	 4
  00071	6a 01		 push	 1
  00073	6a 01		 push	 1
  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 336  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1,	D3DTA_TEXTURE);

  00080	6a 02		 push	 2
  00082	6a 05		 push	 5
  00084	6a 01		 push	 1
  00086	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 337  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2,	D3DTA_CURRENT);

  00091	6a 01		 push	 1
  00093	6a 06		 push	 6
  00095	6a 01		 push	 1
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 338  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  000a2	6a 04		 push	 4
  000a4	6a 04		 push	 4
  000a6	6a 01		 push	 1
  000a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ae	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 34	 add	 eax, 52			; 00000034H
  000b9	89 45 f4	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000bc	8b 45 f4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000bf	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  000c2	8b 45 f4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000ca	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  000cd	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 368  : 	for (; itor != m_DungeonBlockCloneInstanceVector.end(); ++itor)

  000d0	eb 09		 jmp	 SHORT $LN4@RenderDung
$LN2@RenderDung:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000d2	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000d5	83 c0 04	 add	 eax, 4
  000d8	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@RenderDung:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	83 c0 34	 add	 eax, 52			; 00000034H
  000e1	89 45 ec	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000e4	8b 45 ec	 mov	 eax, DWORD PTR __My_data$7[ebp]
  000e7	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000ea	8b 45 ec	 mov	 eax, DWORD PTR __My_data$7[ebp]
  000ed	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f0	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000f3	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  000f6	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000f9	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  000fc	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  000ff	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00102	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  00105	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00107	75 09		 jne	 SHORT $LN69@RenderDung
  00109	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv236[ebp], 1
  00110	eb 04		 jmp	 SHORT $LN70@RenderDung
$LN69@RenderDung:
  00112	83 65 e8 00	 and	 DWORD PTR tv236[ebp], 0
$LN70@RenderDung:
  00116	8a 45 e8	 mov	 al, BYTE PTR tv236[ebp]
  00119	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 153  :         return !(*this == _Right);

  0011c	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00120	85 c0		 test	 eax, eax
  00122	75 09		 jne	 SHORT $LN64@RenderDung
  00124	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv222[ebp], 1
  0012b	eb 04		 jmp	 SHORT $LN65@RenderDung
$LN64@RenderDung:
  0012d	83 65 e4 00	 and	 DWORD PTR tv222[ebp], 0
$LN65@RenderDung:
  00131	8a 45 e4	 mov	 al, BYTE PTR tv222[ebp]
  00134	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 368  : 	for (; itor != m_DungeonBlockCloneInstanceVector.end(); ++itor)

  00137	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  0013b	85 c0		 test	 eax, eax
  0013d	74 1b		 je	 SHORT $LN81@RenderDung
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0013f	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00142	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00145	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  00148	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 370  : 		(*itor)->Render();

  0014b	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0014e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00150	e8 00 00 00 00	 call	 ?Render@CDungeonBlock@@QAEXXZ ; CDungeonBlock::Render

; 371  : 	}

  00155	e9 78 ff ff ff	 jmp	 $LN2@RenderDung
$LN81@RenderDung:

; 372  : 
; 373  : #ifdef WORLD_EDITOR
; 374  : 	if (bRenderTransparent)
; 375  : 	{
; 376  : 		STATEMANAGER.SetRenderState(D3DRS_ZWRITEENABLE, oldZWriteenableState);
; 377  : 		STATEMANAGER.SetRenderState(D3DRS_ALPHABLENDENABLE, oldAlphaBlendState);
; 378  : 	}
; 379  : #endif
; 380  : 
; 381  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,	D3DTOP_DISABLE);

  0015a	6a 01		 push	 1
  0015c	6a 01		 push	 1
  0015e	6a 01		 push	 1
  00160	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00166	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 382  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,	D3DTOP_DISABLE);

  0016b	6a 01		 push	 1
  0016d	6a 04		 push	 4
  0016f	6a 01		 push	 1
  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00177	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 383  : }

  0017c	c9		 leave
  0017d	c3		 ret	 0
?RenderDungeon@CArea@@QAEXXZ ENDP			; CArea::RenderDungeon
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?RenderAmbience@CArea@@QAEXXZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_dwColorOp$ = -64					; size = 4
_dwColorArg1$ = -60					; size = 4
_pInstance$3 = -56					; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
___param0$ = -36					; size = 4
___param0$ = -32					; size = 4
tv192 = -28						; size = 4
tv206 = -24						; size = 4
__My_data$8 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$9 = -12					; size = 4
_itor$ = -8						; size = 4
$T10 = -2						; size = 1
$T11 = -1						; size = 1
?RenderAmbience@CArea@@QAEXXZ PROC			; CArea::RenderAmbience, COMDAT
; _this$ = ecx

; 311  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 312  : 	DWORD dwColorArg1, dwColorOp;
; 313  : 	STATEMANAGER.GetTextureStageState(0, D3DTSS_COLORARG1, &dwColorArg1);

  00009	8d 45 c4	 lea	 eax, DWORD PTR _dwColorArg1$[ebp]
  0000c	50		 push	 eax
  0000d	6a 02		 push	 2
  0000f	6a 00		 push	 0
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00017	e8 00 00 00 00	 call	 ?GetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@PAK@Z ; CStateManager::GetTextureStageState

; 314  : 	STATEMANAGER.GetTextureStageState(0, D3DTSS_COLOROP, &dwColorOp);

  0001c	8d 45 c0	 lea	 eax, DWORD PTR _dwColorOp$[ebp]
  0001f	50		 push	 eax
  00020	6a 01		 push	 1
  00022	6a 00		 push	 0
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002a	e8 00 00 00 00	 call	 ?GetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@PAK@Z ; CStateManager::GetTextureStageState

; 315  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  0002f	6a 03		 push	 3
  00031	6a 02		 push	 2
  00033	6a 00		 push	 0
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 316  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);

  00040	6a 02		 push	 2
  00042	6a 01		 push	 1
  00044	6a 00		 push	 0
  00046	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00051	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00054	83 c0 58	 add	 eax, 88			; 00000058H
  00057	89 45 f4	 mov	 DWORD PTR __My_data$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0005a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  0005d	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00060	8b 45 f4	 mov	 eax, DWORD PTR __My_data$9[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00068	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 318  : 	for (; itor != m_AmbienceCloneInstanceVector.end(); ++itor)

  0006e	eb 09		 jmp	 SHORT $LN4@RenderAmbi
$LN2@RenderAmbi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00073	83 c0 04	 add	 eax, 4
  00076	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@RenderAmbi:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 c0 58	 add	 eax, 88			; 00000058H
  0007f	89 45 ec	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00082	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00085	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00088	8b 45 ec	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0008b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008e	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00091	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00094	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00097	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0009a	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0009d	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  000a3	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a5	75 09		 jne	 SHORT $LN57@RenderAmbi
  000a7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv206[ebp], 1
  000ae	eb 04		 jmp	 SHORT $LN58@RenderAmbi
$LN57@RenderAmbi:
  000b0	83 65 e8 00	 and	 DWORD PTR tv206[ebp], 0
$LN58@RenderAmbi:
  000b4	8a 45 e8	 mov	 al, BYTE PTR tv206[ebp]
  000b7	88 45 ff	 mov	 BYTE PTR $T11[ebp], al

; 153  :         return !(*this == _Right);

  000ba	0f b6 45 ff	 movzx	 eax, BYTE PTR $T11[ebp]
  000be	85 c0		 test	 eax, eax
  000c0	75 09		 jne	 SHORT $LN52@RenderAmbi
  000c2	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  000c9	eb 04		 jmp	 SHORT $LN53@RenderAmbi
$LN52@RenderAmbi:
  000cb	83 65 e4 00	 and	 DWORD PTR tv192[ebp], 0
$LN53@RenderAmbi:
  000cf	8a 45 e4	 mov	 al, BYTE PTR tv192[ebp]
  000d2	88 45 fe	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 318  : 	for (; itor != m_AmbienceCloneInstanceVector.end(); ++itor)

  000d5	0f b6 45 fe	 movzx	 eax, BYTE PTR $T10[ebp]
  000d9	85 c0		 test	 eax, eax
  000db	74 21		 je	 SHORT $LN69@RenderAmbi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000e0	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000e3	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000e6	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 320  : 		TAmbienceInstance * pInstance = *itor;

  000e9	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000ec	8b 00		 mov	 eax, DWORD PTR [eax]
  000ee	89 45 c8	 mov	 DWORD PTR _pInstance$3[ebp], eax

; 321  : 		pInstance->Render();

  000f1	8b 4d c8	 mov	 ecx, DWORD PTR _pInstance$3[ebp]
  000f4	e8 00 00 00 00	 call	 ?Render@SAmbienceInstance@CArea@@QAEXXZ ; CArea::SAmbienceInstance::Render

; 322  : 	}

  000f9	e9 72 ff ff ff	 jmp	 $LN2@RenderAmbi
$LN69@RenderAmbi:

; 323  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, dwColorArg1);

  000fe	ff 75 c4	 push	 DWORD PTR _dwColorArg1$[ebp]
  00101	6a 02		 push	 2
  00103	6a 00		 push	 0
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0010b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 324  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP, dwColorOp);

  00110	ff 75 c0	 push	 DWORD PTR _dwColorOp$[ebp]
  00113	6a 01		 push	 1
  00115	6a 00		 push	 0
  00117	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0011d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 325  : }

  00122	c9		 leave
  00123	c3		 ret	 0
?RenderAmbience@CArea@@QAEXXZ ENDP			; CArea::RenderAmbience
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?RenderCollision@CArea@@QAEXXZ
_TEXT	SEGMENT
tv250 = -36						; size = 4
tv217 = -32						; size = 4
tv184 = -28						; size = 4
_this$ = -24						; size = 4
_j$1 = -20						; size = 4
_j$2 = -16						; size = 4
_j$3 = -12						; size = 4
_i$ = -8						; size = 4
_po$4 = -4						; size = 4
?RenderCollision@CArea@@QAEXXZ PROC			; CArea::RenderCollision, COMDAT
; _this$ = ecx

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 258  : 	DWORD i;
; 259  : 
; 260  : 	STATEMANAGER.SetTexture(0, NULL);

  00009	6a 00		 push	 0
  0000b	6a 00		 push	 0
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00013	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 261  : 	STATEMANAGER.SetTexture(1, NULL);

  00018	6a 00		 push	 0
  0001a	6a 01		 push	 1
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00022	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 262  : 
; 263  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

  00027	6a 00		 push	 0
  00029	6a 1b		 push	 27			; 0000001bH
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00031	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 264  : 	STATEMANAGER.SaveRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

  00036	6a 01		 push	 1
  00038	6a 16		 push	 22			; 00000016H
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00040	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 265  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00045	6a 00		 push	 0
  00047	68 89 00 00 00	 push	 137			; 00000089H
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00052	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 266  : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xff000000);

  00057	68 00 00 00 ff	 push	 -16777216		; ff000000H
  0005c	6a 3c		 push	 60			; 0000003cH
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00064	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 267  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_TEXTURE);

  00069	6a 02		 push	 2
  0006b	6a 02		 push	 2
  0006d	6a 00		 push	 0
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 268  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  0007a	6a 02		 push	 2
  0007c	6a 01		 push	 1
  0007e	6a 00		 push	 0
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00086	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 269  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  0008b	6a 01		 push	 1
  0008d	6a 04		 push	 4
  0008f	6a 00		 push	 0
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00097	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 270  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

  0009c	6a 01		 push	 1
  0009e	6a 01		 push	 1
  000a0	6a 01		 push	 1
  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000a8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 271  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP, D3DTOP_DISABLE);

  000ad	6a 01		 push	 1
  000af	6a 04		 push	 4
  000b1	6a 01		 push	 1
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000b9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 272  : 
; 273  : 	for(i=0;i<GetObjectInstanceCount();i++)

  000be	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0
  000c2	eb 07		 jmp	 SHORT $LN4@RenderColl
$LN2@RenderColl:
  000c4	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000c7	40		 inc	 eax
  000c8	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@RenderColl:
  000cb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?GetObjectInstanceCount@CArea@@QBE?BKXZ ; CArea::GetObjectInstanceCount
  000d3	39 45 f8	 cmp	 DWORD PTR _i$[ebp], eax
  000d6	0f 83 25 01 00
	00		 jae	 $LN41@RenderColl

; 274  : 	{
; 275  : 		const TObjectInstance * po;
; 276  : 		if (GetObjectInstancePointer(i,&po))

  000dc	8d 45 fc	 lea	 eax, DWORD PTR _po$4[ebp]
  000df	50		 push	 eax
  000e0	8d 45 f8	 lea	 eax, DWORD PTR _i$[ebp]
  000e3	50		 push	 eax
  000e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	e8 00 00 00 00	 call	 ?GetObjectInstancePointer@CArea@@QBE?B_NABKPAPBUSObjectInstance@1@@Z ; CArea::GetObjectInstancePointer
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	0f 84 05 01 00
	00		 je	 $LN14@RenderColl

; 277  : 		{
; 278  : 			if (po->pTree && po->pTree->isShow())

  000f7	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  000fa	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000fe	74 4e		 je	 SHORT $LN15@RenderColl
  00100	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  00103	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00106	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  0010b	0f b6 c0	 movzx	 eax, al
  0010e	85 c0		 test	 eax, eax
  00110	74 3c		 je	 SHORT $LN15@RenderColl

; 279  : 			{
; 280  : 				DWORD j;
; 281  : 				for(j=0;j<po->pTree->GetCollisionInstanceCount();j++)

  00112	83 65 f4 00	 and	 DWORD PTR _j$3[ebp], 0
  00116	eb 07		 jmp	 SHORT $LN7@RenderColl
$LN5@RenderColl:
  00118	8b 45 f4	 mov	 eax, DWORD PTR _j$3[ebp]
  0011b	40		 inc	 eax
  0011c	89 45 f4	 mov	 DWORD PTR _j$3[ebp], eax
$LN7@RenderColl:
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  00122	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00125	e8 00 00 00 00	 call	 ?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ ; CGraphicObjectInstance::GetCollisionInstanceCount
  0012a	39 45 f4	 cmp	 DWORD PTR _j$3[ebp], eax
  0012d	73 1f		 jae	 SHORT $LN15@RenderColl

; 282  : 				{
; 283  : 					po->pTree->GetCollisionInstanceData(j)->Render();

  0012f	ff 75 f4	 push	 DWORD PTR _j$3[ebp]
  00132	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  00135	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00138	e8 00 00 00 00	 call	 ?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z ; CGraphicObjectInstance::GetCollisionInstanceData
  0013d	89 45 e4	 mov	 DWORD PTR tv184[ebp], eax
  00140	6a 03		 push	 3
  00142	8b 45 e4	 mov	 eax, DWORD PTR tv184[ebp]
  00145	8b 00		 mov	 eax, DWORD PTR [eax]
  00147	8b 4d e4	 mov	 ecx, DWORD PTR tv184[ebp]
  0014a	ff 10		 call	 DWORD PTR [eax]

; 284  : 				}

  0014c	eb ca		 jmp	 SHORT $LN5@RenderColl
$LN15@RenderColl:

; 285  : 			}
; 286  : 			if (po->pThingInstance && po->pThingInstance->isShow())

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  00151	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00155	74 4e		 je	 SHORT $LN16@RenderColl
  00157	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  0015a	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0015d	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  00162	0f b6 c0	 movzx	 eax, al
  00165	85 c0		 test	 eax, eax
  00167	74 3c		 je	 SHORT $LN16@RenderColl

; 287  : 			{
; 288  : 				DWORD j;
; 289  : 				for(j=0;j<po->pThingInstance->GetCollisionInstanceCount();j++)

  00169	83 65 f0 00	 and	 DWORD PTR _j$2[ebp], 0
  0016d	eb 07		 jmp	 SHORT $LN10@RenderColl
$LN8@RenderColl:
  0016f	8b 45 f0	 mov	 eax, DWORD PTR _j$2[ebp]
  00172	40		 inc	 eax
  00173	89 45 f0	 mov	 DWORD PTR _j$2[ebp], eax
$LN10@RenderColl:
  00176	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  00179	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0017c	e8 00 00 00 00	 call	 ?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ ; CGraphicObjectInstance::GetCollisionInstanceCount
  00181	39 45 f0	 cmp	 DWORD PTR _j$2[ebp], eax
  00184	73 1f		 jae	 SHORT $LN16@RenderColl

; 290  : 				{
; 291  : 					po->pThingInstance->GetCollisionInstanceData(j)->Render();

  00186	ff 75 f0	 push	 DWORD PTR _j$2[ebp]
  00189	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  0018c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0018f	e8 00 00 00 00	 call	 ?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z ; CGraphicObjectInstance::GetCollisionInstanceData
  00194	89 45 e0	 mov	 DWORD PTR tv217[ebp], eax
  00197	6a 03		 push	 3
  00199	8b 45 e0	 mov	 eax, DWORD PTR tv217[ebp]
  0019c	8b 00		 mov	 eax, DWORD PTR [eax]
  0019e	8b 4d e0	 mov	 ecx, DWORD PTR tv217[ebp]
  001a1	ff 10		 call	 DWORD PTR [eax]

; 292  : 				}

  001a3	eb ca		 jmp	 SHORT $LN8@RenderColl
$LN16@RenderColl:

; 293  : 			}
; 294  : 			if (po->pDungeonBlock && po->pDungeonBlock->isShow())

  001a5	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  001a8	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  001ac	74 4e		 je	 SHORT $LN14@RenderColl
  001ae	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  001b1	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001b4	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  001b9	0f b6 c0	 movzx	 eax, al
  001bc	85 c0		 test	 eax, eax
  001be	74 3c		 je	 SHORT $LN14@RenderColl

; 295  : 			{
; 296  : 				DWORD j;
; 297  : 				for(j=0;j<po->pDungeonBlock->GetCollisionInstanceCount();j++)

  001c0	83 65 ec 00	 and	 DWORD PTR _j$1[ebp], 0
  001c4	eb 07		 jmp	 SHORT $LN13@RenderColl
$LN11@RenderColl:
  001c6	8b 45 ec	 mov	 eax, DWORD PTR _j$1[ebp]
  001c9	40		 inc	 eax
  001ca	89 45 ec	 mov	 DWORD PTR _j$1[ebp], eax
$LN13@RenderColl:
  001cd	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  001d0	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001d3	e8 00 00 00 00	 call	 ?GetCollisionInstanceCount@CGraphicObjectInstance@@QAEKXZ ; CGraphicObjectInstance::GetCollisionInstanceCount
  001d8	39 45 ec	 cmp	 DWORD PTR _j$1[ebp], eax
  001db	73 1f		 jae	 SHORT $LN14@RenderColl

; 298  : 				{
; 299  : 					po->pDungeonBlock->GetCollisionInstanceData(j)->Render();

  001dd	ff 75 ec	 push	 DWORD PTR _j$1[ebp]
  001e0	8b 45 fc	 mov	 eax, DWORD PTR _po$4[ebp]
  001e3	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001e6	e8 00 00 00 00	 call	 ?GetCollisionInstanceData@CGraphicObjectInstance@@QAEPAVCBaseCollisionInstance@@K@Z ; CGraphicObjectInstance::GetCollisionInstanceData
  001eb	89 45 dc	 mov	 DWORD PTR tv250[ebp], eax
  001ee	6a 03		 push	 3
  001f0	8b 45 dc	 mov	 eax, DWORD PTR tv250[ebp]
  001f3	8b 00		 mov	 eax, DWORD PTR [eax]
  001f5	8b 4d dc	 mov	 ecx, DWORD PTR tv250[ebp]
  001f8	ff 10		 call	 DWORD PTR [eax]

; 300  : 				}

  001fa	eb ca		 jmp	 SHORT $LN11@RenderColl
$LN14@RenderColl:

; 301  : 			}
; 302  : 		}
; 303  : 	}

  001fc	e9 c3 fe ff ff	 jmp	 $LN2@RenderColl
$LN41@RenderColl:

; 304  : 
; 305  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00201	6a 1b		 push	 27			; 0000001bH
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00209	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 306  : 	STATEMANAGER.RestoreRenderState(D3DRS_CULLMODE);

  0020e	6a 16		 push	 22			; 00000016H
  00210	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00216	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 307  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  0021b	6a 01		 push	 1
  0021d	68 89 00 00 00	 push	 137			; 00000089H
  00222	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00228	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 308  : }

  0022d	c9		 leave
  0022e	c3		 ret	 0
?RenderCollision@CArea@@QAEXXZ ENDP			; CArea::RenderCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?RenderEffect@CArea@@QAEXXZ
_TEXT	SEGMENT
$T1 = -164						; size = 1
$T2 = -160						; size = 4
$T3 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
$T6 = -144						; size = 4
$T7 = -140						; size = 4
$T8 = -136						; size = 4
$T9 = -132						; size = 4
___param0$ = -128					; size = 4
$T10 = -124						; size = 4
___param0$ = -120					; size = 4
$T11 = -116						; size = 1
$T12 = -112						; size = 4
$T13 = -108						; size = 4
__Ptr$14 = -104						; size = 4
__Last$ = -100						; size = 4
$T15 = -96						; size = 4
$T16 = -92						; size = 4
__Ptr$17 = -88						; size = 4
__First$ = -84						; size = 4
$T18 = -80						; size = 4
$T19 = -76						; size = 4
$T20 = -72						; size = 4
___param0$ = -68					; size = 4
$T21 = -64						; size = 4
___param0$ = -60					; size = 4
$T22 = -56						; size = 4
$T23 = -52						; size = 4
$T24 = -48						; size = 4
$T25 = -44						; size = 4
$T26 = -40						; size = 4
$T27 = -36						; size = 4
$T28 = -32						; size = 4
___param0$ = -28					; size = 4
__Scary$29 = -24					; size = 4
$T30 = -20						; size = 4
$T31 = -16						; size = 4
$T32 = -12						; size = 4
___param0$ = -8						; size = 4
__Scary$33 = -4						; size = 4
$T34 = 0						; size = 4
_this$ = 4						; size = 4
_pEffectInstance$35 = 8					; size = 4
$T36 = 12						; size = 4
$T37 = 16						; size = 4
$T38 = 20						; size = 4
$T39 = 24						; size = 4
$T40 = 28						; size = 4
$T41 = 32						; size = 4
$T42 = 36						; size = 4
___param0$ = 40						; size = 4
__Scary$43 = 44						; size = 4
$T44 = 48						; size = 4
__My_data$45 = 52					; size = 4
__My_data$46 = 56					; size = 4
__UFirst$47 = 60					; size = 4
__ULast$48 = 64						; size = 4
__My_data$49 = 68					; size = 4
__My_data$50 = 72					; size = 4
tv397 = 76						; size = 4
tv421 = 80						; size = 4
_rkMap_pkEftInstSrc$51 = 84				; size = 4
tv245 = 88						; size = 4
tv271 = 92						; size = 4
$T52 = 98						; size = 1
$T53 = 99						; size = 1
_i$54 = 100						; size = 4
_this$ = 104						; size = 4
_i$55 = 108						; size = 4
$T56 = 115						; size = 1
$T57 = 116						; size = 1
$T58 = 117						; size = 1
$T59 = 118						; size = 1
_m_isDisableSortRendering$ = 119			; size = 1
?RenderEffect@CArea@@QAEXXZ PROC			; CArea::RenderEffect, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  0000b	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 	__UpdateEffectList();

  0000e	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?__UpdateEffectList@CArea@@IAEXXZ ; CArea::__UpdateEffectList

; 135  : 
; 136  : 	// Effect
; 137  : 	STATEMANAGER.SetTexture(0, NULL);

  00016	6a 00		 push	 0
  00018	6a 00		 push	 0
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00020	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 138  : 	STATEMANAGER.SetTexture(1, NULL);

  00025	6a 00		 push	 0
  00027	6a 01		 push	 1
  00029	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0002f	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 139  : 
; 140  : 	bool m_isDisableSortRendering=false;

  00034	c6 45 77 00	 mov	 BYTE PTR _m_isDisableSortRendering$[ebp], 0

; 141  : 
; 142  : 	if (m_isDisableSortRendering)

  00038	0f b6 45 77	 movzx	 eax, BYTE PTR _m_isDisableSortRendering$[ebp]
  0003c	85 c0		 test	 eax, eax
  0003e	0f 84 c7 00 00
	00		 je	 $LN9@RenderEffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  00044	83 65 6c 00	 and	 DWORD PTR _i$55[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 145  : 		for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end();)

  00048	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00058	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::begin
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	89 45 6c	 mov	 DWORD PTR _i$55[ebp], eax
$LN4@RenderEffe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00062	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00065	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006a	89 45 30	 mov	 DWORD PTR $T44[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0006d	8b 45 30	 mov	 eax, DWORD PTR $T44[ebp]
  00070	89 45 2c	 mov	 DWORD PTR __Scary$43[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00073	8b 45 2c	 mov	 eax, DWORD PTR __Scary$43[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	89 45 28	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0007b	8b 45 28	 mov	 eax, DWORD PTR ___param0$[ebp]
  0007e	89 45 24	 mov	 DWORD PTR $T42[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00081	8d 45 24	 lea	 eax, DWORD PTR $T42[ebp]
  00084	89 45 20	 mov	 DWORD PTR $T41[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00087	8b 45 20	 mov	 eax, DWORD PTR $T41[ebp]
  0008a	8b 4d 6c	 mov	 ecx, DWORD PTR _i$55[ebp]
  0008d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008f	75 09		 jne	 SHORT $LN68@RenderEffe
  00091	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR tv271[ebp], 1
  00098	eb 04		 jmp	 SHORT $LN69@RenderEffe
$LN68@RenderEffe:
  0009a	83 65 5c 00	 and	 DWORD PTR tv271[ebp], 0
$LN69@RenderEffe:
  0009e	8a 45 5c	 mov	 al, BYTE PTR tv271[ebp]
  000a1	88 45 76	 mov	 BYTE PTR $T59[ebp], al

; 236  :         return !(*this == _Right);

  000a4	0f b6 45 76	 movzx	 eax, BYTE PTR $T59[ebp]
  000a8	85 c0		 test	 eax, eax
  000aa	75 09		 jne	 SHORT $LN63@RenderEffe
  000ac	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv245[ebp], 1
  000b3	eb 04		 jmp	 SHORT $LN64@RenderEffe
$LN63@RenderEffe:
  000b5	83 65 58 00	 and	 DWORD PTR tv245[ebp], 0
$LN64@RenderEffe:
  000b9	8a 45 58	 mov	 al, BYTE PTR tv245[ebp]
  000bc	88 45 75	 mov	 BYTE PTR $T58[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 145  : 		for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end();)

  000bf	0f b6 45 75	 movzx	 eax, BYTE PTR $T58[ebp]
  000c3	85 c0		 test	 eax, eax
  000c5	74 3f		 je	 SHORT $LN3@RenderEffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  000c7	8b 45 6c	 mov	 eax, DWORD PTR _i$55[ebp]
  000ca	83 c0 10	 add	 eax, 16			; 00000010H
  000cd	89 45 1c	 mov	 DWORD PTR $T40[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  000d0	8b 45 1c	 mov	 eax, DWORD PTR $T40[ebp]
  000d3	89 45 18	 mov	 DWORD PTR $T39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000d6	8b 45 18	 mov	 eax, DWORD PTR $T39[ebp]
  000d9	89 45 14	 mov	 DWORD PTR $T38[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000dc	8b 45 14	 mov	 eax, DWORD PTR $T38[ebp]
  000df	89 45 10	 mov	 DWORD PTR $T37[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  000e2	8b 45 10	 mov	 eax, DWORD PTR $T37[ebp]
  000e5	89 45 0c	 mov	 DWORD PTR $T36[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 147  : 			CEffectInstance * pEffectInstance = i->second;

  000e8	8b 45 0c	 mov	 eax, DWORD PTR $T36[ebp]
  000eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ee	89 45 08	 mov	 DWORD PTR _pEffectInstance$35[ebp], eax

; 148  : 			pEffectInstance->Render();

  000f1	8b 4d 08	 mov	 ecx, DWORD PTR _pEffectInstance$35[ebp]
  000f4	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  000f9	8d 4d 6c	 lea	 ecx, DWORD PTR _i$55[ebp]
  000fc	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 150  : 		}

  00101	e9 5c ff ff ff	 jmp	 $LN4@RenderEffe
$LN3@RenderEffe:

; 151  : 	}

  00106	e9 5a 02 00 00	 jmp	 $LN1@RenderEffe
$LN9@RenderEffe:

; 154  : 		static std::vector<CEffectInstance*> s_kVct_pkEftInstSort;

  0010b	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00110	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00117	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0011a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA
  00120	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00126	7e 39		 jle	 SHORT $LN5@RenderEffe
  00128	68 00 00 00 00	 push	 OFFSET ?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA
  0012d	e8 00 00 00 00	 call	 __Init_thread_header
  00132	59		 pop	 ecx
  00133	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA, -1
  0013a	75 25		 jne	 SHORT $LN5@RenderEffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0013c	c7 45 04 00 00
	00 00		 mov	 DWORD PTR _this$[ebp], OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00143	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CEffectInstance *> >::_Vector_val<std::_Simple_types<CEffectInstance *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 154  : 		static std::vector<CEffectInstance*> s_kVct_pkEftInstSort;

  0014b	68 00 00 00 00	 push	 OFFSET ??__Fs_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@YAXXZ ; `CArea::RenderEffect'::`9'::`dynamic atexit destructor for 's_kVct_pkEftInstSort''
  00150	e8 00 00 00 00	 call	 _atexit
  00155	59		 pop	 ecx
  00156	68 00 00 00 00	 push	 OFFSET ?$TSS0@?8??RenderEffect@CArea@@QAEXXZ@4HA
  0015b	e8 00 00 00 00	 call	 __Init_thread_footer
  00160	59		 pop	 ecx
$LN5@RenderEffe:

; 155  : 		s_kVct_pkEftInstSort.clear();

  00161	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
  00166	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXXZ ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::clear

; 156  : 
; 157  : 		TEffectInstanceMap& rkMap_pkEftInstSrc=m_EffectInstanceMap;

  0016b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  00173	89 45 54	 mov	 DWORD PTR _rkMap_pkEftInstSrc$51[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  00176	83 65 64 00	 and	 DWORD PTR _i$54[ebp], 0

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0017a	8b 45 54	 mov	 eax, DWORD PTR _rkMap_pkEftInstSrc$51[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0017d	89 45 00	 mov	 DWORD PTR $T34[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00180	8b 45 00	 mov	 eax, DWORD PTR $T34[ebp]
  00183	89 45 fc	 mov	 DWORD PTR __Scary$33[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00186	8b 45 fc	 mov	 eax, DWORD PTR __Scary$33[ebp]
  00189	8b 00		 mov	 eax, DWORD PTR [eax]
  0018b	8b 00		 mov	 eax, DWORD PTR [eax]
  0018d	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00190	8b 45 f8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00193	89 45 f4	 mov	 DWORD PTR $T32[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00196	8d 45 f4	 lea	 eax, DWORD PTR $T32[ebp]
  00199	89 45 f0	 mov	 DWORD PTR $T31[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 159  : 		for (i=rkMap_pkEftInstSrc.begin(); i!=rkMap_pkEftInstSrc.end(); ++i)

  0019c	8b 45 f0	 mov	 eax, DWORD PTR $T31[ebp]
  0019f	8b 00		 mov	 eax, DWORD PTR [eax]
  001a1	89 45 64	 mov	 DWORD PTR _i$54[ebp], eax
  001a4	eb 08		 jmp	 SHORT $LN8@RenderEffe
$LN6@RenderEffe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  001a6	8d 4d 64	 lea	 ecx, DWORD PTR _i$54[ebp]
  001a9	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
$LN8@RenderEffe:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001ae	8b 45 54	 mov	 eax, DWORD PTR _rkMap_pkEftInstSrc$51[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001b1	89 45 ec	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001b4	8b 45 ec	 mov	 eax, DWORD PTR $T30[ebp]
  001b7	89 45 e8	 mov	 DWORD PTR __Scary$29[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  001ba	8b 45 e8	 mov	 eax, DWORD PTR __Scary$29[ebp]
  001bd	8b 00		 mov	 eax, DWORD PTR [eax]
  001bf	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  001c2	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  001c5	89 45 e0	 mov	 DWORD PTR $T28[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  001c8	8d 45 e0	 lea	 eax, DWORD PTR $T28[ebp]
  001cb	89 45 dc	 mov	 DWORD PTR $T27[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  001ce	8b 45 dc	 mov	 eax, DWORD PTR $T27[ebp]
  001d1	8b 4d 64	 mov	 ecx, DWORD PTR _i$54[ebp]
  001d4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001d6	75 09		 jne	 SHORT $LN182@RenderEffe
  001d8	c7 45 50 01 00
	00 00		 mov	 DWORD PTR tv421[ebp], 1
  001df	eb 04		 jmp	 SHORT $LN183@RenderEffe
$LN182@RenderEffe:
  001e1	83 65 50 00	 and	 DWORD PTR tv421[ebp], 0
$LN183@RenderEffe:
  001e5	8a 45 50	 mov	 al, BYTE PTR tv421[ebp]
  001e8	88 45 74	 mov	 BYTE PTR $T57[ebp], al

; 236  :         return !(*this == _Right);

  001eb	0f b6 45 74	 movzx	 eax, BYTE PTR $T57[ebp]
  001ef	85 c0		 test	 eax, eax
  001f1	75 09		 jne	 SHORT $LN177@RenderEffe
  001f3	c7 45 4c 01 00
	00 00		 mov	 DWORD PTR tv397[ebp], 1
  001fa	eb 04		 jmp	 SHORT $LN178@RenderEffe
$LN177@RenderEffe:
  001fc	83 65 4c 00	 and	 DWORD PTR tv397[ebp], 0
$LN178@RenderEffe:
  00200	8a 45 4c	 mov	 al, BYTE PTR tv397[ebp]
  00203	88 45 73	 mov	 BYTE PTR $T56[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 159  : 		for (i=rkMap_pkEftInstSrc.begin(); i!=rkMap_pkEftInstSrc.end(); ++i)

  00206	0f b6 45 73	 movzx	 eax, BYTE PTR $T56[ebp]
  0020a	85 c0		 test	 eax, eax
  0020c	74 37		 je	 SHORT $LN7@RenderEffe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0020e	8b 45 64	 mov	 eax, DWORD PTR _i$54[ebp]
  00211	83 c0 10	 add	 eax, 16			; 00000010H
  00214	89 45 d8	 mov	 DWORD PTR $T26[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00217	8b 45 d8	 mov	 eax, DWORD PTR $T26[ebp]
  0021a	89 45 d4	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0021d	8b 45 d4	 mov	 eax, DWORD PTR $T25[ebp]
  00220	89 45 d0	 mov	 DWORD PTR $T24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00223	8b 45 d0	 mov	 eax, DWORD PTR $T24[ebp]
  00226	89 45 cc	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  00229	8b 45 cc	 mov	 eax, DWORD PTR $T23[ebp]
  0022c	89 45 c8	 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 160  : 			s_kVct_pkEftInstSort.push_back(i->second);

  0022f	8b 45 c8	 mov	 eax, DWORD PTR $T22[ebp]
  00232	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00235	50		 push	 eax
  00236	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
  0023b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCEffectInstance@@@?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@QAEXABQAVCEffectInstance@@@Z ; std::vector<CEffectInstance *,std::allocator<CEffectInstance *> >::emplace_back<CEffectInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 160  : 			s_kVct_pkEftInstSort.push_back(i->second);

  00240	e9 61 ff ff ff	 jmp	 $LN6@RenderEffe
$LN7@RenderEffe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00245	c7 45 48 00 00
	00 00		 mov	 DWORD PTR __My_data$50[ebp], OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0024c	8b 45 48	 mov	 eax, DWORD PTR __My_data$50[ebp]
  0024f	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00255	8b 45 48	 mov	 eax, DWORD PTR __My_data$50[ebp]
  00258	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0025b	89 45 c4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0025e	8b 45 c4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00261	89 45 c0	 mov	 DWORD PTR $T21[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00264	8d 45 c0	 lea	 eax, DWORD PTR $T21[ebp]
  00267	89 45 b4	 mov	 DWORD PTR $T19[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0026a	c7 45 44 00 00
	00 00		 mov	 DWORD PTR __My_data$49[ebp], OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00271	8b 45 44	 mov	 eax, DWORD PTR __My_data$49[ebp]
  00274	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0027a	8b 45 44	 mov	 eax, DWORD PTR __My_data$49[ebp]
  0027d	8b 00		 mov	 eax, DWORD PTR [eax]
  0027f	89 45 bc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00282	8b 45 bc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00285	89 45 b8	 mov	 DWORD PTR $T20[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00288	8d 45 b8	 lea	 eax, DWORD PTR $T20[ebp]
  0028b	89 45 b0	 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 162  : 		std::sort(s_kVct_pkEftInstSort.begin(), s_kVct_pkEftInstSort.end(), CArea_LessEffectInstancePtrRenderOrder());

  0028e	8b 45 b4	 mov	 eax, DWORD PTR $T19[ebp]
  00291	8b 00		 mov	 eax, DWORD PTR [eax]
  00293	89 45 9c	 mov	 DWORD PTR __Last$[ebp], eax
  00296	8b 45 b0	 mov	 eax, DWORD PTR $T18[ebp]
  00299	8b 00		 mov	 eax, DWORD PTR [eax]
  0029b	89 45 ac	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0029e	8b 45 ac	 mov	 eax, DWORD PTR __First$[ebp]
  002a1	89 45 a8	 mov	 DWORD PTR __Ptr$17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  002a4	8b 45 a8	 mov	 eax, DWORD PTR __Ptr$17[ebp]
  002a7	89 45 a4	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  002aa	8b 45 a4	 mov	 eax, DWORD PTR $T16[ebp]
  002ad	89 45 a0	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  002b0	8b 45 a0	 mov	 eax, DWORD PTR $T15[ebp]
  002b3	89 45 3c	 mov	 DWORD PTR __UFirst$47[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  002b6	8b 45 9c	 mov	 eax, DWORD PTR __Last$[ebp]
  002b9	89 45 98	 mov	 DWORD PTR __Ptr$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  002bc	8b 45 98	 mov	 eax, DWORD PTR __Ptr$14[ebp]
  002bf	89 45 94	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  002c2	8b 45 94	 mov	 eax, DWORD PTR $T13[ebp]
  002c5	89 45 90	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  002c8	8b 45 90	 mov	 eax, DWORD PTR $T12[ebp]
  002cb	89 45 40	 mov	 DWORD PTR __ULast$48[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  002ce	8a 45 63	 mov	 al, BYTE PTR $T53[ebp]
  002d1	88 45 8c	 mov	 BYTE PTR $T11[ebp], al
  002d4	ff 75 8c	 push	 DWORD PTR $T11[ebp]
  002d7	8b 45 40	 mov	 eax, DWORD PTR __ULast$48[ebp]
  002da	2b 45 3c	 sub	 eax, DWORD PTR __UFirst$47[ebp]
  002dd	c1 f8 02	 sar	 eax, 2
  002e0	50		 push	 eax
  002e1	ff 75 40	 push	 DWORD PTR __ULast$48[ebp]
  002e4	ff 75 3c	 push	 DWORD PTR __UFirst$47[ebp]
  002e7	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAPAVCEffectInstance@@UCArea_LessEffectInstancePtrRenderOrder@@@std@@YAXPAPAVCEffectInstance@@0HUCArea_LessEffectInstancePtrRenderOrder@@@Z ; std::_Sort_unchecked<CEffectInstance * *,CArea_LessEffectInstancePtrRenderOrder>
  002ec	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  002ef	c7 45 38 00 00
	00 00		 mov	 DWORD PTR __My_data$46[ebp], OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002f6	8b 45 38	 mov	 eax, DWORD PTR __My_data$46[ebp]
  002f9	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  002ff	8b 45 38	 mov	 eax, DWORD PTR __My_data$46[ebp]
  00302	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00305	89 45 88	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00308	8b 45 88	 mov	 eax, DWORD PTR ___param0$[ebp]
  0030b	89 45 84	 mov	 DWORD PTR $T10[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0030e	8d 45 84	 lea	 eax, DWORD PTR $T10[ebp]
  00311	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00317	c7 45 34 00 00
	00 00		 mov	 DWORD PTR __My_data$45[ebp], OFFSET ?s_kVct_pkEftInstSort@?8??RenderEffect@CArea@@QAEXXZ@4V?$vector@PAVCEffectInstance@@V?$allocator@PAVCEffectInstance@@@std@@@std@@A
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0031e	8b 45 34	 mov	 eax, DWORD PTR __My_data$45[ebp]
  00321	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00327	8b 45 34	 mov	 eax, DWORD PTR __My_data$45[ebp]
  0032a	8b 00		 mov	 eax, DWORD PTR [eax]
  0032c	89 45 80	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0032f	8b 45 80	 mov	 eax, DWORD PTR ___param0$[ebp]
  00332	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00338	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  0033e	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 163  : 		std::for_each(s_kVct_pkEftInstSort.begin(), s_kVct_pkEftInstSort.end(), CArea_FEffectInstanceRender());

  00344	ff b5 5c ff ff
	ff		 push	 DWORD PTR $T1[ebp]
  0034a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00350	ff 30		 push	 DWORD PTR [eax]
  00352	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00358	ff 30		 push	 DWORD PTR [eax]
  0035a	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@std@@UCArea_FEffectInstanceRender@@@std@@YA?AUCArea_FEffectInstanceRender@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCEffectInstance@@@std@@@std@@@0@0U1@@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CEffectInstance *> > >,CArea_FEffectInstanceRender>
  0035f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00362	88 45 62	 mov	 BYTE PTR $T52[ebp], al
$LN1@RenderEffe:

; 164  : 		
; 165  : 	}
; 166  : }

  00365	83 c5 78	 add	 ebp, 120		; 00000078H
  00368	c9		 leave
  00369	c3		 ret	 0
?RenderEffect@CArea@@QAEXXZ ENDP			; CArea::RenderEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Render@CArea@@QAEXXZ
_TEXT	SEGMENT
$T1 = -216						; size = 4
$T2 = -212						; size = 4
$T3 = -208						; size = 4
$T4 = -204						; size = 4
$T5 = -200						; size = 4
_aCRCWithNumber$6 = -196				; size = 8
$T7 = -188						; size = 1
$T8 = -184						; size = 4
$T9 = -180						; size = 4
__Ptr$10 = -176						; size = 4
__Last$ = -172						; size = 4
$T11 = -168						; size = 4
$T12 = -164						; size = 4
__Ptr$13 = -160						; size = 4
__First$ = -156						; size = 4
$T14 = -152						; size = 4
$T15 = -148						; size = 4
$T16 = -144						; size = 4
___param0$ = -140					; size = 4
$T17 = -136						; size = 4
___param0$ = -132					; size = 4
$T18 = -128						; size = 4
$T19 = -124						; size = 4
$T20 = -120						; size = 4
___param0$ = -116					; size = 4
$T21 = -112						; size = 4
$T22 = -108						; size = 4
$T23 = -104						; size = 4
$T24 = -100						; size = 4
___param0$ = -96					; size = 4
$T25 = -92						; size = 4
___param0$ = -88					; size = 4
$T26 = -84						; size = 4
$T27 = -80						; size = 4
$T28 = -76						; size = 4
___param0$ = -72					; size = 4
$T29 = -68						; size = 4
$T30 = -64						; size = 4
$T31 = -60						; size = 4
$T32 = -56						; size = 4
$T33 = -52						; size = 4
$T34 = -48						; size = 4
__Tmp$35 = -44						; size = 4
$T36 = -40						; size = 4
$T37 = -36						; size = 4
___param0$ = -32					; size = 4
$T38 = -28						; size = 4
_pkThingInst$39 = -24					; size = 4
$T40 = -20						; size = 4
$T41 = -16						; size = 4
$T42 = -12						; size = 4
$T43 = -8						; size = 4
__Tmp$44 = -4						; size = 4
$T45 = 0						; size = 4
$T46 = 4						; size = 4
___param0$ = 8						; size = 4
$T47 = 12						; size = 4
__UFirst$48 = 16					; size = 4
__ULast$49 = 20						; size = 4
__My_data$50 = 24					; size = 4
__My_data$51 = 28					; size = 4
_rCRCWithNumber$52 = 32					; size = 4
_aCRCWithNumberVectorIterator$53 = 36			; size = 4
_dwCRC$54 = 40						; size = 4
tv521 = 44						; size = 4
__My_data$55 = 48					; size = 4
__My_data$56 = 52					; size = 4
__My_data$57 = 56					; size = 4
_aGraphicThingInstanceCRCMapIterator$ = 60		; size = 4
_this$ = 64						; size = 4
tv362 = 68						; size = 4
tv371 = 72						; size = 4
__My_data$58 = 76					; size = 4
tv290 = 80						; size = 4
tv299 = 84						; size = 4
__My_data$59 = 88					; size = 4
_pkThingInst$ = 92					; size = 4
$T60 = 99						; size = 1
_i$ = 100						; size = 4
_i$61 = 104						; size = 4
$T62 = 111						; size = 1
$T63 = 112						; size = 1
$T64 = 113						; size = 1
$T65 = 114						; size = 1
$T66 = 115						; size = 1
_this$ = 116						; size = 4
?Render@CArea@@QAEXXZ PROC				; CArea::Render, COMDAT
; _this$ = ecx

; 206  : {		

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 50 01 00
	00		 sub	 esp, 336		; 00000150H
  0000b	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx

; 207  : 	{
; 208  : 		CGraphicThingInstance* pkThingInst;
; 209  : 
; 210  : 		TThingInstanceVector::iterator i=m_AniThingCloneInstanceVector.begin();

  0000e	8d 45 68	 lea	 eax, DWORD PTR _i$61[ebp]
  00011	50		 push	 eax
  00012	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 40	 add	 ecx, 64			; 00000040H
  00018	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin
$LN2@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0001d	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 40	 add	 eax, 64			; 00000040H
  00023	89 45 58	 mov	 DWORD PTR __My_data$59[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00026	8b 45 58	 mov	 eax, DWORD PTR __My_data$59[ebp]
  00029	89 45 0c	 mov	 DWORD PTR $T47[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0002c	8b 45 58	 mov	 eax, DWORD PTR __My_data$59[ebp]
  0002f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00032	89 45 08	 mov	 DWORD PTR ___param0$[ebp], eax
  00035	ff 75 0c	 push	 DWORD PTR $T47[ebp]
  00038	ff 75 08	 push	 DWORD PTR ___param0$[ebp]
  0003b	8d 4d 04	 lea	 ecx, DWORD PTR $T46[ebp]
  0003e	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
  00043	8d 45 04	 lea	 eax, DWORD PTR $T46[ebp]
  00046	89 45 00	 mov	 DWORD PTR $T45[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00049	8b 45 00	 mov	 eax, DWORD PTR $T45[ebp]
  0004c	8b 4d 68	 mov	 ecx, DWORD PTR _i$61[ebp]
  0004f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00051	75 09		 jne	 SHORT $LN35@Render
  00053	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv299[ebp], 1
  0005a	eb 04		 jmp	 SHORT $LN36@Render
$LN35@Render:
  0005c	83 65 54 00	 and	 DWORD PTR tv299[ebp], 0
$LN36@Render:
  00060	8a 45 54	 mov	 al, BYTE PTR tv299[ebp]
  00063	88 45 73	 mov	 BYTE PTR $T66[ebp], al

; 153  :         return !(*this == _Right);

  00066	0f b6 45 73	 movzx	 eax, BYTE PTR $T66[ebp]
  0006a	85 c0		 test	 eax, eax
  0006c	75 09		 jne	 SHORT $LN30@Render
  0006e	c7 45 50 01 00
	00 00		 mov	 DWORD PTR tv290[ebp], 1
  00075	eb 04		 jmp	 SHORT $LN31@Render
$LN30@Render:
  00077	83 65 50 00	 and	 DWORD PTR tv290[ebp], 0
$LN31@Render:
  0007b	8a 45 50	 mov	 al, BYTE PTR tv290[ebp]
  0007e	88 45 72	 mov	 BYTE PTR $T65[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 211  : 		while (i!=m_AniThingCloneInstanceVector.end())

  00081	0f b6 45 72	 movzx	 eax, BYTE PTR $T65[ebp]
  00085	85 c0		 test	 eax, eax
  00087	74 3e		 je	 SHORT $LN3@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 265  :         _Vector_iterator _Tmp = *this;

  00089	8b 45 68	 mov	 eax, DWORD PTR _i$61[ebp]
  0008c	89 45 fc	 mov	 DWORD PTR __Tmp$44[ebp], eax

; 75   :         ++_Ptr;

  0008f	8b 45 68	 mov	 eax, DWORD PTR _i$61[ebp]
  00092	83 c0 04	 add	 eax, 4
  00095	89 45 68	 mov	 DWORD PTR _i$61[ebp], eax

; 267  :         return _Tmp;

  00098	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$44[ebp]
  0009b	89 45 f8	 mov	 DWORD PTR $T43[ebp], eax
  0009e	8d 45 f8	 lea	 eax, DWORD PTR $T43[ebp]
  000a1	89 45 f4	 mov	 DWORD PTR $T42[ebp], eax

; 54   :         return *_Ptr;

  000a4	8b 45 f4	 mov	 eax, DWORD PTR $T42[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 45 f0	 mov	 DWORD PTR $T41[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000ac	8b 45 f0	 mov	 eax, DWORD PTR $T41[ebp]
  000af	89 45 ec	 mov	 DWORD PTR $T40[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 213  : 			pkThingInst=*i++;

  000b2	8b 45 ec	 mov	 eax, DWORD PTR $T40[ebp]
  000b5	8b 00		 mov	 eax, DWORD PTR [eax]
  000b7	89 45 e8	 mov	 DWORD PTR _pkThingInst$39[ebp], eax

; 214  : 			pkThingInst->Deform();

  000ba	8b 4d e8	 mov	 ecx, DWORD PTR _pkThingInst$39[ebp]
  000bd	e8 00 00 00 00	 call	 ?Deform@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Deform

; 215  : 		}

  000c2	e9 56 ff ff ff	 jmp	 $LN2@Render
$LN3@Render:

; 216  : 	}
; 217  : 
; 218  : 	CGraphicThingInstance* pkThingInst;
; 219  : 
; 220  : 	TThingInstanceVector::iterator i=m_ThingCloneInstaceVector.begin();

  000c7	8d 45 64	 lea	 eax, DWORD PTR _i$[ebp]
  000ca	50		 push	 eax
  000cb	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	83 c1 28	 add	 ecx, 40			; 00000028H
  000d1	e8 00 00 00 00	 call	 ?begin@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@2@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::begin

; 221  : 
; 222  : 	m_kRenderedThingInstanceCRCWithNumberVector.clear();

  000d6	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	83 c1 6c	 add	 ecx, 108		; 0000006cH
  000dc	e8 00 00 00 00	 call	 ?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear

; 223  : 	m_kRenderedGrapphicThingInstanceVector.clear();

  000e1	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	83 c1 78	 add	 ecx, 120		; 00000078H
  000e7	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  000ec	83 65 3c 00	 and	 DWORD PTR _aGraphicThingInstanceCRCMapIterator$[ebp], 0
$LN4@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  000f0	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	83 c0 28	 add	 eax, 40			; 00000028H
  000f6	89 45 4c	 mov	 DWORD PTR __My_data$58[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000f9	8b 45 4c	 mov	 eax, DWORD PTR __My_data$58[ebp]
  000fc	89 45 e4	 mov	 DWORD PTR $T38[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000ff	8b 45 4c	 mov	 eax, DWORD PTR __My_data$58[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax
  00108	ff 75 e4	 push	 DWORD PTR $T38[ebp]
  0010b	ff 75 e0	 push	 DWORD PTR ___param0$[ebp]
  0010e	8d 4d dc	 lea	 ecx, DWORD PTR $T37[ebp]
  00111	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@@std@@QAE@PAPAVCGraphicThingInstance@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> > >
  00116	8d 45 dc	 lea	 eax, DWORD PTR $T37[ebp]
  00119	89 45 d8	 mov	 DWORD PTR $T36[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0011c	8b 45 d8	 mov	 eax, DWORD PTR $T36[ebp]
  0011f	8b 4d 64	 mov	 ecx, DWORD PTR _i$[ebp]
  00122	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00124	75 09		 jne	 SHORT $LN115@Render
  00126	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv371[ebp], 1
  0012d	eb 04		 jmp	 SHORT $LN116@Render
$LN115@Render:
  0012f	83 65 48 00	 and	 DWORD PTR tv371[ebp], 0
$LN116@Render:
  00133	8a 45 48	 mov	 al, BYTE PTR tv371[ebp]
  00136	88 45 71	 mov	 BYTE PTR $T64[ebp], al

; 153  :         return !(*this == _Right);

  00139	0f b6 45 71	 movzx	 eax, BYTE PTR $T64[ebp]
  0013d	85 c0		 test	 eax, eax
  0013f	75 09		 jne	 SHORT $LN110@Render
  00141	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv362[ebp], 1
  00148	eb 04		 jmp	 SHORT $LN111@Render
$LN110@Render:
  0014a	83 65 44 00	 and	 DWORD PTR tv362[ebp], 0
$LN111@Render:
  0014e	8a 45 44	 mov	 al, BYTE PTR tv362[ebp]
  00151	88 45 70	 mov	 BYTE PTR $T63[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 226  : 	while (i!=m_ThingCloneInstaceVector.end())

  00154	0f b6 45 70	 movzx	 eax, BYTE PTR $T63[ebp]
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 a0 01 00
	00		 je	 $LN5@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 265  :         _Vector_iterator _Tmp = *this;

  00160	8b 45 64	 mov	 eax, DWORD PTR _i$[ebp]
  00163	89 45 d4	 mov	 DWORD PTR __Tmp$35[ebp], eax

; 75   :         ++_Ptr;

  00166	8b 45 64	 mov	 eax, DWORD PTR _i$[ebp]
  00169	83 c0 04	 add	 eax, 4
  0016c	89 45 64	 mov	 DWORD PTR _i$[ebp], eax

; 267  :         return _Tmp;

  0016f	8b 45 d4	 mov	 eax, DWORD PTR __Tmp$35[ebp]
  00172	89 45 d0	 mov	 DWORD PTR $T34[ebp], eax
  00175	8d 45 d0	 lea	 eax, DWORD PTR $T34[ebp]
  00178	89 45 cc	 mov	 DWORD PTR $T33[ebp], eax

; 54   :         return *_Ptr;

  0017b	8b 45 cc	 mov	 eax, DWORD PTR $T33[ebp]
  0017e	8b 00		 mov	 eax, DWORD PTR [eax]
  00180	89 45 c8	 mov	 DWORD PTR $T32[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00183	8b 45 c8	 mov	 eax, DWORD PTR $T32[ebp]
  00186	89 45 c4	 mov	 DWORD PTR $T31[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 228  : 		pkThingInst=*i++;

  00189	8b 45 c4	 mov	 eax, DWORD PTR $T31[ebp]
  0018c	8b 00		 mov	 eax, DWORD PTR [eax]
  0018e	89 45 5c	 mov	 DWORD PTR _pkThingInst$[ebp], eax

; 229  : 		if (pkThingInst->Render())

  00191	8b 4d 5c	 mov	 ecx, DWORD PTR _pkThingInst$[ebp]
  00194	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
  00199	0f b6 c0	 movzx	 eax, al
  0019c	85 c0		 test	 eax, eax
  0019e	0f 84 57 01 00
	00		 je	 $LN6@Render

; 231  : 			aGraphicThingInstanceCRCMapIterator = m_GraphicThingInstanceCRCMap.find(pkThingInst);

  001a4	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	83 c0 64	 add	 eax, 100		; 00000064H
  001aa	89 45 40	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001ad	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001b0	89 45 c0	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  001b3	8b 45 c0	 mov	 eax, DWORD PTR $T30[ebp]
  001b6	89 45 bc	 mov	 DWORD PTR $T29[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  001b9	8d 45 5c	 lea	 eax, DWORD PTR _pkThingInst$[ebp]
  001bc	50		 push	 eax
  001bd	8b 4d 40	 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	e8 00 00 00 00	 call	 ??$_Find@PAVCGraphicThingInstance@@@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@ABQAVCGraphicThingInstance@@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Find<CGraphicThingInstance *>
  001c5	89 45 b8	 mov	 DWORD PTR ___param0$[ebp], eax
  001c8	ff 75 bc	 push	 DWORD PTR $T29[ebp]
  001cb	ff 75 b8	 push	 DWORD PTR ___param0$[ebp]
  001ce	8d 4d b4	 lea	 ecx, DWORD PTR $T28[ebp]
  001d1	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@QAVCGraphicThingInstance@@K@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@QAVCGraphicThingInstance@@K@std@@@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<CGraphicThingInstance * const,unsigned long> > >,std::_Iterator_base0>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 231  : 			aGraphicThingInstanceCRCMapIterator = m_GraphicThingInstanceCRCMap.find(pkThingInst);

  001d6	8b 45 b4	 mov	 eax, DWORD PTR $T28[ebp]
  001d9	89 45 3c	 mov	 DWORD PTR _aGraphicThingInstanceCRCMapIterator$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  001dc	8b 45 3c	 mov	 eax, DWORD PTR _aGraphicThingInstanceCRCMapIterator$[ebp]
  001df	83 c0 10	 add	 eax, 16			; 00000010H
  001e2	89 45 b0	 mov	 DWORD PTR $T27[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  001e5	8b 45 b0	 mov	 eax, DWORD PTR $T27[ebp]
  001e8	89 45 ac	 mov	 DWORD PTR $T26[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 232  : 			DWORD dwCRC = (*aGraphicThingInstanceCRCMapIterator).second;

  001eb	8b 45 ac	 mov	 eax, DWORD PTR $T26[ebp]
  001ee	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f1	89 45 28	 mov	 DWORD PTR _dwCRC$54[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001f4	8d 45 5c	 lea	 eax, DWORD PTR _pkThingInst$[ebp]
  001f7	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 234  : 			m_kRenderedGrapphicThingInstanceVector.push_back(pkThingInst);

  001f8	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	83 c1 78	 add	 ecx, 120		; 00000078H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  001fe	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h

; 174  : 			FFindIfCRC(DWORD dwCRC) { m_dwCRC = dwCRC; }

  00203	8b 45 28	 mov	 eax, DWORD PTR _dwCRC$54[ebp]
  00206	89 45 98	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00209	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0020c	83 c0 6c	 add	 eax, 108		; 0000006cH
  0020f	89 45 38	 mov	 DWORD PTR __My_data$57[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00212	8b 45 38	 mov	 eax, DWORD PTR __My_data$57[ebp]
  00215	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0021b	8b 45 38	 mov	 eax, DWORD PTR __My_data$57[ebp]
  0021e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00221	89 45 a8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00224	8b 45 a8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00227	89 45 a4	 mov	 DWORD PTR $T25[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0022a	8d 45 a4	 lea	 eax, DWORD PTR $T25[ebp]
  0022d	89 45 94	 mov	 DWORD PTR $T22[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00230	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00233	83 c0 6c	 add	 eax, 108		; 0000006cH
  00236	89 45 34	 mov	 DWORD PTR __My_data$56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00239	8b 45 34	 mov	 eax, DWORD PTR __My_data$56[ebp]
  0023c	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00242	8b 45 34	 mov	 eax, DWORD PTR __My_data$56[ebp]
  00245	8b 00		 mov	 eax, DWORD PTR [eax]
  00247	89 45 a0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0024a	8b 45 a0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0024d	89 45 9c	 mov	 DWORD PTR $T24[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00250	8d 45 9c	 lea	 eax, DWORD PTR $T24[ebp]
  00253	89 45 90	 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 236  : 			TCRCWithNumberVector::iterator aCRCWithNumberVectorIterator = std::find_if(m_kRenderedThingInstanceCRCWithNumberVector.begin(), m_kRenderedThingInstanceCRCWithNumberVector.end(), FFindIfCRC(dwCRC));

  00256	ff 75 98	 push	 DWORD PTR $T23[ebp]
  00259	8b 45 94	 mov	 eax, DWORD PTR $T22[ebp]
  0025c	ff 30		 push	 DWORD PTR [eax]
  0025e	8b 45 90	 mov	 eax, DWORD PTR $T21[ebp]
  00261	ff 30		 push	 DWORD PTR [eax]
  00263	8d 45 24	 lea	 eax, DWORD PTR _aCRCWithNumberVectorIterator$53[ebp]
  00266	50		 push	 eax
  00267	e8 00 00 00 00	 call	 ??$find_if@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@std@@UFFindIfCRC@CArea@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@USCRCWithNumber@CArea@@@std@@@std@@@0@V10@V10@UFFindIfCRC@CArea@@@Z ; std::find_if<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CArea::SCRCWithNumber> > >,CArea::FFindIfCRC>
  0026c	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0026f	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00272	83 c0 6c	 add	 eax, 108		; 0000006cH
  00275	89 45 30	 mov	 DWORD PTR __My_data$55[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00278	8b 45 30	 mov	 eax, DWORD PTR __My_data$55[ebp]
  0027b	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00281	8b 45 30	 mov	 eax, DWORD PTR __My_data$55[ebp]
  00284	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00287	89 45 8c	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0028a	8b 45 8c	 mov	 eax, DWORD PTR ___param0$[ebp]
  0028d	89 45 88	 mov	 DWORD PTR $T20[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00290	8d 45 88	 lea	 eax, DWORD PTR $T20[ebp]
  00293	89 45 84	 mov	 DWORD PTR $T19[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00296	8b 45 84	 mov	 eax, DWORD PTR $T19[ebp]
  00299	8b 00		 mov	 eax, DWORD PTR [eax]
  0029b	3b 45 24	 cmp	 eax, DWORD PTR _aCRCWithNumberVectorIterator$53[ebp]
  0029e	75 09		 jne	 SHORT $LN261@Render
  002a0	c7 45 2c 01 00
	00 00		 mov	 DWORD PTR tv521[ebp], 1
  002a7	eb 04		 jmp	 SHORT $LN262@Render
$LN261@Render:
  002a9	83 65 2c 00	 and	 DWORD PTR tv521[ebp], 0
$LN262@Render:
  002ad	8a 45 2c	 mov	 al, BYTE PTR tv521[ebp]
  002b0	88 45 6f	 mov	 BYTE PTR $T62[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 238  : 			if ( m_kRenderedThingInstanceCRCWithNumberVector.end() == aCRCWithNumberVectorIterator)

  002b3	0f b6 45 6f	 movzx	 eax, BYTE PTR $T62[ebp]
  002b7	85 c0		 test	 eax, eax
  002b9	74 27		 je	 SHORT $LN7@Render

; 239  : 			{
; 240  : 				TCRCWithNumber aCRCWithNumber;
; 241  : 				aCRCWithNumber.dwCRC = dwCRC;

  002bb	8b 45 28	 mov	 eax, DWORD PTR _dwCRC$54[ebp]
  002be	89 85 3c ff ff
	ff		 mov	 DWORD PTR _aCRCWithNumber$6[ebp], eax

; 242  : 				aCRCWithNumber.dwNumber = 1;

  002c4	c7 85 40 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR _aCRCWithNumber$6[ebp+4], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002ce	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _aCRCWithNumber$6[ebp]
  002d4	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 243  : 				m_kRenderedThingInstanceCRCWithNumberVector.push_back(aCRCWithNumber);

  002d5	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  002d8	83 c1 6c	 add	 ecx, 108		; 0000006cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002db	e8 00 00 00 00	 call	 ??$emplace_back@ABUSCRCWithNumber@CArea@@@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXABUSCRCWithNumber@CArea@@@Z ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::emplace_back<CArea::SCRCWithNumber const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 244  : 			}

  002e0	eb 19		 jmp	 SHORT $LN6@Render
$LN7@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  002e2	8b 45 24	 mov	 eax, DWORD PTR _aCRCWithNumberVectorIterator$53[ebp]
  002e5	89 45 80	 mov	 DWORD PTR $T18[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  002e8	8b 45 80	 mov	 eax, DWORD PTR $T18[ebp]
  002eb	89 45 20	 mov	 DWORD PTR _rCRCWithNumber$52[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 248  : 				rCRCWithNumber.dwNumber += 1;

  002ee	8b 45 20	 mov	 eax, DWORD PTR _rCRCWithNumber$52[ebp]
  002f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002f4	40		 inc	 eax
  002f5	8b 4d 20	 mov	 ecx, DWORD PTR _rCRCWithNumber$52[ebp]
  002f8	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN6@Render:

; 249  : 			}
; 250  : 		}
; 251  : 	}

  002fb	e9 f0 fd ff ff	 jmp	 $LN4@Render
$LN5@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00300	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00303	83 c0 6c	 add	 eax, 108		; 0000006cH
  00306	89 45 1c	 mov	 DWORD PTR __My_data$51[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00309	8b 45 1c	 mov	 eax, DWORD PTR __My_data$51[ebp]
  0030c	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00312	8b 45 1c	 mov	 eax, DWORD PTR __My_data$51[ebp]
  00315	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00318	89 85 7c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0031e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00324	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T17[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0032a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00330	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T15[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00336	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00339	83 c0 6c	 add	 eax, 108		; 0000006cH
  0033c	89 45 18	 mov	 DWORD PTR __My_data$50[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0033f	8b 45 18	 mov	 eax, DWORD PTR __My_data$50[ebp]
  00342	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00348	8b 45 18	 mov	 eax, DWORD PTR __My_data$50[ebp]
  0034b	8b 00		 mov	 eax, DWORD PTR [eax]
  0034d	89 85 74 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00353	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00359	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T16[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0035f	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00365	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 252  :  	std::sort(m_kRenderedThingInstanceCRCWithNumberVector.begin(), m_kRenderedThingInstanceCRCWithNumberVector.end(), CRCNumComp());

  0036b	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  00371	8b 00		 mov	 eax, DWORD PTR [eax]
  00373	89 85 54 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00379	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  0037f	8b 00		 mov	 eax, DWORD PTR [eax]
  00381	89 85 64 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00387	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR __First$[ebp]
  0038d	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Ptr$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00393	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR __Ptr$13[ebp]
  00399	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0039f	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  003a5	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  003ab	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  003b1	89 45 10	 mov	 DWORD PTR __UFirst$48[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  003b4	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR __Last$[ebp]
  003ba	89 85 50 ff ff
	ff		 mov	 DWORD PTR __Ptr$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  003c0	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR __Ptr$10[ebp]
  003c6	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  003cc	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  003d2	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  003d8	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  003de	89 45 14	 mov	 DWORD PTR __ULast$49[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  003e1	8a 45 63	 mov	 al, BYTE PTR $T60[ebp]
  003e4	88 85 44 ff ff
	ff		 mov	 BYTE PTR $T7[ebp], al
  003ea	ff b5 44 ff ff
	ff		 push	 DWORD PTR $T7[ebp]
  003f0	8b 45 14	 mov	 eax, DWORD PTR __ULast$49[ebp]
  003f3	2b 45 10	 sub	 eax, DWORD PTR __UFirst$48[ebp]
  003f6	c1 f8 03	 sar	 eax, 3
  003f9	50		 push	 eax
  003fa	ff 75 14	 push	 DWORD PTR __ULast$49[ebp]
  003fd	ff 75 10	 push	 DWORD PTR __UFirst$48[ebp]
  00400	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAUSCRCWithNumber@CArea@@UCRCNumComp@2@@std@@YAXPAUSCRCWithNumber@CArea@@0HUCRCNumComp@2@@Z ; std::_Sort_unchecked<CArea::SCRCWithNumber *,CArea::CRCNumComp>
  00405	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 253  : }

  00408	83 c5 78	 add	 ebp, 120		; 00000078H
  0040b	c9		 leave
  0040c	c3		 ret	 0
?Render@CArea@@QAEXXZ ENDP				; CArea::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?UpdateAroundAmbience@CArea@@QAEXMMM@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pInstance$3 = -64					; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
___param0$ = -44					; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
___param0$ = -32					; size = 4
tv176 = -28						; size = 4
tv190 = -24						; size = 4
__My_data$10 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$11 = -12					; size = 4
_i$ = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_fZ$ = 16						; size = 4
?UpdateAroundAmbience@CArea@@QAEXMMM@Z PROC		; CArea::UpdateAroundAmbience, COMDAT
; _this$ = ecx

; 106  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 c0 58	 add	 eax, 88			; 00000058H
  00013	89 45 f4	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00016	8b 45 f4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00019	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00024	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00027	89 45 dc	 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002a	8d 45 dc	 lea	 eax, DWORD PTR $T9[ebp]
  0002d	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 109  : 	for (i = m_AmbienceCloneInstanceVector.begin(); i != m_AmbienceCloneInstanceVector.end(); ++i)

  00030	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00038	eb 09		 jmp	 SHORT $LN27@UpdateArou
$LN2@UpdateArou:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN27@UpdateArou:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 58	 add	 eax, 88			; 00000058H
  00049	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0004f	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00052	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005b	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0005e	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00061	8d 45 d0	 lea	 eax, DWORD PTR $T7[ebp]
  00064	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00067	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 09		 jne	 SHORT $LN55@UpdateArou
  00071	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv190[ebp], 1
  00078	eb 04		 jmp	 SHORT $LN56@UpdateArou
$LN55@UpdateArou:
  0007a	83 65 e8 00	 and	 DWORD PTR tv190[ebp], 0
$LN56@UpdateArou:
  0007e	8a 45 e8	 mov	 al, BYTE PTR tv190[ebp]
  00081	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 153  :         return !(*this == _Right);

  00084	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	75 09		 jne	 SHORT $LN50@UpdateArou
  0008c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv176[ebp], 1
  00093	eb 04		 jmp	 SHORT $LN51@UpdateArou
$LN50@UpdateArou:
  00095	83 65 e4 00	 and	 DWORD PTR tv176[ebp], 0
$LN51@UpdateArou:
  00099	8a 45 e4	 mov	 al, BYTE PTR tv176[ebp]
  0009c	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 109  : 	for (i = m_AmbienceCloneInstanceVector.begin(); i != m_AmbienceCloneInstanceVector.end(); ++i)

  0009f	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  000a3	85 c0		 test	 eax, eax
  000a5	74 42		 je	 SHORT $LN3@UpdateArou
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b0	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 111  : 		TAmbienceInstance * pInstance = *i;

  000b3	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 c0	 mov	 DWORD PTR _pInstance$3[ebp], eax

; 112  : 		pInstance->__Update(fX, fY, fZ);

  000bb	51		 push	 ecx
  000bc	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fZ$[ebp]
  000c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c6	51		 push	 ecx
  000c7	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  000cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d1	51		 push	 ecx
  000d2	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	8b 4d c0	 mov	 ecx, DWORD PTR _pInstance$3[ebp]
  000df	e8 00 00 00 00	 call	 ?__Update@SAmbienceInstance@CArea@@QAEXMMM@Z ; CArea::SAmbienceInstance::__Update

; 113  : 	}

  000e4	e9 51 ff ff ff	 jmp	 $LN2@UpdateArou
$LN3@UpdateArou:

; 114  : }

  000e9	c9		 leave
  000ea	c2 0c 00	 ret	 12			; 0000000cH
?UpdateAroundAmbience@CArea@@QAEXMMM@Z ENDP		; CArea::UpdateAroundAmbience
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Update@CArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Update@CArea@@QAEXXZ PROC				; CArea::Update, COMDAT
; _this$ = ecx

; 101  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 102  : 	__UpdateAniThingList();		

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__UpdateAniThingList@CArea@@IAEXXZ ; CArea::__UpdateAniThingList

; 103  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?Update@CArea@@QAEXXZ ENDP				; CArea::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?RefreshPortal@CArea@@QAEXXZ
_TEXT	SEGMENT
$T2 = -100						; size = 8
$T3 = -92						; size = 4
$T4 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
__Val$ = -76						; size = 4
__Val$ = -72						; size = 4
__Val$ = -68						; size = 4
__Right$ = -64						; size = 4
$T7 = -60						; size = 4
$T8 = -56						; size = 4
___param0$ = -52					; size = 4
__Scary$9 = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -40						; size = 4
$T12 = -36						; size = 4
$T13 = -32						; size = 4
$T14 = -28						; size = 4
___param0$ = -24					; size = 4
$T15 = -20						; size = 4
$T16 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___param0$ = 0						; size = 4
$T17 = 4						; size = 4
_pInstance$18 = 8					; size = 4
$T19 = 12						; size = 4
_this$ = 16						; size = 4
___param0$ = 20						; size = 4
$T20 = 24						; size = 4
$T21 = 28						; size = 4
$T22 = 32						; size = 4
_rData$23 = 36						; size = 4
$T24 = 40						; size = 4
__My_data$25 = 44					; size = 4
__My_data$26 = 48					; size = 4
_kSet_ShowingObjectInstance$ = 52			; size = 8
tv458 = 60						; size = 4
tv409 = 64						; size = 4
tv423 = 68						; size = 4
__My_data$27 = 72					; size = 4
__My_data$28 = 76					; size = 4
tv278 = 80						; size = 4
_this$ = 84						; size = 4
__My_data$29 = 88					; size = 4
_j$30 = 92						; size = 4
_it$ = 96						; size = 4
_i$31 = 100						; size = 4
_pObjectInstance$32 = 104				; size = 4
$T33 = 111						; size = 1
$T34 = 112						; size = 1
$T35 = 113						; size = 1
$T36 = 114						; size = 1
_byPortalID$37 = 115					; size = 1
_this$ = 116						; size = 4
?RefreshPortal@CArea@@QAEXXZ PROC			; CArea::RefreshPortal, COMDAT
; _this$ = ecx

; 1127 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?RefreshPortal@CArea@@QAEXXZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 58	 sub	 esp, 88			; 00000058H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx

; 1128 : 	std::set<TObjectInstance *> kSet_ShowingObjectInstance;

  0002d	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  00030	e8 00 00 00 00	 call	 ??0?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ ; std::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >::set<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *> >
  00035	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1129 : 	kSet_ShowingObjectInstance.clear();

  00039	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  0003c	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::clear

; 1130 : 	for (DWORD i = 0; i < m_ObjectDataVector.size(); ++i)

  00041	83 65 64 00	 and	 DWORD PTR _i$31[ebp], 0
  00045	eb 07		 jmp	 SHORT $LN4@RefreshPor
$LN2@RefreshPor:
  00047	8b 45 64	 mov	 eax, DWORD PTR _i$31[ebp]
  0004a	40		 inc	 eax
  0004b	89 45 64	 mov	 DWORD PTR _i$31[ebp], eax
$LN4@RefreshPor:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0004e	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	89 45 58	 mov	 DWORD PTR __My_data$29[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00057	8b 45 58	 mov	 eax, DWORD PTR __My_data$29[ebp]
  0005a	8b 4d 58	 mov	 ecx, DWORD PTR __My_data$29[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	2b 01		 sub	 eax, DWORD PTR [ecx]
  00062	99		 cdq
  00063	6a 30		 push	 48			; 00000030H
  00065	59		 pop	 ecx
  00066	f7 f9		 idiv	 ecx
  00068	89 45 b0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1130 : 	for (DWORD i = 0; i < m_ObjectDataVector.size(); ++i)

  0006b	8b 45 64	 mov	 eax, DWORD PTR _i$31[ebp]
  0006e	3b 45 b0	 cmp	 eax, DWORD PTR $T6[ebp]
  00071	0f 83 fa 00 00
	00		 jae	 $LN3@RefreshPor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00077	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 c0 04	 add	 eax, 4
  0007d	89 45 30	 mov	 DWORD PTR __My_data$26[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00080	6b 45 64 30	 imul	 eax, DWORD PTR _i$31[ebp], 48
  00084	8b 4d 30	 mov	 ecx, DWORD PTR __My_data$26[ebp]
  00087	03 01		 add	 eax, DWORD PTR [ecx]
  00089	89 45 24	 mov	 DWORD PTR _rData$23[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0008c	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	83 c0 10	 add	 eax, 16			; 00000010H
  00092	89 45 2c	 mov	 DWORD PTR __My_data$25[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00095	8b 45 2c	 mov	 eax, DWORD PTR __My_data$25[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	8b 4d 64	 mov	 ecx, DWORD PTR _i$31[ebp]
  0009d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000a0	89 45 28	 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1133 : 		TObjectInstance * pInstance = m_ObjectInstanceVector[i];

  000a3	8b 45 28	 mov	 eax, DWORD PTR $T24[ebp]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	89 45 08	 mov	 DWORD PTR _pInstance$18[ebp], eax

; 1134 : 
; 1135 : 		for (int j = 0; j < PORTAL_ID_MAX_NUM; ++j)

  000ab	83 65 5c 00	 and	 DWORD PTR _j$30[ebp], 0
  000af	eb 07		 jmp	 SHORT $LN7@RefreshPor
$LN5@RefreshPor:
  000b1	8b 45 5c	 mov	 eax, DWORD PTR _j$30[ebp]
  000b4	40		 inc	 eax
  000b5	89 45 5c	 mov	 DWORD PTR _j$30[ebp], eax
$LN7@RefreshPor:
  000b8	83 7d 5c 08	 cmp	 DWORD PTR _j$30[ebp], 8
  000bc	0f 8d aa 00 00
	00		 jge	 $LN6@RefreshPor

; 1136 : 		{
; 1137 : 			BYTE byPortalID = rData.abyPortalID[j];

  000c2	8b 45 24	 mov	 eax, DWORD PTR _rData$23[ebp]
  000c5	03 45 5c	 add	 eax, DWORD PTR _j$30[ebp]
  000c8	8a 40 10	 mov	 al, BYTE PTR [eax+16]
  000cb	88 45 73	 mov	 BYTE PTR _byPortalID$37[ebp], al

; 1138 : 			if (0 == byPortalID)

  000ce	0f b6 45 73	 movzx	 eax, BYTE PTR _byPortalID$37[ebp]
  000d2	85 c0		 test	 eax, eax
  000d4	75 05		 jne	 SHORT $LN11@RefreshPor

; 1139 : 				break;

  000d6	e9 91 00 00 00	 jmp	 $LN6@RefreshPor
$LN11@RefreshPor:

; 1141 : 			if (m_kSet_ShowingPortalID.end() == m_kSet_ShowingPortalID.find(byPortalID))

  000db	0f b6 45 73	 movzx	 eax, BYTE PTR _byPortalID$37[ebp]
  000df	89 45 1c	 mov	 DWORD PTR $T21[ebp], eax
  000e2	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	05 98 00 00 00	 add	 eax, 152		; 00000098H
  000ea	89 45 54	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000ed	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000f0	89 45 20	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000f3	8b 45 20	 mov	 eax, DWORD PTR $T22[ebp]
  000f6	89 45 18	 mov	 DWORD PTR $T20[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  000f9	8d 45 1c	 lea	 eax, DWORD PTR $T21[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	e8 00 00 00 00	 call	 ??$_Find@H@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@HPAX@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Find<int>
  00105	89 45 14	 mov	 DWORD PTR ___param0$[ebp], eax
  00108	ff 75 18	 push	 DWORD PTR $T20[ebp]
  0010b	ff 75 14	 push	 DWORD PTR ___param0$[ebp]
  0010e	8d 4d 0c	 lea	 ecx, DWORD PTR $T19[ebp]
  00111	e8 00 00 00 00	 call	 ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@HPAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@H@std@@@1@@Z ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<int> >,std::_Iterator_base0>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1141 : 			if (m_kSet_ShowingPortalID.end() == m_kSet_ShowingPortalID.find(byPortalID))

  00116	8d 45 a4	 lea	 eax, DWORD PTR $T3[ebp]
  00119	50		 push	 eax
  0011a	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  00123	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@2@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::end
  00128	89 45 10	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  0012b	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
  00130	3b 45 0c	 cmp	 eax, DWORD PTR $T19[ebp]
  00133	75 09		 jne	 SHORT $LN104@RefreshPor
  00135	c7 45 50 01 00
	00 00		 mov	 DWORD PTR tv278[ebp], 1
  0013c	eb 04		 jmp	 SHORT $LN105@RefreshPor
$LN104@RefreshPor:
  0013e	83 65 50 00	 and	 DWORD PTR tv278[ebp], 0
$LN105@RefreshPor:
  00142	8a 45 50	 mov	 al, BYTE PTR tv278[ebp]
  00145	88 45 72	 mov	 BYTE PTR $T36[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1141 : 			if (m_kSet_ShowingPortalID.end() == m_kSet_ShowingPortalID.find(byPortalID))

  00148	0f b6 45 72	 movzx	 eax, BYTE PTR $T36[ebp]
  0014c	85 c0		 test	 eax, eax
  0014e	74 05		 je	 SHORT $LN12@RefreshPor

; 1142 : 				continue;

  00150	e9 5c ff ff ff	 jmp	 $LN5@RefreshPor
$LN12@RefreshPor:

; 1143 : 
; 1144 : 			kSet_ShowingObjectInstance.insert(pInstance);

  00155	8d 45 08	 lea	 eax, DWORD PTR _pInstance$18[ebp]
  00158	50		 push	 eax
  00159	8d 45 9c	 lea	 eax, DWORD PTR $T2[ebp]
  0015c	50		 push	 eax
  0015d	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  00160	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@_N@1@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::insert<0,0>

; 1145 : 			break;

  00165	eb 05		 jmp	 SHORT $LN6@RefreshPor

; 1146 : 		}

  00167	e9 45 ff ff ff	 jmp	 $LN5@RefreshPor
$LN6@RefreshPor:

; 1147 : 	}

  0016c	e9 d6 fe ff ff	 jmp	 $LN2@RefreshPor
$LN3@RefreshPor:

; 1148 : 
; 1149 : 	///////////////////////////////////////////////////////////////////////////////////////////////
; 1150 : 
; 1151 : 	m_TreeCloneInstaceVector.clear();

  00171	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00177	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear

; 1152 : 	m_ThingCloneInstaceVector.clear();

  0017c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	83 c1 28	 add	 ecx, 40			; 00000028H
  00182	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 1153 : 	m_DungeonBlockCloneInstanceVector.clear();

  00187	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	83 c1 34	 add	 ecx, 52			; 00000034H
  0018d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00192	83 65 60 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00196	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00199	83 c0 10	 add	 eax, 16			; 00000010H
  0019c	89 45 4c	 mov	 DWORD PTR __My_data$28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0019f	8b 45 4c	 mov	 eax, DWORD PTR __My_data$28[ebp]
  001a2	89 45 04	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  001a5	8b 45 4c	 mov	 eax, DWORD PTR __My_data$28[ebp]
  001a8	8b 00		 mov	 eax, DWORD PTR [eax]
  001aa	89 45 00	 mov	 DWORD PTR ___param0$[ebp], eax
  001ad	ff 75 04	 push	 DWORD PTR $T17[ebp]
  001b0	ff 75 00	 push	 DWORD PTR ___param0$[ebp]
  001b3	8d 4d f0	 lea	 ecx, DWORD PTR $T16[ebp]
  001b6	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >
  001bb	8d 45 f0	 lea	 eax, DWORD PTR $T16[ebp]
  001be	89 45 ec	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1156 : 	for(it = m_ObjectInstanceVector.begin(); it != m_ObjectInstanceVector.end(); ++it)

  001c1	8b 45 ec	 mov	 eax, DWORD PTR $T15[ebp]
  001c4	8b 00		 mov	 eax, DWORD PTR [eax]
  001c6	89 45 60	 mov	 DWORD PTR _it$[ebp], eax
  001c9	eb 09		 jmp	 SHORT $LN10@RefreshPor
$LN8@RefreshPor:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  001cb	8b 45 60	 mov	 eax, DWORD PTR _it$[ebp]
  001ce	83 c0 04	 add	 eax, 4
  001d1	89 45 60	 mov	 DWORD PTR _it$[ebp], eax
$LN10@RefreshPor:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  001d4	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	83 c0 10	 add	 eax, 16			; 00000010H
  001da	89 45 48	 mov	 DWORD PTR __My_data$27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001dd	8b 45 48	 mov	 eax, DWORD PTR __My_data$27[ebp]
  001e0	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  001e3	8b 45 48	 mov	 eax, DWORD PTR __My_data$27[ebp]
  001e6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e9	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  001ec	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  001ef	89 45 e4	 mov	 DWORD PTR $T14[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  001f2	8d 45 e4	 lea	 eax, DWORD PTR $T14[ebp]
  001f5	89 45 e0	 mov	 DWORD PTR $T13[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  001f8	8b 45 e0	 mov	 eax, DWORD PTR $T13[ebp]
  001fb	8b 4d 60	 mov	 ecx, DWORD PTR _it$[ebp]
  001fe	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00200	75 09		 jne	 SHORT $LN212@RefreshPor
  00202	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv423[ebp], 1
  00209	eb 04		 jmp	 SHORT $LN213@RefreshPor
$LN212@RefreshPor:
  0020b	83 65 44 00	 and	 DWORD PTR tv423[ebp], 0
$LN213@RefreshPor:
  0020f	8a 45 44	 mov	 al, BYTE PTR tv423[ebp]
  00212	88 45 71	 mov	 BYTE PTR $T35[ebp], al

; 153  :         return !(*this == _Right);

  00215	0f b6 45 71	 movzx	 eax, BYTE PTR $T35[ebp]
  00219	85 c0		 test	 eax, eax
  0021b	75 09		 jne	 SHORT $LN207@RefreshPor
  0021d	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv409[ebp], 1
  00224	eb 04		 jmp	 SHORT $LN208@RefreshPor
$LN207@RefreshPor:
  00226	83 65 40 00	 and	 DWORD PTR tv409[ebp], 0
$LN208@RefreshPor:
  0022a	8a 45 40	 mov	 al, BYTE PTR tv409[ebp]
  0022d	88 45 70	 mov	 BYTE PTR $T34[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1156 : 	for(it = m_ObjectInstanceVector.begin(); it != m_ObjectInstanceVector.end(); ++it)

  00230	0f b6 45 70	 movzx	 eax, BYTE PTR $T34[ebp]
  00234	85 c0		 test	 eax, eax
  00236	0f 84 e8 00 00
	00		 je	 $LN9@RefreshPor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  0023c	8b 45 60	 mov	 eax, DWORD PTR _it$[ebp]
  0023f	89 45 dc	 mov	 DWORD PTR $T12[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  00242	8b 45 dc	 mov	 eax, DWORD PTR $T12[ebp]
  00245	89 45 d8	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1158 : 		TObjectInstance * pObjectInstance = *it;

  00248	8b 45 d8	 mov	 eax, DWORD PTR $T11[ebp]
  0024b	8b 00		 mov	 eax, DWORD PTR [eax]
  0024d	89 45 68	 mov	 DWORD PTR _pObjectInstance$32[ebp], eax

; 1159 : 
; 1160 : 		if (m_bPortalEnable)

  00250	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00253	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  0025a	74 5f		 je	 SHORT $LN13@RefreshPor
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0025c	8d 45 34	 lea	 eax, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0025f	89 45 d4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00262	8b 45 d4	 mov	 eax, DWORD PTR $T10[ebp]
  00265	89 45 d0	 mov	 DWORD PTR __Scary$9[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00268	8b 45 d0	 mov	 eax, DWORD PTR __Scary$9[ebp]
  0026b	8b 00		 mov	 eax, DWORD PTR [eax]
  0026d	89 45 cc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00270	8b 45 cc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00273	89 45 c8	 mov	 DWORD PTR $T8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00276	8d 45 c8	 lea	 eax, DWORD PTR $T8[ebp]
  00279	89 45 c4	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1162 : 			if (kSet_ShowingObjectInstance.end() == kSet_ShowingObjectInstance.find(pObjectInstance))

  0027c	8d 45 68	 lea	 eax, DWORD PTR _pObjectInstance$32[ebp]
  0027f	50		 push	 eax
  00280	8d 45 a8	 lea	 eax, DWORD PTR $T4[ebp]
  00283	50		 push	 eax
  00284	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  00287	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@2@ABQAUSObjectInstance@CArea@@@Z ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::find
  0028c	89 45 c0	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  0028f	8b 45 c4	 mov	 eax, DWORD PTR $T7[ebp]
  00292	8b 4d c0	 mov	 ecx, DWORD PTR __Right$[ebp]
  00295	8b 00		 mov	 eax, DWORD PTR [eax]
  00297	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00299	75 09		 jne	 SHORT $LN280@RefreshPor
  0029b	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR tv458[ebp], 1
  002a2	eb 04		 jmp	 SHORT $LN281@RefreshPor
$LN280@RefreshPor:
  002a4	83 65 3c 00	 and	 DWORD PTR tv458[ebp], 0
$LN281@RefreshPor:
  002a8	8a 45 3c	 mov	 al, BYTE PTR tv458[ebp]
  002ab	88 45 6f	 mov	 BYTE PTR $T33[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1162 : 			if (kSet_ShowingObjectInstance.end() == kSet_ShowingObjectInstance.find(pObjectInstance))

  002ae	0f b6 45 6f	 movzx	 eax, BYTE PTR $T33[ebp]
  002b2	85 c0		 test	 eax, eax
  002b4	74 05		 je	 SHORT $LN13@RefreshPor

; 1163 : 				continue;

  002b6	e9 10 ff ff ff	 jmp	 $LN8@RefreshPor
$LN13@RefreshPor:

; 1164 : 		}
; 1165 : 
; 1166 : 		if (prt::PROPERTY_TYPE_TREE == pObjectInstance->dwType)

  002bb	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  002be	83 78 04 01	 cmp	 DWORD PTR [eax+4], 1
  002c2	75 19		 jne	 SHORT $LN15@RefreshPor

; 1169 : 			m_TreeCloneInstaceVector.push_back(pObjectInstance->pTree);

  002c4	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  002c7	83 c0 0c	 add	 eax, 12			; 0000000cH
  002ca	89 45 bc	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002cd	ff 75 bc	 push	 DWORD PTR __Val$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1169 : 			m_TreeCloneInstaceVector.push_back(pObjectInstance->pTree);

  002d0	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	83 c1 1c	 add	 ecx, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002d6	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCSpeedTreeWrapper@@@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXABQAVCSpeedTreeWrapper@@@Z ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::emplace_back<CSpeedTreeWrapper * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1170 : 		}

  002db	eb 42		 jmp	 SHORT $LN16@RefreshPor
$LN15@RefreshPor:

; 1171 : 		else if (prt::PROPERTY_TYPE_BUILDING == pObjectInstance->dwType)

  002dd	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  002e0	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  002e4	75 19		 jne	 SHORT $LN17@RefreshPor

; 1174 : 			m_ThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  002e6	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  002e9	83 c0 14	 add	 eax, 20			; 00000014H
  002ec	89 45 b8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002ef	ff 75 b8	 push	 DWORD PTR __Val$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1174 : 			m_ThingCloneInstaceVector.push_back(pObjectInstance->pThingInstance);

  002f2	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  002f5	83 c1 28	 add	 ecx, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  002f8	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1175 : 		}

  002fd	eb 20		 jmp	 SHORT $LN16@RefreshPor
$LN17@RefreshPor:

; 1176 : 		else if (prt::PROPERTY_TYPE_DUNGEON_BLOCK == pObjectInstance->dwType)

  002ff	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  00302	83 78 04 05	 cmp	 DWORD PTR [eax+4], 5
  00306	75 17		 jne	 SHORT $LN16@RefreshPor

; 1179 : 			m_DungeonBlockCloneInstanceVector.push_back(pObjectInstance->pDungeonBlock);

  00308	8b 45 68	 mov	 eax, DWORD PTR _pObjectInstance$32[ebp]
  0030b	83 c0 24	 add	 eax, 36			; 00000024H
  0030e	89 45 b4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00311	ff 75 b4	 push	 DWORD PTR __Val$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1179 : 			m_DungeonBlockCloneInstanceVector.push_back(pObjectInstance->pDungeonBlock);

  00314	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00317	83 c1 34	 add	 ecx, 52			; 00000034H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0031a	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCDungeonBlock@@@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXABQAVCDungeonBlock@@@Z ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::emplace_back<CDungeonBlock * const &>
$LN16@RefreshPor:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1181 : 	}

  0031f	e9 a7 fe ff ff	 jmp	 $LN8@RefreshPor
$LN9@RefreshPor:

; 1182 : }

  00324	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00328	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  0032b	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tset_traits@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >::~_Tree<std::_Tset_traits<CArea::SObjectInstance *,std::less<CArea::SObjectInstance *>,std::allocator<CArea::SObjectInstance *>,0> >
  00330	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00333	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0033a	59		 pop	 ecx
  0033b	83 c5 78	 add	 ebp, 120		; 00000078H
  0033e	c9		 leave
  0033f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?RefreshPortal@CArea@@QAEXXZ$0:
  00000	8d 4d 34	 lea	 ecx, DWORD PTR _kSet_ShowingObjectInstance$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$set@PAUSObjectInstance@CArea@@U?$less@PAUSObjectInstance@CArea@@@std@@V?$allocator@PAUSObjectInstance@CArea@@@4@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?RefreshPortal@CArea@@QAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?RefreshPortal@CArea@@QAEXXZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?RefreshPortal@CArea@@QAEXXZ ENDP			; CArea::RefreshPortal
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?AddShowingPortalID@CArea@@QAEXH@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
_iNum$ = 8						; size = 4
?AddShowingPortalID@CArea@@QAEXH@Z PROC			; CArea::AddShowingPortalID, COMDAT
; _this$ = ecx

; 1122 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1123 : 	m_kSet_ShowingPortalID.insert(iNum);

  00009	8d 45 08	 lea	 eax, DWORD PTR _iNum$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  0001a	e8 00 00 00 00	 call	 ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@@std@@_N@1@ABH@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::insert<0,0>

; 1124 : }

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?AddShowingPortalID@CArea@@QAEXH@Z ENDP			; CArea::AddShowingPortalID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?ClearPortal@CArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearPortal@CArea@@QAEXXZ PROC				; CArea::ClearPortal, COMDAT
; _this$ = ecx

; 1117 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1118 : 	m_kSet_ShowingPortalID.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  00010	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::clear

; 1119 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?ClearPortal@CArea@@QAEXXZ ENDP				; CArea::ClearPortal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?EnablePortal@CArea@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 4
?EnablePortal@CArea@@QAEXH@Z PROC			; CArea::EnablePortal, COMDAT
; _this$ = ecx

; 1109 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1110 : 	if (m_bPortalEnable == bFlag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [eax+148]
  00010	3b 45 08	 cmp	 eax, DWORD PTR _bFlag$[ebp]
  00013	75 02		 jne	 SHORT $LN2@EnablePort

; 1111 : 		return;

  00015	eb 0c		 jmp	 SHORT $LN1@EnablePort
$LN2@EnablePort:

; 1112 : 
; 1113 : 	m_bPortalEnable = bFlag;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR _bFlag$[ebp]
  0001d	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx
$LN1@EnablePort:

; 1114 : }

  00023	c9		 leave
  00024	c2 04 00	 ret	 4
?EnablePortal@CArea@@QAEXH@Z ENDP			; CArea::EnablePortal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?GetObjectInstancePointer@CArea@@QBE?B_NABKPAPBUSObjectInstance@1@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Pos$ = -20						; size = 4
__My_data$2 = -16					; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$4 = -4					; size = 4
_dwIndex$ = 8						; size = 4
_ppObjectInstance$ = 12					; size = 4
?GetObjectInstancePointer@CArea@@QBE?B_NABKPAPBUSObjectInstance@1@@Z PROC ; CArea::GetObjectInstancePointer, COMDAT
; _this$ = ecx

; 1100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 02	 sar	 eax, 2
  00020	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1101 : 	if (dwIndex >= m_ObjectInstanceVector.size())

  00023	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	3b 45 f4	 cmp	 eax, DWORD PTR $T3[ebp]
  0002b	72 04		 jb	 SHORT $LN2@GetObjectI

; 1102 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	eb 2b		 jmp	 SHORT $LN1@GetObjectI
$LN2@GetObjectI:

; 1104 : 	*ppObjectInstance = m_ObjectInstanceVector[dwIndex];

  00031	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 ec	 mov	 DWORD PTR __Pos$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	83 c0 10	 add	 eax, 16			; 00000010H
  0003f	89 45 f0	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00042	8b 45 f0	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	8b 4d ec	 mov	 ecx, DWORD PTR __Pos$[ebp]
  0004a	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0004d	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1104 : 	*ppObjectInstance = m_ObjectInstanceVector[dwIndex];

  00050	8b 45 0c	 mov	 eax, DWORD PTR _ppObjectInstance$[ebp]
  00053	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00056	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 1105 : 	return true;

  0005a	b0 01		 mov	 al, 1
$LN1@GetObjectI:

; 1106 : }

  0005c	c9		 leave
  0005d	c2 08 00	 ret	 8
?GetObjectInstancePointer@CArea@@QBE?B_NABKPAPBUSObjectInstance@1@@Z ENDP ; CArea::GetObjectInstancePointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?GetObjectInstanceCount@CArea@@QBE?BKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
?GetObjectInstanceCount@CArea@@QBE?BKXZ PROC		; CArea::GetObjectInstanceCount, COMDAT
; _this$ = ecx

; 1095 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 10	 add	 eax, 16			; 00000010H
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	c1 f8 02	 sar	 eax, 2
  00020	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1096 : 	return m_ObjectInstanceVector.size();

  00023	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 1097 : }

  00026	c9		 leave
  00027	c3		 ret	 0
?GetObjectInstanceCount@CArea@@QBE?BKXZ ENDP		; CArea::GetObjectInstanceCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?GetObjectDataPointer@CArea@@QBE_NKPAPBUSObjectData@1@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__My_data$2 = -8					; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_ppObjectData$ = 12					; size = 4
?GetObjectDataPointer@CArea@@QBE_NKPAPBUSObjectData@1@@Z PROC ; CArea::GetObjectDataPointer, COMDAT
; _this$ = ecx

; 1083 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1084 : 	if (!CheckObjectIndex(dwIndex))

  00009	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?CheckObjectIndex@CArea@@IBE_NK@Z ; CArea::CheckObjectIndex
  00014	0f b6 c0	 movzx	 eax, al
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $LN2@GetObjectD

; 1085 : 	{
; 1086 : 		assert(!"Setting Object Index is corrupted!");
; 1087 : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 1f		 jmp	 SHORT $LN1@GetObjectD
$LN2@GetObjectD:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1508 :         auto& _My_data = _Mypair._Myval2;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c0 04	 add	 eax, 4
  00025	89 45 f8	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1509 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1510 :         _STL_VERIFY(
; 1511 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1512 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1513 : 
; 1514 :         return _My_data._Myfirst[_Pos];

  00028	6b 45 08 30	 imul	 eax, DWORD PTR _dwIndex$[ebp], 48
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  0002f	03 01		 add	 eax, DWORD PTR [ecx]
  00031	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1090 : 	*ppObjectData = &m_ObjectDataVector[dwIndex];

  00034	8b 45 0c	 mov	 eax, DWORD PTR _ppObjectData$[ebp]
  00037	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0003a	89 08		 mov	 DWORD PTR [eax], ecx

; 1091 : 	return true;

  0003c	b0 01		 mov	 al, 1
$LN1@GetObjectD:

; 1092 : }

  0003e	c9		 leave
  0003f	c2 08 00	 ret	 8
?GetObjectDataPointer@CArea@@QBE_NKPAPBUSObjectData@1@@Z ENDP ; CArea::GetObjectDataPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?GetObjectDataCount@CArea@@QAEKXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$2 = -4					; size = 4
?GetObjectDataCount@CArea@@QAEKXZ PROC			; CArea::GetObjectDataCount, COMDAT
; _this$ = ecx

; 1078 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 fc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00012	8b 45 fc	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001d	99		 cdq
  0001e	6a 30		 push	 48			; 00000030H
  00020	59		 pop	 ecx
  00021	f7 f9		 idiv	 ecx
  00023	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1079 : 	return m_ObjectDataVector.size();

  00026	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]

; 1080 : }

  00029	c9		 leave
  0002a	c3		 ret	 0
?GetObjectDataCount@CArea@@QAEKXZ ENDP			; CArea::GetObjectDataCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Load@CArea@@QAE_NPBD@Z
_TEXT	SEGMENT
tv130 = -136						; size = 4
tv65 = -132						; size = 4
tv95 = -128						; size = 4
tv133 = -124						; size = 4
_this$ = -120						; size = 4
$T2 = -113						; size = 1
$T3 = -112						; size = 24
$T4 = -88						; size = 24
_strObjectDataFileName$ = -64				; size = 24
_strAmbienceDataFileName$ = -40				; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_szPathName$ = 8					; size = 4
?Load@CArea@@QAE_NPBD@Z PROC				; CArea::Load, COMDAT
; _this$ = ecx

; 880  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Load@CArea@@QAE_NPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx

; 881  : 	Clear();

  0002b	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?Clear@CArea@@QAEXXZ	; CArea::Clear

; 882  : 
; 883  : 	std::string strObjectDataFileName = c_szPathName + std::string("AreaData.txt");

  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0N@IIOKECFB@AreaData?4txt@
  00038	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  0003b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00040	89 45 84	 mov	 DWORD PTR tv133[ebp], eax
  00043	8b 45 84	 mov	 eax, DWORD PTR tv133[ebp]
  00046	89 45 80	 mov	 DWORD PTR tv95[ebp], eax
  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004d	ff 75 80	 push	 DWORD PTR tv95[ebp]
  00050	ff 75 08	 push	 DWORD PTR _c_szPathName$[ebp]
  00053	8d 45 c0	 lea	 eax, DWORD PTR _strObjectDataFileName$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00063	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  00066	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 884  : 	std::string strAmbienceDataFileName = c_szPathName + std::string("AreaAmbienceData.txt");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@EMGBEFOB@AreaAmbienceData?4txt@
  00070	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  00073	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00078	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv65[ebp], eax
  0007e	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  00084	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], eax
  0008a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0008e	ff b5 78 ff ff
	ff		 push	 DWORD PTR tv130[ebp]
  00094	ff 75 08	 push	 DWORD PTR _c_szPathName$[ebp]
  00097	8d 45 d8	 lea	 eax, DWORD PTR _strAmbienceDataFileName$[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000a7	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 886  : 	__Load_LoadObject(strObjectDataFileName.c_str());

  000af	8d 4d c0	 lea	 ecx, DWORD PTR _strObjectDataFileName$[ebp]
  000b2	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000b7	50		 push	 eax
  000b8	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?__Load_LoadObject@CArea@@IAE_NPBD@Z ; CArea::__Load_LoadObject

; 887  : 	__Load_LoadAmbience(strAmbienceDataFileName.c_str());

  000c0	8d 4d d8	 lea	 ecx, DWORD PTR _strAmbienceDataFileName$[ebp]
  000c3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000c8	50		 push	 eax
  000c9	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?__Load_LoadAmbience@CArea@@IAE_NPBD@Z ; CArea::__Load_LoadAmbience

; 888  : 	__Load_BuildObjectInstances();

  000d1	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?__Load_BuildObjectInstances@CArea@@IAEXXZ ; CArea::__Load_BuildObjectInstances

; 890  : 	return true;

  000d9	c6 45 8f 01	 mov	 BYTE PTR $T2[ebp], 1
  000dd	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000e1	8d 4d d8	 lea	 ecx, DWORD PTR _strAmbienceDataFileName$[ebp]
  000e4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 890  : 	return true;

  000e9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ed	8d 4d c0	 lea	 ecx, DWORD PTR _strObjectDataFileName$[ebp]
  000f0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 890  : 	return true;

  000f5	8a 45 8f	 mov	 al, BYTE PTR $T2[ebp]

; 891  : }

  000f8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00102	59		 pop	 ecx
  00103	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00106	33 cd		 xor	 ecx, ebp
  00108	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0010d	c9		 leave
  0010e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR _strObjectDataFileName$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$2:
  00010	8d 4d 90	 lea	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Load@CArea@@QAE_NPBD@Z$3:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR _strAmbienceDataFileName$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$?Load@CArea@@QAE_NPBD@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Load@CArea@@QAE_NPBD@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Load@CArea@@QAE_NPBD@Z ENDP				; CArea::Load
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Clear@CArea@@QAEXXZ
_TEXT	SEGMENT
$T1 = -120						; size = 4
$T2 = -116						; size = 4
_rkEftMgr$ = -112					; size = 4
_pEffectInstance$3 = -108				; size = 4
$T4 = -104						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
$T8 = -88						; size = 4
__Right$ = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
$T12 = -68						; size = 4
___param0$ = -64					; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
$T15 = -52						; size = 4
___param0$ = -48					; size = 4
$T16 = -44						; size = 4
tv393 = -40						; size = 4
tv412 = -36						; size = 4
tv239 = -32						; size = 4
tv248 = -28						; size = 4
__My_data$17 = -24					; size = 4
__My_data$18 = -20					; size = 4
_i$ = -16						; size = 4
_it$ = -12						; size = 4
$T19 = -8						; size = 1
$T20 = -7						; size = 1
$T21 = -6						; size = 1
$T22 = -5						; size = 1
_this$ = -4						; size = 4
?Clear@CArea@@QAEXXZ PROC				; CArea::Clear, COMDAT
; _this$ = ecx

; 1187 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f4 00	 and	 DWORD PTR _it$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 c0 10	 add	 eax, 16			; 00000010H
  00013	89 45 ec	 mov	 DWORD PTR __My_data$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00016	8b 45 ec	 mov	 eax, DWORD PTR __My_data$18[ebp]
  00019	89 45 d4	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$18[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 d0	 mov	 DWORD PTR ___param0$[ebp], eax
  00024	ff 75 d4	 push	 DWORD PTR $T16[ebp]
  00027	ff 75 d0	 push	 DWORD PTR ___param0$[ebp]
  0002a	8d 4d cc	 lea	 ecx, DWORD PTR $T15[ebp]
  0002d	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >
  00032	8d 45 cc	 lea	 eax, DWORD PTR $T15[ebp]
  00035	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1190 : 	for (it = m_ObjectInstanceVector.begin();it!=m_ObjectInstanceVector.end();++it)

  00038	8b 45 c8	 mov	 eax, DWORD PTR $T14[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	89 45 f4	 mov	 DWORD PTR _it$[ebp], eax
  00040	eb 09		 jmp	 SHORT $LN4@Clear
$LN2@Clear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00042	8b 45 f4	 mov	 eax, DWORD PTR _it$[ebp]
  00045	83 c0 04	 add	 eax, 4
  00048	89 45 f4	 mov	 DWORD PTR _it$[ebp], eax
$LN4@Clear:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c0 10	 add	 eax, 16			; 00000010H
  00051	89 45 e8	 mov	 DWORD PTR __My_data$17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00054	8b 45 e8	 mov	 eax, DWORD PTR __My_data$17[ebp]
  00057	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0005a	8b 45 e8	 mov	 eax, DWORD PTR __My_data$17[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	89 45 c0	 mov	 DWORD PTR ___param0$[ebp], eax
  00063	ff 75 c4	 push	 DWORD PTR $T13[ebp]
  00066	ff 75 c0	 push	 DWORD PTR ___param0$[ebp]
  00069	8d 4d bc	 lea	 ecx, DWORD PTR $T12[ebp]
  0006c	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@@std@@QAE@PAPAUSObjectInstance@CArea@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> > >
  00071	8d 45 bc	 lea	 eax, DWORD PTR $T12[ebp]
  00074	89 45 b8	 mov	 DWORD PTR $T11[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00077	8b 45 b8	 mov	 eax, DWORD PTR $T11[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR _it$[ebp]
  0007d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0007f	75 09		 jne	 SHORT $LN46@Clear
  00081	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv248[ebp], 1
  00088	eb 04		 jmp	 SHORT $LN47@Clear
$LN46@Clear:
  0008a	83 65 e4 00	 and	 DWORD PTR tv248[ebp], 0
$LN47@Clear:
  0008e	8a 45 e4	 mov	 al, BYTE PTR tv248[ebp]
  00091	88 45 fb	 mov	 BYTE PTR $T22[ebp], al

; 153  :         return !(*this == _Right);

  00094	0f b6 45 fb	 movzx	 eax, BYTE PTR $T22[ebp]
  00098	85 c0		 test	 eax, eax
  0009a	75 09		 jne	 SHORT $LN41@Clear
  0009c	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv239[ebp], 1
  000a3	eb 04		 jmp	 SHORT $LN42@Clear
$LN41@Clear:
  000a5	83 65 e0 00	 and	 DWORD PTR tv239[ebp], 0
$LN42@Clear:
  000a9	8a 45 e0	 mov	 al, BYTE PTR tv239[ebp]
  000ac	88 45 fa	 mov	 BYTE PTR $T21[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1190 : 	for (it = m_ObjectInstanceVector.begin();it!=m_ObjectInstanceVector.end();++it)

  000af	0f b6 45 fa	 movzx	 eax, BYTE PTR $T21[ebp]
  000b3	85 c0		 test	 eax, eax
  000b5	74 1e		 je	 SHORT $LN3@Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000b7	8b 45 f4	 mov	 eax, DWORD PTR _it$[ebp]
  000ba	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000bd	8b 45 b4	 mov	 eax, DWORD PTR $T10[ebp]
  000c0	89 45 b0	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1191 : 		__Clear_DestroyObjectInstance(*it);

  000c3	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  000c6	ff 30		 push	 DWORD PTR [eax]
  000c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?__Clear_DestroyObjectInstance@CArea@@IAEXPAUSObjectInstance@1@@Z ; CArea::__Clear_DestroyObjectInstance
  000d0	e9 6d ff ff ff	 jmp	 $LN2@Clear
$LN3@Clear:

; 1192 : 
; 1193 : 	m_ObjectDataVector.clear();

  000d5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	83 c1 04	 add	 ecx, 4
  000db	e8 00 00 00 00	 call	 ?clear@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::clear

; 1194 : 	m_ObjectInstanceVector.clear();

  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	83 c1 10	 add	 ecx, 16			; 00000010H
  000e6	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::clear

; 1195 : 
; 1196 : 	// Clones
; 1197 : 	m_TreeCloneInstaceVector.clear();

  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	83 c1 1c	 add	 ecx, 28			; 0000001cH
  000f1	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear

; 1198 : 	m_ThingCloneInstaceVector.clear();

  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f9	83 c1 28	 add	 ecx, 40			; 00000028H
  000fc	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 1199 : 	m_DungeonBlockCloneInstanceVector.clear();

  00101	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	83 c1 34	 add	 ecx, 52			; 00000034H
  00107	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::clear

; 1200 : 	m_AniThingCloneInstanceVector.clear();

  0010c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	83 c1 40	 add	 ecx, 64			; 00000040H
  00112	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 1201 : 	m_ShadowThingCloneInstaceVector.clear();

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0011d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 1202 : 	m_AmbienceCloneInstanceVector.clear();

  00122	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	83 c1 58	 add	 ecx, 88			; 00000058H
  00128	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::clear

; 1203 : 	m_GraphicThingInstanceCRCMap.clear();

  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	83 c1 64	 add	 ecx, 100		; 00000064H
  00133	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::clear

; 1204 : 	m_kRenderedThingInstanceCRCWithNumberVector.clear();

  00138	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0013e	e8 00 00 00 00	 call	 ?clear@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::clear

; 1205 : 	m_kRenderedGrapphicThingInstanceVector.clear();

  00143	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	83 c1 78	 add	 ecx, 120		; 00000078H
  00149	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::clear

; 1206 : 
; 1207 : 	m_bPortalEnable = FALSE;

  0014e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00151	83 a0 94 00 00
	00 00		 and	 DWORD PTR [eax+148], 0

; 1208 : 	ClearPortal();

  00158	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015b	e8 00 00 00 00	 call	 ?ClearPortal@CArea@@QAEXXZ ; CArea::ClearPortal

; 1209 : 
; 1210 : 	CEffectManager& rkEftMgr=CEffectManager::Instance();

  00160	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00165	89 45 90	 mov	 DWORD PTR _rkEftMgr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 37   :     _Tree_unchecked_const_iterator() noexcept : _Ptr() {}

  00168	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1213 : 	for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end(); ++i)

  0016c	8d 45 8c	 lea	 eax, DWORD PTR $T2[ebp]
  0016f	50		 push	 eax
  00170	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00173	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00179	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::begin
  0017e	8b 00		 mov	 eax, DWORD PTR [eax]
  00180	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
  00183	eb 08		 jmp	 SHORT $LN7@Clear
$LN5@Clear:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  00185	8d 4d f0	 lea	 ecx, DWORD PTR _i$[ebp]
  00188	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++
$LN7@Clear:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1213 : 	for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end(); ++i)

  0018d	8d 45 88	 lea	 eax, DWORD PTR $T1[ebp]
  00190	50		 push	 eax
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0019a	e8 00 00 00 00	 call	 ?end@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::end
  0019f	89 45 ac	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  001a2	8b 45 ac	 mov	 eax, DWORD PTR __Right$[ebp]
  001a5	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  001a8	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001aa	75 09		 jne	 SHORT $LN270@Clear
  001ac	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv412[ebp], 1
  001b3	eb 04		 jmp	 SHORT $LN271@Clear
$LN270@Clear:
  001b5	83 65 dc 00	 and	 DWORD PTR tv412[ebp], 0
$LN271@Clear:
  001b9	8a 45 dc	 mov	 al, BYTE PTR tv412[ebp]
  001bc	88 45 f9	 mov	 BYTE PTR $T20[ebp], al

; 236  :         return !(*this == _Right);

  001bf	0f b6 45 f9	 movzx	 eax, BYTE PTR $T20[ebp]
  001c3	85 c0		 test	 eax, eax
  001c5	75 09		 jne	 SHORT $LN265@Clear
  001c7	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv393[ebp], 1
  001ce	eb 04		 jmp	 SHORT $LN266@Clear
$LN265@Clear:
  001d0	83 65 d8 00	 and	 DWORD PTR tv393[ebp], 0
$LN266@Clear:
  001d4	8a 45 d8	 mov	 al, BYTE PTR tv393[ebp]
  001d7	88 45 f8	 mov	 BYTE PTR $T19[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1213 : 	for (i = m_EffectInstanceMap.begin(); i != m_EffectInstanceMap.end(); ++i)

  001da	0f b6 45 f8	 movzx	 eax, BYTE PTR $T19[ebp]
  001de	85 c0		 test	 eax, eax
  001e0	74 3a		 je	 SHORT $LN6@Clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  001e2	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001e5	83 c0 10	 add	 eax, 16			; 00000010H
  001e8	89 45 a8	 mov	 DWORD PTR $T8[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  001eb	8b 45 a8	 mov	 eax, DWORD PTR $T8[ebp]
  001ee	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  001f1	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  001f4	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  001f7	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
  001fa	89 45 9c	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  001fd	8b 45 9c	 mov	 eax, DWORD PTR $T5[ebp]
  00200	89 45 98	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1215 : 		CEffectInstance * pEffectInstance = i->second;

  00203	8b 45 98	 mov	 eax, DWORD PTR $T4[ebp]
  00206	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00209	89 45 94	 mov	 DWORD PTR _pEffectInstance$3[ebp], eax

; 1216 : 		rkEftMgr.DestroyUnsafeEffectInstance(pEffectInstance);		

  0020c	ff 75 94	 push	 DWORD PTR _pEffectInstance$3[ebp]
  0020f	8b 4d 90	 mov	 ecx, DWORD PTR _rkEftMgr$[ebp]
  00212	e8 00 00 00 00	 call	 ?DestroyUnsafeEffectInstance@CEffectManager@@QAE_NPAVCEffectInstance@@@Z ; CEffectManager::DestroyUnsafeEffectInstance

; 1217 : 	}

  00217	e9 69 ff ff ff	 jmp	 $LN5@Clear
$LN6@Clear:

; 1218 : 	m_EffectInstanceMap.clear();

  0021c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0021f	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00225	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::clear

; 1219 : }

  0022a	c9		 leave
  0022b	c3		 ret	 0
?Clear@CArea@@QAEXXZ ENDP				; CArea::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pOwnerOutdoorMap$ = 8					; size = 4
?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z PROC	; CArea::SetMapOutDoor, COMDAT
; _this$ = ecx

; 1292 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1293 : 	m_pOwnerOutdoorMap=pOwnerOutdoorMap;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pOwnerOutdoorMap$[ebp]
  0000d	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx

; 1294 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetMapOutDoor@CArea@@QAEXPAVCMapOutdoor@@@Z ENDP	; CArea::SetMapOutDoor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
___param0$ = -48					; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
___param0$ = -36					; size = 4
_pkThingInst$11 = -32					; size = 4
tv188 = -28						; size = 4
tv202 = -24						; size = 4
__My_data$12 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$13 = -12					; size = 4
_i$ = -8						; size = 4
$T14 = -2						; size = 1
$T15 = -1						; size = 1
_rkVct_pkBlendThingInst$ = 8				; size = 4
?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z PROC ; CArea::CollectBlendRenderingObject, COMDAT
; _this$ = ecx

; 192  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 c0 28	 add	 eax, 40			; 00000028H
  00013	89 45 f4	 mov	 DWORD PTR __My_data$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00016	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00019	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00024	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00027	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  0002d	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 194  : 	for (i=m_ThingCloneInstaceVector.begin(); i!=m_ThingCloneInstaceVector.end(); ++i)

  00030	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00038	eb 09		 jmp	 SHORT $LN4@CollectBle
$LN2@CollectBle:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CollectBle:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 28	 add	 eax, 40			; 00000028H
  00049	89 45 ec	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0004f	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00052	8b 45 ec	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	89 45 d0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005b	8b 45 d0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0005e	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00061	8d 45 cc	 lea	 eax, DWORD PTR $T8[ebp]
  00064	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00067	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 09		 jne	 SHORT $LN57@CollectBle
  00071	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv202[ebp], 1
  00078	eb 04		 jmp	 SHORT $LN58@CollectBle
$LN57@CollectBle:
  0007a	83 65 e8 00	 and	 DWORD PTR tv202[ebp], 0
$LN58@CollectBle:
  0007e	8a 45 e8	 mov	 al, BYTE PTR tv202[ebp]
  00081	88 45 ff	 mov	 BYTE PTR $T15[ebp], al

; 153  :         return !(*this == _Right);

  00084	0f b6 45 ff	 movzx	 eax, BYTE PTR $T15[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	75 09		 jne	 SHORT $LN52@CollectBle
  0008c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv188[ebp], 1
  00093	eb 04		 jmp	 SHORT $LN53@CollectBle
$LN52@CollectBle:
  00095	83 65 e4 00	 and	 DWORD PTR tv188[ebp], 0
$LN53@CollectBle:
  00099	8a 45 e4	 mov	 al, BYTE PTR tv188[ebp]
  0009c	88 45 fe	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 194  : 	for (i=m_ThingCloneInstaceVector.begin(); i!=m_ThingCloneInstaceVector.end(); ++i)

  0009f	0f b6 45 fe	 movzx	 eax, BYTE PTR $T14[ebp]
  000a3	85 c0		 test	 eax, eax
  000a5	74 4e		 je	 SHORT $LN1@CollectBle
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000b0	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 196  : 		CGraphicThingInstance* pkThingInst=*i;

  000b3	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 e0	 mov	 DWORD PTR _pkThingInst$11[ebp], eax

; 197  : 		if (pkThingInst->isShow())

  000bb	8b 4d e0	 mov	 ecx, DWORD PTR _pkThingInst$11[ebp]
  000be	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  000c3	0f b6 c0	 movzx	 eax, al
  000c6	85 c0		 test	 eax, eax
  000c8	74 26		 je	 SHORT $LN5@CollectBle

; 198  : 		{
; 199  : 			if (pkThingInst->HaveBlendThing())

  000ca	8b 4d e0	 mov	 ecx, DWORD PTR _pkThingInst$11[ebp]
  000cd	e8 00 00 00 00	 call	 ?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::HaveBlendThing
  000d2	0f b6 c0	 movzx	 eax, al
  000d5	85 c0		 test	 eax, eax
  000d7	74 17		 je	 SHORT $LN5@CollectBle
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000df	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000e2	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax

; 717  :         emplace_back(_Val);

  000e5	ff 75 b8	 push	 DWORD PTR $T3[ebp]
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _rkVct_pkBlendThingInst$[ebp]
  000eb	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
$LN5@CollectBle:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 202  : 	}

  000f0	e9 45 ff ff ff	 jmp	 $LN2@CollectBle
$LN1@CollectBle:

; 203  : }

  000f5	c9		 leave
  000f6	c2 04 00	 ret	 4
?CollectBlendRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ENDP ; CArea::CollectBlendRenderingObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
___param0$ = -48					; size = 4
$T9 = -44						; size = 4
$T10 = -40						; size = 4
___param0$ = -36					; size = 4
_pkThingInst$11 = -32					; size = 4
tv188 = -28						; size = 4
tv202 = -24						; size = 4
__My_data$12 = -20					; size = 4
_this$ = -16						; size = 4
__My_data$13 = -12					; size = 4
_i$ = -8						; size = 4
$T14 = -2						; size = 1
$T15 = -1						; size = 1
_rkVct_pkOpaqueThingInst$ = 8				; size = 4
?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z PROC ; CArea::CollectRenderingObject, COMDAT
; _this$ = ecx

; 178  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00009	83 65 f8 00	 and	 DWORD PTR _i$[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0000d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 c0 28	 add	 eax, 40			; 00000028H
  00013	89 45 f4	 mov	 DWORD PTR __My_data$13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00016	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  00019	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$13[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00024	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00027	89 45 d8	 mov	 DWORD PTR $T10[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002a	8d 45 d8	 lea	 eax, DWORD PTR $T10[ebp]
  0002d	89 45 d4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 180  : 	for (i=m_ThingCloneInstaceVector.begin(); i!=m_ThingCloneInstaceVector.end(); ++i)

  00030	8b 45 d4	 mov	 eax, DWORD PTR $T9[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
  00038	eb 09		 jmp	 SHORT $LN4@CollectRen
$LN2@CollectRen:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0003d	83 c0 04	 add	 eax, 4
  00040	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN4@CollectRen:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 28	 add	 eax, 40			; 00000028H
  00049	89 45 ec	 mov	 DWORD PTR __My_data$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004c	8b 45 ec	 mov	 eax, DWORD PTR __My_data$12[ebp]
  0004f	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00052	8b 45 ec	 mov	 eax, DWORD PTR __My_data$12[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	89 45 d0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0005b	8b 45 d0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0005e	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00061	8d 45 cc	 lea	 eax, DWORD PTR $T8[ebp]
  00064	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00067	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0006a	8b 4d f8	 mov	 ecx, DWORD PTR _i$[ebp]
  0006d	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006f	75 09		 jne	 SHORT $LN57@CollectRen
  00071	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv202[ebp], 1
  00078	eb 04		 jmp	 SHORT $LN58@CollectRen
$LN57@CollectRen:
  0007a	83 65 e8 00	 and	 DWORD PTR tv202[ebp], 0
$LN58@CollectRen:
  0007e	8a 45 e8	 mov	 al, BYTE PTR tv202[ebp]
  00081	88 45 ff	 mov	 BYTE PTR $T15[ebp], al

; 153  :         return !(*this == _Right);

  00084	0f b6 45 ff	 movzx	 eax, BYTE PTR $T15[ebp]
  00088	85 c0		 test	 eax, eax
  0008a	75 09		 jne	 SHORT $LN52@CollectRen
  0008c	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv188[ebp], 1
  00093	eb 04		 jmp	 SHORT $LN53@CollectRen
$LN52@CollectRen:
  00095	83 65 e4 00	 and	 DWORD PTR tv188[ebp], 0
$LN53@CollectRen:
  00099	8a 45 e4	 mov	 al, BYTE PTR tv188[ebp]
  0009c	88 45 fe	 mov	 BYTE PTR $T14[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 180  : 	for (i=m_ThingCloneInstaceVector.begin(); i!=m_ThingCloneInstaceVector.end(); ++i)

  0009f	0f b6 45 fe	 movzx	 eax, BYTE PTR $T14[ebp]
  000a3	85 c0		 test	 eax, eax
  000a5	74 4e		 je	 SHORT $LN1@CollectRen
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000aa	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000ad	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000b0	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 182  : 		CGraphicThingInstance* pkThingInst=*i;

  000b3	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	8b 00		 mov	 eax, DWORD PTR [eax]
  000b8	89 45 e0	 mov	 DWORD PTR _pkThingInst$11[ebp], eax

; 183  : 		if (pkThingInst->isShow())

  000bb	8b 4d e0	 mov	 ecx, DWORD PTR _pkThingInst$11[ebp]
  000be	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow
  000c3	0f b6 c0	 movzx	 eax, al
  000c6	85 c0		 test	 eax, eax
  000c8	74 26		 je	 SHORT $LN5@CollectRen

; 184  : 		{
; 185  : 			if (!pkThingInst->HaveBlendThing())

  000ca	8b 4d e0	 mov	 ecx, DWORD PTR _pkThingInst$11[ebp]
  000cd	e8 00 00 00 00	 call	 ?HaveBlendThing@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::HaveBlendThing
  000d2	0f b6 c0	 movzx	 eax, al
  000d5	85 c0		 test	 eax, eax
  000d7	75 17		 jne	 SHORT $LN5@CollectRen
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  000dc	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000df	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000e2	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax

; 717  :         emplace_back(_Val);

  000e5	ff 75 b8	 push	 DWORD PTR $T3[ebp]
  000e8	8b 4d 08	 mov	 ecx, DWORD PTR _rkVct_pkOpaqueThingInst$[ebp]
  000eb	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicThingInstance@@@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAEXABQAVCGraphicThingInstance@@@Z ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::emplace_back<CGraphicThingInstance * const &>
$LN5@CollectRen:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 188  : 	}

  000f0	e9 45 ff ff ff	 jmp	 $LN2@CollectRen
$LN1@CollectRen:

; 189  : }

  000f5	c9		 leave
  000f6	c2 04 00	 ret	 4
?CollectRenderingObject@CArea@@QAEXAAV?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@@Z ENDP ; CArea::CollectRenderingObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??1CArea@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CArea@@UAE@XZ PROC					; CArea::~CArea, COMDAT
; _this$ = ecx

; 1302 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CArea@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CArea@@6B@

; 1303 : 	Clear();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Clear@CArea@@QAEXXZ	; CArea::Clear

; 1304 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 98 00 00
	00		 add	 ecx, 152		; 00000098H
  00040	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  0004e	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 78	 add	 ecx, 120		; 00000078H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00059	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 6c	 add	 ecx, 108		; 0000006cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00064	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 64	 add	 ecx, 100		; 00000064H
  0006f	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	83 c1 58	 add	 ecx, 88			; 00000058H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0007a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  0007f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	83 c1 4c	 add	 ecx, 76			; 0000004cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00085	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	83 c1 40	 add	 ecx, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00090	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	83 c1 34	 add	 ecx, 52			; 00000034H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0009b	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@AAEXXZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  000a0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 28	 add	 ecx, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000a6	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  000ab	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	83 c1 1c	 add	 ecx, 28			; 0000001cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000b1	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000bc	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  000c1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000c7	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1304 : }

  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	c9		 leave
  000d8	c3		 ret	 0
  000d9	cc		 int	 3
  000da	cc		 int	 3
  000db	cc		 int	 3
  000dc	cc		 int	 3
  000dd	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CArea@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CArea@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CArea@@UAE@XZ ENDP					; CArea::~CArea
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\set
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??0CArea@@QAE@XZ
_TEXT	SEGMENT
_this$ = -132						; size = 4
_this$ = -128						; size = 4
_this$ = -124						; size = 4
_this$ = -120						; size = 4
_this$ = -116						; size = 4
_this$ = -112						; size = 4
_this$ = -108						; size = 4
_this$ = -104						; size = 4
_this$ = -100						; size = 4
_this$ = -96						; size = 4
_this$ = -92						; size = 4
_this$ = -88						; size = 4
_this$ = -84						; size = 4
_this$ = -80						; size = 4
_this$ = -76						; size = 4
_this$ = -72						; size = 4
_this$ = -68						; size = 4
_this$ = -64						; size = 4
_this$ = -60						; size = 4
_this$ = -56						; size = 4
_this$ = -52						; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_this$2 = -40						; size = 4
_this$3 = -36						; size = 4
_this$4 = -32						; size = 4
_this$5 = -28						; size = 4
_this$6 = -24						; size = 4
_this$ = -20						; size = 4
$T7 = -15						; size = 1
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0CArea@@QAE@XZ PROC					; CArea::CArea, COMDAT
; _this$ = ecx

; 1297 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CArea@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 78	 sub	 esp, 120		; 00000078H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CArea@@6B@
  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0003a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00040	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea::SObjectData> >::_Vector_val<std::_Simple_types<CArea::SObjectData> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 c0 10	 add	 eax, 16			; 00000010H
  00052	89 45 cc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00055	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0005b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >::_Vector_val<std::_Simple_types<CArea::SObjectInstance *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0006d	89 45 c4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00070	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00076	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  0007e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00085	83 c0 28	 add	 eax, 40			; 00000028H
  00088	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0008b	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00091	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  00099	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0009d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	83 c0 34	 add	 eax, 52			; 00000034H
  000a3	89 45 b4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000a6	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	89 45 b0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000ac	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000af	89 45 e8	 mov	 DWORD PTR _this$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _this$6[ebp]
  000b5	83 20 00	 and	 DWORD PTR [eax], 0
  000b8	8b 45 e8	 mov	 eax, DWORD PTR _this$6[ebp]
  000bb	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  000bf	8b 45 e8	 mov	 eax, DWORD PTR _this$6[ebp]
  000c2	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  000c6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000ca	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	83 c0 40	 add	 eax, 64			; 00000040H
  000d0	89 45 ac	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000d3	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	89 45 a8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000d9	8b 4d a8	 mov	 ecx, DWORD PTR _this$[ebp]
  000dc	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >::_Vector_val<std::_Simple_types<CGraphicThingInstance *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  000e1	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000e5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	83 c0 4c	 add	 eax, 76			; 0000004cH
  000eb	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000ee	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	89 45 a0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000f4	8b 45 a0	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	89 45 e4	 mov	 DWORD PTR _this$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000fa	8b 45 e4	 mov	 eax, DWORD PTR _this$5[ebp]
  000fd	83 20 00	 and	 DWORD PTR [eax], 0
  00100	8b 45 e4	 mov	 eax, DWORD PTR _this$5[ebp]
  00103	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00107	8b 45 e4	 mov	 eax, DWORD PTR _this$5[ebp]
  0010a	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  0010e	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00112	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00115	83 c0 58	 add	 eax, 88			; 00000058H
  00118	89 45 9c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0011b	8b 45 9c	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	89 45 98	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00121	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00124	89 45 e0	 mov	 DWORD PTR _this$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00127	8b 45 e0	 mov	 eax, DWORD PTR _this$4[ebp]
  0012a	83 20 00	 and	 DWORD PTR [eax], 0
  0012d	8b 45 e0	 mov	 eax, DWORD PTR _this$4[ebp]
  00130	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00134	8b 45 e0	 mov	 eax, DWORD PTR _this$4[ebp]
  00137	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  0013b	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0013f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00142	83 c0 64	 add	 eax, 100		; 00000064H
  00145	89 45 94	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00148	8d 45 f3	 lea	 eax, DWORD PTR $T9[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVCGraphicThingInstance@@@1@@Z ; std::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >::_Tree<std::_Tmap_traits<CGraphicThingInstance *,unsigned long,std::less<CGraphicThingInstance *>,std::allocator<std::pair<CGraphicThingInstance * const,unsigned long> >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  00154	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00158	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015b	83 c0 6c	 add	 eax, 108		; 0000006cH
  0015e	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00161	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00164	89 45 8c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00167	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0016a	89 45 dc	 mov	 DWORD PTR _this$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0016d	8b 45 dc	 mov	 eax, DWORD PTR _this$3[ebp]
  00170	83 20 00	 and	 DWORD PTR [eax], 0
  00173	8b 45 dc	 mov	 eax, DWORD PTR _this$3[ebp]
  00176	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0017a	8b 45 dc	 mov	 eax, DWORD PTR _this$3[ebp]
  0017d	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  00181	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00185	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00188	83 c0 78	 add	 eax, 120		; 00000078H
  0018b	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0018e	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00191	89 45 84	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00194	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00197	89 45 d8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0019a	8b 45 d8	 mov	 eax, DWORD PTR _this$2[ebp]
  0019d	83 20 00	 and	 DWORD PTR [eax], 0
  001a0	8b 45 d8	 mov	 eax, DWORD PTR _this$2[ebp]
  001a3	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  001a7	8b 45 d8	 mov	 eax, DWORD PTR _this$2[ebp]
  001aa	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  001ae	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  001b2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001b5	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  001ba	89 45 80	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  001bd	8d 45 f2	 lea	 eax, DWORD PTR $T8[ebp]
  001c0	50		 push	 eax
  001c1	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1297 : {

  001c9	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  001cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001d0	05 98 00 00 00	 add	 eax, 152		; 00000098H
  001d5	89 85 7c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\set

; 84   :     set() : _Mybase(key_compare()) {}

  001db	8d 45 f1	 lea	 eax, DWORD PTR $T7[ebp]
  001de	50		 push	 eax
  001df	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1298 : 	m_wX = m_wY = 0xFF;

  001ea	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	66 89 81 86 00
	00 00		 mov	 WORD PTR [ecx+134], ax
  001f9	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  001fe	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00201	66 89 81 84 00
	00 00		 mov	 WORD PTR [ecx+132], ax

; 1299 : }

  00208	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0020c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0020f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00212	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00219	59		 pop	 ecx
  0021a	c9		 leave
  0021b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CArea@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::~vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >
__unwindfunclet$??0CArea@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@PAUSObjectInstance@CArea@@V?$allocator@PAUSObjectInstance@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >::~vector<CArea::SObjectInstance *,std::allocator<CArea::SObjectInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$2:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
__unwindfunclet$??0CArea@@QAE@XZ$3:
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 28	 add	 ecx, 40			; 00000028H
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$4:
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	83 c1 34	 add	 ecx, 52			; 00000034H
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCDungeonBlock@@V?$allocator@PAVCDungeonBlock@@@std@@@std@@QAE@XZ ; std::vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >::~vector<CDungeonBlock *,std::allocator<CDungeonBlock *> >
__unwindfunclet$??0CArea@@QAE@XZ$5:
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 40	 add	 ecx, 64			; 00000040H
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$6:
  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$7:
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 58	 add	 ecx, 88			; 00000058H
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@PAUSAmbienceInstance@CArea@@V?$allocator@PAUSAmbienceInstance@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >::~vector<CArea::SAmbienceInstance *,std::allocator<CArea::SAmbienceInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$8:
  00058	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	83 c1 64	 add	 ecx, 100		; 00000064H
  0005e	e9 00 00 00 00	 jmp	 ??1?$map@PAVCGraphicThingInstance@@KU?$less@PAVCGraphicThingInstance@@@std@@V?$allocator@U?$pair@QAVCGraphicThingInstance@@K@std@@@3@@std@@QAE@XZ
__unwindfunclet$??0CArea@@QAE@XZ$9:
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00069	e9 00 00 00 00	 jmp	 ??1?$vector@USCRCWithNumber@CArea@@V?$allocator@USCRCWithNumber@CArea@@@std@@@std@@QAE@XZ ; std::vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >::~vector<CArea::SCRCWithNumber,std::allocator<CArea::SCRCWithNumber> >
__unwindfunclet$??0CArea@@QAE@XZ$10:
  0006e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	83 c1 78	 add	 ecx, 120		; 00000078H
  00074	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicThingInstance@@V?$allocator@PAVCGraphicThingInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >::~vector<CGraphicThingInstance *,std::allocator<CGraphicThingInstance *> >
__unwindfunclet$??0CArea@@QAE@XZ$11:
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	81 c1 8c 00 00
	00		 add	 ecx, 140		; 0000008cH
  00082	e9 00 00 00 00	 jmp	 ??1?$map@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@@std@@QAE@XZ
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
__ehhandler$??0CArea@@QAE@XZ:
  0008c	90		 npad	 1
  0008d	90		 npad	 1
  0008e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00092	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00095	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  00098	33 c8		 xor	 ecx, eax
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CArea@@QAE@XZ
  000a4	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CArea@@QAE@XZ ENDP					; CArea::CArea
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
;	COMDAT ??_GSObjectInstance@CArea@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSObjectInstance@CArea@@UAEPAXI@Z PROC		; CArea::SObjectInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 			{

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SObjectInstance@CArea@@6B@
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $LN2@scalar
  00018	6a 28		 push	 40			; 00000028H
  0001a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??_GSObjectInstance@CArea@@UAEPAXI@Z ENDP		; CArea::SObjectInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
;	COMDAT ?__Initialize@SObjectInstance@CArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@SObjectInstance@CArea@@QAEXXZ PROC	; CArea::SObjectInstance::__Initialize, COMDAT
; _this$ = ecx

; 132  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 133  : 				dwType = prt::PROPERTY_TYPE_NONE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 134  : 
; 135  : 				dwEffectID = 0xffffffff;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 48 18 ff	 or	 DWORD PTR [eax+24], -1

; 136  : 				dwEffectInstanceIndex = 0xffffffff;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 48 1c ff	 or	 DWORD PTR [eax+28], -1

; 137  : 				isShadowFlag = false;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 138  : 
; 139  : 				pTree=NULL;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 140  : 				pThingInstance=NULL;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 141  : 				pAttributeInstance=NULL;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 142  : 				pAmbienceInstance=NULL;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 143  : 				pDungeonBlock=NULL;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 60 24 00	 and	 DWORD PTR [eax+36], 0

; 144  : 			}

  00046	c9		 leave
  00047	c3		 ret	 0
?__Initialize@SObjectInstance@CArea@@QAEXXZ ENDP	; CArea::SObjectInstance::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?SetTree@SObjectInstance@CArea@@QAEXMMMKPBD@Z
_TEXT	SEGMENT
_rkForest$ = -8						; size = 4
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_dwTreeCRC$ = 20					; size = 4
_c_szTreeName$ = 24					; size = 4
?SetTree@SObjectInstance@CArea@@QAEXMMMKPBD@Z PROC	; CArea::SObjectInstance::SetTree, COMDAT
; _this$ = ecx

; 589  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 590  : 	CSpeedTreeForestDirectX8& rkForest=CSpeedTreeForestDirectX8::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  0000d	89 45 f8	 mov	 DWORD PTR _rkForest$[ebp], eax

; 591  : 	pTree=rkForest.CreateInstance(x, y, z, dwTreeCRC, c_szTreeName);

  00010	ff 75 18	 push	 DWORD PTR _c_szTreeName$[ebp]
  00013	ff 75 14	 push	 DWORD PTR _dwTreeCRC$[ebp]
  00016	51		 push	 ecx
  00017	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0001c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00021	51		 push	 ecx
  00022	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00027	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002c	51		 push	 ecx
  0002d	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00032	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _rkForest$[ebp]
  0003a	e8 00 00 00 00	 call	 ?CreateInstance@CSpeedTreeForest@@QAEPAVCSpeedTreeWrapper@@MMMKPBD@Z ; CSpeedTreeForest::CreateInstance
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 592  : 	dwType = prt::PROPERTY_TYPE_TREE;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 593  : }

  0004f	c9		 leave
  00050	c2 14 00	 ret	 20			; 00000014H
?SetTree@SObjectInstance@CArea@@QAEXMMMKPBD@Z ENDP	; CArea::SObjectInstance::SetTree
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
;	COMDAT ?Clear@SObjectInstance@CArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@SObjectInstance@CArea@@QAEXXZ PROC		; CArea::SObjectInstance::Clear, COMDAT
; _this$ = ecx

; 110  : 			{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 				if (pTree)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  0000e	74 0b		 je	 SHORT $LN2@Clear

; 112  : 					pTree->Clear();

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00016	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear
$LN2@Clear:

; 113  : 
; 114  : 				if (pThingInstance)

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00022	74 0b		 je	 SHORT $LN3@Clear

; 115  : 					pThingInstance->Clear();

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0002a	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear
$LN3@Clear:

; 116  : 
; 117  : 				if (pAttributeInstance)

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00036	74 0b		 je	 SHORT $LN4@Clear

; 118  : 					pAttributeInstance->Clear();

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0003e	e8 00 00 00 00	 call	 ?Clear@CAttributeInstance@@QAEXXZ ; CAttributeInstance::Clear
$LN4@Clear:

; 119  : 
; 120  : 				if (pAmbienceInstance)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0004a	74 0b		 je	 SHORT $LN5@Clear

; 121  : 					pAmbienceInstance->Clear();

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00052	e8 00 00 00 00	 call	 ?Clear@CScreen@@QAEXXZ	; CScreen::Clear
$LN5@Clear:

; 122  : 
; 123  : 				if (pDungeonBlock)

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 78 24 00	 cmp	 DWORD PTR [eax+36], 0
  0005e	74 0b		 je	 SHORT $LN6@Clear

; 124  : 					pDungeonBlock->Clear();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00066	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear
$LN6@Clear:

; 125  : 
; 126  : 				__Initialize();

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?__Initialize@SObjectInstance@CArea@@QAEXXZ ; CArea::SObjectInstance::__Initialize

; 127  : 			}

  00073	c9		 leave
  00074	c3		 ret	 0
?Clear@SObjectInstance@CArea@@QAEXXZ ENDP		; CArea::SObjectInstance::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.h
;	COMDAT ??_GSAmbienceInstance@CArea@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSAmbienceInstance@CArea@@UAEPAXI@Z PROC		; CArea::SAmbienceInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 			virtual ~SAmbienceInstance() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SAmbienceInstance@CArea@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 20	 add	 ecx, 32			; 00000020H
  00016	e8 00 00 00 00	 call	 ??1TPropertyAmbience@prt@@QAE@XZ
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  00023	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00026	83 e0 01	 and	 eax, 1
  00029	74 0c		 je	 SHORT $LN2@scalar
  0002b	6a 6c		 push	 108			; 0000006cH
  0002d	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
$LN2@scalar:
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c9		 leave
  0003b	c2 04 00	 ret	 4
??_GSAmbienceInstance@CArea@@UAEPAXI@Z ENDP		; CArea::SAmbienceInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__GetVolumeFromDistance@SAmbienceInstance@CArea@@QAEMM@Z
_TEXT	SEGMENT
tv130 = -36						; size = 8
tv82 = -28						; size = 8
tv136 = -20						; size = 4
tv94 = -16						; size = 4
tv78 = -12						; size = 4
_this$ = -8						; size = 4
_fMaxVolumeAreaRadius$ = -4				; size = 4
_fDistance$ = 8						; size = 4
?__GetVolumeFromDistance@SAmbienceInstance@CArea@@QAEMM@Z PROC ; CArea::SAmbienceInstance::__GetVolumeFromDistance, COMDAT
; _this$ = ecx

; 1399 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1400 : 	float fMaxVolumeAreaRadius = float(dwRange) * fMaxVolumeAreaPercentage;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR tv78[ebp], eax
  00012	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv78[ebp]
  00017	8b 45 f4	 mov	 eax, DWORD PTR tv78[ebp]
  0001a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0001d	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00026	f2 0f 11 45 e4	 movsd	 QWORD PTR tv82[ebp], xmm0
  0002b	f2 0f 5a 45 e4	 cvtsd2ss xmm0, QWORD PTR tv82[ebp]
  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	f3 0f 59 40 14	 mulss	 xmm0, DWORD PTR [eax+20]
  00038	f3 0f 11 45 fc	 movss	 DWORD PTR _fMaxVolumeAreaRadius$[ebp], xmm0

; 1401 : 	if (fMaxVolumeAreaRadius <= 0.0f)

  0003d	0f 57 c0	 xorps	 xmm0, xmm0
  00040	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _fMaxVolumeAreaRadius$[ebp]
  00044	72 04		 jb	 SHORT $LN2@GetVolumeF

; 1402 : 		return 1.0f;

  00046	d9 e8		 fld1
  00048	eb 5d		 jmp	 SHORT $LN1@GetVolumeF
$LN2@GetVolumeF:

; 1403 : 	if (fDistance <= fMaxVolumeAreaRadius)

  0004a	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fMaxVolumeAreaRadius$[ebp]
  0004f	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _fDistance$[ebp]
  00053	72 04		 jb	 SHORT $LN3@GetVolumeF

; 1404 : 		return 1.0f;

  00055	d9 e8		 fld1
  00057	eb 4e		 jmp	 SHORT $LN1@GetVolumeF
$LN3@GetVolumeF:

; 1405 : 
; 1406 : 	return 1.0f - ((fDistance - fMaxVolumeAreaRadius) / (dwRange - fMaxVolumeAreaRadius));

  00059	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  0005e	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fMaxVolumeAreaRadius$[ebp]
  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00069	89 45 f0	 mov	 DWORD PTR tv94[ebp], eax
  0006c	f2 0f 2a 4d f0	 cvtsi2sd xmm1, DWORD PTR tv94[ebp]
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv94[ebp]
  00074	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00077	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00080	f2 0f 11 4d dc	 movsd	 QWORD PTR tv130[ebp], xmm1
  00085	f2 0f 5a 4d dc	 cvtsd2ss xmm1, QWORD PTR tv130[ebp]
  0008a	f3 0f 5c 4d fc	 subss	 xmm1, DWORD PTR _fMaxVolumeAreaRadius$[ebp]
  0008f	f3 0f 5e c1	 divss	 xmm0, xmm1
  00093	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0009b	f3 0f 5c c8	 subss	 xmm1, xmm0
  0009f	f3 0f 11 4d ec	 movss	 DWORD PTR tv136[ebp], xmm1
  000a4	d9 45 ec	 fld	 DWORD PTR tv136[ebp]
$LN1@GetVolumeF:

; 1407 : }

  000a7	c9		 leave
  000a8	c2 04 00	 ret	 4
?__GetVolumeFromDistance@SAmbienceInstance@CArea@@QAEMM@Z ENDP ; CArea::SAmbienceInstance::__GetVolumeFromDistance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Picking@SAmbienceInstance@CArea@@QAE_NXZ
_TEXT	SEGMENT
tv143 = -44						; size = 8
_fz$ = -36						; size = 4
_fy$ = -32						; size = 4
_fx$ = -28						; size = 4
tv139 = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?Picking@SAmbienceInstance@CArea@@QAE_NXZ PROC		; CArea::SAmbienceInstance::Picking, COMDAT
; _this$ = ecx

; 1436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1437 : 	return CGraphicCollisionObject::IntersectSphere(D3DXVECTOR3(fx, fy, fz), dwRange);

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0001b	f3 0f 11 45 e4	 movss	 DWORD PTR _fx$[ebp], xmm0
  00020	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00023	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00028	f3 0f 11 45 e0	 movss	 DWORD PTR _fy$[ebp], xmm0
  0002d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00030	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00035	f3 0f 11 45 dc	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0003a	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0003f	f3 0f 11 45 f0	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  00044	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00049	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  0004e	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00053	f3 0f 11 45 f8	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1437 : 	return CGraphicCollisionObject::IntersectSphere(D3DXVECTOR3(fx, fy, fz), dwRange);

  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005e	89 45 e8	 mov	 DWORD PTR tv139[ebp], eax
  00061	f2 0f 2a 45 e8	 cvtsi2sd xmm0, DWORD PTR tv139[ebp]
  00066	8b 45 e8	 mov	 eax, DWORD PTR tv139[ebp]
  00069	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0006c	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00075	f2 0f 11 45 d4	 movsd	 QWORD PTR tv143[ebp], xmm0
  0007a	f2 0f 5a 45 d4	 cvtsd2ss xmm0, QWORD PTR tv143[ebp]
  0007f	51		 push	 ecx
  00080	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00085	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00088	50		 push	 eax
  00089	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?IntersectSphere@CGraphicCollisionObject@@IAE_NABUD3DXVECTOR3@@M@Z ; CGraphicCollisionObject::IntersectSphere

; 1438 : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	c9		 leave
  0009c	c3		 ret	 0
?Picking@SAmbienceInstance@CArea@@QAE_NXZ ENDP		; CArea::SAmbienceInstance::Picking
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?Render@SAmbienceInstance@CArea@@QAEXXZ
_TEXT	SEGMENT
tv368 = -108						; size = 8
tv353 = -100						; size = 8
tv328 = -92						; size = 8
tv307 = -84						; size = 8
tv287 = -76						; size = 8
tv266 = -68						; size = 8
$T1 = -60						; size = 4
__X$ = -56						; size = 4
$T2 = -52						; size = 4
__X$ = -48						; size = 4
tv364 = -44						; size = 4
tv349 = -40						; size = 4
tv324 = -36						; size = 4
tv303 = -32						; size = 4
tv283 = -28						; size = 4
tv262 = -24						; size = 4
_fxAdd$3 = -20						; size = 4
_fyAdd$4 = -16						; size = 4
_i$5 = -12						; size = 4
_fBoxSize$ = -8						; size = 4
_this$ = -4						; size = 4
?Render@SAmbienceInstance@CArea@@QAEXXZ PROC		; CArea::SAmbienceInstance::Render, COMDAT
; _this$ = ecx

; 1410 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1411 : 	float fBoxSize = 10.0f;

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  00011	f3 0f 11 45 f8	 movss	 DWORD PTR _fBoxSize$[ebp], xmm0

; 1412 : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xff00ff00);

  00016	68 00 ff 00 ff	 push	 -16711936		; ff00ff00H
  0001b	6a 3c		 push	 60			; 0000003cH
  0001d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00023	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1413 : 	RenderCube(fx-fBoxSize, fy-fBoxSize, fz-fBoxSize, fx+fBoxSize, fy+fBoxSize, fz+fBoxSize);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00030	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  00035	51		 push	 ecx
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00043	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  00048	51		 push	 ecx
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00056	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  0005b	51		 push	 ecx
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00064	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00069	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  0006e	51		 push	 ecx
  0006f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00074	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00077	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0007c	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  00081	51		 push	 ecx
  00082	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0008f	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _fBoxSize$[ebp]
  00094	51		 push	 ecx
  00095	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?RenderCube@CScreen@@QAEXMMMMMM@Z ; CScreen::RenderCube

; 1414 : 	STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xffffffff);

  000a2	6a ff		 push	 -1
  000a4	6a 3c		 push	 60			; 0000003cH
  000a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ac	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1415 : 	RenderSphere(NULL, fx, fy, fz, float(dwRange) * fMaxVolumeAreaPercentage, D3DFILL_POINT);

  000b1	6a 01		 push	 1
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000b9	89 45 e8	 mov	 DWORD PTR tv262[ebp], eax
  000bc	f2 0f 2a 45 e8	 cvtsi2sd xmm0, DWORD PTR tv262[ebp]
  000c1	8b 45 e8	 mov	 eax, DWORD PTR tv262[ebp]
  000c4	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c7	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000d0	f2 0f 11 45 bc	 movsd	 QWORD PTR tv266[ebp], xmm0
  000d5	f2 0f 5a 45 bc	 cvtsd2ss xmm0, QWORD PTR tv266[ebp]
  000da	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	f3 0f 59 40 14	 mulss	 xmm0, DWORD PTR [eax+20]
  000e2	51		 push	 ecx
  000e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	51		 push	 ecx
  000ec	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	51		 push	 ecx
  000fa	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000ff	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00107	51		 push	 ecx
  00108	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	6a 00		 push	 0
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	e8 00 00 00 00	 call	 ?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderSphere

; 1416 : 	RenderSphere(NULL, fx, fy, fz, float(dwRange), D3DFILL_POINT);

  0011c	6a 01		 push	 1
  0011e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00121	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00124	89 45 e4	 mov	 DWORD PTR tv283[ebp], eax
  00127	f2 0f 2a 45 e4	 cvtsi2sd xmm0, DWORD PTR tv283[ebp]
  0012c	8b 45 e4	 mov	 eax, DWORD PTR tv283[ebp]
  0012f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00132	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0013b	f2 0f 11 45 b4	 movsd	 QWORD PTR tv287[ebp], xmm0
  00140	f2 0f 5a 45 b4	 cvtsd2ss xmm0, QWORD PTR tv287[ebp]
  00145	51		 push	 ecx
  00146	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	51		 push	 ecx
  0014f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00154	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00159	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	51		 push	 ecx
  0015d	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00162	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00167	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0016a	51		 push	 ecx
  0016b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00170	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00175	6a 00		 push	 0
  00177	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	e8 00 00 00 00	 call	 ?RenderSphere@CScreen@@QAEXPBUD3DXMATRIX@@MMMMW4_D3DFILLMODE@@@Z ; CScreen::RenderSphere

; 1417 : 	RenderCircle2d(fx, fy, fz, float(dwRange) * fMaxVolumeAreaPercentage);

  0017f	6a 32		 push	 50			; 00000032H
  00181	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00184	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00187	89 45 e0	 mov	 DWORD PTR tv303[ebp], eax
  0018a	f2 0f 2a 45 e0	 cvtsi2sd xmm0, DWORD PTR tv303[ebp]
  0018f	8b 45 e0	 mov	 eax, DWORD PTR tv303[ebp]
  00192	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00195	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0019e	f2 0f 11 45 ac	 movsd	 QWORD PTR tv307[ebp], xmm0
  001a3	f2 0f 5a 45 ac	 cvtsd2ss xmm0, QWORD PTR tv307[ebp]
  001a8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	f3 0f 59 40 14	 mulss	 xmm0, DWORD PTR [eax+20]
  001b0	51		 push	 ecx
  001b1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001b9	51		 push	 ecx
  001ba	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	51		 push	 ecx
  001c8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001d5	51		 push	 ecx
  001d6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001db	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e3	e8 00 00 00 00	 call	 ?RenderCircle2d@CScreen@@QAEXMMMMH@Z ; CScreen::RenderCircle2d

; 1418 : 	RenderCircle2d(fx, fy, fz, float(dwRange));

  001e8	6a 32		 push	 50			; 00000032H
  001ea	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  001f0	89 45 dc	 mov	 DWORD PTR tv324[ebp], eax
  001f3	f2 0f 2a 45 dc	 cvtsi2sd xmm0, DWORD PTR tv324[ebp]
  001f8	8b 45 dc	 mov	 eax, DWORD PTR tv324[ebp]
  001fb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001fe	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00207	f2 0f 11 45 a4	 movsd	 QWORD PTR tv328[ebp], xmm0
  0020c	f2 0f 5a 45 a4	 cvtsd2ss xmm0, QWORD PTR tv328[ebp]
  00211	51		 push	 ecx
  00212	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00217	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	51		 push	 ecx
  0021b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00220	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00225	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00228	51		 push	 ecx
  00229	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0022e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00233	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00236	51		 push	 ecx
  00237	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0023c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00241	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00244	e8 00 00 00 00	 call	 ?RenderCircle2d@CScreen@@QAEXMMMMH@Z ; CScreen::RenderCircle2d

; 1419 : 
; 1420 : 	for (int i = 0; i < 4; ++i)

  00249	83 65 f4 00	 and	 DWORD PTR _i$5[ebp], 0
  0024d	eb 07		 jmp	 SHORT $LN4@Render
$LN2@Render:
  0024f	8b 45 f4	 mov	 eax, DWORD PTR _i$5[ebp]
  00252	40		 inc	 eax
  00253	89 45 f4	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@Render:
  00256	83 7d f4 04	 cmp	 DWORD PTR _i$5[ebp], 4
  0025a	0f 8d 70 01 00
	00		 jge	 $LN3@Render

; 1422 : 		float fxAdd = cosf(float(i) * D3DX_PI/4.0f) * float(dwRange) / 2.0f;

  00260	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _i$5[ebp]
  00265	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  0026d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  00275	f3 0f 11 45 d0	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  0027a	f3 0f 5a 45 d0	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0027f	51		 push	 ecx
  00280	51		 push	 ecx
  00281	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00286	e8 00 00 00 00	 call	 _cos
  0028b	59		 pop	 ecx
  0028c	59		 pop	 ecx
  0028d	d9 5d cc	 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1422 : 		float fxAdd = cosf(float(i) * D3DX_PI/4.0f) * float(dwRange) / 2.0f;

  00290	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00293	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00296	89 45 d8	 mov	 DWORD PTR tv349[ebp], eax
  00299	f2 0f 2a 45 d8	 cvtsi2sd xmm0, DWORD PTR tv349[ebp]
  0029e	8b 45 d8	 mov	 eax, DWORD PTR tv349[ebp]
  002a1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002a4	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002ad	f2 0f 11 45 9c	 movsd	 QWORD PTR tv353[ebp], xmm0
  002b2	f2 0f 5a 45 9c	 cvtsd2ss xmm0, QWORD PTR tv353[ebp]
  002b7	f3 0f 59 45 cc	 mulss	 xmm0, DWORD PTR $T2[ebp]
  002bc	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  002c4	f3 0f 11 45 ec	 movss	 DWORD PTR _fxAdd$3[ebp], xmm0

; 1423 : 		float fyAdd = sinf(float(i) * D3DX_PI/4.0f) * float(dwRange) / 2.0f;

  002c9	f3 0f 2a 45 f4	 cvtsi2ss xmm0, DWORD PTR _i$5[ebp]
  002ce	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@40490fdb
  002d6	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40800000
  002de	f3 0f 11 45 c8	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  002e3	f3 0f 5a 45 c8	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  002e8	51		 push	 ecx
  002e9	51		 push	 ecx
  002ea	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002ef	e8 00 00 00 00	 call	 _sin
  002f4	59		 pop	 ecx
  002f5	59		 pop	 ecx
  002f6	d9 5d c4	 fstp	 DWORD PTR $T1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1423 : 		float fyAdd = sinf(float(i) * D3DX_PI/4.0f) * float(dwRange) / 2.0f;

  002f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  002fc	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  002ff	89 45 d4	 mov	 DWORD PTR tv364[ebp], eax
  00302	f2 0f 2a 45 d4	 cvtsi2sd xmm0, DWORD PTR tv364[ebp]
  00307	8b 45 d4	 mov	 eax, DWORD PTR tv364[ebp]
  0030a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0030d	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00316	f2 0f 11 45 94	 movsd	 QWORD PTR tv368[ebp], xmm0
  0031b	f2 0f 5a 45 94	 cvtsd2ss xmm0, QWORD PTR tv368[ebp]
  00320	f3 0f 59 45 c4	 mulss	 xmm0, DWORD PTR $T1[ebp]
  00325	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0032d	f3 0f 11 45 f0	 movss	 DWORD PTR _fyAdd$4[ebp], xmm0

; 1424 : 
; 1425 : 		if (i%2)

  00332	8b 45 f4	 mov	 eax, DWORD PTR _i$5[ebp]
  00335	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0033a	79 05		 jns	 SHORT $LN15@Render
  0033c	48		 dec	 eax
  0033d	83 c8 fe	 or	 eax, -2			; fffffffeH
  00340	40		 inc	 eax
$LN15@Render:
  00341	85 c0		 test	 eax, eax
  00343	74 24		 je	 SHORT $LN5@Render

; 1426 : 		{
; 1427 : 			fxAdd /= 2.0f;

  00345	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fxAdd$3[ebp]
  0034a	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00352	f3 0f 11 45 ec	 movss	 DWORD PTR _fxAdd$3[ebp], xmm0

; 1428 : 			fyAdd /= 2.0f;

  00357	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fyAdd$4[ebp]
  0035c	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00364	f3 0f 11 45 f0	 movss	 DWORD PTR _fyAdd$4[ebp], xmm0
$LN5@Render:

; 1429 : 		}
; 1430 : 
; 1431 : 		RenderLine2d(fx + fxAdd, fy + fyAdd, fx - fxAdd, fy - fyAdd, fz);

  00369	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0036c	51		 push	 ecx
  0036d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00372	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00377	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0037a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0037f	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _fyAdd$4[ebp]
  00384	51		 push	 ecx
  00385	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0038a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0038d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00392	f3 0f 5c 45 ec	 subss	 xmm0, DWORD PTR _fxAdd$3[ebp]
  00397	51		 push	 ecx
  00398	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0039d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003a0	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003a5	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR _fyAdd$4[ebp]
  003aa	51		 push	 ecx
  003ab	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  003b3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  003b8	f3 0f 58 45 ec	 addss	 xmm0, DWORD PTR _fxAdd$3[ebp]
  003bd	51		 push	 ecx
  003be	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c6	e8 00 00 00 00	 call	 ?RenderLine2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderLine2d

; 1432 : 	}

  003cb	e9 7f fe ff ff	 jmp	 $LN2@Render
$LN3@Render:

; 1433 : }

  003d0	c9		 leave
  003d1	c3		 ret	 0
?Render@SAmbienceInstance@CArea@@QAEXXZ ENDP		; CArea::SAmbienceInstance::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?UpdateLoopSound@SAmbienceInstance@CArea@@QAEXMMM@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
_c_szFileName$3 = -36					; size = 4
$T4 = -32						; size = 4
__My_data$5 = -28					; size = 4
__X$ = -24						; size = 4
_fDistance$ = -20					; size = 4
tv170 = -16						; size = 4
__My_data$6 = -12					; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
_fxCenter$ = 8						; size = 4
_fyCenter$ = 12						; size = 4
_fzCenter$ = 16						; size = 4
?UpdateLoopSound@SAmbienceInstance@CArea@@QAEXMMM@Z PROC ; CArea::SAmbienceInstance::UpdateLoopSound, COMDAT
; _this$ = ecx

; 1367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1368 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00011	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _fzCenter$[ebp]
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  0001e	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR _fzCenter$[ebp]
  00023	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0002f	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fyCenter$[ebp]
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  0003c	f3 0f 5c 55 0c	 subss	 xmm2, DWORD PTR _fyCenter$[ebp]
  00041	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fxCenter$[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0005a	f3 0f 5c 5d 08	 subss	 xmm3, DWORD PTR _fxCenter$[ebp]
  0005f	f3 0f 59 d8	 mulss	 xmm3, xmm0
  00063	f3 0f 58 da	 addss	 xmm3, xmm2
  00067	f3 0f 58 d9	 addss	 xmm3, xmm1
  0006b	f3 0f 11 5d e8	 movss	 DWORD PTR __X$[ebp], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00070	f3 0f 5a 45 e8	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00075	51		 push	 ecx
  00076	51		 push	 ecx
  00077	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007c	e8 00 00 00 00	 call	 _sqrt
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1368 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00083	d9 5d ec	 fstp	 DWORD PTR _fDistance$[ebp]

; 1369 : 	if (DWORD(fDistance) < dwRange)

  00086	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  0008b	e8 00 00 00 00	 call	 __ftoui3
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00096	0f 83 e1 00 00
	00		 jae	 $LN2@UpdateLoop

; 1370 : 	{
; 1371 : 		if (-1 == iPlaySoundIndex)

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  000a3	0f 85 9c 00 00
	00		 jne	 $LN4@UpdateLoop
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 c0 5c	 add	 eax, 92			; 0000005cH
  000af	89 45 f4	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  000b2	8b 45 f4	 mov	 eax, DWORD PTR __My_data$6[ebp]
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000bd	75 09		 jne	 SHORT $LN13@UpdateLoop
  000bf	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv170[ebp], 1
  000c6	eb 04		 jmp	 SHORT $LN14@UpdateLoop
$LN13@UpdateLoop:
  000c8	83 65 f0 00	 and	 DWORD PTR tv170[ebp], 0
$LN14@UpdateLoop:
  000cc	8a 45 f0	 mov	 al, BYTE PTR tv170[ebp]
  000cf	88 45 ff	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1373 : 			if (AmbienceData.AmbienceSoundVector.empty())

  000d2	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  000d6	85 c0		 test	 eax, eax
  000d8	74 05		 je	 SHORT $LN5@UpdateLoop

; 1374 : 				return;

  000da	e9 bf 00 00 00	 jmp	 $LN1@UpdateLoop
$LN5@UpdateLoop:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	83 c0 5c	 add	 eax, 92			; 0000005cH
  000e5	89 45 e4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000e8	33 c0		 xor	 eax, eax
  000ea	6b c0 18	 imul	 eax, eax, 24
  000ed	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  000f0	03 01		 add	 eax, DWORD PTR [ecx]
  000f2	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1376 : 			const char * c_szFileName = AmbienceData.AmbienceSoundVector[0].c_str();

  000f5	8b 4d e0	 mov	 ecx, DWORD PTR $T4[ebp]
  000f8	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000fd	89 45 dc	 mov	 DWORD PTR _c_szFileName$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00100	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
  00105	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1377 : 			iPlaySoundIndex = CSoundManager::Instance().PlayAmbienceSound3D(fx, fy, fz, c_szFileName, 0);

  00108	6a 00		 push	 0
  0010a	ff 75 dc	 push	 DWORD PTR _c_szFileName$3[ebp]
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00110	51		 push	 ecx
  00111	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00116	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011e	51		 push	 ecx
  0011f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00124	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00129	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	51		 push	 ecx
  0012d	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00132	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00137	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
  0013a	e8 00 00 00 00	 call	 ?PlayAmbienceSound3D@CSoundManager@@QAEHMMMPBDH@Z ; CSoundManager::PlayAmbienceSound3D
  0013f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN4@UpdateLoop:

; 1378 : //			Tracef(" %d : LoopPlay [%f] : %s\n", iPlaySoundIndex, fDistance, c_szFileName);
; 1379 : 		}
; 1380 : 
; 1381 : 		if (-1 != iPlaySoundIndex)

  00145	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00148	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  0014c	74 2d		 je	 SHORT $LN6@UpdateLoop
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0014e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
  00153	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1384 : 			CSoundManager::Instance().SetSoundVolume3D(iPlaySoundIndex, __GetVolumeFromDistance(fDistance));

  00156	51		 push	 ecx
  00157	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  0015c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00161	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ?__GetVolumeFromDistance@SAmbienceInstance@CArea@@QAEMM@Z ; CArea::SAmbienceInstance::__GetVolumeFromDistance
  00169	51		 push	 ecx
  0016a	d9 1c 24	 fstp	 DWORD PTR [esp]
  0016d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	ff 70 18	 push	 DWORD PTR [eax+24]
  00173	8b 4d d4	 mov	 ecx, DWORD PTR $T1[ebp]
  00176	e8 00 00 00 00	 call	 ?SetSoundVolume3D@CSoundManager@@QAEXHM@Z ; CSoundManager::SetSoundVolume3D
$LN6@UpdateLoop:

; 1385 : 		}
; 1386 : 	}

  0017b	eb 21		 jmp	 SHORT $LN7@UpdateLoop
$LN2@UpdateLoop:

; 1387 : 	else
; 1388 : 	{
; 1389 : 		if (-1 != iPlaySoundIndex)

  0017d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00180	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  00184	74 18		 je	 SHORT $LN7@UpdateLoop

; 1390 : 		{
; 1391 : //			Tracef(" %d : LoopStop\n", iPlaySoundIndex);
; 1392 : 			CSoundManager::Instance().StopSound3D(iPlaySoundIndex);

  00186	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00189	ff 70 18	 push	 DWORD PTR [eax+24]
  0018c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
  00192	e8 00 00 00 00	 call	 ?StopSound3D@CSoundManager@@QAEXH@Z ; CSoundManager::StopSound3D

; 1393 : 			iPlaySoundIndex = -1;

  00197	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	83 48 18 ff	 or	 DWORD PTR [eax+24], -1
$LN7@UpdateLoop:
$LN1@UpdateLoop:

; 1394 : 		}
; 1395 : 	}
; 1396 : }

  0019e	c9		 leave
  0019f	c2 0c 00	 ret	 12			; 0000000cH
?UpdateLoopSound@SAmbienceInstance@CArea@@QAEXMMM@Z ENDP ; CArea::SAmbienceInstance::UpdateLoopSound
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?UpdateStepSound@SAmbienceInstance@CArea@@QAEXMMM@Z
_TEXT	SEGMENT
tv238 = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -48						; size = 4
_c_szFileName$3 = -44					; size = 4
$T4 = -40						; size = 4
__My_data$5 = -36					; size = 4
_fcurTime$6 = -32					; size = 4
$T7 = -28						; size = 4
_fDistance$ = -24					; size = 4
__X$ = -20						; size = 4
tv173 = -16						; size = 4
__My_data$8 = -12					; size = 4
_this$ = -8						; size = 4
$T9 = -1						; size = 1
_fxCenter$ = 8						; size = 4
_fyCenter$ = 12						; size = 4
_fzCenter$ = 16						; size = 4
?UpdateStepSound@SAmbienceInstance@CArea@@QAEXMMM@Z PROC ; CArea::SAmbienceInstance::UpdateStepSound, COMDAT
; _this$ = ecx

; 1340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1341 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00011	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _fzCenter$[ebp]
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  0001e	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR _fzCenter$[ebp]
  00023	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0002f	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fyCenter$[ebp]
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  0003c	f3 0f 5c 55 0c	 subss	 xmm2, DWORD PTR _fyCenter$[ebp]
  00041	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fxCenter$[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0005a	f3 0f 5c 5d 08	 subss	 xmm3, DWORD PTR _fxCenter$[ebp]
  0005f	f3 0f 59 d8	 mulss	 xmm3, xmm0
  00063	f3 0f 58 da	 addss	 xmm3, xmm2
  00067	f3 0f 58 d9	 addss	 xmm3, xmm1
  0006b	f3 0f 11 5d ec	 movss	 DWORD PTR __X$[ebp], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00070	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00075	51		 push	 ecx
  00076	51		 push	 ecx
  00077	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007c	e8 00 00 00 00	 call	 _sqrt
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1341 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00083	d9 5d e8	 fstp	 DWORD PTR _fDistance$[ebp]

; 1342 : 	if (DWORD(fDistance) < dwRange)

  00086	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  0008b	e8 00 00 00 00	 call	 __ftoui3
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00096	0f 83 17 01 00
	00		 jae	 $LN2@UpdateStep
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  000a1	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1344 : 		float fcurTime = CTimer::Instance().GetCurrentSecond();

  000a4	8b 4d e4	 mov	 ecx, DWORD PTR $T7[ebp]
  000a7	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  000ac	d9 5d e0	 fstp	 DWORD PTR _fcurTime$6[ebp]

; 1345 : 
; 1346 : 		if (fcurTime > fNextPlayTime)

  000af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fcurTime$6[ebp]
  000b7	0f 2f 40 1c	 comiss	 xmm0, DWORD PTR [eax+28]
  000bb	0f 86 f0 00 00
	00		 jbe	 $LN4@UpdateStep
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  000c1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	83 c0 5c	 add	 eax, 92			; 0000005cH
  000c7	89 45 f4	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  000ca	8b 45 f4	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000cd	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  000d0	8b 00		 mov	 eax, DWORD PTR [eax]
  000d2	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000d5	75 09		 jne	 SHORT $LN13@UpdateStep
  000d7	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv173[ebp], 1
  000de	eb 04		 jmp	 SHORT $LN14@UpdateStep
$LN13@UpdateStep:
  000e0	83 65 f0 00	 and	 DWORD PTR tv173[ebp], 0
$LN14@UpdateStep:
  000e4	8a 45 f0	 mov	 al, BYTE PTR tv173[ebp]
  000e7	88 45 ff	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1348 : 			if (AmbienceData.AmbienceSoundVector.empty())

  000ea	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  000ee	85 c0		 test	 eax, eax
  000f0	74 05		 je	 SHORT $LN5@UpdateStep

; 1349 : 				return;

  000f2	e9 ce 00 00 00	 jmp	 $LN1@UpdateStep
$LN5@UpdateStep:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000f7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	83 c0 5c	 add	 eax, 92			; 0000005cH
  000fd	89 45 dc	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00100	33 c0		 xor	 eax, eax
  00102	6b c0 18	 imul	 eax, eax, 24
  00105	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00108	03 01		 add	 eax, DWORD PTR [ecx]
  0010a	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1351 : 			const char * c_szFileName = AmbienceData.AmbienceSoundVector[0].c_str();

  0010d	8b 4d d8	 mov	 ecx, DWORD PTR $T4[ebp]
  00110	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00115	89 45 d4	 mov	 DWORD PTR _c_szFileName$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
  0011d	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1352 : 			iPlaySoundIndex = CSoundManager::Instance().PlayAmbienceSound3D(fx, fy, fz, c_szFileName);

  00120	6a 01		 push	 1
  00122	ff 75 d4	 push	 DWORD PTR _c_szFileName$3[ebp]
  00125	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00128	51		 push	 ecx
  00129	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0012e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00133	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00136	51		 push	 ecx
  00137	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0013c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00141	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00144	51		 push	 ecx
  00145	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	8b 4d d0	 mov	 ecx, DWORD PTR $T2[ebp]
  00152	e8 00 00 00 00	 call	 ?PlayAmbienceSound3D@CSoundManager@@QAEHMMMPBDH@Z ; CSoundManager::PlayAmbienceSound3D
  00157	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0015d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00162	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1355 : 			fNextPlayTime = CTimer::Instance().GetCurrentSecond();

  00165	8b 4d cc	 mov	 ecx, DWORD PTR $T1[ebp]
  00168	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  0016d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	d9 58 1c	 fstp	 DWORD PTR [eax+28]

; 1356 : 			fNextPlayTime += AmbienceData.fPlayInterval + frandom(0.0f, AmbienceData.fPlayIntervalVariation);

  00173	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00176	51		 push	 ecx
  00177	f3 0f 10 40 54	 movss	 xmm0, DWORD PTR [eax+84]
  0017c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00181	51		 push	 ecx
  00182	0f 57 c0	 xorps	 xmm0, xmm0
  00185	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0018a	e8 00 00 00 00	 call	 ?frandom@@YAMMM@Z	; frandom
  0018f	59		 pop	 ecx
  00190	59		 pop	 ecx
  00191	d9 5d c8	 fstp	 DWORD PTR tv238[ebp]
  00194	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00197	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv238[ebp]
  0019c	f3 0f 58 40 50	 addss	 xmm0, DWORD PTR [eax+80]
  001a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a4	f3 0f 58 40 1c	 addss	 xmm0, DWORD PTR [eax+28]
  001a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001ac	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0
$LN4@UpdateStep:

; 1357 : 		}
; 1358 : 	}

  001b1	eb 12		 jmp	 SHORT $LN3@UpdateStep
$LN2@UpdateStep:

; 1359 : 	else
; 1360 : 	{
; 1361 : 		iPlaySoundIndex = -1;

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	83 48 18 ff	 or	 DWORD PTR [eax+24], -1

; 1362 : 		fNextPlayTime = 0.0f;

  001ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001bd	0f 57 c0	 xorps	 xmm0, xmm0
  001c0	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0
$LN3@UpdateStep:
$LN1@UpdateStep:

; 1363 : 	}
; 1364 : }

  001c5	c9		 leave
  001c6	c2 0c 00	 ret	 12			; 0000000cH
?UpdateStepSound@SAmbienceInstance@CArea@@QAEXMMM@Z ENDP ; CArea::SAmbienceInstance::UpdateStepSound
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?UpdateOnceSound@SAmbienceInstance@CArea@@QAEXMMM@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_c_szFileName$2 = -36					; size = 4
$T3 = -32						; size = 4
__My_data$4 = -28					; size = 4
_fDistance$ = -24					; size = 4
__X$ = -20						; size = 4
tv154 = -16						; size = 4
__My_data$5 = -12					; size = 4
_this$ = -8						; size = 4
$T6 = -1						; size = 1
_fxCenter$ = 8						; size = 4
_fyCenter$ = 12						; size = 4
_fzCenter$ = 16						; size = 4
?UpdateOnceSound@SAmbienceInstance@CArea@@QAEXMMM@Z PROC ; CArea::SAmbienceInstance::UpdateOnceSound, COMDAT
; _this$ = ecx

; 1319 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1320 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00011	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _fzCenter$[ebp]
  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	f3 0f 10 48 0c	 movss	 xmm1, DWORD PTR [eax+12]
  0001e	f3 0f 5c 4d 10	 subss	 xmm1, DWORD PTR _fzCenter$[ebp]
  00023	f3 0f 59 c8	 mulss	 xmm1, xmm0
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0002f	f3 0f 5c 45 0c	 subss	 xmm0, DWORD PTR _fyCenter$[ebp]
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	f3 0f 10 50 08	 movss	 xmm2, DWORD PTR [eax+8]
  0003c	f3 0f 5c 55 0c	 subss	 xmm2, DWORD PTR _fyCenter$[ebp]
  00041	f3 0f 59 d0	 mulss	 xmm2, xmm0
  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004d	f3 0f 5c 45 08	 subss	 xmm0, DWORD PTR _fxCenter$[ebp]
  00052	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00055	f3 0f 10 58 04	 movss	 xmm3, DWORD PTR [eax+4]
  0005a	f3 0f 5c 5d 08	 subss	 xmm3, DWORD PTR _fxCenter$[ebp]
  0005f	f3 0f 59 d8	 mulss	 xmm3, xmm0
  00063	f3 0f 58 da	 addss	 xmm3, xmm2
  00067	f3 0f 58 d9	 addss	 xmm3, xmm1
  0006b	f3 0f 11 5d ec	 movss	 DWORD PTR __X$[ebp], xmm3
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00070	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00075	51		 push	 ecx
  00076	51		 push	 ecx
  00077	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0007c	e8 00 00 00 00	 call	 _sqrt
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1320 : 	float fDistance = sqrtf((fx - fxCenter)*(fx - fxCenter) + (fy - fyCenter)*(fy - fyCenter) + (fz - fzCenter)*(fz - fzCenter));

  00083	d9 5d e8	 fstp	 DWORD PTR _fDistance$[ebp]

; 1321 : 	if (DWORD(fDistance) < dwRange)

  00086	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  0008b	e8 00 00 00 00	 call	 __ftoui3
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00096	0f 83 a8 00 00
	00		 jae	 $LN2@UpdateOnce

; 1322 : 	{
; 1323 : 		if (-1 == iPlaySoundIndex)

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	83 78 18 ff	 cmp	 DWORD PTR [eax+24], -1
  000a3	0f 85 99 00 00
	00		 jne	 $LN4@UpdateOnce
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 c0 5c	 add	 eax, 92			; 0000005cH
  000af	89 45 f4	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  000b2	8b 45 f4	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000b5	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000bd	75 09		 jne	 SHORT $LN11@UpdateOnce
  000bf	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv154[ebp], 1
  000c6	eb 04		 jmp	 SHORT $LN12@UpdateOnce
$LN11@UpdateOnce:
  000c8	83 65 f0 00	 and	 DWORD PTR tv154[ebp], 0
$LN12@UpdateOnce:
  000cc	8a 45 f0	 mov	 al, BYTE PTR tv154[ebp]
  000cf	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1325 : 			if (AmbienceData.AmbienceSoundVector.empty())

  000d2	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  000d6	85 c0		 test	 eax, eax
  000d8	74 02		 je	 SHORT $LN5@UpdateOnce

; 1326 : 				return;

  000da	eb 6f		 jmp	 SHORT $LN1@UpdateOnce
$LN5@UpdateOnce:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 c0 5c	 add	 eax, 92			; 0000005cH
  000e2	89 45 e4	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000e5	33 c0		 xor	 eax, eax
  000e7	6b c0 18	 imul	 eax, eax, 24
  000ea	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  000ed	03 01		 add	 eax, DWORD PTR [ecx]
  000ef	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1328 : 			const char * c_szFileName = AmbienceData.AmbienceSoundVector[0].c_str();

  000f2	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  000f5	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000fa	89 45 dc	 mov	 DWORD PTR _c_szFileName$2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSoundManager@@@@0PAVCSoundManager@@A ; CSingleton<CSoundManager>::ms_singleton
  00102	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp

; 1329 : 			iPlaySoundIndex = CSoundManager::Instance().PlayAmbienceSound3D(fx, fy, fz, c_szFileName);

  00105	6a 01		 push	 1
  00107	ff 75 dc	 push	 DWORD PTR _c_szFileName$2[ebp]
  0010a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	51		 push	 ecx
  0010e	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00113	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00118	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	51		 push	 ecx
  0011c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00121	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00126	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00129	51		 push	 ecx
  0012a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0012f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00134	8b 4d d8	 mov	 ecx, DWORD PTR $T1[ebp]
  00137	e8 00 00 00 00	 call	 ?PlayAmbienceSound3D@CSoundManager@@QAEHMMMPBDH@Z ; CSoundManager::PlayAmbienceSound3D
  0013c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0013f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN4@UpdateOnce:

; 1330 : //			Tracef(" %d : OncePlay [%f] : %s\n", iPlaySoundIndex, fDistance, c_szFileName);
; 1331 : 		}
; 1332 : 	}

  00142	eb 07		 jmp	 SHORT $LN3@UpdateOnce
$LN2@UpdateOnce:

; 1333 : 	else
; 1334 : 	{
; 1335 : 		iPlaySoundIndex = -1;

  00144	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00147	83 48 18 ff	 or	 DWORD PTR [eax+24], -1
$LN3@UpdateOnce:
$LN1@UpdateOnce:

; 1336 : 	}
; 1337 : }

  0014b	c9		 leave
  0014c	c2 0c 00	 ret	 12			; 0000000cH
?UpdateOnceSound@SAmbienceInstance@CArea@@QAEXMMM@Z ENDP ; CArea::SAmbienceInstance::UpdateOnceSound
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__Update@SAmbienceInstance@CArea@@QAEXMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fxCenter$ = 8						; size = 4
_fyCenter$ = 12						; size = 4
_fzCenter$ = 16						; size = 4
?__Update@SAmbienceInstance@CArea@@QAEXMMM@Z PROC	; CArea::SAmbienceInstance::__Update, COMDAT
; _this$ = ecx

; 1311 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1312 : 	if (0 == dwRange)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000e	75 02		 jne	 SHORT $LN2@Update

; 1313 : 		return;

  00010	eb 2a		 jmp	 SHORT $LN1@Update
$LN2@Update:

; 1314 : 
; 1315 : 	(this->*Update)(fxCenter, fyCenter, fzCenter);

  00012	51		 push	 ecx
  00013	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fzCenter$[ebp]
  00018	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001d	51		 push	 ecx
  0001e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fyCenter$[ebp]
  00023	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00028	51		 push	 ecx
  00029	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fxCenter$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	ff 50 68	 call	 DWORD PTR [eax+104]
$LN1@Update:

; 1316 : }

  0003c	c9		 leave
  0003d	c2 0c 00	 ret	 12			; 0000000cH
?__Update@SAmbienceInstance@CArea@@QAEXMMM@Z ENDP	; CArea::SAmbienceInstance::__Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ??0SAmbienceInstance@CArea@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SAmbienceInstance@CArea@@QAE@XZ PROC			; CArea::SAmbienceInstance::SAmbienceInstance, COMDAT
; _this$ = ecx

; 1441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SAmbienceInstance@CArea@@6B@
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 20	 add	 ecx, 32			; 00000020H
  0001e	e8 00 00 00 00	 call	 ??0TPropertyAmbience@prt@@QAE@XZ

; 1442 : 	fx = 0.0f;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	0f 57 c0	 xorps	 xmm0, xmm0
  00029	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1443 : 	fy = 0.0f;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	0f 57 c0	 xorps	 xmm0, xmm0
  00034	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1444 : 	fz = 0.0f;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 1445 : 	dwRange = 0;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 1446 : 	iPlaySoundIndex = -1;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 48 18 ff	 or	 DWORD PTR [eax+24], -1

; 1447 : 	fNextPlayTime = 0.0f;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	0f 57 c0	 xorps	 xmm0, xmm0
  00058	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 1448 : }

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00060	c9		 leave
  00061	c3		 ret	 0
??0SAmbienceInstance@CArea@@QAE@XZ ENDP			; CArea::SAmbienceInstance::SAmbienceInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CArea::SObjectData> >::_Vector_val<std::_Simple_types<CArea::SObjectData> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@USObjectData@CArea@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CArea::SObjectData> >::_Vector_val<std::_Simple_types<CArea::SObjectData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 30		 push	 48			; 00000030H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXQAUSObjectData@CArea@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXQAUSObjectData@CArea@@II@Z PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 30		 push	 48			; 00000030H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 30	 imul	 eax, DWORD PTR __Newsize$[ebp], 48
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 30	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 48
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXQAUSObjectData@CArea@@II@Z ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 30		 push	 48			; 00000030H
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 05		 mov	 DWORD PTR $T7[ebp], 89478485 ; 05555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXPAUSObjectData@CArea@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXPAUSObjectData@CArea@@0@Z PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXPAUSObjectData@CArea@@0@Z ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USObjectData@CArea@@@std@@@std@@YAXPAUSObjectData@CArea@@QAU12@AAV?$allocator@USObjectData@CArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea::SObjectData> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::~vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@AAEXXZ ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USObjectData@CArea@@V?$allocator@USObjectData@CArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >::~vector<CArea::SObjectData,std::allocator<CArea::SObjectData> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USObjectData@CArea@@@std@@QAEXQAUSObjectData@CArea@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USObjectData@CArea@@@std@@QAEXQAUSObjectData@CArea@@I@Z PROC ; std::allocator<CArea::SObjectData>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 30	 imul	 eax, DWORD PTR __Count$[ebp], 48
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@USObjectData@CArea@@@std@@QAEXQAUSObjectData@CArea@@I@Z ENDP ; std::allocator<CArea::SObjectData>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?InitializeRotation@SObjectData@CArea@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitializeRotation@SObjectData@CArea@@QAEXXZ PROC	; CArea::SObjectData::InitializeRotation, COMDAT
; _this$ = ecx

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 23   : 	m_fYaw=m_fPitch=m_fRoll=0.0f;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f 57 c0	 xorps	 xmm0, xmm0
  0000d	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	0f 57 c0	 xorps	 xmm0, xmm0
  00018	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 24   : }

  00028	c9		 leave
  00029	c3		 ret	 0
?InitializeRotation@SObjectData@CArea@@QAEXXZ ENDP	; CArea::SObjectData::InitializeRotation
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >::_Vector_val<std::_Simple_types<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@CAXXZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXQAPAVCSpeedTreeWrapper@@II@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@ABEII@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXPAPAVCSpeedTreeWrapper@@0@Z ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@YAXPAPAVCSpeedTreeWrapper@@QAPAV1@AAV?$allocator@PAVCSpeedTreeWrapper@@@0@@Z ; std::_Destroy_range<std::allocator<CSpeedTreeWrapper *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAEXXZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ PROC ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@AAEXXZ ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCSpeedTreeWrapper@@V?$allocator@PAVCSpeedTreeWrapper@@@std@@@std@@QAE@XZ ENDP ; std::vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >::~vector<CSpeedTreeWrapper *,std::allocator<CSpeedTreeWrapper *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z PROC ; std::allocator<CSpeedTreeWrapper *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCSpeedTreeWrapper@@@std@@QAEXQAPAVCSpeedTreeWrapper@@I@Z ENDP ; std::allocator<CSpeedTreeWrapper *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@@std@@QAE@XZ PROC ; std::map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >::~map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@@std@@QAE@XZ ENDP ; std::map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >::~map<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
__Right$ = -48						; size = 4
__Left$ = -44						; size = 4
tv144 = -40						; size = 4
tv133 = -36						; size = 4
__Pnode$ = -32						; size = 4
__Pnode$ = -28						; size = 4
_this$ = -24						; size = 4
__Erasednode$ = -20					; size = 4
__Fixnode$ = -16					; size = 4
__Fixnodeparent$ = -12					; size = 4
__Pnode$ = -8						; size = 4
__Tmp$6 = -1						; size = 1
__Where$ = 8						; size = 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Extract, COMDAT
; _this$ = ecx

; 502  :     _Nodeptr _Extract(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 503  :         _Nodeptr _Erasednode = _Where._Ptr; // node to erase

  00009	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 504  :         ++_Where; // save successor iterator for return

  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __Where$[ebp]
  00012	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++

; 505  : 
; 506  :         _Nodeptr _Fixnode; // the node to recolor as needed
; 507  :         _Nodeptr _Fixnodeparent; // parent of _Fixnode (which may be nil)
; 508  :         _Nodeptr _Pnode = _Erasednode;

  00017	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 509  : 
; 510  :         if (_Pnode->_Left->_Isnil) {

  0001d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00026	85 c0		 test	 eax, eax
  00028	74 0b		 je	 SHORT $LN5@Extract

; 511  :             _Fixnode = _Pnode->_Right; // stitch up right subtree

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00030	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax
  00033	eb 27		 jmp	 SHORT $LN6@Extract
$LN5@Extract:

; 512  :         } else if (_Pnode->_Right->_Isnil) {

  00035	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0003b	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003f	85 c0		 test	 eax, eax
  00041	74 0a		 je	 SHORT $LN7@Extract

; 513  :             _Fixnode = _Pnode->_Left; // stitch up left subtree

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 514  :         } else { // two subtrees, must lift successor node to replace erased

  0004b	eb 0f		 jmp	 SHORT $LN6@Extract
$LN7@Extract:

; 515  :             _Pnode   = _Where._Ptr; // _Pnode is successor node

  0004d	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00050	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 516  :             _Fixnode = _Pnode->_Right; // _Fixnode is only subtree

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00056	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00059	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax
$LN6@Extract:

; 517  :         }
; 518  : 
; 519  :         if (_Pnode == _Erasednode) { // at most one subtree, relink it

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005f	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00062	0f 85 01 01 00
	00		 jne	 $LN9@Extract

; 520  :             _Fixnodeparent = _Erasednode->_Parent;

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 521  :             if (!_Fixnode->_Isnil) {

  00071	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00074	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00078	85 c0		 test	 eax, eax
  0007a	75 09		 jne	 SHORT $LN11@Extract

; 522  :                 _Fixnode->_Parent = _Fixnodeparent; // link up

  0007c	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00082	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN11@Extract:

; 523  :             }
; 524  : 
; 525  :             if (_Myhead->_Parent == _Erasednode) {

  00085	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008d	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00090	75 0d		 jne	 SHORT $LN12@Extract

; 526  :                 _Myhead->_Parent = _Fixnode; // link down from root

  00092	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0009a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0009d	eb 1d		 jmp	 SHORT $LN13@Extract
$LN12@Extract:

; 527  :             } else if (_Fixnodeparent->_Left == _Erasednode) {

  0009f	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000a7	75 0a		 jne	 SHORT $LN14@Extract

; 528  :                 _Fixnodeparent->_Left = _Fixnode; // link down to left

  000a9	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000af	89 08		 mov	 DWORD PTR [eax], ecx

; 529  :             } else {

  000b1	eb 09		 jmp	 SHORT $LN13@Extract
$LN14@Extract:

; 530  :                 _Fixnodeparent->_Right = _Fixnode; // link down to right

  000b3	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  000b9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN13@Extract:

; 531  :             }
; 532  : 
; 533  :             if (_Myhead->_Left == _Erasednode) {

  000bc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 00		 mov	 eax, DWORD PTR [eax]
  000c1	8b 00		 mov	 eax, DWORD PTR [eax]
  000c3	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  000c6	75 46		 jne	 SHORT $LN16@Extract

; 534  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  000c8	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000cb	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000cf	85 c0		 test	 eax, eax
  000d1	74 08		 je	 SHORT $LN42@Extract
  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  000d6	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
  000d9	eb 29		 jmp	 SHORT $LN43@Extract
$LN42@Extract:
  000db	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  000de	89 45 e4	 mov	 DWORD PTR __Pnode$[ebp], eax
  000e1	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  000e4	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
$LN59@Extract:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  000e7	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  000f0	85 c0		 test	 eax, eax
  000f2	75 0a		 jne	 SHORT $LN60@Extract

; 452  :             _Pnode = _Pnode->_Left;

  000f4	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	89 45 e4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  000fc	eb e9		 jmp	 SHORT $LN59@Extract
$LN60@Extract:

; 454  : 
; 455  :         return _Pnode;

  000fe	8b 45 e4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00101	89 45 dc	 mov	 DWORD PTR tv133[ebp], eax
$LN43@Extract:

; 534  :                 _Myhead->_Left = _Fixnode->_Isnil ? _Fixnodeparent // smallest is parent of erased node

  00104	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00107	8b 00		 mov	 eax, DWORD PTR [eax]
  00109	8b 4d dc	 mov	 ecx, DWORD PTR tv133[ebp]
  0010c	89 08		 mov	 DWORD PTR [eax], ecx
$LN16@Extract:

; 535  :                                                   : _Min(_Fixnode); // smallest in relinked subtree
; 536  :             }
; 537  : 
; 538  :             if (_Myhead->_Right == _Erasednode) {

  0010e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00111	8b 00		 mov	 eax, DWORD PTR [eax]
  00113	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00116	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  00119	75 49		 jne	 SHORT $LN17@Extract

; 539  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  0011b	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0011e	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00122	85 c0		 test	 eax, eax
  00124	74 08		 je	 SHORT $LN44@Extract
  00126	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00129	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
  0012c	eb 2b		 jmp	 SHORT $LN45@Extract
$LN44@Extract:
  0012e	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00131	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax
  00134	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00137	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
$LN64@Extract:

; 443  :         while (!_Pnode->_Right->_Isnil) {

  0013a	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0013d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00140	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00144	85 c0		 test	 eax, eax
  00146	75 0b		 jne	 SHORT $LN65@Extract

; 444  :             _Pnode = _Pnode->_Right;

  00148	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0014b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0014e	89 45 e0	 mov	 DWORD PTR __Pnode$[ebp], eax

; 445  :         }

  00151	eb e7		 jmp	 SHORT $LN64@Extract
$LN65@Extract:

; 446  : 
; 447  :         return _Pnode;

  00153	8b 45 e0	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00156	89 45 d8	 mov	 DWORD PTR tv144[ebp], eax
$LN45@Extract:

; 539  :                 _Myhead->_Right = _Fixnode->_Isnil ? _Fixnodeparent // largest is parent of erased node

  00159	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	8b 4d d8	 mov	 ecx, DWORD PTR tv144[ebp]
  00161	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN17@Extract:

; 540  :                                                    : _Max(_Fixnode); // largest in relinked subtree
; 541  :             }
; 542  :         } else { // erased has two subtrees, _Pnode is successor to erased

  00164	e9 f1 00 00 00	 jmp	 $LN10@Extract
$LN9@Extract:

; 543  :             _Erasednode->_Left->_Parent = _Pnode; // link left up

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0016c	8b 00		 mov	 eax, DWORD PTR [eax]
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00171	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 544  :             _Pnode->_Left               = _Erasednode->_Left; // link successor down

  00174	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00177	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  0017a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0017c	89 08		 mov	 DWORD PTR [eax], ecx

; 545  : 
; 546  :             if (_Pnode == _Erasednode->_Right) {

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00181	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00184	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00187	75 08		 jne	 SHORT $LN18@Extract

; 547  :                 _Fixnodeparent = _Pnode; // successor is next to erased

  00189	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0018c	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 548  :             } else { // successor further down, link in place of erased

  0018f	eb 3d		 jmp	 SHORT $LN19@Extract
$LN18@Extract:

; 549  :                 _Fixnodeparent = _Pnode->_Parent; // parent is successor's

  00191	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00194	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00197	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax

; 550  :                 if (!_Fixnode->_Isnil) {

  0019a	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0019d	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  001a1	85 c0		 test	 eax, eax
  001a3	75 09		 jne	 SHORT $LN20@Extract

; 551  :                     _Fixnode->_Parent = _Fixnodeparent; // link fix up

  001a5	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  001a8	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  001ab	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN20@Extract:

; 552  :                 }
; 553  : 
; 554  :                 _Fixnodeparent->_Left        = _Fixnode; // link fix down

  001ae	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  001b1	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  001b4	89 08		 mov	 DWORD PTR [eax], ecx

; 555  :                 _Pnode->_Right               = _Erasednode->_Right; // link next down

  001b6	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  001b9	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  001bc	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001bf	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 556  :                 _Erasednode->_Right->_Parent = _Pnode; // right up

  001c2	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001c5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001c8	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001cb	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN19@Extract:

; 557  :             }
; 558  : 
; 559  :             if (_Myhead->_Parent == _Erasednode) {

  001ce	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001d1	8b 00		 mov	 eax, DWORD PTR [eax]
  001d3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d6	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001d9	75 0d		 jne	 SHORT $LN21@Extract

; 560  :                 _Myhead->_Parent = _Pnode; // link down from root

  001db	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001de	8b 00		 mov	 eax, DWORD PTR [eax]
  001e0	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001e6	eb 26		 jmp	 SHORT $LN22@Extract
$LN21@Extract:

; 561  :             } else if (_Erasednode->_Parent->_Left == _Erasednode) {

  001e8	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001eb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001ee	8b 00		 mov	 eax, DWORD PTR [eax]
  001f0	3b 45 ec	 cmp	 eax, DWORD PTR __Erasednode$[ebp]
  001f3	75 0d		 jne	 SHORT $LN23@Extract

; 562  :                 _Erasednode->_Parent->_Left = _Pnode; // link down to left

  001f5	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  001f8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001fb	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  001fe	89 08		 mov	 DWORD PTR [eax], ecx

; 563  :             } else {

  00200	eb 0c		 jmp	 SHORT $LN22@Extract
$LN23@Extract:

; 564  :                 _Erasednode->_Parent->_Right = _Pnode; // link down to right

  00202	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00205	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00208	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0020b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN22@Extract:

; 565  :             }
; 566  : 
; 567  :             _Pnode->_Parent = _Erasednode->_Parent; // link successor up

  0020e	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00211	8b 4d ec	 mov	 ecx, DWORD PTR __Erasednode$[ebp]
  00214	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00217	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 568  :             _STD swap(_Pnode->_Color, _Erasednode->_Color); // recolor it

  0021a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0021d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00220	89 45 d0	 mov	 DWORD PTR __Right$[ebp], eax
  00223	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00226	83 c0 0c	 add	 eax, 12			; 0000000cH
  00229	89 45 d4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0022c	8b 45 d4	 mov	 eax, DWORD PTR __Left$[ebp]
  0022f	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00232	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  00235	8a 00		 mov	 al, BYTE PTR [eax]
  00237	88 45 ff	 mov	 BYTE PTR __Tmp$6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0023a	8b 45 d0	 mov	 eax, DWORD PTR __Right$[ebp]
  0023d	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00240	8b 45 d4	 mov	 eax, DWORD PTR __Left$[ebp]
  00243	8b 4d c8	 mov	 ecx, DWORD PTR $T4[ebp]
  00246	8a 09		 mov	 cl, BYTE PTR [ecx]
  00248	88 08		 mov	 BYTE PTR [eax], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0024a	8d 45 ff	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  0024d	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00250	8b 45 d0	 mov	 eax, DWORD PTR __Right$[ebp]
  00253	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp]
  00256	8a 09		 mov	 cl, BYTE PTR [ecx]
  00258	88 08		 mov	 BYTE PTR [eax], cl
$LN10@Extract:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 571  :         if (_Erasednode->_Color == _Black) { // erasing black link, must recolor/rebalance tree

  0025a	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  0025d	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00261	83 f8 01	 cmp	 eax, 1
  00264	0f 85 f4 01 00
	00		 jne	 $LN25@Extract

; 572  :             for (; _Fixnode != _Myhead->_Parent && _Fixnode->_Color == _Black; _Fixnodeparent = _Fixnode->_Parent) {

  0026a	eb 09		 jmp	 SHORT $LN4@Extract
$LN2@Extract:
  0026c	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0026f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00272	89 45 f4	 mov	 DWORD PTR __Fixnodeparent$[ebp], eax
$LN4@Extract:
  00275	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00278	8b 00		 mov	 eax, DWORD PTR [eax]
  0027a	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0027d	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00280	0f 84 d1 01 00
	00		 je	 $LN3@Extract
  00286	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  00289	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  0028d	83 f8 01	 cmp	 eax, 1
  00290	0f 85 c1 01 00
	00		 jne	 $LN3@Extract

; 573  :                 if (_Fixnode == _Fixnodeparent->_Left) { // fixup left subtree

  00296	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00299	8b 4d f0	 mov	 ecx, DWORD PTR __Fixnode$[ebp]
  0029c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0029e	0f 85 dd 00 00
	00		 jne	 $LN26@Extract

; 574  :                     _Pnode = _Fixnodeparent->_Right;

  002a4	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002a7	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002aa	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 575  :                     if (_Pnode->_Color == _Red) { // rotate red up from right subtree

  002ad	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002b0	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  002b4	85 c0		 test	 eax, eax
  002b6	75 22		 jne	 SHORT $LN28@Extract

; 576  :                         _Pnode->_Color         = _Black;

  002b8	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002bb	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 577  :                         _Fixnodeparent->_Color = _Red;

  002bf	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002c2	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 578  :                         _Lrotate(_Fixnodeparent);

  002c6	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  002c9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cc	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate

; 579  :                         _Pnode = _Fixnodeparent->_Right;

  002d1	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002d4	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002d7	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN28@Extract:

; 580  :                     }
; 581  : 
; 582  :                     if (_Pnode->_Isnil) {

  002da	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002dd	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  002e1	85 c0		 test	 eax, eax
  002e3	74 0b		 je	 SHORT $LN29@Extract

; 583  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  002e5	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  002e8	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 584  :                     } else if (_Pnode->_Left->_Color == _Black

  002eb	e9 8c 00 00 00	 jmp	 $LN30@Extract
$LN29@Extract:

; 585  :                                && _Pnode->_Right->_Color == _Black) { // redden right subtree with black children

  002f0	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  002f3	8b 00		 mov	 eax, DWORD PTR [eax]
  002f5	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  002f9	83 f8 01	 cmp	 eax, 1
  002fc	75 1e		 jne	 SHORT $LN31@Extract
  002fe	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00301	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00304	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00308	83 f8 01	 cmp	 eax, 1
  0030b	75 0f		 jne	 SHORT $LN31@Extract

; 586  :                         _Pnode->_Color = _Red;

  0030d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00310	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 587  :                         _Fixnode       = _Fixnodeparent;

  00314	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00317	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 588  :                     } else { // must rearrange right subtree

  0031a	eb 60		 jmp	 SHORT $LN30@Extract
$LN31@Extract:

; 589  :                         if (_Pnode->_Right->_Color == _Black) { // rotate red up from left sub-subtree

  0031c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0031f	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00322	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00326	83 f8 01	 cmp	 eax, 1
  00329	75 24		 jne	 SHORT $LN33@Extract

; 590  :                             _Pnode->_Left->_Color = _Black;

  0032b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0032e	8b 00		 mov	 eax, DWORD PTR [eax]
  00330	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 591  :                             _Pnode->_Color        = _Red;

  00334	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00337	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 592  :                             _Rrotate(_Pnode);

  0033b	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  0033e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00341	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate

; 593  :                             _Pnode = _Fixnodeparent->_Right;

  00346	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00349	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0034c	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN33@Extract:

; 594  :                         }
; 595  : 
; 596  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  0034f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00352	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  00355	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00358	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 597  :                         _Fixnodeparent->_Color = _Black;

  0035b	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0035e	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 598  :                         _Pnode->_Right->_Color = _Black;

  00362	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00365	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00368	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 599  :                         _Lrotate(_Fixnodeparent);

  0036c	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  0036f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00372	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate

; 600  :                         break; // tree now recolored/rebalanced

  00377	e9 db 00 00 00	 jmp	 $LN3@Extract
$LN30@Extract:

; 601  :                     }
; 602  :                 } else { // fixup right subtree

  0037c	e9 d1 00 00 00	 jmp	 $LN27@Extract
$LN26@Extract:

; 603  :                     _Pnode = _Fixnodeparent->_Left;

  00381	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00384	8b 00		 mov	 eax, DWORD PTR [eax]
  00386	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 604  :                     if (_Pnode->_Color == _Red) { // rotate red up from left subtree

  00389	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0038c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00390	85 c0		 test	 eax, eax
  00392	75 21		 jne	 SHORT $LN34@Extract

; 605  :                         _Pnode->_Color         = _Black;

  00394	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00397	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 606  :                         _Fixnodeparent->_Color = _Red;

  0039b	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  0039e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 607  :                         _Rrotate(_Fixnodeparent);

  003a2	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  003a5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003a8	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate

; 608  :                         _Pnode = _Fixnodeparent->_Left;

  003ad	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003b0	8b 00		 mov	 eax, DWORD PTR [eax]
  003b2	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN34@Extract:

; 609  :                     }
; 610  : 
; 611  :                     if (_Pnode->_Isnil) {

  003b5	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003b8	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  003bc	85 c0		 test	 eax, eax
  003be	74 0b		 je	 SHORT $LN35@Extract

; 612  :                         _Fixnode = _Fixnodeparent; // shouldn't happen

  003c0	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003c3	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 613  :                     } else if (_Pnode->_Right->_Color == _Black

  003c6	e9 87 00 00 00	 jmp	 $LN27@Extract
$LN35@Extract:

; 614  :                                && _Pnode->_Left->_Color == _Black) { // redden left subtree with black children

  003cb	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003ce	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  003d1	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  003d5	83 f8 01	 cmp	 eax, 1
  003d8	75 1d		 jne	 SHORT $LN37@Extract
  003da	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003dd	8b 00		 mov	 eax, DWORD PTR [eax]
  003df	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  003e3	83 f8 01	 cmp	 eax, 1
  003e6	75 0f		 jne	 SHORT $LN37@Extract

; 615  :                         _Pnode->_Color = _Red;

  003e8	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003eb	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 616  :                         _Fixnode       = _Fixnodeparent;

  003ef	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  003f2	89 45 f0	 mov	 DWORD PTR __Fixnode$[ebp], eax

; 617  :                     } else { // must rearrange left subtree

  003f5	eb 5b		 jmp	 SHORT $LN27@Extract
$LN37@Extract:

; 618  :                         if (_Pnode->_Left->_Color == _Black) { // rotate red up from right sub-subtree

  003f7	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  003fa	8b 00		 mov	 eax, DWORD PTR [eax]
  003fc	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00400	83 f8 01	 cmp	 eax, 1
  00403	75 24		 jne	 SHORT $LN39@Extract

; 619  :                             _Pnode->_Right->_Color = _Black;

  00405	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00408	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0040b	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 620  :                             _Pnode->_Color         = _Red;

  0040f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00412	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 621  :                             _Lrotate(_Pnode);

  00416	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00419	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0041c	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate

; 622  :                             _Pnode = _Fixnodeparent->_Left;

  00421	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00424	8b 00		 mov	 eax, DWORD PTR [eax]
  00426	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN39@Extract:

; 623  :                         }
; 624  : 
; 625  :                         _Pnode->_Color         = _Fixnodeparent->_Color;

  00429	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0042c	8b 4d f4	 mov	 ecx, DWORD PTR __Fixnodeparent$[ebp]
  0042f	8a 49 0c	 mov	 cl, BYTE PTR [ecx+12]
  00432	88 48 0c	 mov	 BYTE PTR [eax+12], cl

; 626  :                         _Fixnodeparent->_Color = _Black;

  00435	8b 45 f4	 mov	 eax, DWORD PTR __Fixnodeparent$[ebp]
  00438	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 627  :                         _Pnode->_Left->_Color  = _Black;

  0043c	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0043f	8b 00		 mov	 eax, DWORD PTR [eax]
  00441	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 628  :                         _Rrotate(_Fixnodeparent);

  00445	ff 75 f4	 push	 DWORD PTR __Fixnodeparent$[ebp]
  00448	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0044b	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate

; 629  :                         break; // tree now recolored/rebalanced

  00450	eb 05		 jmp	 SHORT $LN3@Extract
$LN27@Extract:

; 630  :                     }
; 631  :                 }
; 632  :             }

  00452	e9 15 fe ff ff	 jmp	 $LN2@Extract
$LN3@Extract:

; 633  : 
; 634  :             _Fixnode->_Color = _Black; // stopping node is black

  00457	8b 45 f0	 mov	 eax, DWORD PTR __Fixnode$[ebp]
  0045a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1
$LN25@Extract:

; 635  :         }
; 636  : 
; 637  :         if (0 < _Mysize) {

  0045e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00461	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00465	76 0d		 jbe	 SHORT $LN40@Extract

; 638  :             --_Mysize;

  00467	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0046a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0046d	48		 dec	 eax
  0046e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00471	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN40@Extract:

; 639  :         }
; 640  : 
; 641  :         return _Erasednode;

  00474	8b 45 ec	 mov	 eax, DWORD PTR __Erasednode$[ebp]

; 642  :     }

  00477	c9		 leave
  00478	c2 04 00	 ret	 4
?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Extract
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S26$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S26$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@K@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Find<unsigned long>
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
__Scary$ = -20						; size = 4
$T4 = -16						; size = 4
__Successor$ = -12					; size = 4
__Erasednode$ = -8					; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Erase_unchecked, COMDAT
; _this$ = ecx

; 1385 :     _Nodeptr _Erase_unchecked(_Unchecked_const_iterator _Where) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Scary$[ebp], eax

; 1386 :         const auto _Scary                    = _Get_scary();
; 1387 :         _Unchecked_const_iterator _Successor = _Where;

  00015	8b 45 08	 mov	 eax, DWORD PTR __Where$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR __Successor$[ebp], eax

; 1388 :         ++_Successor; // save successor iterator for return

  0001b	8d 4d f4	 lea	 ecx, DWORD PTR __Successor$[ebp]
  0001e	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >,std::_Iterator_base0>::operator++

; 1389 :         _Nodeptr _Erasednode = _Scary->_Extract(_Where); // node to erase

  00023	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  00026	8b 4d ec	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Extract@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Extract
  0002e	89 45 f8	 mov	 DWORD PTR __Erasednode$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00034	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00037	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003d	8b 45 f8	 mov	 eax, DWORD PTR __Erasednode$[ebp]
  00040	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00046	ff 75 f8	 push	 DWORD PTR __Erasednode$[ebp]
  00049	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0004c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx

; 1390 :         _Scary->_Orphan_ptr(_Erasednode);
; 1391 :         _Node::_Freenode(_Getal(), _Erasednode); // delete erased node
; 1392 :         return _Successor._Ptr; // return successor nodeptr

  00053	8b 45 f4	 mov	 eax, DWORD PTR __Successor$[ebp]

; 1393 :     }

  00056	c9		 leave
  00057	c2 04 00	 ret	 4
?_Erase_unchecked@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@AAEPAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@2@V?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@U_Iterator_base0@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Erase_unchecked
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::end, COMDAT
; _this$ = ecx

; 1248 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1249 :         const auto _Scary = _Get_scary();
; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1251 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?end@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::begin, COMDAT
; _this$ = ecx

; 1238 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 :     }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKPAVCEffectInstance@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,CEffectInstance *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKPAVCEffectInstance@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,CEffectInstance *>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@KPAVCEffectInstance@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCEffectInstance@@@std@@@3@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >::_Tree<std::_Tmap_traits<unsigned long,CEffectInstance *,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,CEffectInstance *> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv83 = -16						; size = 4
__Ptr$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 2645 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2646 :         if (_Mypair._Myval2) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 2f		 je	 SHORT $LN3@unique_ptr

; 2647 :             _Mypair._Get_first()(_Mypair._Myval2);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2647 :             _Mypair._Get_first()(_Mypair._Myval2);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2537 :         delete _Ptr;

  0001f	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00022	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00025	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00029	74 11		 je	 SHORT $LN9@unique_ptr
  0002b	6a 01		 push	 1
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00035	ff 10		 call	 DWORD PTR [eax]
  00037	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0003a	eb 04		 jmp	 SHORT $LN3@unique_ptr
$LN9@unique_ptr:
  0003c	83 65 f0 00	 and	 DWORD PTR tv83[ebp], 0
$LN3@unique_ptr:

; 2648 :         }
; 2649 :     }

  00040	c9		 leave
  00041	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 908  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 909  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 910  :         _Left = _STD move(_Right);
; 911  :     }
; 912  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1TPropertyDungeonBlock@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TPropertyDungeonBlock@prt@@QAE@XZ PROC		; prt::TPropertyDungeonBlock::~TPropertyDungeonBlock, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 30	 add	 ecx, 48			; 00000030H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 18	 add	 ecx, 24			; 00000018H
  00018	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	c9		 leave
  00026	c3		 ret	 0
??1TPropertyDungeonBlock@prt@@QAE@XZ ENDP		; prt::TPropertyDungeonBlock::~TPropertyDungeonBlock
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TPropertyDungeonBlock@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TPropertyDungeonBlock@prt@@QAE@XZ PROC		; prt::TPropertyDungeonBlock::TPropertyDungeonBlock, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 18	 add	 ecx, 24			; 00000018H
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c9		 leave
  00029	c3		 ret	 0
??0TPropertyDungeonBlock@prt@@QAE@XZ ENDP		; prt::TPropertyDungeonBlock::TPropertyDungeonBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1TPropertyAmbience@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TPropertyAmbience@prt@@QAE@XZ PROC			; prt::TPropertyAmbience::~TPropertyAmbience, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 3c	 add	 ecx, 60			; 0000003cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0000d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 18	 add	 ecx, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00018	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	c9		 leave
  00026	c3		 ret	 0
??1TPropertyAmbience@prt@@QAE@XZ ENDP			; prt::TPropertyAmbience::~TPropertyAmbience
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0TPropertyAmbience@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$1 = -8						; size = 4
_this$ = -4						; size = 4
??0TPropertyAmbience@prt@@QAE@XZ PROC			; prt::TPropertyAmbience::TPropertyAmbience, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 18	 add	 ecx, 24			; 00000018H
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00022	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00034	83 20 00	 and	 DWORD PTR [eax], 0
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  0003a	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00041	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c9		 leave
  00049	c3		 ret	 0
??0TPropertyAmbience@prt@@QAE@XZ ENDP			; prt::TPropertyAmbience::TPropertyAmbience
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1TPropertyEffect@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TPropertyEffect@prt@@QAE@XZ PROC			; prt::TPropertyEffect::~TPropertyEffect, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001a	c9		 leave
  0001b	c3		 ret	 0
??1TPropertyEffect@prt@@QAE@XZ ENDP			; prt::TPropertyEffect::~TPropertyEffect
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TPropertyEffect@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TPropertyEffect@prt@@QAE@XZ PROC			; prt::TPropertyEffect::TPropertyEffect, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 18	 add	 ecx, 24			; 00000018H
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c9		 leave
  0001e	c3		 ret	 0
??0TPropertyEffect@prt@@QAE@XZ ENDP			; prt::TPropertyEffect::TPropertyEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1TPropertyBuilding@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1TPropertyBuilding@prt@@QAE@XZ PROC			; prt::TPropertyBuilding::~TPropertyBuilding, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 30	 add	 ecx, 48			; 00000030H

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 18	 add	 ecx, 24			; 00000018H
  00018	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	c9		 leave
  00026	c3		 ret	 0
??1TPropertyBuilding@prt@@QAE@XZ ENDP			; prt::TPropertyBuilding::~TPropertyBuilding
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0TPropertyBuilding@prt@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0TPropertyBuilding@prt@@QAE@XZ PROC			; prt::TPropertyBuilding::TPropertyBuilding, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 18	 add	 ecx, 24			; 00000018H
  00015	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 30	 add	 ecx, 48			; 00000030H
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c9		 leave
  00029	c3		 ret	 0
??0TPropertyBuilding@prt@@QAE@XZ ENDP			; prt::TPropertyBuilding::TPropertyBuilding
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Lock$5 = -60						; size = 4
__Old_val$6 = -56					; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
_this$ = -44						; size = 4
__Ptr$ = -40						; size = 4
__Id$9 = -36						; size = 4
__Psave_guard$10 = -32					; size = 4
__Val$ = -28						; size = 4
__Pf$11 = -24						; size = 4
__Pfmod$12 = -20					; size = 4
__Psave$13 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 426  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 bc 00	 and	 DWORD PTR $T3[ebp], 0

; 427  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00029	6a 00		 push	 0
  0002b	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 428  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003c	89 45 f0	 mov	 DWORD PTR __Psave$13[ebp], eax

; 429  : 
; 430  :     const size_t _Id         = _Facet::id;

  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00044	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00049	89 45 dc	 mov	 DWORD PTR __Id$9[ebp], eax

; 431  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004c	ff 75 dc	 push	 DWORD PTR __Id$9[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax

; 432  : 
; 433  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$11[ebp], 0
  0005e	0f 85 9f 00 00
	00		 jne	 $LN2@use_facet

; 434  :         if (_Psave) {

  00064	83 7d f0 00	 cmp	 DWORD PTR __Psave$13[ebp], 0
  00068	74 0b		 je	 SHORT $LN3@use_facet

; 435  :             _Pf = _Psave; // lazy facet already allocated

  0006a	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  0006d	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
  00070	e9 8e 00 00 00	 jmp	 $LN2@use_facet
$LN3@use_facet:

; 436  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  00075	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  00078	8d 45 f0	 lea	 eax, DWORD PTR __Psave$13[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
  00083	83 f8 ff	 cmp	 eax, -1
  00086	75 07		 jne	 SHORT $LN5@use_facet

; 437  : #if _HAS_EXCEPTIONS
; 438  :             _Throw_bad_cast(); // lazy disallowed

  00088	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast

; 439  : #else // _HAS_EXCEPTIONS
; 440  :             _CSTD abort(); // lazy disallowed
; 441  : #endif // _HAS_EXCEPTIONS
; 442  :         } else { // queue up lazy facet for destruction

  0008d	eb 74		 jmp	 SHORT $LN2@use_facet
$LN5@use_facet:

; 443  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008f	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  00092	89 45 ec	 mov	 DWORD PTR __Pfmod$12[ebp], eax

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00095	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  00098	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2590 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  0009b	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  0009e	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000a1	8d 45 d8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  000a4	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  000ad	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000af	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 445  : 
; 446  : #if defined(_M_CEE)
; 447  :             _Facet_Register_m(_Pfmod);
; 448  : #else // defined(_M_CEE)
; 449  :             _Facet_Register(_Pfmod);

  000b5	ff 75 ec	 push	 DWORD PTR __Pfmod$12[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000bd	59		 pop	 ecx

; 450  : #endif // defined(_M_CEE)
; 451  : 
; 452  :             _Pfmod->_Incref();

  000be	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  000c1	8b 00		 mov	 eax, DWORD PTR [eax]
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$12[ebp]
  000c6	ff 50 04	 call	 DWORD PTR [eax+4]

; 453  :             _Facetptr<_Facet>::_Psave = _Psave;

  000c9	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000cc	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 454  :             _Pf                       = _Psave;

  000d1	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000d4	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2676 :         return _STD exchange(_Mypair._Myval2, pointer());

  000d7	83 65 cc 00	 and	 DWORD PTR $T7[ebp], 0
  000db	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  000de	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e1	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000e4	8b 00		 mov	 eax, DWORD PTR [eax]
  000e6	89 45 c8	 mov	 DWORD PTR __Old_val$6[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000e9	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000ec	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  000f1	8b 45 c8	 mov	 eax, DWORD PTR __Old_val$6[ebp]
  000f4	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 457  :         }

  000f7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fb	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  000fe	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 458  :     }
; 459  : 
; 460  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00103	8b 45 e8	 mov	 eax, DWORD PTR __Pf$11[ebp]
  00106	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  00109	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0010d	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00110	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00115	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
$LN7@use_facet:

; 461  :     _END_LOCK()
; 462  : } // end of use_facet body

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2725 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2726 :         _Tidy();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 2368 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00033	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00036	83 e0 01	 and	 eax, 1
  00039	74 0c		 je	 SHORT $LN2@scalar
  0003b	6a 18		 push	 24			; 00000018H
  0003d	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx
$LN2@scalar:
  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	c9		 leave
  0004b	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2787 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2788 :         _Adl_verify_range(_First, _Last);
; 2789 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000a	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	ff 75 14	 push	 DWORD PTR __Dest$[ebp]
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2790 :         return _Last;

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2791 :     }

  0001f	c9		 leave
  00020	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2782 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2783 :         return _Ch;

  00007	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]

; 2784 :     }

  0000a	c9		 leave
  0000b	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2776 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2777 :         _Adl_verify_range(_First, _Last);
; 2778 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000a	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00011	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00014	e8 00 00 00 00	 call	 _memcpy
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2779 :         return _Last;

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2780 :     }

  0001f	c9		 leave
  00020	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2771 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2772 :         return _Byte;

  00007	8a 45 08	 mov	 al, BYTE PTR __Byte$[ebp]

; 2773 :     }

  0000a	c9		 leave
  0000b	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2762 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2763 :         _Adl_verify_range(_First, _Last);
; 2764 :         for (; _First != _Last; ++_First) {

  00007	eb 07		 jmp	 SHORT $LN4@do_toupper
$LN2@do_toupper:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@do_toupper:
  00010	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00013	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00016	74 1c		 je	 SHORT $LN3@do_toupper

; 2765 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	50		 push	 eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Toupper
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00030	88 01		 mov	 BYTE PTR [ecx], al

; 2766 :         }

  00032	eb d5		 jmp	 SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2767 : 
; 2768 :         return _First;

  00034	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2769 :     }

  00037	c9		 leave
  00038	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2757 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2758 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 __Toupper
  00018	59		 pop	 ecx
  00019	59		 pop	 ecx

; 2759 :     }

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2748 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2749 :         _Adl_verify_range(_First, _Last);
; 2750 :         for (; _First != _Last; ++_First) {

  00007	eb 07		 jmp	 SHORT $LN4@do_tolower
$LN2@do_tolower:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@do_tolower:
  00010	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00013	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00016	74 1c		 je	 SHORT $LN3@do_tolower

; 2751 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c0 08	 add	 eax, 8
  0001e	50		 push	 eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00022	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Tolower
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00030	88 01		 mov	 BYTE PTR [ecx], al

; 2752 :         }

  00032	eb d5		 jmp	 SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2753 : 
; 2754 :         return _First;

  00034	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2755 :     }

  00037	c9		 leave
  00038	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2743 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2744 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 __Tolower
  00018	59		 pop	 ecx
  00019	59		 pop	 ecx

; 2745 :     }

  0001a	c9		 leave
  0001b	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2733 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2734 :         if (0 < _Ctype._Delfl) {

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0000f	7e 0e		 jle	 SHORT $LN2@Tidy

; 2735 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	ff 70 0c	 push	 DWORD PTR [eax+12]
  00017	e8 00 00 00 00	 call	 _free
  0001c	59		 pop	 ecx
  0001d	eb 1b		 jmp	 SHORT $LN3@Tidy
$LN2@Tidy:

; 2736 :         } else if (_Ctype._Delfl < 0) {

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00026	7d 12		 jge	 SHORT $LN3@Tidy

; 2737 :             delete[] _Ctype._Table;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00031	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00039	59		 pop	 ecx
$LN3@Tidy:

; 2738 :         }
; 2739 : 
; 2740 :         _CSTD free(_Ctype._LocaleName);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 14	 push	 DWORD PTR [eax+20]
  00040	e8 00 00 00 00	 call	 _free
  00045	59		 pop	 ecx

; 2741 :     }

  00046	c9		 leave
  00047	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -148						; size = 52
$T3 = -96						; size = 16
$T4 = -80						; size = 16
$T5 = -64						; size = 16
tv128 = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
tv89 = -36						; size = 4
tv142 = -32						; size = 4
tv137 = -28						; size = 4
_this$ = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2706 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	83 65 ec 00	 and	 DWORD PTR $T8[ebp], 0

; 2707 :         if (_Ppf && !*_Ppf) {

  0002e	83 7d 08 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00032	0f 84 0e 01 00
	00		 je	 $LN2@Getcat
  00038	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0003b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003e	0f 85 02 01 00
	00		 jne	 $LN2@Getcat

; 2708 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  00044	6a 18		 push	 24			; 00000018H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004b	59		 pop	 ecx
  0004c	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
  0004f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00053	83 7d f0 00	 cmp	 DWORD PTR $T9[ebp], 0
  00057	0f 84 bc 00 00
	00		 je	 $LN4@Getcat

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  0005d	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00060	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00064	74 35		 je	 SHORT $LN12@Getcat
  00066	8b 45 0c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00069	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006c	83 c0 18	 add	 eax, 24			; 00000018H
  0006f	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
  00072	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  00075	89 45 e4	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  00078	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0007e	74 0a		 je	 SHORT $LN16@Getcat
  00080	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	89 45 e0	 mov	 DWORD PTR tv142[ebp], eax
  00088	eb 09		 jmp	 SHORT $LN17@Getcat
$LN16@Getcat:
  0008a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	83 c0 04	 add	 eax, 4
  00090	89 45 e0	 mov	 DWORD PTR tv142[ebp], eax
$LN17@Getcat:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv142[ebp]
  00096	89 45 e4	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00099	eb 07		 jmp	 SHORT $LN10@Getcat
$LN12@Getcat:
  0009b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN10@Getcat:

; 2708 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  000a2	ff 75 e4	 push	 DWORD PTR tv137[ebp]
  000a5	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000ab	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  000b0	89 45 d0	 mov	 DWORD PTR tv128[ebp], eax
  000b3	8b 45 ec	 mov	 eax, DWORD PTR $T8[ebp]
  000b6	83 c8 01	 or	 eax, 1
  000b9	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
  000bc	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  000bf	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@

; 153  :         {}

  000c5	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  000c8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  000ce	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  000d1	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 2366 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

  000d5	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  000d8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2702 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  000de	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  000e1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 199  :         return ::_Getctype();

  000e7	8d 45 a0	 lea	 eax, DWORD PTR $T3[ebp]
  000ea	50		 push	 eax
  000eb	e8 00 00 00 00	 call	 __Getctype
  000f0	59		 pop	 ecx
  000f1	8b f0		 mov	 esi, eax
  000f3	8d 7d c0	 lea	 edi, DWORD PTR $T5[ebp]
  000f6	a5		 movsd
  000f7	a5		 movsd
  000f8	a5		 movsd
  000f9	a5		 movsd
  000fa	8d 75 c0	 lea	 esi, DWORD PTR $T5[ebp]
  000fd	8d 7d b0	 lea	 edi, DWORD PTR $T4[ebp]
  00100	a5		 movsd
  00101	a5		 movsd
  00102	a5		 movsd
  00103	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2730 :         _Ctype = _Lobj._Getctype();

  00104	8b 7d f0	 mov	 edi, DWORD PTR $T9[ebp]
  00107	83 c7 08	 add	 edi, 8
  0010a	8d 75 b0	 lea	 esi, DWORD PTR $T4[ebp]
  0010d	a5		 movsd
  0010e	a5		 movsd
  0010f	a5		 movsd
  00110	a5		 movsd

; 2708 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  00111	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00114	89 45 dc	 mov	 DWORD PTR tv89[ebp], eax
  00117	eb 04		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00119	83 65 dc 00	 and	 DWORD PTR tv89[ebp], 0
$LN5@Getcat:
  0011d	8b 45 dc	 mov	 eax, DWORD PTR tv89[ebp]
  00120	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
  00123	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00127	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0012a	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
  0012d	89 08		 mov	 DWORD PTR [eax], ecx
  0012f	8b 45 ec	 mov	 eax, DWORD PTR $T8[ebp]
  00132	83 e0 01	 and	 eax, 1
  00135	74 0f		 je	 SHORT $LN2@Getcat
  00137	83 65 ec fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  0013b	8d 8d 6c ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00141	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2709 :         }
; 2710 : 
; 2711 :         return _X_CTYPE;

  00146	6a 02		 push	 2
  00148	58		 pop	 eax

; 2712 :     }

  00149	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00153	59		 pop	 ecx
  00154	5f		 pop	 edi
  00155	5e		 pop	 esi
  00156	c9		 leave
  00157	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	ff 75 f0	 push	 DWORD PTR $T9[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 6c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-148]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2368 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00022	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00025	83 e0 01	 and	 eax, 1
  00028	74 0c		 je	 SHORT $LN2@scalar
  0002a	6a 08		 push	 8
  0002c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
$LN2@scalar:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Ptr0$ = -16						; size = 4
__Facptr$ = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  00012	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00015	73 14		 jae	 SHORT $LN6@Getfacet
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  00023	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00026	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00029	eb 04		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0002b	83 65 f8 00	 and	 DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  00032	89 45 f4	 mov	 DWORD PTR __Facptr$[ebp], eax

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00035	83 7d f4 00	 cmp	 DWORD PTR __Facptr$[ebp], 0
  00039	75 0e		 jne	 SHORT $LN3@Getfacet
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	0f b6 40 14	 movzx	 eax, BYTE PTR [eax+20]
  00045	85 c0		 test	 eax, eax
  00047	75 05		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 376  :             return _Facptr; // found facet or not transparent

  00049	8b 45 f4	 mov	 eax, DWORD PTR __Facptr$[ebp]
  0004c	eb 23		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  0004e	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00053	89 45 f0	 mov	 DWORD PTR __Ptr0$[ebp], eax

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  00056	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0005c	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0005f	73 0e		 jae	 SHORT $LN4@Getfacet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00061	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00064	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0006d	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 383  :         }
; 384  : 
; 385  :         return nullptr; // no entry in current locale

  0006f	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 386  :     }

  00071	c9		 leave
  00072	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 350  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 2f		 je	 SHORT $LN3@locale

; 352  :             delete _Ptr->_Decref();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00020	ff 50 08	 call	 DWORD PTR [eax+8]
  00023	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00026	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002a	74 11		 je	 SHORT $LN4@locale
  0002c	6a 01		 push	 1
  0002e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00036	ff 10		 call	 DWORD PTR [eax]
  00038	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0003b	eb 04		 jmp	 SHORT $LN3@locale
$LN4@locale:
  0003d	83 65 f4 00	 and	 DWORD PTR tv84[ebp], 0
$LN3@locale:

; 353  :         }
; 354  :     }

  00041	c9		 leave
  00042	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00019	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	74 0c		 je	 SHORT $LN2@scalar
  00021	6a 08		 push	 8
  00023	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 139  :         virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :             if (_MT_DECR(_Myrefs) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 05		 jne	 SHORT $LN2@Decref

; 141  :                 return this;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	eb 02		 jmp	 SHORT $LN3@Decref
$LN2@Decref:

; 142  :             }
; 143  : 
; 144  :             return nullptr;

  0001c	33 c0		 xor	 eax, eax
$LN3@Decref:

; 145  :         }

  0001e	c9		 leave
  0001f	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 135  :         virtual void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 136  :             _MT_INCR(_Myrefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 137  :         }

  00010	c9		 leave
  00011	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -8						; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000e	75 30		 jne	 SHORT $LN2@operator

; 106  :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00010	6a 00		 push	 0
  00012	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00015	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 107  :                 if (_Id == 0) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	75 16		 jne	 SHORT $LN3@operator

; 108  :                     _Id = static_cast<size_t>(++_Id_cnt);

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00027	40		 inc	 eax
  00028	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00036	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator:

; 109  :                 }
; 110  :                 _END_LOCK()

  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0003b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN2@operator:

; 111  :             }
; 112  :             return _Id;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 113  :         }

  00045	c9		 leave
  00046	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN4@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	e8 00 00 00 00	 call	 _free
  00019	59		 pop	 ecx
$LN4@Yarn:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 20 00	 and	 DWORD PTR [eax], 0

; 101  :         _Tidy();
; 102  :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN4@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	e8 00 00 00 00	 call	 _free
  00019	59		 pop	 ecx
$LN4@Yarn:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 20 00	 and	 DWORD PTR [eax], 0

; 101  :         _Tidy();
; 102  :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 178  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 179  :         _Locinfo_dtor(this);

  00028	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  00030	59		 pop	 ecx

; 180  :     }

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 2c	 add	 eax, 44			; 0000002cH
  00037	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00040	74 0b		 je	 SHORT $LN7@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	ff 30		 push	 DWORD PTR [eax]
  00047	e8 00 00 00 00	 call	 _free
  0004c	59		 pop	 ecx
$LN7@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 24	 add	 eax, 36			; 00000024H
  00059	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0005c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00062	74 0b		 je	 SHORT $LN14@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00064	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	ff 30		 push	 DWORD PTR [eax]
  00069	e8 00 00 00 00	 call	 _free
  0006e	59		 pop	 ecx
$LN14@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0006f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00075	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 1c	 add	 eax, 28			; 0000001cH
  0007b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0007e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00081	83 38 00	 cmp	 DWORD PTR [eax], 0
  00084	74 0b		 je	 SHORT $LN21@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00086	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00089	ff 30		 push	 DWORD PTR [eax]
  0008b	e8 00 00 00 00	 call	 _free
  00090	59		 pop	 ecx
$LN21@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  00091	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	83 c0 14	 add	 eax, 20			; 00000014H
  0009d	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000a0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a6	74 0b		 je	 SHORT $LN28@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	ff 30		 push	 DWORD PTR [eax]
  000ad	e8 00 00 00 00	 call	 _free
  000b2	59		 pop	 ecx
$LN28@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000b3	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000bf	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000c2	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c8	74 0b		 je	 SHORT $LN35@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000ca	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	ff 30		 push	 DWORD PTR [eax]
  000cf	e8 00 00 00 00	 call	 _free
  000d4	59		 pop	 ecx
$LN35@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000d5	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	83 c0 04	 add	 eax, 4
  000e1	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000e4	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ea	74 0b		 je	 SHORT $LN42@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000ec	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	ff 30		 push	 DWORD PTR [eax]
  000f1	e8 00 00 00 00	 call	 _free
  000f6	59		 pop	 ecx
$LN42@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000f7	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010f	59		 pop	 ecx
  00110	c9		 leave
  00111	c3		 ret	 0
  00112	cc		 int	 3
  00113	cc		 int	 3
  00114	cc		 int	 3
  00115	cc		 int	 3
  00116	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 155  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 
; 61   :     __CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 62   :         *this = _Right;
; 63   :     }
; 64   : 
; 65   :     __CLR_OR_THIS_CALL _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 66   :         *this = _Right;
; 67   :     }
; 68   : 
; 69   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right) noexcept {
; 70   :         return *this = _Right._Myptr;
; 71   :     }
; 72   : 
; 73   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Elem* _Right) noexcept {
; 74   :         if (_Myptr != _Right) { // new value, discard old and copy new
; 75   :             _Tidy();
; 76   : 
; 77   :             if (_Right) { // new is not empty, copy it
; 78   :                 const _Elem* _Ptr = _Right;
; 79   :                 while (*_Ptr != _Elem{}) {
; 80   :                     ++_Ptr;
; 81   :                 }
; 82   : 
; 83   :                 const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
; 84   : 
; 85   : #ifdef _DEBUG
; 86   :                 _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, _CRT_BLOCK, __FILE__, __LINE__));
; 87   : #else // _DEBUG
; 88   :                 _Myptr = static_cast<_Elem*>(_CSTD malloc(_Count));
; 89   : #endif // _DEBUG
; 90   : 
; 91   :                 if (_Myptr) {
; 92   :                     _CSTD memcpy(_Myptr, _Right, _Count);
; 93   :                 }
; 94   :             }
; 95   :         }
; 96   : 
; 97   :         return *this;
; 98   :     }
; 99   : 
; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {
; 101  :         _Tidy();
; 102  :     }
; 103  : 
; 104  :     _NODISCARD bool __CLR_OR_THIS_CALL empty() const noexcept {
; 105  :         return _Myptr == nullptr;
; 106  :     }
; 107  : 
; 108  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {
; 109  :         return _Myptr ? _Myptr : &_Nul;
; 110  :     }
; 111  : 
; 112  :     _NODISCARD bool __CLR_OR_THIS_CALL _Empty() const noexcept {
; 113  :         return _Myptr == nullptr;
; 114  :     }
; 115  : 
; 116  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL _C_str() const noexcept {
; 117  :         return _Myptr ? _Myptr : &_Nul;
; 118  :     }
; 119  : 
; 120  : private:
; 121  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {
; 122  :         if (_Myptr) {
; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);
; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;
; 131  :     }
; 132  : 
; 133  :     _Elem* _Myptr; // pointer to allocated string
; 134  :     _Elem _Nul; // nul terminator for unallocated string
; 135  : };
; 136  : 
; 137  : // CLASS _Locinfo
; 138  : class _CRTIMP2_PURE_IMPORT _Locinfo { // summary of all stuff specific to a locale used by standard facets
; 139  : public:
; 140  :     using _Collvec  = ::_Collvec;
; 141  :     using _Ctypevec = ::_Ctypevec;
; 142  :     using _Cvtvec   = ::_Cvtvec;
; 143  :     using _Timevec  = _STD _Timevec;
; 144  : 
; 145  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, const char*);
; 146  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, int, const char*);
; 147  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(_Locinfo*);
; 148  :     static _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(_Locinfo*, int, const char*);
; 149  : 
; 150  :     __CLR_OR_THIS_CALL _Locinfo(const char* _Pch = "C")
; 151  : #ifndef _M_CEE
; 152  :         : _Lock(_LOCK_LOCALE)

  00028	6a 00		 push	 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 155  :     {

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 c0 04	 add	 eax, 4
  0003c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 20 00	 and	 DWORD PTR [eax], 0
  00045	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  0004c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c0 0c	 add	 eax, 12			; 0000000cH
  00056	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 20 00	 and	 DWORD PTR [eax], 0
  0005f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  00066	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 c0 14	 add	 eax, 20			; 00000014H
  00070	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00073	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	83 20 00	 and	 DWORD PTR [eax], 0
  00079	33 c0		 xor	 eax, eax
  0007b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 155  :     {

  00082	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 1c	 add	 eax, 28			; 0000001cH
  0008c	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 20 00	 and	 DWORD PTR [eax], 0
  00095	33 c0		 xor	 eax, eax
  00097	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 155  :     {

  0009e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	83 c0 24	 add	 eax, 36			; 00000024H
  000a8	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  000ab	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 20 00	 and	 DWORD PTR [eax], 0
  000b1	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  000b8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 c0 2c	 add	 eax, 44			; 0000002cH
  000c2	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  000c5	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	83 20 00	 and	 DWORD PTR [eax], 0
  000cb	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  000d2	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 156  :         if (_Pch) {

  000d6	83 7d 08 00	 cmp	 DWORD PTR __Pch$[ebp], 0
  000da	74 0f		 je	 SHORT $LN2@Locinfo

; 157  :             _Locinfo_ctor(this, _Pch);

  000dc	ff 75 08	 push	 DWORD PTR __Pch$[ebp]
  000df	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000e7	59		 pop	 ecx
  000e8	59		 pop	 ecx

; 158  :             return;

  000e9	eb 0a		 jmp	 SHORT $LN1@Locinfo
$LN2@Locinfo:

; 159  :         }
; 160  : 
; 161  :         _Xruntime_error("bad locale name");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  000f0	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
$LN1@Locinfo:

; 162  :     }

  000f5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000f9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00106	59		 pop	 ecx
  00107	c9		 leave
  00108	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $LN2@scalar
  00018	6a 04		 push	 4
  0001a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 65   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 66   : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 135  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 135  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 136  :     }

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c9		 leave
  00034	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h
;	COMDAT ?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
_TEXT	SEGMENT
__Alproxy$2 = -36					; size = 4
_this$ = -32						; size = 4
_npos$ = -28						; size = 4
_this$3 = -24						; size = 4
$T4 = -20						; size = 4
_$S8$5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_str$ = 12						; size = 4
?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z PROC ; CFileNameHelper::NoExtension, COMDAT

; 214  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 ec 00	 and	 DWORD PTR $T4[ebp], 0

; 215  : 	std::size_t npos = str.find_last_of('.');

  00029	6a ff		 push	 -1
  0002b	6a 2e		 push	 46			; 0000002eH
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _str$[ebp]
  00030	e8 00 00 00 00	 call	 ?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
  00035	89 45 e4	 mov	 DWORD PTR _npos$[ebp], eax

; 216  : 
; 217  : 	if (string::npos != npos)

  00038	83 7d e4 ff	 cmp	 DWORD PTR _npos$[ebp], -1
  0003c	74 4e		 je	 SHORT $LN2@NoExtensio
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00044	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e8	 mov	 DWORD PTR _this$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  0004a	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  0004d	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00051	8b 45 e8	 mov	 eax, DWORD PTR _this$3[ebp]
  00054	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00058	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0005c	8d 45 f3	 lea	 eax, DWORD PTR _$S8$5[ebp]
  0005f	89 45 dc	 mov	 DWORD PTR __Alproxy$2[ebp], eax

; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();

  00062	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00065	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2390 :         assign(_Right, _Roff, _Count);

  0006a	ff 75 e4	 push	 DWORD PTR _npos$[ebp]
  0006d	6a 00		 push	 0
  0006f	ff 75 0c	 push	 DWORD PTR _str$[ebp]
  00072	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00075	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2391 :         _Proxy._Release();
; 2392 :     }

  0007a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\filename.h

; 218  : 		return std::string(str, 0, npos);

  0007e	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00081	83 c8 01	 or	 eax, 1
  00084	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  00087	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008a	eb 17		 jmp	 SHORT $LN1@NoExtensio
$LN2@NoExtensio:

; 219  : 
; 220  : 	return str;

  0008c	ff 75 0c	 push	 DWORD PTR _str$[ebp]
  0008f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00092	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00097	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0009a	83 c8 01	 or	 eax, 1
  0009d	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  000a0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@NoExtensio:

; 221  : }

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	c9		 leave
  000af	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z$9:
  00000	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?NoExtension@CFileNameHelper@@SA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAV23@@Z ENDP ; CFileNameHelper::NoExtension
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 414  : [[noreturn]] inline void _Throw_tree_length_error() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :     _Xlength_error("map/set too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Throw_tree:

; 416  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
__Count$ = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Ptr$ = -44						; size = 4
__Ans$5 = -40						; size = 4
tv132 = -36						; size = 4
_this$ = -32						; size = 4
__Result$6 = -28					; size = 4
tv91 = -24						; size = 4
_this$ = -20						; size = 4
$T7 = -16						; size = 4
__Right_size$ = -12					; size = 4
__Left_size$ = -8					; size = 4
$T8 = -1						; size = 1
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4233 :     _NODISCARD int compare(_In_z_ const _Elem* const _Ptr) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00015	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@compare
  0002a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@compare
$LN12@compare:
  00033	83 65 e8 00	 and	 DWORD PTR tv91[ebp], 0
$LN13@compare:
  00037	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 e4	 mov	 DWORD PTR __Result$6[ebp], eax
$LN7@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 e4	 mov	 eax, DWORD PTR __Result$6[ebp]
  00056	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00059	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax
  0005f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00065	89 45 f8	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  0006b	3b 45 f8	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  0006e	73 08		 jae	 SHORT $LN26@compare
  00070	8d 45 f4	 lea	 eax, DWORD PTR __Right_size$[ebp]
  00073	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
  00076	eb 06		 jmp	 SHORT $LN27@compare
$LN26@compare:
  00078	8d 45 f8	 lea	 eax, DWORD PTR __Left_size$[ebp]
  0007b	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
$LN27@compare:
  0007e	8b 45 dc	 mov	 eax, DWORD PTR tv132[ebp]
  00081	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  00084	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00087	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  0008a	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
  0008f	89 45 c4	 mov	 DWORD PTR __Count$[ebp], eax

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  00092	ff 75 c4	 push	 DWORD PTR __Count$[ebp]
  00095	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00098	ff 75 c0	 push	 DWORD PTR $T1[ebp]
  0009b	e8 00 00 00 00	 call	 _memcmp
  000a0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a3	89 45 d8	 mov	 DWORD PTR __Ans$5[ebp], eax

; 570  :     if (_Ans != 0) {

  000a6	83 7d d8 00	 cmp	 DWORD PTR __Ans$5[ebp], 0
  000aa	74 08		 je	 SHORT $LN19@compare

; 571  :         return _Ans;

  000ac	8b 45 d8	 mov	 eax, DWORD PTR __Ans$5[ebp]
  000af	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  000b2	eb 23		 jmp	 SHORT $LN22@compare
$LN19@compare:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000b4	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000b7	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000ba	73 06		 jae	 SHORT $LN20@compare

; 575  :         return -1;

  000bc	83 4d f0 ff	 or	 DWORD PTR $T7[ebp], -1
  000c0	eb 15		 jmp	 SHORT $LN22@compare
$LN20@compare:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000c2	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000c5	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000c8	76 09		 jbe	 SHORT $LN21@compare

; 579  :         return 1;

  000ca	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
  000d1	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:

; 580  :     }
; 581  : 
; 582  :     return 0;

  000d3	83 65 f0 00	 and	 DWORD PTR $T7[ebp], 0
$LN22@compare:

; 4234 :         // compare [0, size()) with [_Ptr, <null>)
; 4235 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  000d7	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]

; 4236 :     }

  000da	c9		 leave
  000db	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
__Count$ = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Ptr$ = -60						; size = 4
__Ptr$ = -56						; size = 4
__Ans$5 = -52						; size = 4
tv146 = -48						; size = 4
_this$ = -44						; size = 4
__Result$6 = -40					; size = 4
tv137 = -36						; size = 4
__Result$7 = -32					; size = 4
tv95 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -16						; size = 4
__Right_size$ = -12					; size = 4
__Left_size$ = -8					; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 4212 :     _NODISCARD int compare(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@compare
  0001e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@compare
$LN9@compare:
  00027	83 65 e4 00	 and	 DWORD PTR tv95[ebp], 0
$LN10@compare:
  0002b	8a 45 e4	 mov	 al, BYTE PTR tv95[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 c8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 c8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __Result$7[ebp], eax
$LN4@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 e0	 mov	 eax, DWORD PTR __Result$7[ebp]
  0004a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00053	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00056	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00060	72 09		 jb	 SHORT $LN21@compare
  00062	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  00069	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:
  0006b	83 65 dc 00	 and	 DWORD PTR tv137[ebp], 0
$LN22@compare:
  0006f	8a 45 dc	 mov	 al, BYTE PTR tv137[ebp]
  00072	88 45 fe	 mov	 BYTE PTR $T9[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00075	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $LN16@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0007d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00085	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00088	89 45 d8	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __Result$6[ebp]
  0008e	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00091	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00094	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00097	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000a0	89 45 f8	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  000a3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000a6	3b 45 f8	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  000a9	73 08		 jae	 SHORT $LN35@compare
  000ab	8d 45 f4	 lea	 eax, DWORD PTR __Right_size$[ebp]
  000ae	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
  000b1	eb 06		 jmp	 SHORT $LN36@compare
$LN35@compare:
  000b3	8d 45 f8	 lea	 eax, DWORD PTR __Left_size$[ebp]
  000b6	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
$LN36@compare:
  000b9	8b 45 d0	 mov	 eax, DWORD PTR tv146[ebp]
  000bc	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  000bf	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
  000c2	89 45 bc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  000c5	8b 45 bc	 mov	 eax, DWORD PTR $T3[ebp]
  000c8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ca	89 45 b8	 mov	 DWORD PTR __Count$[ebp], eax

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  000cd	ff 75 b8	 push	 DWORD PTR __Count$[ebp]
  000d0	ff 75 b4	 push	 DWORD PTR $T2[ebp]
  000d3	ff 75 b0	 push	 DWORD PTR $T1[ebp]
  000d6	e8 00 00 00 00	 call	 _memcmp
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	89 45 cc	 mov	 DWORD PTR __Ans$5[ebp], eax

; 570  :     if (_Ans != 0) {

  000e1	83 7d cc 00	 cmp	 DWORD PTR __Ans$5[ebp], 0
  000e5	74 08		 je	 SHORT $LN28@compare

; 571  :         return _Ans;

  000e7	8b 45 cc	 mov	 eax, DWORD PTR __Ans$5[ebp]
  000ea	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  000ed	eb 23		 jmp	 SHORT $LN31@compare
$LN28@compare:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000f2	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000f5	73 06		 jae	 SHORT $LN29@compare

; 575  :         return -1;

  000f7	83 4d f0 ff	 or	 DWORD PTR $T8[ebp], -1
  000fb	eb 15		 jmp	 SHORT $LN31@compare
$LN29@compare:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000fd	8b 45 f8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00100	3b 45 f4	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00103	76 09		 jbe	 SHORT $LN30@compare

; 579  :         return 1;

  00105	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  0010c	eb 04		 jmp	 SHORT $LN31@compare
$LN30@compare:

; 580  :     }
; 581  : 
; 582  :     return 0;

  0010e	83 65 f0 00	 and	 DWORD PTR $T8[ebp], 0
$LN31@compare:

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00112	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]

; 4214 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4215 :     }

  00115	c9		 leave
  00116	c2 04 00	 ret	 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T3 = -60						; size = 4
tv135 = -56						; size = 4
tv133 = -52						; size = 4
__Start_at$ = -48					; size = 4
$T4 = -44						; size = 4
__Hay_size$ = -40					; size = 4
_this$ = -36						; size = 4
__Result$5 = -32					; size = 4
tv88 = -28						; size = 4
$T6 = -24						; size = 4
_this$ = -20						; size = 4
__Match_try$7 = -16					; size = 4
$T8 = -9						; size = 1
__Ch$ = -8						; size = 1
$T9 = -1						; size = 1
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of, COMDAT
; _this$ = ecx

; 4079 :     _NODISCARD size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  00009	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 e0	 mov	 DWORD PTR __Result$5[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@find_last_
  0001e	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@find_last_
$LN9@find_last_:
  00027	83 65 e4 00	 and	 DWORD PTR tv88[ebp], 0
$LN10@find_last_:
  0002b	8a 45 e4	 mov	 al, BYTE PTR tv88[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@find_last_

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __Result$5[ebp], eax
$LN4@find_last_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 e0	 mov	 eax, DWORD PTR __Result$5[ebp]
  0004a	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  0004d	8a 45 08	 mov	 al, BYTE PTR __Ch$[ebp]
  00050	88 45 f8	 mov	 BYTE PTR __Ch$[ebp], al
  00053	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00056	89 45 d0	 mov	 DWORD PTR __Start_at$[ebp], eax
  00059	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005f	89 45 d8	 mov	 DWORD PTR __Hay_size$[ebp], eax

; 661  :     if (_Hay_size != 0) { // room for match, look for it

  00062	83 7d d8 00	 cmp	 DWORD PTR __Hay_size$[ebp], 0
  00066	74 7d		 je	 SHORT $LN19@find_last_

; 662  :         for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {

  00068	8b 45 d8	 mov	 eax, DWORD PTR __Hay_size$[ebp]
  0006b	48		 dec	 eax
  0006c	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0006f	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  00072	3b 45 d0	 cmp	 eax, DWORD PTR __Start_at$[ebp]
  00075	73 08		 jae	 SHORT $LN26@find_last_
  00077	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
  0007d	eb 06		 jmp	 SHORT $LN27@find_last_
$LN26@find_last_:
  0007f	8d 45 d0	 lea	 eax, DWORD PTR __Start_at$[ebp]
  00082	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
$LN27@find_last_:
  00085	8b 45 cc	 mov	 eax, DWORD PTR tv133[ebp]
  00088	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
  0008b	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]
  0008e	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 662  :         for (auto _Match_try = _Haystack + (_STD min)(_Start_at, _Hay_size - 1);; --_Match_try) {

  00091	8b 45 b8	 mov	 eax, DWORD PTR $T1[ebp]
  00094	8b 4d e8	 mov	 ecx, DWORD PTR $T6[ebp]
  00097	03 08		 add	 ecx, DWORD PTR [eax]
  00099	89 4d f0	 mov	 DWORD PTR __Match_try$7[ebp], ecx
  0009c	eb 07		 jmp	 SHORT $LN18@find_last_
$LN16@find_last_:
  0009e	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000a1	48		 dec	 eax
  000a2	89 45 f0	 mov	 DWORD PTR __Match_try$7[ebp], eax
$LN18@find_last_:

; 432  :         return _Left == _Right;

  000a5	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000a8	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000ab	0f be 4d f8	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  000af	3b c1		 cmp	 eax, ecx
  000b1	75 09		 jne	 SHORT $LN31@find_last_
  000b3	c7 45 c8 01 00
	00 00		 mov	 DWORD PTR tv135[ebp], 1
  000ba	eb 04		 jmp	 SHORT $LN32@find_last_
$LN31@find_last_:
  000bc	83 65 c8 00	 and	 DWORD PTR tv135[ebp], 0
$LN32@find_last_:
  000c0	8a 45 c8	 mov	 al, BYTE PTR tv135[ebp]
  000c3	88 45 f7	 mov	 BYTE PTR $T8[ebp], al

; 663  :             if (_Traits::eq(*_Match_try, _Ch)) {

  000c6	0f b6 45 f7	 movzx	 eax, BYTE PTR $T8[ebp]
  000ca	85 c0		 test	 eax, eax
  000cc	74 0b		 je	 SHORT $LN20@find_last_

; 664  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  000ce	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000d1	2b 45 e8	 sub	 eax, DWORD PTR $T6[ebp]
  000d4	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  000d7	eb 10		 jmp	 SHORT $LN22@find_last_
$LN20@find_last_:

; 665  :             }
; 666  : 
; 667  :             if (_Match_try == _Haystack) {

  000d9	8b 45 f0	 mov	 eax, DWORD PTR __Match_try$7[ebp]
  000dc	3b 45 e8	 cmp	 eax, DWORD PTR $T6[ebp]
  000df	75 02		 jne	 SHORT $LN21@find_last_

; 668  :                 break; // at beginning, no more chance for match

  000e1	eb 02		 jmp	 SHORT $LN19@find_last_
$LN21@find_last_:

; 669  :             }
; 670  :         }

  000e3	eb b9		 jmp	 SHORT $LN16@find_last_
$LN19@find_last_:

; 671  :     }
; 672  : 
; 673  :     return static_cast<size_t>(-1); // no match

  000e5	83 4d c4 ff	 or	 DWORD PTR $T3[ebp], -1
$LN22@find_last_:

; 4080 :         // look for _Ch before _Off
; 4081 :         return static_cast<size_type>(

  000e9	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]

; 4082 :             _Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
; 4083 :     }

  000ec	c9		 leave
  000ed	c2 08 00	 ret	 8
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$3 = -16					; size = 4
tv92 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 3963 :     /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 3964 :         // look for [_Ptr, <null>) beginning at or after _Off
; 3965 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@find
  0002a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@find
$LN12@find:
  00033	83 65 f4 00	 and	 DWORD PTR tv92[ebp], 0
$LN13@find:
  00037	8a 45 f4	 mov	 al, BYTE PTR tv92[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T4[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@find

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR __Result$3[ebp], eax
$LN7@find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Result$3[ebp]
  00056	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 3964 :         // look for [_Ptr, <null>) beginning at or after _Off
; 3965 :         return static_cast<size_type>(_Traits_find<_Traits>(

  00059	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  0005c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0005f	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00062	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00065	ff 70 10	 push	 DWORD PTR [eax+16]
  00068	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  0006b	e8 00 00 00 00	 call	 ??$_Traits_find@U?$char_traits@D@std@@@std@@YAIQBDII0I@Z ; std::_Traits_find<std::char_traits<char> >
  00070	83 c4 14	 add	 esp, 20			; 00000014H

; 3966 :             _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
; 3967 :     }

  00073	c9		 leave
  00074	c2 08 00	 ret	 8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
___param0$ = -32					; size = 4
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
__Result$3 = -20					; size = 4
tv128 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 3577 :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3578 :         return iterator(

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3578 :         return iterator(

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 ec	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00022	72 09		 jb	 SHORT $LN12@end
  00024	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  0002b	eb 04		 jmp	 SHORT $LN13@end
$LN12@end:
  0002d	83 65 f0 00	 and	 DWORD PTR tv128[ebp], 0
$LN13@end:
  00031	8a 45 f0	 mov	 al, BYTE PTR tv128[ebp]
  00034	88 45 ff	 mov	 BYTE PTR $T4[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00037	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 0e		 je	 SHORT $LN7@end

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00047	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR __Result$3[ebp], eax
$LN7@end:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR __Result$3[ebp]
  00050	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 3578 :         return iterator(

  00053	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00056	e8 00 00 00 00	 call	 ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ; std::_Refancy<char *,0>
  0005b	59		 pop	 ecx
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  00062	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 1846 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

  00065	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00068	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0006b	89 08		 mov	 DWORD PTR [eax], ecx

; 3578 :         return iterator(

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3579 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 3580 :             _STD addressof(_Mypair._Myval2));
; 3581 :     }

  00070	c9		 leave
  00071	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
___param0$ = -32					; size = 4
$T2 = -28						; size = 4
__Ptr$ = -24						; size = 4
__Result$3 = -20					; size = 4
tv92 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 3569 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3570 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3570 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 ec	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00022	72 09		 jb	 SHORT $LN12@begin
  00024	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  0002b	eb 04		 jmp	 SHORT $LN13@begin
$LN12@begin:
  0002d	83 65 f0 00	 and	 DWORD PTR tv92[ebp], 0
$LN13@begin:
  00031	8a 45 f0	 mov	 al, BYTE PTR tv92[ebp]
  00034	88 45 ff	 mov	 BYTE PTR $T4[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00037	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 0e		 je	 SHORT $LN7@begin

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00047	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR __Result$3[ebp], eax
$LN7@begin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR __Result$3[ebp]
  00050	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 3570 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  00053	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00056	e8 00 00 00 00	 call	 ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ; std::_Refancy<char *,0>
  0005b	59		 pop	 ecx
  0005c	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 1846 :     _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

  0005f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00062	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00065	89 08		 mov	 DWORD PTR [eax], ecx

; 3570 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  00067	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3571 :     }

  0006a	c9		 leave
  0006b	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z
_TEXT	SEGMENT
$T1 = -32						; size = 1
__First1$ = -28						; size = 4
__First1$ = -24						; size = 4
__Old_ptr$2 = -20					; size = 4
__Old_size$ = -16					; size = 4
__Ptr_shifted_after$3 = -12				; size = 4
_this$ = -8						; size = 4
__Insert_at$4 = -4					; size = 4
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 3156 :         const size_type _Off, _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2231 :         if (_Mysize < _Off) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Off$[ebp]
  00012	73 05		 jae	 SHORT $LN11@insert

; 2232 :             _Xran();

  00014	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN11@insert:

; 3157 :         // insert [_Ptr, _Ptr + _Count) at _Off
; 3158 :         _Mypair._Myval2._Check_offset(_Off);
; 3159 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001f	89 45 f0	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3160 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00022	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00028	2b 45 f0	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0002b	39 45 10	 cmp	 DWORD PTR __Count$[ebp], eax
  0002e	0f 87 af 00 00
	00		 ja	 $LN2@insert

; 3161 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00034	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00037	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3162 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00048	89 45 ec	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3163 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  0004b	8b 45 ec	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0004e	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00051	89 45 fc	 mov	 DWORD PTR __Insert_at$4[ebp], eax

; 3164 :             // the range [_Ptr, _Ptr + _Ptr_shifted_after) is left alone by moving the suffix out,
; 3165 :             // while the range [_Ptr + _Ptr_shifted_after, _Ptr + _Count) shifts down by _Count
; 3166 :             size_type _Ptr_shifted_after;
; 3167 :             if (_Ptr + _Count <= _Insert_at
; 3168 :                 || _Ptr > _Old_ptr + _Old_size) { // inserted content is before the shifted region, or does not alias

  00054	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00057	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  0005a	3b 45 fc	 cmp	 eax, DWORD PTR __Insert_at$4[ebp]
  0005d	76 0b		 jbe	 SHORT $LN5@insert
  0005f	8b 45 ec	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00062	03 45 f0	 add	 eax, DWORD PTR __Old_size$[ebp]
  00065	39 45 0c	 cmp	 DWORD PTR __Ptr$[ebp], eax
  00068	76 08		 jbe	 SHORT $LN3@insert
$LN5@insert:

; 3169 :                 _Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0006a	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0006d	89 45 f4	 mov	 DWORD PTR __Ptr_shifted_after$3[ebp], eax
  00070	eb 17		 jmp	 SHORT $LN4@insert
$LN3@insert:

; 3170 :             } else if (_Insert_at <= _Ptr) { // all of [_Ptr, _Ptr + _Count) shifts

  00072	8b 45 fc	 mov	 eax, DWORD PTR __Insert_at$4[ebp]
  00075	3b 45 0c	 cmp	 eax, DWORD PTR __Ptr$[ebp]
  00078	77 06		 ja	 SHORT $LN6@insert

; 3171 :                 _Ptr_shifted_after = 0;

  0007a	83 65 f4 00	 and	 DWORD PTR __Ptr_shifted_after$3[ebp], 0

; 3172 :             } else { // [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts

  0007e	eb 09		 jmp	 SHORT $LN4@insert
$LN6@insert:

; 3173 :                 _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Insert_at$4[ebp]
  00083	2b 45 0c	 sub	 eax, DWORD PTR __Ptr$[ebp]
  00086	89 45 f4	 mov	 DWORD PTR __Ptr_shifted_after$3[ebp], eax
$LN4@insert:

; 3174 :             }
; 3175 : 
; 3176 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Insert_at$4[ebp]
  0008c	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  0008f	89 45 e8	 mov	 DWORD PTR __First1$[ebp], eax
  00092	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00095	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00098	40		 inc	 eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00099	50		 push	 eax
  0009a	ff 75 fc	 push	 DWORD PTR __Insert_at$4[ebp]
  0009d	ff 75 e8	 push	 DWORD PTR __First1$[ebp]
  000a0	e8 00 00 00 00	 call	 _memmove
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a8	ff 75 f4	 push	 DWORD PTR __Ptr_shifted_after$3[ebp]
  000ab	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  000ae	ff 75 fc	 push	 DWORD PTR __Insert_at$4[ebp]
  000b1	e8 00 00 00 00	 call	 _memcpy
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3177 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3178 :             _Traits::copy(

  000b9	8b 45 fc	 mov	 eax, DWORD PTR __Insert_at$4[ebp]
  000bc	03 45 f4	 add	 eax, DWORD PTR __Ptr_shifted_after$3[ebp]
  000bf	89 45 e4	 mov	 DWORD PTR __First1$[ebp], eax
  000c2	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000c5	2b 45 f4	 sub	 eax, DWORD PTR __Ptr_shifted_after$3[ebp]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c8	50		 push	 eax

; 3177 :             _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
; 3178 :             _Traits::copy(

  000c9	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000cc	03 45 10	 add	 eax, DWORD PTR __Count$[ebp]
  000cf	03 45 f4	 add	 eax, DWORD PTR __Ptr_shifted_after$3[ebp]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d2	50		 push	 eax
  000d3	ff 75 e4	 push	 DWORD PTR __First1$[ebp]
  000d6	e8 00 00 00 00	 call	 _memcpy
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3179 :                 _Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
; 3180 :             return *this;

  000de	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e1	eb 1c		 jmp	 SHORT $LN12@insert
$LN2@insert:

; 3181 :         }
; 3182 : 
; 3183 :         return _Reallocate_grow_by(

  000e3	33 c0		 xor	 eax, eax
  000e5	88 45 e0	 mov	 BYTE PTR $T1[ebp], al
  000e8	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  000eb	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  000ee	ff 75 08	 push	 DWORD PTR __Off$[ebp]
  000f1	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  000f4	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  000f7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fa	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_4d79bb85f269e6e8002a4599002d832c>@@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_4d79bb85f269e6e8002a4599002d832c>,unsigned int,char const *,unsigned int>
$LN12@insert:

; 3184 :             _Count,
; 3185 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 3186 :                 const _Elem* const _Ptr, const size_type _Count) {
; 3187 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 3188 :                 _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 3189 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 3190 :             },
; 3191 :             _Off, _Ptr, _Count);
; 3192 :     }

  000ff	c9		 leave
  00100	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
__Result$4 = -28					; size = 4
tv128 = -24						; size = 4
tv89 = -20						; size = 4
__Size$ = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3020 :     basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 2231 :         if (_Mysize < _Off) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	3b 45 0c	 cmp	 eax, DWORD PTR __Roff$[ebp]
  00012	73 05		 jae	 SHORT $LN5@assign

; 2232 :             _Xran();

  00014	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN5@assign:

; 3021 :         // assign _Right [_Roff, _Roff + _Count)
; 3022 :         _Right._Mypair._Myval2._Check_offset(_Roff);
; 3023 :         _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);

  00019	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	89 45 f0	 mov	 DWORD PTR __Size$[ebp], eax

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00025	2b 45 0c	 sub	 eax, DWORD PTR __Roff$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0002e	3b 45 f0	 cmp	 eax, DWORD PTR __Size$[ebp]
  00031	73 08		 jae	 SHORT $LN12@assign
  00033	8d 45 f4	 lea	 eax, DWORD PTR $T5[ebp]
  00036	89 45 ec	 mov	 DWORD PTR tv89[ebp], eax
  00039	eb 06		 jmp	 SHORT $LN13@assign
$LN12@assign:
  0003b	8d 45 f0	 lea	 eax, DWORD PTR __Size$[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR tv89[ebp], eax
$LN13@assign:
  00041	8b 45 ec	 mov	 eax, DWORD PTR tv89[ebp]
  00044	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0004d	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	89 45 10	 mov	 DWORD PTR __Count$[ebp], eax

; 3024 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00055	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00058	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	89 45 e4	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00068	72 09		 jb	 SHORT $LN21@assign
  0006a	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv128[ebp], 1
  00071	eb 04		 jmp	 SHORT $LN22@assign
$LN21@assign:
  00073	83 65 e8 00	 and	 DWORD PTR tv128[ebp], 0
$LN22@assign:
  00077	8a 45 e8	 mov	 al, BYTE PTR tv128[ebp]
  0007a	88 45 ff	 mov	 BYTE PTR $T6[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0007d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00081	85 c0		 test	 eax, eax
  00083	74 0e		 je	 SHORT $LN16@assign

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0008d	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00090	89 45 e4	 mov	 DWORD PTR __Result$4[ebp], eax
$LN16@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00093	8b 45 e4	 mov	 eax, DWORD PTR __Result$4[ebp]
  00096	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 3024 :         return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);

  00099	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  0009c	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  0009f	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  000a2	50		 push	 eax
  000a3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@assign:

; 3025 :     }

  000ab	c9		 leave
  000ac	c2 0c 00	 ret	 12			; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -36					; size = 4
__Right_data_mem$2 = -32				; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign, COMDAT
; _this$ = ecx

; 2636 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2637 :         _Tidy_deallocate();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 2638 :         _Pocma(_Getal(), _Right._Getal());

  00029	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  0002c	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx

; 2639 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00036	33 c0		 xor	 eax, eax
  00038	88 45 ff	 mov	 BYTE PTR $T7[ebp], al
  0003b	8a 45 ff	 mov	 al, BYTE PTR $T7[ebp]
  0003e	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00041	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00044	89 45 dc	 mov	 DWORD PTR __My_data_mem$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00047	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	89 45 e0	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	ff 75 e0	 push	 DWORD PTR __Right_data_mem$2[ebp]
  00052	ff 75 dc	 push	 DWORD PTR __My_data_mem$1[ebp]
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2640 :     }

  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?_Move_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Alproxy$ = -32					; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S8$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S8$[ebp]
  00049	89 45 e0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2390 :         assign(_Right, _Roff, _Count);

  00054	ff 75 10	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 0c	 push	 DWORD PTR __Roff$[ebp]
  0005a	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2391 :         _Proxy._Release();
; 2392 :     }

  00065	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00069	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00076	59		 pop	 ecx
  00077	c9		 leave
  00078	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S9$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S9$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2242 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2243 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2244 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	83 c9 01	 or	 ecx, 1
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH
  00036	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003d	7d 06		 jge	 SHORT $LN7@sprintf
  0003f	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00043	eb 06		 jmp	 SHORT $LN3@sprintf
$LN7@sprintf:
  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00048	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00051	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00058	c9		 leave
  00059	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\Area.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
