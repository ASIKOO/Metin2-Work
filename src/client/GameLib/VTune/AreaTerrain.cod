; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CTerrainPatch@@QAE@XZ			; CTerrainPatch::CTerrainPatch
PUBLIC	??1CTerrainPatch@@QAE@XZ			; CTerrainPatch::~CTerrainPatch
PUBLIC	??1SHardwareTransformPatch@CTerrainPatch@@QAE@XZ ; CTerrainPatch::SHardwareTransformPatch::~SHardwareTransformPatch
PUBLIC	??0CTerrain@@QAE@XZ				; CTerrain::CTerrain
PUBLIC	??1CTerrain@@UAE@XZ				; CTerrain::~CTerrain
PUBLIC	?Clear@CTerrain@@UAEXXZ				; CTerrain::Clear
PUBLIC	?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z	; CTerrain::SetMapOutDoor
PUBLIC	?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z		; CTerrain::RAW_LoadTileMap
PUBLIC	?LoadHeightMap@CTerrain@@QAE_NPBD@Z		; CTerrain::LoadHeightMap
PUBLIC	?CalculateTerrainPatch@CTerrain@@QAEXXZ		; CTerrain::CalculateTerrainPatch
PUBLIC	?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ	; CTerrain::CopySettingFromGlobalSetting
PUBLIC	?WE_GetHeightMapValue@CTerrain@@QAEGFF@Z	; CTerrain::WE_GetHeightMapValue
PUBLIC	?GetHeight@CTerrain@@QAEMHH@Z			; CTerrain::GetHeight
PUBLIC	?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z	; CTerrain::GetNormal
PUBLIC	?LoadAttrMap@CTerrain@@QAE_NPBD@Z		; CTerrain::LoadAttrMap
PUBLIC	?GetAttr@CTerrain@@QAEEGG@Z			; CTerrain::GetAttr
PUBLIC	?isAttrOn@CTerrain@@QAE_NGGE@Z			; CTerrain::isAttrOn
PUBLIC	?GetWaterHeight@CTerrain@@QAEXEPAJ@Z		; CTerrain::GetWaterHeight
PUBLIC	?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z		; CTerrain::GetWaterHeight
PUBLIC	?LoadShadowTexture@CTerrain@@QAEXPBD@Z		; CTerrain::LoadShadowTexture
PUBLIC	?LoadShadowMap@CTerrain@@QAE_NPBD@Z		; CTerrain::LoadShadowMap
PUBLIC	?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z		; CTerrain::LoadMiniMapTexture
PUBLIC	?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z	; CTerrain::AllocateMarkedSplats
PUBLIC	?DeallocateMarkedSplats@CTerrain@@QAEXXZ	; CTerrain::DeallocateMarkedSplats
PUBLIC	?SetCoordinate@CTerrain@@QAEXGG@Z		; CTerrain::SetCoordinate
PUBLIC	?RAW_GenerateSplat@CTerrain@@QAEX_N@Z		; CTerrain::RAW_GenerateSplat
PUBLIC	?Initialize@CTerrain@@IAE_NXZ			; CTerrain::Initialize
PUBLIC	?RAW_AllocateSplats@CTerrain@@IAEX_N@Z		; CTerrain::RAW_AllocateSplats
PUBLIC	?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z	; CTerrain::RAW_DeallocateSplats
PUBLIC	?RAW_CountTiles@CTerrain@@MAEXXZ		; CTerrain::RAW_CountTiles
PUBLIC	?AddTexture32@CTerrain@@IAEPAUIDirect3DTexture8@@EPAEJJ@Z ; CTerrain::AddTexture32
PUBLIC	?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z		; CTerrain::PutImage32
PUBLIC	?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z		; CTerrain::PutImage16
PUBLIC	?CalculateNormal@CTerrain@@IAEXJJ@Z		; CTerrain::CalculateNormal
PUBLIC	??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
PUBLIC	?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z ; CTerrain::GetTerrainPatchPtr
PUBLIC	?_CalculateTerrainPatch@CTerrain@@IAEXEE@Z	; CTerrain::_CalculateTerrainPatch
PUBLIC	?DestroySystem@CTerrain@@SAXXZ			; CTerrain::DestroySystem
PUBLIC	?New@CTerrain@@SAPAV1@XZ			; CTerrain::New
PUBLIC	?Delete@CTerrain@@SAXPAV1@@Z			; CTerrain::Delete
PUBLIC	??_GCTerrain@@UAEPAXI@Z				; CTerrain::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXQAPAVCTerrain@@I@Z ; std::allocator<CTerrain *>::deallocate
PUBLIC	?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXQAPAVCTerrain@@II@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
PUBLIC	??0?$CDynamicPool@VCTerrain@@@@QAE@XZ		; CDynamicPool<CTerrain>::CDynamicPool<CTerrain>
PUBLIC	??1?$CDynamicPool@VCTerrain@@@@UAE@XZ		; CDynamicPool<CTerrain>::~CDynamicPool<CTerrain>
PUBLIC	?Destroy@?$CDynamicPool@VCTerrain@@@@QAEXXZ	; CDynamicPool<CTerrain>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ ; CDynamicPool<CTerrain>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCTerrain@@@@KAXPAVCTerrain@@@Z ; CDynamicPool<CTerrain>::Delete
PUBLIC	??_G?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z	; CDynamicPool<CTerrain>::`scalar deleting destructor'
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
PUBLIC	??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::emplace_back<CTerrain * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_back_with_unused_capacity<CTerrain * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
PUBLIC	??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
PUBLIC	??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >
PUBLIC	??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
PUBLIC	??_ECTerrain@@WGKFFA@AEPAXI@Z			; [thunk]:CTerrain::`vector deleting destructor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
PUBLIC	??_7CTerrain@@6BCTerrainImpl@@@			; CTerrain::`vftable'
PUBLIC	??_7CTerrain@@6BCGraphicBase@@@			; CTerrain::`vftable'
PUBLIC	??_7?$CDynamicPool@VCTerrain@@@@6B@		; CDynamicPool<CTerrain>::`vftable'
PUBLIC	??_C@_0CE@KIPOLACJ@CTerrain?3?3LoadMiniMapTexture?5?$CFd@ ; `string'
PUBLIC	??_C@_0DF@NCADIKFN@?5CTerrain?3?3LoadMiniMapTexture?5?9@ ; `string'
PUBLIC	??_C@_0DG@HIAJBENM@?5CTerrain?3?3LoadShadowTexture?5?9?5@ ; `string'
PUBLIC	??_C@_0CD@IJFAIKJL@CTerrain?3?3LoadShadowTexture?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0BC@DNLHKNND@LoadShadowMap?5?$CFs?5@	; `string'
PUBLIC	??_C@_0CJ@CPMONPNA@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5O@ ; `string'
PUBLIC	??_C@_0CJ@HOIKLCAI@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5S@ ; `string'
PUBLIC	??_C@_06MIKGEFKP@?$CFd?5ms?6@			; `string'
PUBLIC	??_C@_0EI@CCJJGEPA@CTerrain?3?3WE_GetHeightMapValue?5@ ; `string'
PUBLIC	??_C@_0CB@BJJCGNIJ@CTerrain?3?3RAW_AllocateSplats?5?$CFd@ ; `string'
PUBLIC	??_C@_0CG@DNKMEFFO@LoadHeightMap?3?3CalculateNormal?5@ ; `string'
PUBLIC	??_C@_0GK@JCKMMDJF@CTerrain?3?3isAttrOn?5Coordiante?5E@ ; `string'
PUBLIC	??_C@_0GF@DKPFJAMA@CTerrain?3?3GetAttr?5Coordiante?5Er@ ; `string'
PUBLIC	??_C@_0DK@FNOMKIKO@CTerrain?3?3GetWaterHeight?5WaterN@ ; `string'
PUBLIC	??_C@_0CN@IPEKMCGJ@CTerrain?3?3GetWaterHeight?5?$CIX?5?$CFd?0@ ; `string'
PUBLIC	??_C@_0EP@MGCDBJBL@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@ ; `string'
PUBLIC	??_C@_0EN@EFOOENIC@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@ ; `string'
PUBLIC	??_C@_0CN@NONLPBAM@CTerrain?3?3AddTexture32?5?9?5Create@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CTerrain@@6BCTerrainImpl@@@		; CTerrain::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTerrain@@@8				; CTerrain `RTTI Type Descriptor'
PUBLIC	??_R3CTerrain@@8				; CTerrain::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTerrain@@8				; CTerrain::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTerrain@@8			; CTerrain::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CTerrainImpl@@8			; CTerrainImpl::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCTerrainImpl@@@8			; CTerrainImpl `RTTI Type Descriptor'
PUBLIC	??_R3CTerrainImpl@@8				; CTerrainImpl::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTerrainImpl@@8				; CTerrainImpl::`RTTI Base Class Array'
PUBLIC	??_R1GKFFA@?0A@EA@CGraphicBase@@8		; CGraphicBase::`RTTI Base Class Descriptor at (435536,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CTerrain@@6BCGraphicBase@@@		; CTerrain::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CDynamicPool@VCTerrain@@@@6B@		; CDynamicPool<CTerrain>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCTerrain@@@@@8		; CDynamicPool<CTerrain> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCTerrain@@@@8		; CDynamicPool<CTerrain>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCTerrain@@@@8		; CDynamicPool<CTerrain>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCTerrain@@@@8	; CDynamicPool<CTerrain>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3ba3d70a
PUBLIC	__real@3c0101f3
PUBLIC	__real@3c010204
PUBLIC	__real@3f000000
PUBLIC	__real@3f4ccccd
PUBLIC	__real@3f5db3d7
PUBLIC	__real@3f800000
PUBLIC	__real@42fe0000
PUBLIC	__real@43480000
PUBLIC	__real@437f0000
PUBLIC	__real@43c80000
PUBLIC	__real@45480000
PUBLIC	__real@497423f0
PUBLIC	__real@c97423f0
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_sqrt:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	??0CGraphicBase@@QAE@XZ:PROC			; CGraphicBase::CGraphicBase
EXTRN	??1CGraphicBase@@UAE@XZ:PROC			; CGraphicBase::~CGraphicBase
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicVertexBuffer@@QAE@XZ:PROC		; CGraphicVertexBuffer::CGraphicVertexBuffer
EXTRN	??1CGraphicVertexBuffer@@UAE@XZ:PROC		; CGraphicVertexBuffer::~CGraphicVertexBuffer
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:PROC ; CEterPackManager::Get
EXTRN	?GetTextureCount@CTextureSet@@QAEKXZ:PROC	; CTextureSet::GetTextureCount
EXTRN	?GetTextureSet@CTerrainImpl@@SAPAVCTextureSet@@XZ:PROC ; CTerrainImpl::GetTextureSet
EXTRN	??0CTerrainImpl@@QAE@XZ:PROC			; CTerrainImpl::CTerrainImpl
EXTRN	??1CTerrainImpl@@UAE@XZ:PROC			; CTerrainImpl::~CTerrainImpl
EXTRN	?Clear@CTerrainImpl@@MAEXXZ:PROC		; CTerrainImpl::Clear
EXTRN	?LoadHeightMap@CTerrainImpl@@IAE_NPBD@Z:PROC	; CTerrainImpl::LoadHeightMap
EXTRN	?RAW_LoadTileMap@CTerrainImpl@@IAE_NPBD@Z:PROC	; CTerrainImpl::RAW_LoadTileMap
EXTRN	?LoadAttrMap@CTerrainImpl@@IAE_NPBD@Z:PROC	; CTerrainImpl::LoadAttrMap
EXTRN	?Clear@CTerrainPatch@@QAEXXZ:PROC		; CTerrainPatch::Clear
EXTRN	?BuildTerrainVertexBuffer@CTerrainPatch@@QAEXPAUHardwareTransformPatch_SSourceVertex@@@Z:PROC ; CTerrainPatch::BuildTerrainVertexBuffer
EXTRN	?BuildWaterVertexBuffer@CTerrainPatch@@QAEXPAUSWaterVertex@@I@Z:PROC ; CTerrainPatch::BuildWaterVertexBuffer
EXTRN	??0SSoftwareTransformPatch@CTerrainPatch@@QAE@XZ:PROC ; CTerrainPatch::SSoftwareTransformPatch::SSoftwareTransformPatch
EXTRN	??1SSoftwareTransformPatch@CTerrainPatch@@QAE@XZ:PROC ; CTerrainPatch::SSoftwareTransformPatch::~SSoftwareTransformPatch
EXTRN	??_ECTerrain@@UAEPAXI@Z:PROC			; CTerrain::`vector deleting destructor'
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z:PROC ; CMapOutdoor::GetTerrainNumFromCoord
EXTRN	??_E?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z:PROC	; CDynamicPool<CTerrain>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	?ms_bSupportDXT@CGraphicBase@@1_NA:BYTE		; CGraphicBase::ms_bSupportDXT
EXTRN	?PR_FCNV@@3MA:DWORD				; PR_FCNV
EXTRN	?PR_ICNV@@3JA:DWORD				; PR_ICNV
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A DB 024H DUP (?) ; CTerrain::ms_kPool
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CTerrain@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CTerrain@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c97423f0
CONST	SEGMENT
__real@c97423f0 DD 0c97423f0r			; -999999
CONST	ENDS
;	COMDAT __real@497423f0
CONST	SEGMENT
__real@497423f0 DD 0497423f0r			; 999999
CONST	ENDS
;	COMDAT __real@45480000
CONST	SEGMENT
__real@45480000 DD 045480000r			; 3200
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@43480000
CONST	SEGMENT
__real@43480000 DD 043480000r			; 200
CONST	ENDS
;	COMDAT __real@42fe0000
CONST	SEGMENT
__real@42fe0000 DD 042fe0000r			; 127
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f5db3d7
CONST	SEGMENT
__real@3f5db3d7 DD 03f5db3d7r			; 0.866025
CONST	ENDS
;	COMDAT __real@3f4ccccd
CONST	SEGMENT
__real@3f4ccccd DD 03f4ccccdr			; 0.8
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c010204
CONST	SEGMENT
__real@3c010204 DD 03c010204r			; 0.00787402
CONST	ENDS
;	COMDAT __real@3c0101f3
CONST	SEGMENT
__real@3c0101f3 DD 03c0101f3r			; 0.007874
CONST	ENDS
;	COMDAT __real@3ba3d70a
CONST	SEGMENT
__real@3ba3d70a DD 03ba3d70ar			; 0.005
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCTerrain@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCTerrain@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCTerrain@@@@@8 ; CDynamicPool<CTerrain>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCTerrain@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCTerrain@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCTerrain@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCTerrain@@@@8 ; CDynamicPool<CTerrain>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCTerrain@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCTerrain@@@@8 DD 00H		; CDynamicPool<CTerrain>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCTerrain@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCTerrain@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCTerrain@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CTerrain> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCTerrain@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCTerrain@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCTerrain@@@@6B@ DD 00H		; CDynamicPool<CTerrain>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCTerrain@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCTerrain@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CTerrain@@6BCGraphicBase@@@
rdata$r	SEGMENT
??_R4CTerrain@@6BCGraphicBase@@@ DD 00H			; CTerrain::`RTTI Complete Object Locator'
	DD	06a550H
	DD	00H
	DD	FLAT:??_R0?AVCTerrain@@@8
	DD	FLAT:??_R3CTerrain@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1GKFFA@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1GKFFA@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (435536,-1,0,64)'
	DD	00H
	DD	06a550H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CTerrainImpl@@8
rdata$r	SEGMENT
??_R2CTerrainImpl@@8 DD FLAT:??_R1A@?0A@EA@CTerrainImpl@@8 ; CTerrainImpl::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CTerrainImpl@@8
rdata$r	SEGMENT
??_R3CTerrainImpl@@8 DD 00H				; CTerrainImpl::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CTerrainImpl@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTerrainImpl@@@8
data$rs	SEGMENT
??_R0?AVCTerrainImpl@@@8 DD FLAT:??_7type_info@@6B@	; CTerrainImpl `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTerrainImpl@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CTerrainImpl@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTerrainImpl@@8 DD FLAT:??_R0?AVCTerrainImpl@@@8 ; CTerrainImpl::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTerrainImpl@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTerrain@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTerrain@@8 DD FLAT:??_R0?AVCTerrain@@@8	; CTerrain::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTerrain@@8
rdata$r	ENDS
;	COMDAT ??_R2CTerrain@@8
rdata$r	SEGMENT
??_R2CTerrain@@8 DD FLAT:??_R1A@?0A@EA@CTerrain@@8	; CTerrain::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CTerrainImpl@@8
	DD	FLAT:??_R1GKFFA@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CTerrain@@8
rdata$r	SEGMENT
??_R3CTerrain@@8 DD 00H					; CTerrain::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CTerrain@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTerrain@@@8
data$rs	SEGMENT
??_R0?AVCTerrain@@@8 DD FLAT:??_7type_info@@6B@		; CTerrain `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTerrain@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CTerrain@@6BCTerrainImpl@@@
rdata$r	SEGMENT
??_R4CTerrain@@6BCTerrainImpl@@@ DD 00H			; CTerrain::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTerrain@@@8
	DD	FLAT:??_R3CTerrain@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@NONLPBAM@CTerrain?3?3AddTexture32?5?9?5Create@
CONST	SEGMENT
??_C@_0CN@NONLPBAM@CTerrain?3?3AddTexture32?5?9?5Create@ DB 'CTerrain::Ad'
	DB	'dTexture32 - CreateTexture Error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@EFOOENIC@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@
CONST	SEGMENT
??_C@_0EN@EFOOENIC@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@ DB ' CTerrain::'
	DB	'RAW_GenerateSplat - TileDount 0 : Alpha Texture Release(%d) E'
	DB	'RROR', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0EP@MGCDBJBL@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@
CONST	SEGMENT
??_C@_0EP@MGCDBJBL@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@ DB ' CTerrain::'
	DB	'RAW_GenerateSplat - TileCount > 0 : Alpha Texture Release(%d)'
	DB	' ERROR', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@IPEKMCGJ@CTerrain?3?3GetWaterHeight?5?$CIX?5?$CFd?0@
CONST	SEGMENT
??_C@_0CN@IPEKMCGJ@CTerrain?3?3GetWaterHeight?5?$CIX?5?$CFd?0@ DB 'CTerra'
	DB	'in::GetWaterHeight (X %d, Y %d) ERROR!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@FNOMKIKO@CTerrain?3?3GetWaterHeight?5WaterN@
CONST	SEGMENT
??_C@_0DK@FNOMKIKO@CTerrain?3?3GetWaterHeight?5WaterN@ DB 'CTerrain::GetW'
	DB	'aterHeight WaterNum %d(Total Num %d) ERROR!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GF@DKPFJAMA@CTerrain?3?3GetAttr?5Coordiante?5Er@
CONST	SEGMENT
??_C@_0GF@DKPFJAMA@CTerrain?3?3GetAttr?5Coordiante?5Er@ DB 'CTerrain::Get'
	DB	'Attr Coordiante Error! Return 0... Input Coord - X : %d, Y : '
	DB	'%d ( Limit X : %d, Y : %d)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GK@JCKMMDJF@CTerrain?3?3isAttrOn?5Coordiante?5E@
CONST	SEGMENT
??_C@_0GK@JCKMMDJF@CTerrain?3?3isAttrOn?5Coordiante?5E@ DB 'CTerrain::isA'
	DB	'ttrOn Coordiante Error! Return false... Input Coord - X : %d,'
	DB	' Y : %d ( Limit X : %d, Y : %d)', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@DNKMEFFO@LoadHeightMap?3?3CalculateNormal?5@
CONST	SEGMENT
??_C@_0CG@DNKMEFFO@LoadHeightMap?3?3CalculateNormal?5@ DB 'LoadHeightMap:'
	DB	':CalculateNormal %d ms', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BJJCGNIJ@CTerrain?3?3RAW_AllocateSplats?5?$CFd@
CONST	SEGMENT
??_C@_0CB@BJJCGNIJ@CTerrain?3?3RAW_AllocateSplats?5?$CFd@ DB 'CTerrain::R'
	DB	'AW_AllocateSplats %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@CCJJGEPA@CTerrain?3?3WE_GetHeightMapValue?5@
CONST	SEGMENT
??_C@_0EI@CCJJGEPA@CTerrain?3?3WE_GetHeightMapValue?5@ DB 'CTerrain::WE_G'
	DB	'etHeightMapValue : Can''t Get TerrainNum from Coord %d, %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06MIKGEFKP@?$CFd?5ms?6@
CONST	SEGMENT
??_C@_06MIKGEFKP@?$CFd?5ms?6@ DB '%d ms', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@HOIKLCAI@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5S@
CONST	SEGMENT
??_C@_0CJ@HOIKLCAI@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5S@ DB ' CTerra'
	DB	'in::LoadShadowMap - %s SIZE ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@CPMONPNA@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5O@
CONST	SEGMENT
??_C@_0CJ@CPMONPNA@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5O@ DB ' CTerra'
	DB	'in::LoadShadowMap - %s OPEN ERROR', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DNLHKNND@LoadShadowMap?5?$CFs?5@
CONST	SEGMENT
??_C@_0BC@DNLHKNND@LoadShadowMap?5?$CFs?5@ DB 'LoadShadowMap %s ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@IJFAIKJL@CTerrain?3?3LoadShadowTexture?5?$CFd?5@
CONST	SEGMENT
??_C@_0CD@IJFAIKJL@CTerrain?3?3LoadShadowTexture?5?$CFd?5@ DB 'CTerrain::'
	DB	'LoadShadowTexture %d ms', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@HIAJBENM@?5CTerrain?3?3LoadShadowTexture?5?9?5@
CONST	SEGMENT
??_C@_0DG@HIAJBENM@?5CTerrain?3?3LoadShadowTexture?5?9?5@ DB ' CTerrain::'
	DB	'LoadShadowTexture - ShadowTexture is Empty', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NCADIKFN@?5CTerrain?3?3LoadMiniMapTexture?5?9@
CONST	SEGMENT
??_C@_0DF@NCADIKFN@?5CTerrain?3?3LoadMiniMapTexture?5?9@ DB ' CTerrain::L'
	DB	'oadMiniMapTexture - MiniMapTexture Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@KIPOLACJ@CTerrain?3?3LoadMiniMapTexture?5?$CFd@
CONST	SEGMENT
??_C@_0CE@KIPOLACJ@CTerrain?3?3LoadMiniMapTexture?5?$CFd@ DB 'CTerrain::L'
	DB	'oadMiniMapTexture %d ms', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCTerrain@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCTerrain@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCTerrain@@@@6B@ ; CDynamicPool<CTerrain>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CTerrain@@6BCGraphicBase@@@
CONST	SEGMENT
??_7CTerrain@@6BCGraphicBase@@@ DD FLAT:??_R4CTerrain@@6BCGraphicBase@@@ ; CTerrain::`vftable'
	DD	FLAT:??_ECTerrain@@WGKFFA@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CTerrain@@6BCTerrainImpl@@@
CONST	SEGMENT
??_7CTerrain@@6BCTerrainImpl@@@ DD FLAT:??_R4CTerrain@@6BCTerrainImpl@@@ ; CTerrain::`vftable'
	DD	FLAT:??_ECTerrain@@UAEPAXI@Z
	DD	FLAT:?Clear@CTerrain@@UAEXXZ
	DD	FLAT:?RAW_CountTiles@CTerrain@@MAEXXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadShadowMap@CTerrain@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadShadowMap@CTerrain@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadShadowMap@CTerrain@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadShadowMap@CTerrain@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CTerrain@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CTerrain@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CTerrain@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CTerrain@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CTerrain@@QAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CTerrainPatch@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTerrainPatch@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTerrainPatch@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CTerrainPatch@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CTerrainPatch@@QAE@XZ$2
__ehfuncinfo$??0CTerrainPatch@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CTerrainPatch@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECTerrain@@WGKFFA@AEPAXI@Z
_TEXT	SEGMENT
??_ECTerrain@@WGKFFA@AEPAXI@Z PROC			; [thunk]:CTerrain::`vector deleting destructor', COMDAT
  00000	81 e9 50 a5 06
	00		 sub	 ecx, 435536		; 0006a550H
  00006	e9 00 00 00 00	 jmp	 ??_ECTerrain@@UAEPAXI@Z
??_ECTerrain@@WGKFFA@AEPAXI@Z ENDP			; [thunk]:CTerrain::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CTerrain * *,CTerrain * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z PROC ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ENDP ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned long> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@YAPAPAVCTerrain@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Uninitialized_move<CTerrain * *,std::allocator<CTerrain *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXQAPAVCTerrain@@I@Z ; std::allocator<CTerrain *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXQAPAVCTerrain@@II@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABQAVCTerrain@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABQAVCTerrain@@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_back_with_unused_capacity<CTerrain * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABQAVCTerrain@@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_back_with_unused_capacity<CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::emplace_back<CTerrain * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_back_with_unused_capacity<CTerrain * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEPAPAVCTerrain@@QAPAV2@ABQAV2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Emplace_reallocate<CTerrain * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::emplace_back<CTerrain * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CTerrain *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CTerrain::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCTerrain@@@@UAE@XZ ; CDynamicPool<CTerrain>::~CDynamicPool<CTerrain>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CTerrain::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ??__E?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CTerrain::ms_kPool'', COMDAT

; 11   : CDynamicPool<CTerrain>		CTerrain::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCTerrain@@@@QAE@XZ ; CDynamicPool<CTerrain>::CDynamicPool<CTerrain>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CTerrain::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CTerrain::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z PROC		; CDynamicPool<CTerrain>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCTerrain@@@@UAE@XZ ; CDynamicPool<CTerrain>::~CDynamicPool<CTerrain>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCTerrain@@@@UAEPAXI@Z ENDP		; CDynamicPool<CTerrain>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCTerrain@@@@KAXPAVCTerrain@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCTerrain@@@@KAXPAVCTerrain@@@Z PROC ; CDynamicPool<CTerrain>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCTerrain@@@@KAXPAVCTerrain@@@Z ENDP ; CDynamicPool<CTerrain>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ PROC ; CDynamicPool<CTerrain>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 5a		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	68 e4 d1 07 00	 push	 512484			; 0007d1e4H
  0005e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00063	59		 pop	 ecx
  00064	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006f	74 0d		 je	 SHORT $LN4@Alloc
  00071	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00074	e8 00 00 00 00	 call	 ??0CTerrain@@QAE@XZ	; CTerrain::CTerrain
  00079	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007e	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00082	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00085	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00092	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00095	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::emplace_back<CTerrain * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a7	40		 inc	 eax
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ae	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000b1	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000bc	6a 04		 push	 4
  000be	58		 pop	 eax
  000bf	6b c0 ff	 imul	 eax, eax, -1
  000c2	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c5	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000cb	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000dc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000e2	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000eb	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f6	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ff	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00102	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	83 e8 04	 sub	 eax, 4
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00115	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ$0:
  00000	68 e4 d1 07 00	 push	 512484			; 0007d1e4H
  00005	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ ENDP ; CDynamicPool<CTerrain>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCTerrain@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCTerrain@@@@QAEXXZ PROC	; CDynamicPool<CTerrain>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCTerrain@@@@KAXPAVCTerrain@@@Z ; CDynamicPool<CTerrain>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@std@@P6AXPAVCTerrain@@@Z@std@@YAP6AXPAVCTerrain@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CTerrain *> > >,void (__cdecl*)(CTerrain *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCTerrain@@@@QAEXXZ ENDP	; CDynamicPool<CTerrain>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCTerrain@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCTerrain@@@@UAE@XZ PROC		; CDynamicPool<CTerrain>::~CDynamicPool<CTerrain>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCTerrain@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCTerrain@@@@UAE@XZ ENDP		; CDynamicPool<CTerrain>::~CDynamicPool<CTerrain>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCTerrain@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCTerrain@@@@QAE@XZ PROC		; CDynamicPool<CTerrain>::CDynamicPool<CTerrain>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCTerrain@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCTerrain@@@@QAE@XZ ENDP		; CDynamicPool<CTerrain>::CDynamicPool<CTerrain>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXQAPAVCTerrain@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXQAPAVCTerrain@@II@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXQAPAVCTerrain@@II@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXQAPAVCTerrain@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXQAPAVCTerrain@@I@Z PROC ; std::allocator<CTerrain *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCTerrain@@@std@@QAEXQAPAVCTerrain@@I@Z ENDP ; std::allocator<CTerrain *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCTerrain@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTerrain@@UAEPAXI@Z PROC				; CTerrain::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTerrain@@UAE@XZ	; CTerrain::~CTerrain
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 e4 d1 07 00	 push	 512484			; 0007d1e4H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCTerrain@@UAEPAXI@Z ENDP				; CTerrain::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?Delete@CTerrain@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkTerrain$ = 8						; size = 4
?Delete@CTerrain@@SAXPAV1@@Z PROC			; CTerrain::Delete, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 25   : 	pkTerrain->Clear();

  00004	8b 45 08	 mov	 eax, DWORD PTR _pkTerrain$[ebp]
  00007	8b 00		 mov	 eax, DWORD PTR [eax]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _pkTerrain$[ebp]
  0000c	ff 50 04	 call	 DWORD PTR [eax+4]

; 26   : 	ms_kPool.Free(pkTerrain);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pkTerrain$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00015	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00018	50		 push	 eax
  00019	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A+16
  0001e	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXABQAVCTerrain@@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::emplace_back<CTerrain * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 27   : }

  00023	c9		 leave
  00024	c3		 ret	 0
?Delete@CTerrain@@SAXPAV1@@Z ENDP			; CTerrain::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?New@CTerrain@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CTerrain@@SAPAV1@XZ PROC				; CTerrain::New, COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20   : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCTerrain@@@@QAEPAVCTerrain@@XZ ; CDynamicPool<CTerrain>::Alloc

; 21   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CTerrain@@SAPAV1@XZ ENDP				; CTerrain::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?DestroySystem@CTerrain@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CTerrain@@SAXXZ PROC			; CTerrain::DestroySystem, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCTerrain@@@@QAEXXZ ; CDynamicPool<CTerrain>::Destroy

; 16   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CTerrain@@SAXXZ ENDP			; CTerrain::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?_CalculateTerrainPatch@CTerrain@@IAEXEE@Z
_TEXT	SEGMENT
tv610 = -31772						; size = 8
tv568 = -31764						; size = 8
_fOrigY$ = -31756					; size = 4
_dwAlphaKey$1 = -31752					; size = 4
_fOrigX$ = -31748					; size = 4
tv540 = -31744						; size = 4
_dwPatchNum$ = -31740					; size = 4
tv575 = -31736						; size = 4
tv565 = -31732						; size = 4
___t$ = -31728						; size = 4
_dwAlpha0$2 = -31724					; size = 4
_dwNormalWidth$ = -31720				; size = 4
_uTerrainVertexCount$ = -31716				; size = 4
_dwAlpha3$3 = -31712					; size = 4
_fOpaqueWaterDepth$ = -31708				; size = 4
tv392 = -31704						; size = 4
tv386 = -31700						; size = 4
tv380 = -31696						; size = 4
tv374 = -31692						; size = 4
_dwAlpha1$4 = -31688					; size = 4
_dwAlpha2$5 = -31684					; size = 4
_pbyWater$6 = -31680					; size = 4
___n$ = -31676						; size = 4
_uWaterVertexCount$ = -31672				; size = 4
_fMaxZ$ = -31668					; size = 4
_fMinZ$ = -31664					; size = 4
_byOrigWaterPtr$ = -31660				; size = 4
_chOrigNormalPtr$ = -31656				; size = 4
_wOrigRawHeightPtr$ = -31652				; size = 4
_lpTerrainVertex$ = -31648				; size = 4
_fOOOpaqueWaterDepth$ = -31644				; size = 4
_fWaterTerrainHeightDifference3$7 = -31640		; size = 4
_fWaterTerrainHeightDifference2$8 = -31636		; size = 4
_fWaterTerrainHeightDifference1$9 = -31632		; size = 4
_fWaterTerrainHeightDifference0$10 = -31628		; size = 4
tv514 = -31622						; size = 2
_hgt$11 = -31620					; size = 2
_pwRawHeight$12 = -31616				; size = 4
_dwY$13 = -31612					; size = 4
_dwX$14 = -31608					; size = 4
_dwStartY$ = -31604					; size = 4
_dwStartX$ = -31600					; size = 4
_wNumPlainType$ = -31596				; size = 2
$T15 = -31589						; size = 1
_fTransparentWaterDepth$ = -31588			; size = 4
_pchNormal$16 = -31584					; size = 4
_lWaterHeight$17 = -31580				; size = 4
_wNumHillType$ = -31576					; size = 2
_wNumCliffType$ = -31572				; size = 2
_byNumWater$18 = -31565					; size = 1
_fY$ = -31564						; size = 4
_fX$ = -31560						; size = 4
_rkTerrainPatch$ = -31556				; size = 4
_bWaterExist$ = -31549					; size = 1
_this$ = -31548						; size = 4
_lpWaterVertex$ = -31544				; size = 4
_kNormal$ = -31540					; size = 12
_kPosition$ = -31528					; size = 12
_akSrcTerrainVertex$ = -31516				; size = 6936
_akSrcWaterVertex$ = -24580				; size = 24576
__$ArrayPad$ = -4					; size = 4
_byPatchNumX$ = 8					; size = 1
_byPatchNumY$ = 12					; size = 1
?_CalculateTerrainPatch@CTerrain@@IAEXEE@Z PROC		; CTerrain::_CalculateTerrainPatch, COMDAT
; _this$ = ecx

; 930  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 1c 7c 00 00	 mov	 eax, 31772		; 00007c1cH
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00012	33 c5		 xor	 eax, ebp
  00014	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	89 8d c4 84 ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 931  : 	if (!m_awRawHeightMap || !m_acNormalMap || !m_abyWaterMap)

  0001f	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00025	05 04 04 00 00	 add	 eax, 1028		; 00000404H
  0002a	74 1a		 je	 SHORT $LN9@CalculateT
  0002c	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00032	05 1a ce 02 00	 add	 eax, 183834		; 0002ce1aH
  00037	74 0d		 je	 SHORT $LN9@CalculateT
  00039	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0003f	05 1a 8e 02 00	 add	 eax, 167450		; 00028e1aH
  00044	75 05		 jne	 SHORT $LN8@CalculateT
$LN9@CalculateT:

; 932  : 		return;

  00046	e9 a8 0d 00 00	 jmp	 $LN1@CalculateT
$LN8@CalculateT:

; 933  : 
; 934  : 	DWORD dwPatchNum = byPatchNumY * PATCH_XCOUNT + byPatchNumX;

  0004b	0f b6 45 0c	 movzx	 eax, BYTE PTR _byPatchNumY$[ebp]
  0004f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _byPatchNumX$[ebp]
  00053	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00056	89 85 04 84 ff
	ff		 mov	 DWORD PTR _dwPatchNum$[ebp], eax

; 935  : 
; 936  : 	CTerrainPatch& rkTerrainPatch=m_TerrainPatchList[dwPatchNum];

  0005c	6b 85 04 84 ff
	ff 70		 imul	 eax, DWORD PTR _dwPatchNum$[ebp], 112
  00063	8b 8d c4 84 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00069	8d 84 01 d8 a5
	06 00		 lea	 eax, DWORD PTR [ecx+eax+435672]
  00070	89 85 bc 84 ff
	ff		 mov	 DWORD PTR _rkTerrainPatch$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 94   : 	bool NeedUpdate()										{ return m_bNeedUpdate; }

  00076	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  0007c	8a 40 45	 mov	 al, BYTE PTR [eax+69]
  0007f	88 85 9b 84 ff
	ff		 mov	 BYTE PTR $T15[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 937  : 	if (!rkTerrainPatch.NeedUpdate())

  00085	0f b6 85 9b 84
	ff ff		 movzx	 eax, BYTE PTR $T15[ebp]
  0008c	85 c0		 test	 eax, eax
  0008e	75 05		 jne	 SHORT $LN10@CalculateT

; 938  : 		return;

  00090	e9 5e 0d 00 00	 jmp	 $LN1@CalculateT
$LN10@CalculateT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h

; 671  : 		float	GetOpaqueWaterDepth() { return m_fOpaqueWaterDepth;	}

  00095	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 80 b8 a5 06
	00		 mov	 eax, DWORD PTR [eax+435640]
  000a1	f3 0f 10 80 24
	0a 00 00	 movss	 xmm0, DWORD PTR [eax+2596]
  000a9	f3 0f 11 85 24
	84 ff ff	 movss	 DWORD PTR _fOpaqueWaterDepth$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 941  : 	const float fOOOpaqueWaterDepth = 1.0f/fOpaqueWaterDepth;

  000b1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b9	f3 0f 5e 85 24
	84 ff ff	 divss	 xmm0, DWORD PTR _fOpaqueWaterDepth$[ebp]
  000c1	f3 0f 11 85 64
	84 ff ff	 movss	 DWORD PTR _fOOOpaqueWaterDepth$[ebp], xmm0

; 942  : 	const float fTransparentWaterDepth = 0.8f * fOpaqueWaterDepth;

  000c9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f4ccccd
  000d1	f3 0f 59 85 24
	84 ff ff	 mulss	 xmm0, DWORD PTR _fOpaqueWaterDepth$[ebp]
  000d9	f3 0f 11 85 9c
	84 ff ff	 movss	 DWORD PTR _fTransparentWaterDepth$[ebp], xmm0

; 943  : 
; 944  : 	rkTerrainPatch.Clear();	

  000e1	8b 8d bc 84 ff
	ff		 mov	 ecx, DWORD PTR _rkTerrainPatch$[ebp]
  000e7	e8 00 00 00 00	 call	 ?Clear@CTerrainPatch@@QAEXXZ ; CTerrainPatch::Clear

; 945  : 
; 946  : 	HardwareTransformPatch_SSourceVertex akSrcTerrainVertex[CTerrainPatch::TERRAIN_VERTEX_COUNT];

  000ec	c7 85 44 84 ff
	ff 21 01 00 00	 mov	 DWORD PTR ___n$[ebp], 289 ; 00000121H
  000f6	8d 85 e4 84 ff
	ff		 lea	 eax, DWORD PTR _akSrcTerrainVertex$[ebp]
  000fc	89 85 10 84 ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN49@CalculateT:
  00102	8b 85 44 84 ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00108	89 85 00 84 ff
	ff		 mov	 DWORD PTR tv540[ebp], eax
  0010e	8b 85 44 84 ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00114	48		 dec	 eax
  00115	89 85 44 84 ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  0011b	83 bd 00 84 ff
	ff 00		 cmp	 DWORD PTR tv540[ebp], 0
  00122	76 11		 jbe	 SHORT $LN50@CalculateT
  00124	8b 85 10 84 ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  0012a	83 c0 18	 add	 eax, 24			; 00000018H
  0012d	89 85 10 84 ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  00133	eb cd		 jmp	 SHORT $LN49@CalculateT
$LN50@CalculateT:

; 947  : 	SWaterVertex akSrcWaterVertex[PATCH_XSIZE * PATCH_YSIZE * 6];
; 948  : 		
; 949  : 	DWORD dwNormalWidth = CTerrainImpl::NORMALMAP_XSIZE * 3;

  00135	c7 85 18 84 ff
	ff 83 01 00 00	 mov	 DWORD PTR _dwNormalWidth$[ebp], 387 ; 00000183H

; 950  : 	DWORD dwStartX = byPatchNumX * PATCH_XSIZE;

  0013f	0f b6 45 08	 movzx	 eax, BYTE PTR _byPatchNumX$[ebp]
  00143	c1 e0 04	 shl	 eax, 4
  00146	89 85 90 84 ff
	ff		 mov	 DWORD PTR _dwStartX$[ebp], eax

; 951  : 	DWORD dwStartY = byPatchNumY * PATCH_YSIZE;

  0014c	0f b6 45 0c	 movzx	 eax, BYTE PTR _byPatchNumY$[ebp]
  00150	c1 e0 04	 shl	 eax, 4
  00153	89 85 8c 84 ff
	ff		 mov	 DWORD PTR _dwStartY$[ebp], eax

; 952  : 	
; 953  : 	WORD * wOrigRawHeightPtr = m_awRawHeightMap + ((dwStartY+1) * HEIGHTMAP_RAW_XSIZE) + dwStartX+1;

  00159	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  0015f	40		 inc	 eax
  00160	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00166	8b 8d c4 84 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0016c	8d 84 41 04 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax*2+1028]
  00173	8b 8d 90 84 ff
	ff		 mov	 ecx, DWORD PTR _dwStartX$[ebp]
  00179	8d 44 48 02	 lea	 eax, DWORD PTR [eax+ecx*2+2]
  0017d	89 85 5c 84 ff
	ff		 mov	 DWORD PTR _wOrigRawHeightPtr$[ebp], eax

; 954  : 	char * chOrigNormalPtr = m_acNormalMap + (dwStartY * dwNormalWidth) + dwStartX * 3;

  00183	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  00189	0f af 85 18 84
	ff ff		 imul	 eax, DWORD PTR _dwNormalWidth$[ebp]
  00190	8b 8d c4 84 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00196	8d 84 01 1a ce
	02 00		 lea	 eax, DWORD PTR [ecx+eax+183834]
  0019d	6b 8d 90 84 ff
	ff 03		 imul	 ecx, DWORD PTR _dwStartX$[ebp], 3
  001a4	03 c1		 add	 eax, ecx
  001a6	89 85 58 84 ff
	ff		 mov	 DWORD PTR _chOrigNormalPtr$[ebp], eax

; 955  : 	BYTE * byOrigWaterPtr = m_abyWaterMap + (dwStartY * WATERMAP_XSIZE) + dwStartX;

  001ac	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  001b2	c1 e0 07	 shl	 eax, 7
  001b5	03 85 90 84 ff
	ff		 add	 eax, DWORD PTR _dwStartX$[ebp]
  001bb	8b 8d c4 84 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	8d 84 01 1a 8e
	02 00		 lea	 eax, DWORD PTR [ecx+eax+167450]
  001c8	89 85 54 84 ff
	ff		 mov	 DWORD PTR _byOrigWaterPtr$[ebp], eax

; 956  : 	
; 957  : 	float fX, fY, fOrigX, fOrigY;
; 958  : 	fOrigX = fX = (float)(m_wX * XSIZE * CELLSCALE) + (float)(dwStartX * CELLSCALE);

  001ce	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001d4	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  001db	c1 e0 07	 shl	 eax, 7
  001de	69 c0 c8 00 00
	00		 imul	 eax, eax, 200
  001e4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001e8	69 85 90 84 ff
	ff c8 00 00 00	 imul	 eax, DWORD PTR _dwStartX$[ebp], 200
  001f2	89 85 0c 84 ff
	ff		 mov	 DWORD PTR tv565[ebp], eax
  001f8	f2 0f 2a 8d 0c
	84 ff ff	 cvtsi2sd xmm1, DWORD PTR tv565[ebp]
  00200	8b 85 0c 84 ff
	ff		 mov	 eax, DWORD PTR tv565[ebp]
  00206	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00209	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00212	f2 0f 11 8d ec
	83 ff ff	 movsd	 QWORD PTR tv568[ebp], xmm1
  0021a	f2 0f 5a 8d ec
	83 ff ff	 cvtsd2ss xmm1, QWORD PTR tv568[ebp]
  00222	f3 0f 58 c1	 addss	 xmm0, xmm1
  00226	f3 0f 11 85 b8
	84 ff ff	 movss	 DWORD PTR _fX$[ebp], xmm0
  0022e	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00236	f3 0f 11 85 fc
	83 ff ff	 movss	 DWORD PTR _fOrigX$[ebp], xmm0

; 959  : 	fOrigY = fY = (float)(m_wY * YSIZE * CELLSCALE) + (float)(dwStartY * CELLSCALE);

  0023e	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00244	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  0024b	c1 e0 07	 shl	 eax, 7
  0024e	69 c0 c8 00 00
	00		 imul	 eax, eax, 200
  00254	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00258	69 85 8c 84 ff
	ff c8 00 00 00	 imul	 eax, DWORD PTR _dwStartY$[ebp], 200
  00262	89 85 08 84 ff
	ff		 mov	 DWORD PTR tv575[ebp], eax
  00268	f2 0f 2a 8d 08
	84 ff ff	 cvtsi2sd xmm1, DWORD PTR tv575[ebp]
  00270	8b 85 08 84 ff
	ff		 mov	 eax, DWORD PTR tv575[ebp]
  00276	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00279	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00282	f2 0f 11 8d e4
	83 ff ff	 movsd	 QWORD PTR tv610[ebp], xmm1
  0028a	f2 0f 5a 8d e4
	83 ff ff	 cvtsd2ss xmm1, QWORD PTR tv610[ebp]
  00292	f3 0f 58 c1	 addss	 xmm0, xmm1
  00296	f3 0f 11 85 b4
	84 ff ff	 movss	 DWORD PTR _fY$[ebp], xmm0
  0029e	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  002a6	f3 0f 11 85 f4
	83 ff ff	 movss	 DWORD PTR _fOrigY$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 63   : 	void SetMinX(float fMinX)								{ m_fMinX = fMinX; }

  002ae	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  002b4	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  002bc	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 962  : 	rkTerrainPatch.SetMaxX(fX + (float)(PATCH_XSIZE*CELLSCALE));

  002c0	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  002c8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@45480000
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 66   : 	void SetMaxX(float fMaxX)								{ m_fMaxX = fMaxX; }

  002d0	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  002d6	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 69   : 	void SetMinY(float fMinY)								{ m_fMinY = fMinY; }

  002db	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  002e1	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  002e9	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 964  : 	rkTerrainPatch.SetMaxY(fY + (float)(PATCH_YSIZE*CELLSCALE));

  002ee	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  002f6	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@45480000
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 72   : 	void SetMaxY(float fMaxY)								{ m_fMaxY = fMaxY; }

  002fe	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00304	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 966  : 	float fMinZ =  999999.0f;

  00309	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@497423f0
  00311	f3 0f 11 85 50
	84 ff ff	 movss	 DWORD PTR _fMinZ$[ebp], xmm0

; 967  : 	float fMaxZ = -999999.0f;

  00319	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c97423f0
  00321	f3 0f 11 85 4c
	84 ff ff	 movss	 DWORD PTR _fMaxZ$[ebp], xmm0

; 968  : 	WORD wNumPlainType = 0;

  00329	33 c0		 xor	 eax, eax
  0032b	66 89 85 94 84
	ff ff		 mov	 WORD PTR _wNumPlainType$[ebp], ax

; 969  : 	WORD wNumHillType = 0;

  00332	33 c0		 xor	 eax, eax
  00334	66 89 85 a8 84
	ff ff		 mov	 WORD PTR _wNumHillType$[ebp], ax

; 970  : 	WORD wNumCliffType = 0;

  0033b	33 c0		 xor	 eax, eax
  0033d	66 89 85 ac 84
	ff ff		 mov	 WORD PTR _wNumCliffType$[ebp], ax

; 971  : 
; 972  : 	bool bWaterExist=false;

  00344	c6 85 c3 84 ff
	ff 00		 mov	 BYTE PTR _bWaterExist$[ebp], 0

; 973  : 	
; 974  : 	SWaterVertex*	lpWaterVertex=akSrcWaterVertex;

  0034b	8d 85 fc 9f ff
	ff		 lea	 eax, DWORD PTR _akSrcWaterVertex$[ebp]
  00351	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 975  : 	UINT uWaterVertexCount=0;

  00357	83 a5 48 84 ff
	ff 00		 and	 DWORD PTR _uWaterVertexCount$[ebp], 0

; 976  : 	
; 977  : 	HardwareTransformPatch_SSourceVertex*	lpTerrainVertex=akSrcTerrainVertex;	

  0035e	8d 85 e4 84 ff
	ff		 lea	 eax, DWORD PTR _akSrcTerrainVertex$[ebp]
  00364	89 85 60 84 ff
	ff		 mov	 DWORD PTR _lpTerrainVertex$[ebp], eax

; 978  : 	UINT uTerrainVertexCount=0;

  0036a	83 a5 1c 84 ff
	ff 00		 and	 DWORD PTR _uTerrainVertexCount$[ebp], 0

; 979  : 
; 980  : 	D3DXVECTOR3 kNormal;
; 981  : 	D3DXVECTOR3 kPosition;
; 982  : 	for (DWORD dwY = dwStartY; dwY <= dwStartY + PATCH_YSIZE; ++dwY)

  00371	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  00377	89 85 84 84 ff
	ff		 mov	 DWORD PTR _dwY$13[ebp], eax
  0037d	eb 0d		 jmp	 SHORT $LN4@CalculateT
$LN2@CalculateT:
  0037f	8b 85 84 84 ff
	ff		 mov	 eax, DWORD PTR _dwY$13[ebp]
  00385	40		 inc	 eax
  00386	89 85 84 84 ff
	ff		 mov	 DWORD PTR _dwY$13[ebp], eax
$LN4@CalculateT:
  0038c	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  00392	83 c0 10	 add	 eax, 16			; 00000010H
  00395	39 85 84 84 ff
	ff		 cmp	 DWORD PTR _dwY$13[ebp], eax
  0039b	0f 87 74 09 00
	00		 ja	 $LN3@CalculateT

; 983  :     {
; 984  : 		WORD * pwRawHeight	= wOrigRawHeightPtr;

  003a1	8b 85 5c 84 ff
	ff		 mov	 eax, DWORD PTR _wOrigRawHeightPtr$[ebp]
  003a7	89 85 80 84 ff
	ff		 mov	 DWORD PTR _pwRawHeight$12[ebp], eax

; 985  : 		char * pchNormal	= chOrigNormalPtr;

  003ad	8b 85 58 84 ff
	ff		 mov	 eax, DWORD PTR _chOrigNormalPtr$[ebp]
  003b3	89 85 a0 84 ff
	ff		 mov	 DWORD PTR _pchNormal$16[ebp], eax

; 986  : 		BYTE * pbyWater		= byOrigWaterPtr;

  003b9	8b 85 54 84 ff
	ff		 mov	 eax, DWORD PTR _byOrigWaterPtr$[ebp]
  003bf	89 85 40 84 ff
	ff		 mov	 DWORD PTR _pbyWater$6[ebp], eax

; 987  : 		fX = fOrigX;

  003c5	f3 0f 10 85 fc
	83 ff ff	 movss	 xmm0, DWORD PTR _fOrigX$[ebp]
  003cd	f3 0f 11 85 b8
	84 ff ff	 movss	 DWORD PTR _fX$[ebp], xmm0

; 988  : 		
; 989  : 		for (DWORD dwX = dwStartX; dwX <= dwStartX + PATCH_XSIZE; ++dwX)

  003d5	8b 85 90 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartX$[ebp]
  003db	89 85 88 84 ff
	ff		 mov	 DWORD PTR _dwX$14[ebp], eax
  003e1	eb 0d		 jmp	 SHORT $LN7@CalculateT
$LN5@CalculateT:
  003e3	8b 85 88 84 ff
	ff		 mov	 eax, DWORD PTR _dwX$14[ebp]
  003e9	40		 inc	 eax
  003ea	89 85 88 84 ff
	ff		 mov	 DWORD PTR _dwX$14[ebp], eax
$LN7@CalculateT:
  003f0	8b 85 90 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartX$[ebp]
  003f6	83 c0 10	 add	 eax, 16			; 00000010H
  003f9	39 85 88 84 ff
	ff		 cmp	 DWORD PTR _dwX$14[ebp], eax
  003ff	0f 87 bf 08 00
	00		 ja	 $LN6@CalculateT

; 990  : 		{
; 991  : 			WORD hgt = (*pwRawHeight++);

  00405	8b 85 80 84 ff
	ff		 mov	 eax, DWORD PTR _pwRawHeight$12[ebp]
  0040b	66 8b 00	 mov	 ax, WORD PTR [eax]
  0040e	66 89 85 7c 84
	ff ff		 mov	 WORD PTR _hgt$11[ebp], ax
  00415	8b 85 80 84 ff
	ff		 mov	 eax, DWORD PTR _pwRawHeight$12[ebp]
  0041b	40		 inc	 eax
  0041c	40		 inc	 eax
  0041d	89 85 80 84 ff
	ff		 mov	 DWORD PTR _pwRawHeight$12[ebp], eax

; 992  : 			
; 993  : 			kNormal.x = -(*pchNormal++) * 0.0078740f;

  00423	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  00429	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0042c	f7 d8		 neg	 eax
  0042e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00432	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c0101f3
  0043a	f3 0f 11 85 cc
	84 ff ff	 movss	 DWORD PTR _kNormal$[ebp], xmm0
  00442	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  00448	40		 inc	 eax
  00449	89 85 a0 84 ff
	ff		 mov	 DWORD PTR _pchNormal$16[ebp], eax

; 994  : 			kNormal.y = (*pchNormal++) * 0.0078740f;

  0044f	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  00455	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00458	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0045c	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c0101f3
  00464	f3 0f 11 85 d0
	84 ff ff	 movss	 DWORD PTR _kNormal$[ebp+4], xmm0
  0046c	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  00472	40		 inc	 eax
  00473	89 85 a0 84 ff
	ff		 mov	 DWORD PTR _pchNormal$16[ebp], eax

; 995  : 			kNormal.z = (*pchNormal++) * 0.0078740f;

  00479	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  0047f	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00482	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00486	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c0101f3
  0048e	f3 0f 11 85 d4
	84 ff ff	 movss	 DWORD PTR _kNormal$[ebp+8], xmm0
  00496	8b 85 a0 84 ff
	ff		 mov	 eax, DWORD PTR _pchNormal$16[ebp]
  0049c	40		 inc	 eax
  0049d	89 85 a0 84 ff
	ff		 mov	 DWORD PTR _pchNormal$16[ebp], eax

; 996  : 
; 997  : 			kPosition.x = +fX;

  004a3	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  004ab	f3 0f 11 85 d8
	84 ff ff	 movss	 DWORD PTR _kPosition$[ebp], xmm0

; 998  : 			kPosition.y = -fY;

  004b3	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  004bb	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  004c2	f3 0f 11 85 dc
	84 ff ff	 movss	 DWORD PTR _kPosition$[ebp+4], xmm0

; 999  : 			kPosition.z = (float)(hgt) * m_fHeightScale;

  004ca	0f b7 85 7c 84
	ff ff		 movzx	 eax, WORD PTR _hgt$11[ebp]
  004d1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  004d5	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004db	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  004e3	f3 0f 11 85 e0
	84 ff ff	 movss	 DWORD PTR _kPosition$[ebp+8], xmm0

; 1000 : 			lpTerrainVertex->kPosition = kPosition;

  004eb	8d b5 d8 84 ff
	ff		 lea	 esi, DWORD PTR _kPosition$[ebp]
  004f1	8b bd 60 84 ff
	ff		 mov	 edi, DWORD PTR _lpTerrainVertex$[ebp]
  004f7	a5		 movsd
  004f8	a5		 movsd
  004f9	a5		 movsd

; 1001 : 			lpTerrainVertex->kNormal = kNormal;

  004fa	8b bd 60 84 ff
	ff		 mov	 edi, DWORD PTR _lpTerrainVertex$[ebp]
  00500	83 c7 0c	 add	 edi, 12			; 0000000cH
  00503	8d b5 cc 84 ff
	ff		 lea	 esi, DWORD PTR _kNormal$[ebp]
  00509	a5		 movsd
  0050a	a5		 movsd
  0050b	a5		 movsd

; 1002 : 
; 1003 : 			if (0.5f > kNormal.z)				//   30     . Cliff type 

  0050c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00514	0f 2f 85 d4 84
	ff ff		 comiss	 xmm0, DWORD PTR _kNormal$[ebp+8]
  0051b	76 14		 jbe	 SHORT $LN11@CalculateT

; 1004 : 				++wNumCliffType;

  0051d	66 8b 85 ac 84
	ff ff		 mov	 ax, WORD PTR _wNumCliffType$[ebp]
  00524	66 83 c0 01	 add	 ax, 1
  00528	66 89 85 ac 84
	ff ff		 mov	 WORD PTR _wNumCliffType$[ebp], ax
  0052f	eb 37		 jmp	 SHORT $LN14@CalculateT
$LN11@CalculateT:

; 1005 : 			else if (0.8660254f > kNormal.z)	//   60     . Hill type 

  00531	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f5db3d7
  00539	0f 2f 85 d4 84
	ff ff		 comiss	 xmm0, DWORD PTR _kNormal$[ebp+8]
  00540	76 14		 jbe	 SHORT $LN13@CalculateT

; 1006 : 				++wNumHillType;

  00542	66 8b 85 a8 84
	ff ff		 mov	 ax, WORD PTR _wNumHillType$[ebp]
  00549	66 83 c0 01	 add	 ax, 1
  0054d	66 89 85 a8 84
	ff ff		 mov	 WORD PTR _wNumHillType$[ebp], ax
  00554	eb 12		 jmp	 SHORT $LN14@CalculateT
$LN13@CalculateT:

; 1007 : 			else										//   plain 
; 1008 : 				++wNumPlainType;

  00556	66 8b 85 94 84
	ff ff		 mov	 ax, WORD PTR _wNumPlainType$[ebp]
  0055d	66 83 c0 01	 add	 ax, 1
  00561	66 89 85 94 84
	ff ff		 mov	 WORD PTR _wNumPlainType$[ebp], ax
$LN14@CalculateT:

; 1009 : 			
; 1010 : 			if (kPosition.z > fMaxZ)

  00568	f3 0f 10 85 e0
	84 ff ff	 movss	 xmm0, DWORD PTR _kPosition$[ebp+8]
  00570	0f 2f 85 4c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fMaxZ$[ebp]
  00577	76 10		 jbe	 SHORT $LN15@CalculateT

; 1011 : 				fMaxZ = kPosition.z;

  00579	f3 0f 10 85 e0
	84 ff ff	 movss	 xmm0, DWORD PTR _kPosition$[ebp+8]
  00581	f3 0f 11 85 4c
	84 ff ff	 movss	 DWORD PTR _fMaxZ$[ebp], xmm0
$LN15@CalculateT:

; 1012 : 			if (kPosition.z < fMinZ)

  00589	f3 0f 10 85 50
	84 ff ff	 movss	 xmm0, DWORD PTR _fMinZ$[ebp]
  00591	0f 2f 85 e0 84
	ff ff		 comiss	 xmm0, DWORD PTR _kPosition$[ebp+8]
  00598	76 10		 jbe	 SHORT $LN16@CalculateT

; 1013 : 				fMinZ = kPosition.z;

  0059a	f3 0f 10 85 e0
	84 ff ff	 movss	 xmm0, DWORD PTR _kPosition$[ebp+8]
  005a2	f3 0f 11 85 50
	84 ff ff	 movss	 DWORD PTR _fMinZ$[ebp], xmm0
$LN16@CalculateT:

; 1014 : 			
; 1015 : 			if (0 <= dwX && 0 <= dwY && XSIZE > dwX && YSIZE > dwY && 
; 1016 : 				(dwStartX + PATCH_XSIZE) != dwX && (dwStartY + PATCH_YSIZE) != dwY)

  005aa	83 bd 88 84 ff
	ff 00		 cmp	 DWORD PTR _dwX$14[ebp], 0
  005b1	0f 82 d4 06 00
	00		 jb	 $LN28@CalculateT
  005b7	83 bd 84 84 ff
	ff 00		 cmp	 DWORD PTR _dwY$13[ebp], 0
  005be	0f 82 c7 06 00
	00		 jb	 $LN28@CalculateT
  005c4	81 bd 88 84 ff
	ff 80 00 00 00	 cmp	 DWORD PTR _dwX$14[ebp], 128 ; 00000080H
  005ce	0f 83 b7 06 00
	00		 jae	 $LN28@CalculateT
  005d4	81 bd 84 84 ff
	ff 80 00 00 00	 cmp	 DWORD PTR _dwY$13[ebp], 128 ; 00000080H
  005de	0f 83 a7 06 00
	00		 jae	 $LN28@CalculateT
  005e4	8b 85 90 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartX$[ebp]
  005ea	83 c0 10	 add	 eax, 16			; 00000010H
  005ed	3b 85 88 84 ff
	ff		 cmp	 eax, DWORD PTR _dwX$14[ebp]
  005f3	0f 84 92 06 00
	00		 je	 $LN28@CalculateT
  005f9	8b 85 8c 84 ff
	ff		 mov	 eax, DWORD PTR _dwStartY$[ebp]
  005ff	83 c0 10	 add	 eax, 16			; 00000010H
  00602	3b 85 84 84 ff
	ff		 cmp	 eax, DWORD PTR _dwY$13[ebp]
  00608	0f 84 7d 06 00
	00		 je	 $LN28@CalculateT

; 1017 : 			{
; 1018 : 				BYTE byNumWater = (*pbyWater++);

  0060e	8b 85 40 84 ff
	ff		 mov	 eax, DWORD PTR _pbyWater$6[ebp]
  00614	8a 00		 mov	 al, BYTE PTR [eax]
  00616	88 85 b3 84 ff
	ff		 mov	 BYTE PTR _byNumWater$18[ebp], al
  0061c	8b 85 40 84 ff
	ff		 mov	 eax, DWORD PTR _pbyWater$6[ebp]
  00622	40		 inc	 eax
  00623	89 85 40 84 ff
	ff		 mov	 DWORD PTR _pbyWater$6[ebp], eax

; 1019 : 
; 1020 : 				if (byNumWater != 0xFF)

  00629	0f b6 85 b3 84
	ff ff		 movzx	 eax, BYTE PTR _byNumWater$18[ebp]
  00630	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00635	0f 84 50 06 00
	00		 je	 $LN28@CalculateT

; 1021 : 				{
; 1022 : 					long lWaterHeight = m_lWaterHeight[byNumWater];

  0063b	0f b6 85 b3 84
	ff ff		 movzx	 eax, BYTE PTR _byNumWater$18[ebp]
  00642	8b 8d c4 84 ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00648	8b 84 81 44 a1
	04 00		 mov	 eax, DWORD PTR [ecx+eax*4+303428]
  0064f	89 85 a4 84 ff
	ff		 mov	 DWORD PTR _lWaterHeight$17[ebp], eax

; 1023 : 					if (-1 != lWaterHeight)

  00655	83 bd a4 84 ff
	ff ff		 cmp	 DWORD PTR _lWaterHeight$17[ebp], -1
  0065c	0f 84 29 06 00
	00		 je	 $LN28@CalculateT

; 1024 : 					{
; 1025 : 						float fWaterTerrainHeightDifference0 = (float)(lWaterHeight - (long)hgt);

  00662	0f b7 85 7c 84
	ff ff		 movzx	 eax, WORD PTR _hgt$11[ebp]
  00669	8b 8d a4 84 ff
	ff		 mov	 ecx, DWORD PTR _lWaterHeight$17[ebp]
  0066f	2b c8		 sub	 ecx, eax
  00671	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00675	f3 0f 11 85 74
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference0$10[ebp], xmm0

; 1026 : 						if (fWaterTerrainHeightDifference0 >= fTransparentWaterDepth)

  0067d	f3 0f 10 85 74
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference0$10[ebp]
  00685	0f 2f 85 9c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  0068c	72 10		 jb	 SHORT $LN20@CalculateT

; 1027 : 							fWaterTerrainHeightDifference0 = fTransparentWaterDepth;

  0068e	f3 0f 10 85 9c
	84 ff ff	 movss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  00696	f3 0f 11 85 74
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference0$10[ebp], xmm0
$LN20@CalculateT:

; 1028 : 						if (fWaterTerrainHeightDifference0 <= 0.0f)

  0069e	0f 57 c0	 xorps	 xmm0, xmm0
  006a1	0f 2f 85 74 84
	ff ff		 comiss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference0$10[ebp]
  006a8	72 0b		 jb	 SHORT $LN21@CalculateT

; 1029 : 							fWaterTerrainHeightDifference0 = 0.0f;

  006aa	0f 57 c0	 xorps	 xmm0, xmm0
  006ad	f3 0f 11 85 74
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference0$10[ebp], xmm0
$LN21@CalculateT:

; 1030 : 
; 1031 : 						float fWaterTerrainHeightDifference1 = (float)(lWaterHeight - (long)(*(pwRawHeight + CTerrainImpl::HEIGHTMAP_RAW_XSIZE - 1)));

  006b5	8b 85 80 84 ff
	ff		 mov	 eax, DWORD PTR _pwRawHeight$12[ebp]
  006bb	0f b7 80 04 01
	00 00		 movzx	 eax, WORD PTR [eax+260]
  006c2	8b 8d a4 84 ff
	ff		 mov	 ecx, DWORD PTR _lWaterHeight$17[ebp]
  006c8	2b c8		 sub	 ecx, eax
  006ca	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  006ce	f3 0f 11 85 70
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference1$9[ebp], xmm0

; 1032 : 						if (fWaterTerrainHeightDifference1 >= fTransparentWaterDepth)

  006d6	f3 0f 10 85 70
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference1$9[ebp]
  006de	0f 2f 85 9c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  006e5	72 10		 jb	 SHORT $LN22@CalculateT

; 1033 : 							fWaterTerrainHeightDifference1 = fTransparentWaterDepth;

  006e7	f3 0f 10 85 9c
	84 ff ff	 movss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  006ef	f3 0f 11 85 70
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference1$9[ebp], xmm0
$LN22@CalculateT:

; 1034 : 						if (fWaterTerrainHeightDifference1 <= 0.0f)

  006f7	0f 57 c0	 xorps	 xmm0, xmm0
  006fa	0f 2f 85 70 84
	ff ff		 comiss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference1$9[ebp]
  00701	72 0b		 jb	 SHORT $LN23@CalculateT

; 1035 : 							fWaterTerrainHeightDifference1 = 0.0f;

  00703	0f 57 c0	 xorps	 xmm0, xmm0
  00706	f3 0f 11 85 70
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference1$9[ebp], xmm0
$LN23@CalculateT:

; 1036 : 
; 1037 : 						float fWaterTerrainHeightDifference2 = (float)(lWaterHeight - (long)(*(pwRawHeight)));

  0070e	8b 85 80 84 ff
	ff		 mov	 eax, DWORD PTR _pwRawHeight$12[ebp]
  00714	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00717	8b 8d a4 84 ff
	ff		 mov	 ecx, DWORD PTR _lWaterHeight$17[ebp]
  0071d	2b c8		 sub	 ecx, eax
  0071f	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  00723	f3 0f 11 85 6c
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference2$8[ebp], xmm0

; 1038 : 						if (fWaterTerrainHeightDifference2 >= fTransparentWaterDepth)

  0072b	f3 0f 10 85 6c
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference2$8[ebp]
  00733	0f 2f 85 9c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  0073a	72 10		 jb	 SHORT $LN24@CalculateT

; 1039 : 							fWaterTerrainHeightDifference2 = fTransparentWaterDepth;

  0073c	f3 0f 10 85 9c
	84 ff ff	 movss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  00744	f3 0f 11 85 6c
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference2$8[ebp], xmm0
$LN24@CalculateT:

; 1040 : 						if (fWaterTerrainHeightDifference2 <= 0.0f)

  0074c	0f 57 c0	 xorps	 xmm0, xmm0
  0074f	0f 2f 85 6c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference2$8[ebp]
  00756	72 0b		 jb	 SHORT $LN25@CalculateT

; 1041 : 							fWaterTerrainHeightDifference2 = 0.0f;

  00758	0f 57 c0	 xorps	 xmm0, xmm0
  0075b	f3 0f 11 85 6c
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference2$8[ebp], xmm0
$LN25@CalculateT:

; 1042 : 
; 1043 : 						float fWaterTerrainHeightDifference3 = (float)(lWaterHeight - (long)(*(pwRawHeight + CTerrainImpl::HEIGHTMAP_RAW_XSIZE)));

  00763	8b 85 80 84 ff
	ff		 mov	 eax, DWORD PTR _pwRawHeight$12[ebp]
  00769	0f b7 80 06 01
	00 00		 movzx	 eax, WORD PTR [eax+262]
  00770	8b 8d a4 84 ff
	ff		 mov	 ecx, DWORD PTR _lWaterHeight$17[ebp]
  00776	2b c8		 sub	 ecx, eax
  00778	f3 0f 2a c1	 cvtsi2ss xmm0, ecx
  0077c	f3 0f 11 85 68
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference3$7[ebp], xmm0

; 1044 : 						if (fWaterTerrainHeightDifference3 >= fTransparentWaterDepth)

  00784	f3 0f 10 85 68
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference3$7[ebp]
  0078c	0f 2f 85 9c 84
	ff ff		 comiss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  00793	72 10		 jb	 SHORT $LN26@CalculateT

; 1045 : 							fWaterTerrainHeightDifference3 = fTransparentWaterDepth;

  00795	f3 0f 10 85 9c
	84 ff ff	 movss	 xmm0, DWORD PTR _fTransparentWaterDepth$[ebp]
  0079d	f3 0f 11 85 68
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference3$7[ebp], xmm0
$LN26@CalculateT:

; 1046 : 						if (fWaterTerrainHeightDifference3 <= 0.0f)

  007a5	0f 57 c0	 xorps	 xmm0, xmm0
  007a8	0f 2f 85 68 84
	ff ff		 comiss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference3$7[ebp]
  007af	72 0b		 jb	 SHORT $LN27@CalculateT

; 1047 : 							fWaterTerrainHeightDifference3 = 0.0f;

  007b1	0f 57 c0	 xorps	 xmm0, xmm0
  007b4	f3 0f 11 85 68
	84 ff ff	 movss	 DWORD PTR _fWaterTerrainHeightDifference3$7[ebp], xmm0
$LN27@CalculateT:

; 1048 : 
; 1049 : 						DWORD dwAlpha0;
; 1050 : 						DWORD dwAlpha1;
; 1051 : 						DWORD dwAlpha2;
; 1052 : 						DWORD dwAlpha3;
; 1053 : 
; 1054 : 						PR_FLOAT_TO_INT(fWaterTerrainHeightDifference0 * fOOOpaqueWaterDepth * 255.0f, dwAlpha0);

  007bc	f3 0f 10 85 74
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference0$10[ebp]
  007c4	f3 0f 59 85 64
	84 ff ff	 mulss	 xmm0, DWORD PTR _fOOOpaqueWaterDepth$[ebp]
  007cc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  007d4	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  007dc	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  007e2	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  007e8	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  007f0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  007f7	76 0e		 jbe	 SHORT $LN34@CalculateT
  007f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  007fe	48		 dec	 eax
  007ff	89 85 34 84 ff
	ff		 mov	 DWORD PTR tv374[ebp], eax
  00805	eb 0b		 jmp	 SHORT $LN35@CalculateT
$LN34@CalculateT:
  00807	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0080c	89 85 34 84 ff
	ff		 mov	 DWORD PTR tv374[ebp], eax
$LN35@CalculateT:
  00812	8b 85 34 84 ff
	ff		 mov	 eax, DWORD PTR tv374[ebp]
  00818	89 85 14 84 ff
	ff		 mov	 DWORD PTR _dwAlpha0$2[ebp], eax

; 1055 : 						PR_FLOAT_TO_INT(fWaterTerrainHeightDifference1 * fOOOpaqueWaterDepth * 255.0f, dwAlpha1);

  0081e	f3 0f 10 85 70
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference1$9[ebp]
  00826	f3 0f 59 85 64
	84 ff ff	 mulss	 xmm0, DWORD PTR _fOOOpaqueWaterDepth$[ebp]
  0082e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00836	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  0083e	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00844	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0084a	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00852	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00859	76 0e		 jbe	 SHORT $LN36@CalculateT
  0085b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00860	48		 dec	 eax
  00861	89 85 30 84 ff
	ff		 mov	 DWORD PTR tv380[ebp], eax
  00867	eb 0b		 jmp	 SHORT $LN37@CalculateT
$LN36@CalculateT:
  00869	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0086e	89 85 30 84 ff
	ff		 mov	 DWORD PTR tv380[ebp], eax
$LN37@CalculateT:
  00874	8b 85 30 84 ff
	ff		 mov	 eax, DWORD PTR tv380[ebp]
  0087a	89 85 38 84 ff
	ff		 mov	 DWORD PTR _dwAlpha1$4[ebp], eax

; 1056 : 						PR_FLOAT_TO_INT(fWaterTerrainHeightDifference2 * fOOOpaqueWaterDepth * 255.0f, dwAlpha2);

  00880	f3 0f 10 85 6c
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference2$8[ebp]
  00888	f3 0f 59 85 64
	84 ff ff	 mulss	 xmm0, DWORD PTR _fOOOpaqueWaterDepth$[ebp]
  00890	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00898	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  008a0	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  008a6	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  008ac	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  008b4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  008bb	76 0e		 jbe	 SHORT $LN38@CalculateT
  008bd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  008c2	48		 dec	 eax
  008c3	89 85 2c 84 ff
	ff		 mov	 DWORD PTR tv386[ebp], eax
  008c9	eb 0b		 jmp	 SHORT $LN39@CalculateT
$LN38@CalculateT:
  008cb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  008d0	89 85 2c 84 ff
	ff		 mov	 DWORD PTR tv386[ebp], eax
$LN39@CalculateT:
  008d6	8b 85 2c 84 ff
	ff		 mov	 eax, DWORD PTR tv386[ebp]
  008dc	89 85 3c 84 ff
	ff		 mov	 DWORD PTR _dwAlpha2$5[ebp], eax

; 1057 : 						PR_FLOAT_TO_INT(fWaterTerrainHeightDifference3 * fOOOpaqueWaterDepth * 255.0f, dwAlpha3);

  008e2	f3 0f 10 85 68
	84 ff ff	 movss	 xmm0, DWORD PTR _fWaterTerrainHeightDifference3$7[ebp]
  008ea	f3 0f 59 85 64
	84 ff ff	 mulss	 xmm0, DWORD PTR _fOOOpaqueWaterDepth$[ebp]
  008f2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  008fa	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00902	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00908	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0090e	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00916	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0091d	76 0e		 jbe	 SHORT $LN40@CalculateT
  0091f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00924	48		 dec	 eax
  00925	89 85 28 84 ff
	ff		 mov	 DWORD PTR tv392[ebp], eax
  0092b	eb 0b		 jmp	 SHORT $LN41@CalculateT
$LN40@CalculateT:
  0092d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00932	89 85 28 84 ff
	ff		 mov	 DWORD PTR tv392[ebp], eax
$LN41@CalculateT:
  00938	8b 85 28 84 ff
	ff		 mov	 eax, DWORD PTR tv392[ebp]
  0093e	89 85 20 84 ff
	ff		 mov	 DWORD PTR _dwAlpha3$3[ebp], eax

; 1058 : 
; 1059 : 						DWORD dwAlphaKey=(dwAlpha0<<24)|(dwAlpha1<<16)|(dwAlpha2<<8)|dwAlpha3;

  00944	8b 85 14 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha0$2[ebp]
  0094a	c1 e0 18	 shl	 eax, 24			; 00000018H
  0094d	8b 8d 38 84 ff
	ff		 mov	 ecx, DWORD PTR _dwAlpha1$4[ebp]
  00953	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00956	0b c1		 or	 eax, ecx
  00958	8b 8d 3c 84 ff
	ff		 mov	 ecx, DWORD PTR _dwAlpha2$5[ebp]
  0095e	c1 e1 08	 shl	 ecx, 8
  00961	0b c1		 or	 eax, ecx
  00963	0b 85 20 84 ff
	ff		 or	 eax, DWORD PTR _dwAlpha3$3[ebp]
  00969	89 85 f8 83 ff
	ff		 mov	 DWORD PTR _dwAlphaKey$1[ebp], eax

; 1060 : 						if (dwAlphaKey!=0)

  0096f	0f 84 16 03 00
	00		 je	 $LN28@CalculateT

; 1061 : 						{							
; 1062 : 							assert(lpWaterVertex<akSrcWaterVertex+PATCH_XSIZE * PATCH_YSIZE * 6);
; 1063 : 							lpWaterVertex->x = fX;

  00975	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  0097b	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00983	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1064 : 							lpWaterVertex->y = -fY;

  00987	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  0098f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00996	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  0099c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1065 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  009a1	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  009a9	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009af	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  009b7	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  009bd	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1066 : 							lpWaterVertex->dwDiffuse = ((dwAlpha0 << 24) & 0xFF000000) | 0x000000FF;// 0x000F939B

  009c2	8b 85 14 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha0$2[ebp]
  009c8	c1 e0 18	 shl	 eax, 24			; 00000018H
  009cb	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  009d0	0d ff 00 00 00	 or	 eax, 255		; 000000ffH
  009d5	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  009db	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1067 : 							lpWaterVertex++;

  009de	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  009e4	83 c0 10	 add	 eax, 16			; 00000010H
  009e7	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1068 : 							
; 1069 : 							lpWaterVertex->x = fX;

  009ed	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  009f3	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  009fb	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1070 : 							lpWaterVertex->y = -fY - float(CELLSCALE);

  009ff	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00a07	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00a0e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43480000
  00a16	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00a1c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1071 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  00a21	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  00a29	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a2f	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00a37	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00a3d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1072 : 							lpWaterVertex->dwDiffuse = ((dwAlpha1 << 24) & 0xFF000000) | 0x00FFFFFF;

  00a42	8b 85 38 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha1$4[ebp]
  00a48	c1 e0 18	 shl	 eax, 24			; 00000018H
  00a4b	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00a50	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00a55	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  00a5b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1073 : 							lpWaterVertex++;

  00a5e	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00a64	83 c0 10	 add	 eax, 16			; 00000010H
  00a67	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1074 : 
; 1075 : 							lpWaterVertex->x = fX + float(CELLSCALE);

  00a6d	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00a75	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43480000
  00a7d	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00a83	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1076 : 							lpWaterVertex->y = -fY;

  00a87	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00a8f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00a96	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00a9c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1077 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  00aa1	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  00aa9	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00aaf	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00ab7	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00abd	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1078 : 							lpWaterVertex->dwDiffuse = ((dwAlpha2 << 24) & 0xFF000000) | 0x00FFFFFF;

  00ac2	8b 85 3c 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha2$5[ebp]
  00ac8	c1 e0 18	 shl	 eax, 24			; 00000018H
  00acb	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00ad0	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00ad5	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  00adb	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1079 : 							lpWaterVertex++;

  00ade	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00ae4	83 c0 10	 add	 eax, 16			; 00000010H
  00ae7	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1080 : 
; 1081 : 							lpWaterVertex->x = fX + float(CELLSCALE);

  00aed	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00af5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43480000
  00afd	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b03	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1082 : 							lpWaterVertex->y = -fY;

  00b07	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00b0f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00b16	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b1c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1083 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  00b21	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  00b29	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b2f	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00b37	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b3d	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1084 : 							lpWaterVertex->dwDiffuse = ((dwAlpha2 << 24) & 0xFF000000) | 0x00FFFFFF;

  00b42	8b 85 3c 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha2$5[ebp]
  00b48	c1 e0 18	 shl	 eax, 24			; 00000018H
  00b4b	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00b50	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00b55	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  00b5b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1085 : 							lpWaterVertex++;

  00b5e	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b64	83 c0 10	 add	 eax, 16			; 00000010H
  00b67	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1086 : 
; 1087 : 							lpWaterVertex->x = fX;

  00b6d	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b73	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00b7b	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1088 : 							lpWaterVertex->y = -fY - float(CELLSCALE);

  00b7f	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00b87	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00b8e	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43480000
  00b96	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00b9c	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1089 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  00ba1	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  00ba9	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00baf	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00bb7	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00bbd	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1090 : 							lpWaterVertex->dwDiffuse = ((dwAlpha1 << 24) & 0xFF000000) | 0x00FFFFFF;

  00bc2	8b 85 38 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha1$4[ebp]
  00bc8	c1 e0 18	 shl	 eax, 24			; 00000018H
  00bcb	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00bd0	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00bd5	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  00bdb	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1091 : 							lpWaterVertex++;

  00bde	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00be4	83 c0 10	 add	 eax, 16			; 00000010H
  00be7	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1092 : 
; 1093 : 							lpWaterVertex->x = fX + float(CELLSCALE);

  00bed	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00bf5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43480000
  00bfd	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00c03	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 1094 : 							lpWaterVertex->y = -fY - float(CELLSCALE);

  00c07	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00c0f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00c16	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@43480000
  00c1e	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00c24	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 1095 : 							lpWaterVertex->z = (float)lWaterHeight * m_fHeightScale;

  00c29	f3 0f 2a 85 a4
	84 ff ff	 cvtsi2ss xmm0, DWORD PTR _lWaterHeight$17[ebp]
  00c31	8b 85 c4 84 ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c37	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00c3f	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00c45	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 1096 : 							lpWaterVertex->dwDiffuse = ((dwAlpha3 << 24) & 0xFF0000FF) | 0x00FFFFFF;

  00c4a	8b 85 20 84 ff
	ff		 mov	 eax, DWORD PTR _dwAlpha3$3[ebp]
  00c50	c1 e0 18	 shl	 eax, 24			; 00000018H
  00c53	25 ff 00 00 ff	 and	 eax, -16776961		; ff0000ffH
  00c58	0d ff ff ff 00	 or	 eax, 16777215		; 00ffffffH
  00c5d	8b 8d c8 84 ff
	ff		 mov	 ecx, DWORD PTR _lpWaterVertex$[ebp]
  00c63	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1097 : 							lpWaterVertex++;

  00c66	8b 85 c8 84 ff
	ff		 mov	 eax, DWORD PTR _lpWaterVertex$[ebp]
  00c6c	83 c0 10	 add	 eax, 16			; 00000010H
  00c6f	89 85 c8 84 ff
	ff		 mov	 DWORD PTR _lpWaterVertex$[ebp], eax

; 1098 : 							
; 1099 : 							uWaterVertexCount+=6;

  00c75	8b 85 48 84 ff
	ff		 mov	 eax, DWORD PTR _uWaterVertexCount$[ebp]
  00c7b	83 c0 06	 add	 eax, 6
  00c7e	89 85 48 84 ff
	ff		 mov	 DWORD PTR _uWaterVertexCount$[ebp], eax

; 1100 : 							bWaterExist = true;

  00c84	c6 85 c3 84 ff
	ff 01		 mov	 BYTE PTR _bWaterExist$[ebp], 1
$LN28@CalculateT:

; 1101 : 						}
; 1102 : 					}
; 1103 : 					
; 1104 : 				}
; 1105 : 			}
; 1106 : 			
; 1107 : 			++lpTerrainVertex;

  00c8b	8b 85 60 84 ff
	ff		 mov	 eax, DWORD PTR _lpTerrainVertex$[ebp]
  00c91	83 c0 18	 add	 eax, 24			; 00000018H
  00c94	89 85 60 84 ff
	ff		 mov	 DWORD PTR _lpTerrainVertex$[ebp], eax

; 1108 : 			++uTerrainVertexCount;

  00c9a	8b 85 1c 84 ff
	ff		 mov	 eax, DWORD PTR _uTerrainVertexCount$[ebp]
  00ca0	40		 inc	 eax
  00ca1	89 85 1c 84 ff
	ff		 mov	 DWORD PTR _uTerrainVertexCount$[ebp], eax

; 1109 : 			fX += float(CELLSCALE);

  00ca7	f3 0f 10 85 b8
	84 ff ff	 movss	 xmm0, DWORD PTR _fX$[ebp]
  00caf	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43480000
  00cb7	f3 0f 11 85 b8
	84 ff ff	 movss	 DWORD PTR _fX$[ebp], xmm0

; 1110 : 		}

  00cbf	e9 1f f7 ff ff	 jmp	 $LN5@CalculateT
$LN6@CalculateT:

; 1111 : 		
; 1112 : 		wOrigRawHeightPtr += CTerrainImpl::HEIGHTMAP_RAW_XSIZE;

  00cc4	8b 85 5c 84 ff
	ff		 mov	 eax, DWORD PTR _wOrigRawHeightPtr$[ebp]
  00cca	05 06 01 00 00	 add	 eax, 262		; 00000106H
  00ccf	89 85 5c 84 ff
	ff		 mov	 DWORD PTR _wOrigRawHeightPtr$[ebp], eax

; 1113 : 		chOrigNormalPtr += dwNormalWidth;

  00cd5	8b 85 58 84 ff
	ff		 mov	 eax, DWORD PTR _chOrigNormalPtr$[ebp]
  00cdb	03 85 18 84 ff
	ff		 add	 eax, DWORD PTR _dwNormalWidth$[ebp]
  00ce1	89 85 58 84 ff
	ff		 mov	 DWORD PTR _chOrigNormalPtr$[ebp], eax

; 1114 : 		byOrigWaterPtr  += CTerrainImpl::XSIZE;

  00ce7	8b 85 54 84 ff
	ff		 mov	 eax, DWORD PTR _byOrigWaterPtr$[ebp]
  00ced	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00cf2	89 85 54 84 ff
	ff		 mov	 DWORD PTR _byOrigWaterPtr$[ebp], eax

; 1115 : 		fY += float(CELLSCALE);

  00cf8	f3 0f 10 85 b4
	84 ff ff	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00d00	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@43480000
  00d08	f3 0f 11 85 b4
	84 ff ff	 movss	 DWORD PTR _fY$[ebp], xmm0

; 1116 :     }

  00d10	e9 6a f6 ff ff	 jmp	 $LN2@CalculateT
$LN3@CalculateT:

; 1117 : 	
; 1118 : 	if (wNumPlainType <= max(wNumHillType, wNumCliffType))

  00d15	0f b7 85 a8 84
	ff ff		 movzx	 eax, WORD PTR _wNumHillType$[ebp]
  00d1c	0f b7 8d ac 84
	ff ff		 movzx	 ecx, WORD PTR _wNumCliffType$[ebp]
  00d23	3b c1		 cmp	 eax, ecx
  00d25	7e 10		 jle	 SHORT $LN42@CalculateT
  00d27	66 8b 85 a8 84
	ff ff		 mov	 ax, WORD PTR _wNumHillType$[ebp]
  00d2e	66 89 85 7a 84
	ff ff		 mov	 WORD PTR tv514[ebp], ax
  00d35	eb 0e		 jmp	 SHORT $LN43@CalculateT
$LN42@CalculateT:
  00d37	66 8b 85 ac 84
	ff ff		 mov	 ax, WORD PTR _wNumCliffType$[ebp]
  00d3e	66 89 85 7a 84
	ff ff		 mov	 WORD PTR tv514[ebp], ax
$LN43@CalculateT:
  00d45	0f b7 85 94 84
	ff ff		 movzx	 eax, WORD PTR _wNumPlainType$[ebp]
  00d4c	0f b7 8d 7a 84
	ff ff		 movzx	 ecx, WORD PTR tv514[ebp]
  00d53	3b c1		 cmp	 eax, ecx
  00d55	7f 28		 jg	 SHORT $LN72@CalculateT

; 1119 : 	{
; 1120 : 		if (wNumCliffType <= wNumHillType)

  00d57	0f b7 85 ac 84
	ff ff		 movzx	 eax, WORD PTR _wNumCliffType$[ebp]
  00d5e	0f b7 8d a8 84
	ff ff		 movzx	 ecx, WORD PTR _wNumHillType$[ebp]
  00d65	3b c1		 cmp	 eax, ecx
  00d67	7f 0c		 jg	 SHORT $LN30@CalculateT
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 90   : 	void SetType(BYTE byType)								{ m_byType = byType; }

  00d69	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00d6f	c6 40 44 01	 mov	 BYTE PTR [eax+68], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 1121 : 			rkTerrainPatch.SetType(CTerrainPatch::PATCH_TYPE_HILL);

  00d73	eb 0a		 jmp	 SHORT $LN72@CalculateT
$LN30@CalculateT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 90   : 	void SetType(BYTE byType)								{ m_byType = byType; }

  00d75	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00d7b	c6 40 44 02	 mov	 BYTE PTR [eax+68], 2
$LN72@CalculateT:

; 85   : 	void SetWaterExist(bool bWaterExist)					{ m_bWaterExist = bWaterExist; }

  00d7f	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00d85	8a 8d c3 84 ff
	ff		 mov	 cl, BYTE PTR _bWaterExist$[ebp]
  00d8b	88 48 19	 mov	 BYTE PTR [eax+25], cl

; 75   : 	void SetMinZ(float fMinZ)								{ m_fMinZ = fMinZ; }

  00d8e	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00d94	f3 0f 10 85 50
	84 ff ff	 movss	 xmm0, DWORD PTR _fMinZ$[ebp]
  00d9c	f3 0f 11 40 10	 movss	 DWORD PTR [eax+16], xmm0

; 78   : 	void SetMaxZ(float fMaxZ)								{ m_fMaxZ = fMaxZ; }

  00da1	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00da7	f3 0f 10 85 4c
	84 ff ff	 movss	 xmm0, DWORD PTR _fMaxZ$[ebp]
  00daf	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 1132 : 	rkTerrainPatch.BuildTerrainVertexBuffer(akSrcTerrainVertex);

  00db4	8d 85 e4 84 ff
	ff		 lea	 eax, DWORD PTR _akSrcTerrainVertex$[ebp]
  00dba	50		 push	 eax
  00dbb	8b 8d bc 84 ff
	ff		 mov	 ecx, DWORD PTR _rkTerrainPatch$[ebp]
  00dc1	e8 00 00 00 00	 call	 ?BuildTerrainVertexBuffer@CTerrainPatch@@QAEXPAUHardwareTransformPatch_SSourceVertex@@@Z ; CTerrainPatch::BuildTerrainVertexBuffer

; 1133 : 	
; 1134 : 	if (bWaterExist)

  00dc6	0f b6 85 c3 84
	ff ff		 movzx	 eax, BYTE PTR _bWaterExist$[ebp]
  00dcd	85 c0		 test	 eax, eax
  00dcf	74 18		 je	 SHORT $LN32@CalculateT

; 1135 : 		rkTerrainPatch.BuildWaterVertexBuffer(akSrcWaterVertex, uWaterVertexCount);

  00dd1	ff b5 48 84 ff
	ff		 push	 DWORD PTR _uWaterVertexCount$[ebp]
  00dd7	8d 85 fc 9f ff
	ff		 lea	 eax, DWORD PTR _akSrcWaterVertex$[ebp]
  00ddd	50		 push	 eax
  00dde	8b 8d bc 84 ff
	ff		 mov	 ecx, DWORD PTR _rkTerrainPatch$[ebp]
  00de4	e8 00 00 00 00	 call	 ?BuildWaterVertexBuffer@CTerrainPatch@@QAEXPAUSWaterVertex@@I@Z ; CTerrainPatch::BuildWaterVertexBuffer
$LN32@CalculateT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 93   : 	void NeedUpdate(bool bNeedUpdate)						{ m_bNeedUpdate = bNeedUpdate;}

  00de9	8b 85 bc 84 ff
	ff		 mov	 eax, DWORD PTR _rkTerrainPatch$[ebp]
  00def	c6 40 45 00	 mov	 BYTE PTR [eax+69], 0
$LN1@CalculateT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 1138 : }

  00df3	5f		 pop	 edi
  00df4	5e		 pop	 esi
  00df5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00df8	33 cd		 xor	 ecx, ebp
  00dfa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00dff	c9		 leave
  00e00	c2 08 00	 ret	 8
?_CalculateTerrainPatch@CTerrain@@IAEXEE@Z ENDP		; CTerrain::_CalculateTerrainPatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_byPatchNumX$ = 8					; size = 1
_byPatchNumY$ = 12					; size = 1
?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z PROC ; CTerrain::GetTerrainPatchPtr, COMDAT
; _this$ = ecx

; 920  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 921  : 	if (byPatchNumX < 0 || byPatchNumX >= PATCH_XCOUNT || byPatchNumY < 0 || byPatchNumY >= PATCH_YCOUNT)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _byPatchNumX$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	7c 1a		 jl	 SHORT $LN3@GetTerrain
  0000f	0f b6 45 08	 movzx	 eax, BYTE PTR _byPatchNumX$[ebp]
  00013	83 f8 08	 cmp	 eax, 8
  00016	7d 11		 jge	 SHORT $LN3@GetTerrain
  00018	0f b6 45 0c	 movzx	 eax, BYTE PTR _byPatchNumY$[ebp]
  0001c	85 c0		 test	 eax, eax
  0001e	7c 09		 jl	 SHORT $LN3@GetTerrain
  00020	0f b6 45 0c	 movzx	 eax, BYTE PTR _byPatchNumY$[ebp]
  00024	83 f8 08	 cmp	 eax, 8
  00027	7c 04		 jl	 SHORT $LN2@GetTerrain
$LN3@GetTerrain:

; 922  : 		return NULL;

  00029	33 c0		 xor	 eax, eax
  0002b	eb 18		 jmp	 SHORT $LN1@GetTerrain
$LN2@GetTerrain:

; 923  : 
; 924  : 	return &m_TerrainPatchList[byPatchNumY * PATCH_XCOUNT + byPatchNumX];

  0002d	0f b6 45 0c	 movzx	 eax, BYTE PTR _byPatchNumY$[ebp]
  00031	0f b6 4d 08	 movzx	 ecx, BYTE PTR _byPatchNumX$[ebp]
  00035	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00038	6b c0 70	 imul	 eax, eax, 112
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8d 84 01 d8 a5
	06 00		 lea	 eax, DWORD PTR [ecx+eax+435672]
$LN1@GetTerrain:

; 925  : }

  00045	c9		 leave
  00046	c2 08 00	 ret	 8
?GetTerrainPatchPtr@CTerrain@@QAEPAVCTerrainPatch@@EE@Z ENDP ; CTerrain::GetTerrainPatchPtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@K@std@@@std@@YAXPAKQAKAAV?$allocator@K@0@@Z ; std::_Destroy_range<std::allocator<unsigned long> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?CalculateNormal@CTerrain@@IAEXJJ@Z
_TEXT	SEGMENT
_iz$ = -72						; size = 4
_iy$ = -68						; size = 4
_ix$ = -64						; size = 4
tv330 = -60						; size = 4
tv329 = -56						; size = 4
__X$ = -52						; size = 4
tv207 = -48						; size = 4
tv198 = -44						; size = 4
tv189 = -40						; size = 4
_f$ = -36						; size = 4
$T1 = -32						; size = 2
$T2 = -30						; size = 2
$T3 = -28						; size = 2
$T4 = -26						; size = 2
_this$ = -24						; size = 4
_n$ = -20						; size = 4
_normal$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?CalculateNormal@CTerrain@@IAEXJJ@Z PROC		; CTerrain::CalculateNormal, COMDAT
; _this$ = ecx

; 440  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00013	0f bf 45 0c	 movsx	 eax, WORD PTR _y$[ebp]
  00017	40		 inc	 eax
  00018	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 443  : 	normal.x = -m_fHeightScale * ((float)GetHeightMapValue((x-1),y)-(float)GetHeightMapValue((x+1),y));

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00021	49		 dec	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00022	0f bf c9	 movsx	 ecx, cx
  00025	03 c1		 add	 eax, ecx
  00027	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00032	66 89 45 e6	 mov	 WORD PTR $T4[ebp], ax
  00036	0f bf 45 0c	 movsx	 eax, WORD PTR _y$[ebp]
  0003a	40		 inc	 eax
  0003b	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 443  : 	normal.x = -m_fHeightScale * ((float)GetHeightMapValue((x-1),y)-(float)GetHeightMapValue((x+1),y));

  00041	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00044	41		 inc	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00045	0f bf c9	 movsx	 ecx, cx
  00048	03 c1		 add	 eax, ecx
  0004a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00055	66 89 45 e4	 mov	 WORD PTR $T3[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 443  : 	normal.x = -m_fHeightScale * ((float)GetHeightMapValue((x-1),y)-(float)GetHeightMapValue((x+1),y));

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	f3 0f 10 80 38
	91 03 00	 movss	 xmm0, DWORD PTR [eax+233784]
  00064	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0006b	0f b7 45 e6	 movzx	 eax, WORD PTR $T4[ebp]
  0006f	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  00073	0f b7 45 e4	 movzx	 eax, WORD PTR $T3[ebp]
  00077	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  0007b	f3 0f 5c ca	 subss	 xmm1, xmm2
  0007f	f3 0f 59 c1	 mulss	 xmm0, xmm1
  00083	f3 0f 11 45 f0	 movss	 DWORD PTR _normal$[ebp], xmm0

; 444  : 	normal.y = -m_fHeightScale * ((float)GetHeightMapValue(x,(y-1))-(float)GetHeightMapValue(x,(y+1)));

  00088	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0008b	48		 dec	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0008c	98		 cwde
  0008d	40		 inc	 eax
  0008e	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00094	0f bf 4d 08	 movsx	 ecx, WORD PTR _x$[ebp]
  00098	03 c1		 add	 eax, ecx
  0009a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  000a5	66 89 45 e2	 mov	 WORD PTR $T2[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 444  : 	normal.y = -m_fHeightScale * ((float)GetHeightMapValue(x,(y-1))-(float)GetHeightMapValue(x,(y+1)));

  000a9	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000ac	40		 inc	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  000ad	98		 cwde
  000ae	40		 inc	 eax
  000af	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  000b5	0f bf 4d 08	 movsx	 ecx, WORD PTR _x$[ebp]
  000b9	03 c1		 add	 eax, ecx
  000bb	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  000c6	66 89 45 e0	 mov	 WORD PTR $T1[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 444  : 	normal.y = -m_fHeightScale * ((float)GetHeightMapValue(x,(y-1))-(float)GetHeightMapValue(x,(y+1)));

  000ca	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	f3 0f 10 80 38
	91 03 00	 movss	 xmm0, DWORD PTR [eax+233784]
  000d5	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000dc	0f b7 45 e2	 movzx	 eax, WORD PTR $T2[ebp]
  000e0	f3 0f 2a c8	 cvtsi2ss xmm1, eax
  000e4	0f b7 45 e0	 movzx	 eax, WORD PTR $T1[ebp]
  000e8	f3 0f 2a d0	 cvtsi2ss xmm2, eax
  000ec	f3 0f 5c ca	 subss	 xmm1, xmm2
  000f0	f3 0f 59 c1	 mulss	 xmm0, xmm1
  000f4	f3 0f 11 45 f4	 movss	 DWORD PTR _normal$[ebp+4], xmm0

; 445  : 
; 446  : 	normal.z = 2.0f * CELLSCALE;

  000f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43c80000
  00101	f3 0f 11 45 f8	 movss	 DWORD PTR _normal$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00106	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _normal$[ebp+8]
  0010b	f3 0f 59 45 f8	 mulss	 xmm0, DWORD PTR _normal$[ebp+8]
  00110	f3 0f 10 4d f4	 movss	 xmm1, DWORD PTR _normal$[ebp+4]
  00115	f3 0f 59 4d f4	 mulss	 xmm1, DWORD PTR _normal$[ebp+4]
  0011a	f3 0f 10 55 f0	 movss	 xmm2, DWORD PTR _normal$[ebp]
  0011f	f3 0f 59 55 f0	 mulss	 xmm2, DWORD PTR _normal$[ebp]
  00124	f3 0f 58 d1	 addss	 xmm2, xmm1
  00128	f3 0f 58 d0	 addss	 xmm2, xmm0
  0012c	f3 0f 11 55 cc	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00131	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00136	51		 push	 ecx
  00137	51		 push	 ecx
  00138	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0013d	e8 00 00 00 00	 call	 _sqrt
  00142	59		 pop	 ecx
  00143	59		 pop	 ecx
  00144	d9 5d c8	 fstp	 DWORD PTR tv329[ebp]
  00147	d9 45 c8	 fld	 DWORD PTR tv329[ebp]
  0014a	d9 5d c4	 fstp	 DWORD PTR tv330[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 447  : 	normal *= 127.0f / D3DXVec3Length(&normal);

  0014d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42fe0000
  00155	f3 0f 5e 45 c4	 divss	 xmm0, DWORD PTR tv330[ebp]
  0015a	f3 0f 11 45 dc	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 222  :     x *= f;

  0015f	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _normal$[ebp]
  00164	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00169	f3 0f 11 45 f0	 movss	 DWORD PTR _normal$[ebp], xmm0

; 223  :     y *= f;

  0016e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _normal$[ebp+4]
  00173	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00178	f3 0f 11 45 f4	 movss	 DWORD PTR _normal$[ebp+4], xmm0

; 224  :     z *= f;

  0017d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _normal$[ebp+8]
  00182	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00187	f3 0f 11 45 f8	 movss	 DWORD PTR _normal$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 450  : 	PR_FLOAT_TO_INT(normal.x, ix);

  0018c	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _normal$[ebp]
  00191	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00199	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0019f	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  001a5	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001ad	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  001b4	76 0b		 jbe	 SHORT $LN3@CalculateN
  001b6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001bb	48		 dec	 eax
  001bc	89 45 d8	 mov	 DWORD PTR tv189[ebp], eax
  001bf	eb 08		 jmp	 SHORT $LN4@CalculateN
$LN3@CalculateN:
  001c1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001c6	89 45 d8	 mov	 DWORD PTR tv189[ebp], eax
$LN4@CalculateN:
  001c9	8b 45 d8	 mov	 eax, DWORD PTR tv189[ebp]
  001cc	89 45 c0	 mov	 DWORD PTR _ix$[ebp], eax

; 451  : 	PR_FLOAT_TO_INT(normal.y, iy);

  001cf	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _normal$[ebp+4]
  001d4	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  001dc	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  001e2	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  001e8	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001f0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  001f7	76 0b		 jbe	 SHORT $LN5@CalculateN
  001f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001fe	48		 dec	 eax
  001ff	89 45 d4	 mov	 DWORD PTR tv198[ebp], eax
  00202	eb 08		 jmp	 SHORT $LN6@CalculateN
$LN5@CalculateN:
  00204	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00209	89 45 d4	 mov	 DWORD PTR tv198[ebp], eax
$LN6@CalculateN:
  0020c	8b 45 d4	 mov	 eax, DWORD PTR tv198[ebp]
  0020f	89 45 bc	 mov	 DWORD PTR _iy$[ebp], eax

; 452  : 	PR_FLOAT_TO_INT(normal.z, iz);

  00212	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _normal$[ebp+8]
  00217	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  0021f	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00225	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0022b	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00233	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0023a	76 0b		 jbe	 SHORT $LN7@CalculateN
  0023c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00241	48		 dec	 eax
  00242	89 45 d0	 mov	 DWORD PTR tv207[ebp], eax
  00245	eb 08		 jmp	 SHORT $LN8@CalculateN
$LN7@CalculateN:
  00247	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0024c	89 45 d0	 mov	 DWORD PTR tv207[ebp], eax
$LN8@CalculateN:
  0024f	8b 45 d0	 mov	 eax, DWORD PTR tv207[ebp]
  00252	89 45 b8	 mov	 DWORD PTR _iz$[ebp], eax

; 453  : 	
; 454  : 	char * n = (char*) &m_acNormalMap[(y * NORMALMAP_XSIZE + x)*3];

  00255	69 45 0c 81 00
	00 00		 imul	 eax, DWORD PTR _y$[ebp], 129
  0025c	03 45 08	 add	 eax, DWORD PTR _x$[ebp]
  0025f	6b c0 03	 imul	 eax, eax, 3
  00262	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00265	8d 84 01 1a ce
	02 00		 lea	 eax, DWORD PTR [ecx+eax+183834]
  0026c	89 45 ec	 mov	 DWORD PTR _n$[ebp], eax

; 455  : 	
; 456  : 	*n++ = (char) ix;

  0026f	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  00272	8a 4d c0	 mov	 cl, BYTE PTR _ix$[ebp]
  00275	88 08		 mov	 BYTE PTR [eax], cl
  00277	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  0027a	40		 inc	 eax
  0027b	89 45 ec	 mov	 DWORD PTR _n$[ebp], eax

; 457  : 	*n++ = (char) iy;

  0027e	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  00281	8a 4d bc	 mov	 cl, BYTE PTR _iy$[ebp]
  00284	88 08		 mov	 BYTE PTR [eax], cl
  00286	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  00289	40		 inc	 eax
  0028a	89 45 ec	 mov	 DWORD PTR _n$[ebp], eax

; 458  : 	*n++ = (char) iz;

  0028d	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  00290	8a 4d b8	 mov	 cl, BYTE PTR _iz$[ebp]
  00293	88 08		 mov	 BYTE PTR [eax], cl
  00295	8b 45 ec	 mov	 eax, DWORD PTR _n$[ebp]
  00298	40		 inc	 eax
  00299	89 45 ec	 mov	 DWORD PTR _n$[ebp], eax

; 459  : }

  0029c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0029f	33 cd		 xor	 ecx, ebp
  002a1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a6	c9		 leave
  002a7	c2 08 00	 ret	 8
?CalculateNormal@CTerrain@@IAEXJJ@Z ENDP		; CTerrain::CalculateNormal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_y$1 = -12						; size = 4
_x$2 = -8						; size = 4
_packed_pixel$3 = -4					; size = 2
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_src_pitch$ = 16					; size = 4
_dst_pitch$ = 20					; size = 4
_texturewidth$ = 24					; size = 4
_textureheight$ = 28					; size = 4
_bResize$ = 32						; size = 1
?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z PROC		; CTerrain::PutImage16, COMDAT
; _this$ = ecx

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 891  : 	for (int y = 0; y < textureheight; ++y)

  00009	83 65 f4 00	 and	 DWORD PTR _y$1[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@PutImage16
$LN2@PutImage16:
  0000f	8b 45 f4	 mov	 eax, DWORD PTR _y$1[ebp]
  00012	40		 inc	 eax
  00013	89 45 f4	 mov	 DWORD PTR _y$1[ebp], eax
$LN4@PutImage16:
  00016	8b 45 f4	 mov	 eax, DWORD PTR _y$1[ebp]
  00019	3b 45 1c	 cmp	 eax, DWORD PTR _textureheight$[ebp]
  0001c	7d 49		 jge	 SHORT $LN1@PutImage16

; 892  :     {
; 893  : 		for (int x = 0; x < texturewidth; ++x)

  0001e	83 65 f8 00	 and	 DWORD PTR _x$2[ebp], 0
  00022	eb 07		 jmp	 SHORT $LN7@PutImage16
$LN5@PutImage16:
  00024	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  00027	40		 inc	 eax
  00028	89 45 f8	 mov	 DWORD PTR _x$2[ebp], eax
$LN7@PutImage16:
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  0002e	3b 45 18	 cmp	 eax, DWORD PTR _texturewidth$[ebp]
  00031	7d 20		 jge	 SHORT $LN6@PutImage16

; 894  : 		{
; 895  : 			WORD packed_pixel = src[x] << 8;

  00033	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00036	03 45 f8	 add	 eax, DWORD PTR _x$2[ebp]
  00039	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0003c	c1 e0 08	 shl	 eax, 8
  0003f	66 89 45 fc	 mov	 WORD PTR _packed_pixel$3[ebp], ax

; 896  : 			//&   
; 897  : 			//WORD packed_pixel = (src[x]&0xF0) << 8;
; 898  : 			*((WORD*)(dst+x*2)) = packed_pixel;

  00043	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  00049	66 8b 55 fc	 mov	 dx, WORD PTR _packed_pixel$3[ebp]
  0004d	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 899  : 		}

  00051	eb d1		 jmp	 SHORT $LN5@PutImage16
$LN6@PutImage16:

; 900  : 
; 901  : 		dst += dst_pitch;

  00053	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  00056	03 45 14	 add	 eax, DWORD PTR _dst_pitch$[ebp]
  00059	89 45 0c	 mov	 DWORD PTR _dst$[ebp], eax

; 902  : 		src += src_pitch;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0005f	03 45 10	 add	 eax, DWORD PTR _src_pitch$[ebp]
  00062	89 45 08	 mov	 DWORD PTR _src$[ebp], eax

; 903  :     }

  00065	eb a8		 jmp	 SHORT $LN2@PutImage16
$LN1@PutImage16:

; 904  : }

  00067	c9		 leave
  00068	c2 1c 00	 ret	 28			; 0000001cH
?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z ENDP		; CTerrain::PutImage16
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_packed_pixel$1 = -12					; size = 4
_y$2 = -8						; size = 4
_x$3 = -4						; size = 4
_src$ = 8						; size = 4
_dst$ = 12						; size = 4
_src_pitch$ = 16					; size = 4
_dst_pitch$ = 20					; size = 4
_texturewidth$ = 24					; size = 4
_textureheight$ = 28					; size = 4
_bResize$ = 32						; size = 1
?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z PROC		; CTerrain::PutImage32, COMDAT
; _this$ = ecx

; 874  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 875  : 	for (int y = 0; y < textureheight; ++y)

  00009	83 65 f8 00	 and	 DWORD PTR _y$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@PutImage32
$LN2@PutImage32:
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _y$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 f8	 mov	 DWORD PTR _y$2[ebp], eax
$LN4@PutImage32:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _y$2[ebp]
  00019	3b 45 1c	 cmp	 eax, DWORD PTR _textureheight$[ebp]
  0001c	7d 46		 jge	 SHORT $LN1@PutImage32

; 876  :     {
; 877  : 		for (int x = 0; x < texturewidth; ++x)

  0001e	83 65 fc 00	 and	 DWORD PTR _x$3[ebp], 0
  00022	eb 07		 jmp	 SHORT $LN7@PutImage32
$LN5@PutImage32:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _x$3[ebp]
  00027	40		 inc	 eax
  00028	89 45 fc	 mov	 DWORD PTR _x$3[ebp], eax
$LN7@PutImage32:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _x$3[ebp]
  0002e	3b 45 18	 cmp	 eax, DWORD PTR _texturewidth$[ebp]
  00031	7d 1d		 jge	 SHORT $LN6@PutImage32

; 878  : 		{
; 879  : 			DWORD packed_pixel = src[x] << 24;

  00033	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  00036	03 45 fc	 add	 eax, DWORD PTR _x$3[ebp]
  00039	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0003c	c1 e0 18	 shl	 eax, 24			; 00000018H
  0003f	89 45 f4	 mov	 DWORD PTR _packed_pixel$1[ebp], eax

; 880  : 			*((DWORD*)(dst+x*4)) = packed_pixel;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _x$3[ebp]
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR _dst$[ebp]
  00048	8b 55 f4	 mov	 edx, DWORD PTR _packed_pixel$1[ebp]
  0004b	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 881  : 
; 882  : 		}

  0004e	eb d4		 jmp	 SHORT $LN5@PutImage32
$LN6@PutImage32:

; 883  : 
; 884  : 		dst += dst_pitch;

  00050	8b 45 0c	 mov	 eax, DWORD PTR _dst$[ebp]
  00053	03 45 14	 add	 eax, DWORD PTR _dst_pitch$[ebp]
  00056	89 45 0c	 mov	 DWORD PTR _dst$[ebp], eax

; 885  : 		src += src_pitch;

  00059	8b 45 08	 mov	 eax, DWORD PTR _src$[ebp]
  0005c	03 45 10	 add	 eax, DWORD PTR _src_pitch$[ebp]
  0005f	89 45 08	 mov	 DWORD PTR _src$[ebp], eax

; 886  :     }

  00062	eb ab		 jmp	 SHORT $LN2@PutImage32
$LN1@PutImage32:

; 887  : }

  00064	c9		 leave
  00065	c2 1c 00	 ret	 28			; 0000001cH
?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z ENDP		; CTerrain::PutImage32
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?AddTexture32@CTerrain@@IAEPAUIDirect3DTexture8@@EPAEJJ@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
__Tmp$2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
_uiNewWidth$ = -112					; size = 4
_uiNewHeight$ = -108					; size = 4
_d3dlr$5 = -104						; size = 8
_d3dlr$6 = -96						; size = 8
_format$ = -88						; size = 4
_pbSrcBuffer$ = -84					; size = 4
_pbDstPixel$7 = -80					; size = 4
_abCurLine$8 = -76					; size = 4
_y$9 = -72						; size = 4
_pbDstPixel$10 = -68					; size = 4
_abCurLine$11 = -64					; size = 4
_y$12 = -60						; size = 4
_bResizedAndSuccess$ = -56				; size = 1
_pbSrcPixel$13 = -52					; size = 4
_x$14 = -48						; size = 4
_x$15 = -44						; size = 4
_pbDstBuffer$ = -40					; size = 4
_uMipMapLevel$16 = -36					; size = 4
_hr$ = -32						; size = 4
_uSrcSize$ = -28					; size = 4
_uDstSize$17 = -24					; size = 4
_this$ = -20						; size = 4
_pbSrcPixel$18 = -16					; size = 4
_pkTex$ = -12						; size = 4
_abResizeImage$ = -8					; size = 65536
_abResizeImage2$ = 65528				; size = 16384
__$ArrayPad$ = 81912					; size = 4
_byImageNum$ = 81924					; size = 1
_pbyImage$ = 81928					; size = 4
_lTextureWidth$ = 81932					; size = 4
_lTextureHeight$ = 81936				; size = 4
?AddTexture32@CTerrain@@IAEPAUIDirect3DTexture8@@EPAEJJ@Z PROC ; CTerrain::AddTexture32, COMDAT
; _this$ = ecx

; 761  : {

  00000	55		 push	 ebp
  00001	8d ac 24 04 c0
	fe ff		 lea	 ebp, DWORD PTR [esp-81916]
  00008	b8 7c 40 01 00	 mov	 eax, 82044		; 0001407cH
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 f8 3f 01
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 762  : 	assert(NULL==m_lpAlphaTexture[byImageNum]);
; 763  : 
; 764  : 	if (m_lpAlphaTexture[byImageNum])

  00022	0f b6 85 04 40
	01 00		 movzx	 eax, BYTE PTR _byImageNum$[ebp]
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 7c 81 04 00	 cmp	 DWORD PTR [ecx+eax*4+4], 0
  00031	74 21		 je	 SHORT $LN17@AddTexture

; 765  : 		m_lpAlphaTexture[byImageNum]->Release();

  00033	0f b6 85 04 40
	01 00		 movzx	 eax, BYTE PTR _byImageNum$[ebp]
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00041	0f b6 8d 04 40
	01 00		 movzx	 ecx, BYTE PTR _byImageNum$[ebp]
  00048	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	ff 74 8a 04	 push	 DWORD PTR [edx+ecx*4+4]
  00051	ff 50 08	 call	 DWORD PTR [eax+8]
$LN17@AddTexture:

; 766  : 
; 767  : 	m_lpAlphaTexture[byImageNum]=NULL;

  00054	0f b6 85 04 40
	01 00		 movzx	 eax, BYTE PTR _byImageNum$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 64 81 04 00	 and	 DWORD PTR [ecx+eax*4+4], 0

; 768  : 
; 769  : 	HRESULT hr;
; 770  : 	D3DFORMAT format;
; 771  : 
; 772  : 	if(ms_bSupportDXT)

  00063	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA ; CGraphicBase::ms_bSupportDXT
  0006a	85 c0		 test	 eax, eax
  0006c	74 09		 je	 SHORT $LN18@AddTexture

; 773  : 		format = D3DFMT_A8R8G8B8;

  0006e	c7 45 a8 15 00
	00 00		 mov	 DWORD PTR _format$[ebp], 21 ; 00000015H
  00075	eb 07		 jmp	 SHORT $LN19@AddTexture
$LN18@AddTexture:

; 774  : 	else
; 775  : 		format = D3DFMT_A4R4G4B4;

  00077	c7 45 a8 1a 00
	00 00		 mov	 DWORD PTR _format$[ebp], 26 ; 0000001aH
$LN19@AddTexture:

; 776  : 
; 777  : 
; 778  : 	bool bResizedAndSuccess = false;

  0007e	c6 45 c8 00	 mov	 BYTE PTR _bResizedAndSuccess$[ebp], 0

; 779  : 
; 780  : 	IDirect3DTexture8* pkTex=NULL;

  00082	83 65 f4 00	 and	 DWORD PTR _pkTex$[ebp], 0

; 781  : 
; 782  : 	UINT uiNewWidth = 256;

  00086	c7 45 90 00 01
	00 00		 mov	 DWORD PTR _uiNewWidth$[ebp], 256 ; 00000100H

; 783  : 	UINT uiNewHeight = 256;

  0008d	c7 45 94 00 01
	00 00		 mov	 DWORD PTR _uiNewHeight$[ebp], 256 ; 00000100H

; 784  : 	hr = ms_lpd3dDevice->CreateTexture(

  00094	8d 45 f4	 lea	 eax, DWORD PTR _pkTex$[ebp]
  00097	50		 push	 eax
  00098	6a 01		 push	 1
  0009a	ff 75 a8	 push	 DWORD PTR _format$[ebp]
  0009d	6a 00		 push	 0
  0009f	6a 05		 push	 5
  000a1	ff 75 94	 push	 DWORD PTR _uiNewHeight$[ebp]
  000a4	ff 75 90	 push	 DWORD PTR _uiNewWidth$[ebp]
  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  000ac	8b 00		 mov	 eax, DWORD PTR [eax]
  000ae	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  000b4	ff 50 50	 call	 DWORD PTR [eax+80]
  000b7	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 785  : 		uiNewWidth, uiNewHeight, 5, 0, 
; 786  : 		format, D3DPOOL_MANAGED, &pkTex);
; 787  : 	if (FAILED(hr))

  000ba	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000be	7d 12		 jge	 SHORT $LN20@AddTexture

; 788  : 	{
; 789  : 		TraceError("CTerrain::AddTexture32 - CreateTexture Error");

  000c0	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@NONLPBAM@CTerrain?3?3AddTexture32?5?9?5Create@
  000c5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000ca	59		 pop	 ecx

; 790  : 		return NULL;

  000cb	33 c0		 xor	 eax, eax
  000cd	e9 37 03 00 00	 jmp	 $LN1@AddTexture
$LN20@AddTexture:

; 791  : 	}
; 792  : 	
; 793  : 
; 794  : 	BYTE abResizeImage[256*256];
; 795  : 	{
; 796  : 		BYTE* pbDstPixel=abResizeImage;

  000d2	8d 45 f8	 lea	 eax, DWORD PTR _abResizeImage$[ebp]
  000d5	89 45 bc	 mov	 DWORD PTR _pbDstPixel$10[ebp], eax

; 797  : 		BYTE* pbSrcPixel;
; 798  : 		BYTE* abCurLine=pbyImage;

  000d8	8b 85 08 40 01
	00		 mov	 eax, DWORD PTR _pbyImage$[ebp]
  000de	89 45 c0	 mov	 DWORD PTR _abCurLine$11[ebp], eax

; 799  : 		for (UINT y=0; y<256; ++y, abCurLine+=258)

  000e1	83 65 c4 00	 and	 DWORD PTR _y$12[ebp], 0
  000e5	eb 12		 jmp	 SHORT $LN4@AddTexture
$LN2@AddTexture:
  000e7	8b 45 c4	 mov	 eax, DWORD PTR _y$12[ebp]
  000ea	40		 inc	 eax
  000eb	89 45 c4	 mov	 DWORD PTR _y$12[ebp], eax
  000ee	8b 45 c0	 mov	 eax, DWORD PTR _abCurLine$11[ebp]
  000f1	05 02 01 00 00	 add	 eax, 258		; 00000102H
  000f6	89 45 c0	 mov	 DWORD PTR _abCurLine$11[ebp], eax
$LN4@AddTexture:
  000f9	81 7d c4 00 01
	00 00		 cmp	 DWORD PTR _y$12[ebp], 256 ; 00000100H
  00100	0f 83 d4 00 00
	00		 jae	 $LN3@AddTexture

; 800  : 		{
; 801  : 			for (UINT x=0; x<256; ++x)

  00106	83 65 d4 00	 and	 DWORD PTR _x$15[ebp], 0
  0010a	eb 07		 jmp	 SHORT $LN7@AddTexture
$LN5@AddTexture:
  0010c	8b 45 d4	 mov	 eax, DWORD PTR _x$15[ebp]
  0010f	40		 inc	 eax
  00110	89 45 d4	 mov	 DWORD PTR _x$15[ebp], eax
$LN7@AddTexture:
  00113	81 7d d4 00 01
	00 00		 cmp	 DWORD PTR _x$15[ebp], 256 ; 00000100H
  0011a	0f 83 b5 00 00
	00		 jae	 $LN6@AddTexture

; 802  : 			{
; 803  : 				pbSrcPixel=abCurLine+x;

  00120	8b 45 c0	 mov	 eax, DWORD PTR _abCurLine$11[ebp]
  00123	03 45 d4	 add	 eax, DWORD PTR _x$15[ebp]
  00126	89 45 f0	 mov	 DWORD PTR _pbSrcPixel$18[ebp], eax

; 804  : 				*pbDstPixel++=

  00129	33 c0		 xor	 eax, eax
  0012b	40		 inc	 eax
  0012c	6b c0 00	 imul	 eax, eax, 0
  0012f	8b 4d f0	 mov	 ecx, DWORD PTR _pbSrcPixel$18[ebp]
  00132	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00136	33 c9		 xor	 ecx, ecx
  00138	41		 inc	 ecx
  00139	c1 e1 00	 shl	 ecx, 0
  0013c	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  0013f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00143	03 c1		 add	 eax, ecx
  00145	33 c9		 xor	 ecx, ecx
  00147	41		 inc	 ecx
  00148	d1 e1		 shl	 ecx, 1
  0014a	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  0014d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00151	03 c1		 add	 eax, ecx
  00153	33 c9		 xor	 ecx, ecx
  00155	41		 inc	 ecx
  00156	69 c9 02 01 00
	00		 imul	 ecx, ecx, 258
  0015c	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  0015f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00163	03 c1		 add	 eax, ecx
  00165	33 c9		 xor	 ecx, ecx
  00167	41		 inc	 ecx
  00168	69 c9 04 01 00
	00		 imul	 ecx, ecx, 260
  0016e	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  00171	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00175	03 c1		 add	 eax, ecx
  00177	33 c9		 xor	 ecx, ecx
  00179	41		 inc	 ecx
  0017a	69 c9 04 02 00
	00		 imul	 ecx, ecx, 516
  00180	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  00183	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00187	03 c1		 add	 eax, ecx
  00189	33 c9		 xor	 ecx, ecx
  0018b	41		 inc	 ecx
  0018c	69 c9 05 02 00
	00		 imul	 ecx, ecx, 517
  00192	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  00195	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00199	03 c1		 add	 eax, ecx
  0019b	33 c9		 xor	 ecx, ecx
  0019d	41		 inc	 ecx
  0019e	69 c9 06 02 00
	00		 imul	 ecx, ecx, 518
  001a4	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  001a7	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  001ab	03 c1		 add	 eax, ecx
  001ad	c1 f8 03	 sar	 eax, 3
  001b0	33 c9		 xor	 ecx, ecx
  001b2	41		 inc	 ecx
  001b3	69 c9 03 01 00
	00		 imul	 ecx, ecx, 259
  001b9	8b 55 f0	 mov	 edx, DWORD PTR _pbSrcPixel$18[ebp]
  001bc	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  001c0	03 c1		 add	 eax, ecx
  001c2	d1 f8		 sar	 eax, 1
  001c4	8b 4d bc	 mov	 ecx, DWORD PTR _pbDstPixel$10[ebp]
  001c7	88 01		 mov	 BYTE PTR [ecx], al
  001c9	8b 45 bc	 mov	 eax, DWORD PTR _pbDstPixel$10[ebp]
  001cc	40		 inc	 eax
  001cd	89 45 bc	 mov	 DWORD PTR _pbDstPixel$10[ebp], eax

; 805  : 				(((	pbSrcPixel[0]+pbSrcPixel[1]+pbSrcPixel[2]+
; 806  : 					pbSrcPixel[258]+pbSrcPixel[260]+
; 807  : 					pbSrcPixel[258*2]+pbSrcPixel[258*2+1]+pbSrcPixel[258*2+2])
; 808  : 				>>3)+pbSrcPixel[259])>>1;
; 809  : 			}

  001d0	e9 37 ff ff ff	 jmp	 $LN5@AddTexture
$LN6@AddTexture:

; 810  : 		}

  001d5	e9 0d ff ff ff	 jmp	 $LN2@AddTexture
$LN3@AddTexture:

; 811  : 
; 812  : 		D3DLOCKED_RECT  d3dlr;
; 813  : 		hr = pkTex->LockRect(0, &d3dlr, 0, 0);

  001da	6a 00		 push	 0
  001dc	6a 00		 push	 0
  001de	8d 45 a0	 lea	 eax, DWORD PTR _d3dlr$6[ebp]
  001e1	50		 push	 eax
  001e2	6a 00		 push	 0
  001e4	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  001e7	8b 00		 mov	 eax, DWORD PTR [eax]
  001e9	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  001ec	ff 50 40	 call	 DWORD PTR [eax+64]
  001ef	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 814  : 		if (FAILED(hr))

  001f2	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  001f6	7d 12		 jge	 SHORT $LN21@AddTexture

; 815  : 		{
; 816  : 			pkTex->Release();

  001f8	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  001fb	8b 00		 mov	 eax, DWORD PTR [eax]
  001fd	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  00200	ff 50 08	 call	 DWORD PTR [eax+8]

; 817  : 			return NULL;

  00203	33 c0		 xor	 eax, eax
  00205	e9 ff 01 00 00	 jmp	 $LN1@AddTexture
$LN21@AddTexture:

; 818  : 		}
; 819  : 		
; 820  : 		if(ms_bSupportDXT)

  0020a	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA ; CGraphicBase::ms_bSupportDXT
  00211	85 c0		 test	 eax, eax
  00213	74 26		 je	 SHORT $LN22@AddTexture

; 821  : 			PutImage32(abResizeImage, (BYTE*) d3dlr.pBits, 256, d3dlr.Pitch, 256, 256, bResizedAndSuccess);

  00215	ff 75 c8	 push	 DWORD PTR _bResizedAndSuccess$[ebp]
  00218	68 00 01 00 00	 push	 256			; 00000100H
  0021d	68 00 01 00 00	 push	 256			; 00000100H
  00222	ff 75 a0	 push	 DWORD PTR _d3dlr$6[ebp]
  00225	68 00 01 00 00	 push	 256			; 00000100H
  0022a	ff 75 a4	 push	 DWORD PTR _d3dlr$6[ebp+4]
  0022d	8d 45 f8	 lea	 eax, DWORD PTR _abResizeImage$[ebp]
  00230	50		 push	 eax
  00231	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z ; CTerrain::PutImage32
  00239	eb 24		 jmp	 SHORT $LN23@AddTexture
$LN22@AddTexture:

; 822  : 		else
; 823  : 			PutImage16(abResizeImage, (BYTE*) d3dlr.pBits, 256, d3dlr.Pitch, 256, 256, bResizedAndSuccess);

  0023b	ff 75 c8	 push	 DWORD PTR _bResizedAndSuccess$[ebp]
  0023e	68 00 01 00 00	 push	 256			; 00000100H
  00243	68 00 01 00 00	 push	 256			; 00000100H
  00248	ff 75 a0	 push	 DWORD PTR _d3dlr$6[ebp]
  0024b	68 00 01 00 00	 push	 256			; 00000100H
  00250	ff 75 a4	 push	 DWORD PTR _d3dlr$6[ebp+4]
  00253	8d 45 f8	 lea	 eax, DWORD PTR _abResizeImage$[ebp]
  00256	50		 push	 eax
  00257	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	e8 00 00 00 00	 call	 ?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z ; CTerrain::PutImage16
$LN23@AddTexture:

; 824  : 
; 825  : 		pkTex->UnlockRect(0);

  0025f	6a 00		 push	 0
  00261	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  00264	8b 00		 mov	 eax, DWORD PTR [eax]
  00266	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  00269	ff 50 44	 call	 DWORD PTR [eax+68]

; 826  : 	}
; 827  : 
; 828  : 	BYTE abResizeImage2[128*128];
; 829  : 
; 830  : 	BYTE* pbSrcBuffer=abResizeImage;

  0026c	8d 45 f8	 lea	 eax, DWORD PTR _abResizeImage$[ebp]
  0026f	89 45 ac	 mov	 DWORD PTR _pbSrcBuffer$[ebp], eax

; 831  : 	BYTE* pbDstBuffer=abResizeImage2;

  00272	8d 85 f8 ff 00
	00		 lea	 eax, DWORD PTR _abResizeImage2$[ebp]
  00278	89 45 d8	 mov	 DWORD PTR _pbDstBuffer$[ebp], eax

; 832  : 
; 833  : 	UINT uSrcSize=256;

  0027b	c7 45 e4 00 01
	00 00		 mov	 DWORD PTR _uSrcSize$[ebp], 256 ; 00000100H

; 834  : 	
; 835  : 	for (UINT uMipMapLevel=1; uMipMapLevel!=pkTex->GetLevelCount(); ++uMipMapLevel)

  00282	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _uMipMapLevel$16[ebp], 1
  00289	eb 07		 jmp	 SHORT $LN10@AddTexture
$LN8@AddTexture:
  0028b	8b 45 dc	 mov	 eax, DWORD PTR _uMipMapLevel$16[ebp]
  0028e	40		 inc	 eax
  0028f	89 45 dc	 mov	 DWORD PTR _uMipMapLevel$16[ebp], eax
$LN10@AddTexture:
  00292	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  00295	8b 00		 mov	 eax, DWORD PTR [eax]
  00297	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  0029a	ff 50 34	 call	 DWORD PTR [eax+52]
  0029d	39 45 dc	 cmp	 DWORD PTR _uMipMapLevel$16[ebp], eax
  002a0	0f 84 4f 01 00
	00		 je	 $LN9@AddTexture

; 836  : 	{
; 837  : 		UINT uDstSize=uSrcSize>>1;

  002a6	8b 45 e4	 mov	 eax, DWORD PTR _uSrcSize$[ebp]
  002a9	d1 e8		 shr	 eax, 1
  002ab	89 45 e8	 mov	 DWORD PTR _uDstSize$17[ebp], eax

; 838  : 
; 839  : 		BYTE* pbDstPixel=pbDstBuffer;

  002ae	8b 45 d8	 mov	 eax, DWORD PTR _pbDstBuffer$[ebp]
  002b1	89 45 b0	 mov	 DWORD PTR _pbDstPixel$7[ebp], eax

; 840  : 		BYTE* pbSrcPixel;
; 841  : 		BYTE* abCurLine=pbSrcBuffer;

  002b4	8b 45 ac	 mov	 eax, DWORD PTR _pbSrcBuffer$[ebp]
  002b7	89 45 b4	 mov	 DWORD PTR _abCurLine$8[ebp], eax

; 842  : 		for (UINT y=0; y!=uSrcSize; y+=2, abCurLine+=uSrcSize*2)

  002ba	83 65 b8 00	 and	 DWORD PTR _y$9[ebp], 0
  002be	eb 14		 jmp	 SHORT $LN13@AddTexture
$LN11@AddTexture:
  002c0	8b 45 b8	 mov	 eax, DWORD PTR _y$9[ebp]
  002c3	40		 inc	 eax
  002c4	40		 inc	 eax
  002c5	89 45 b8	 mov	 DWORD PTR _y$9[ebp], eax
  002c8	8b 45 e4	 mov	 eax, DWORD PTR _uSrcSize$[ebp]
  002cb	8b 4d b4	 mov	 ecx, DWORD PTR _abCurLine$8[ebp]
  002ce	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  002d1	89 45 b4	 mov	 DWORD PTR _abCurLine$8[ebp], eax
$LN13@AddTexture:
  002d4	8b 45 b8	 mov	 eax, DWORD PTR _y$9[ebp]
  002d7	3b 45 e4	 cmp	 eax, DWORD PTR _uSrcSize$[ebp]
  002da	74 68		 je	 SHORT $LN12@AddTexture

; 843  : 		{
; 844  : 			for (UINT x=0; x!=uSrcSize; x+=2)

  002dc	83 65 d0 00	 and	 DWORD PTR _x$14[ebp], 0
  002e0	eb 08		 jmp	 SHORT $LN16@AddTexture
$LN14@AddTexture:
  002e2	8b 45 d0	 mov	 eax, DWORD PTR _x$14[ebp]
  002e5	40		 inc	 eax
  002e6	40		 inc	 eax
  002e7	89 45 d0	 mov	 DWORD PTR _x$14[ebp], eax
$LN16@AddTexture:
  002ea	8b 45 d0	 mov	 eax, DWORD PTR _x$14[ebp]
  002ed	3b 45 e4	 cmp	 eax, DWORD PTR _uSrcSize$[ebp]
  002f0	74 4d		 je	 SHORT $LN15@AddTexture

; 845  : 			{
; 846  : 				pbSrcPixel=abCurLine+x;

  002f2	8b 45 b4	 mov	 eax, DWORD PTR _abCurLine$8[ebp]
  002f5	03 45 d0	 add	 eax, DWORD PTR _x$14[ebp]
  002f8	89 45 cc	 mov	 DWORD PTR _pbSrcPixel$13[ebp], eax

; 847  : 				*pbDstPixel++=(pbSrcPixel[0]+pbSrcPixel[1]+pbSrcPixel[uSrcSize+0]+pbSrcPixel[uSrcSize+1])>>2;

  002fb	33 c0		 xor	 eax, eax
  002fd	40		 inc	 eax
  002fe	6b c0 00	 imul	 eax, eax, 0
  00301	8b 4d cc	 mov	 ecx, DWORD PTR _pbSrcPixel$13[ebp]
  00304	0f b6 04 01	 movzx	 eax, BYTE PTR [ecx+eax]
  00308	33 c9		 xor	 ecx, ecx
  0030a	41		 inc	 ecx
  0030b	c1 e1 00	 shl	 ecx, 0
  0030e	8b 55 cc	 mov	 edx, DWORD PTR _pbSrcPixel$13[ebp]
  00311	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [edx+ecx]
  00315	03 c1		 add	 eax, ecx
  00317	8b 4d cc	 mov	 ecx, DWORD PTR _pbSrcPixel$13[ebp]
  0031a	03 4d e4	 add	 ecx, DWORD PTR _uSrcSize$[ebp]
  0031d	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00320	03 c1		 add	 eax, ecx
  00322	8b 4d cc	 mov	 ecx, DWORD PTR _pbSrcPixel$13[ebp]
  00325	03 4d e4	 add	 ecx, DWORD PTR _uSrcSize$[ebp]
  00328	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  0032c	03 c1		 add	 eax, ecx
  0032e	c1 f8 02	 sar	 eax, 2
  00331	8b 4d b0	 mov	 ecx, DWORD PTR _pbDstPixel$7[ebp]
  00334	88 01		 mov	 BYTE PTR [ecx], al
  00336	8b 45 b0	 mov	 eax, DWORD PTR _pbDstPixel$7[ebp]
  00339	40		 inc	 eax
  0033a	89 45 b0	 mov	 DWORD PTR _pbDstPixel$7[ebp], eax

; 848  : 			}

  0033d	eb a3		 jmp	 SHORT $LN14@AddTexture
$LN15@AddTexture:

; 849  : 		}

  0033f	e9 7c ff ff ff	 jmp	 $LN11@AddTexture
$LN12@AddTexture:

; 850  : 
; 851  : 		D3DLOCKED_RECT  d3dlr;
; 852  : 	
; 853  : 		hr = pkTex->LockRect(uMipMapLevel, &d3dlr, 0, 0);

  00344	6a 00		 push	 0
  00346	6a 00		 push	 0
  00348	8d 45 98	 lea	 eax, DWORD PTR _d3dlr$5[ebp]
  0034b	50		 push	 eax
  0034c	ff 75 dc	 push	 DWORD PTR _uMipMapLevel$16[ebp]
  0034f	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  00352	8b 00		 mov	 eax, DWORD PTR [eax]
  00354	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  00357	ff 50 40	 call	 DWORD PTR [eax+64]
  0035a	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax

; 854  : 		if (FAILED(hr))

  0035d	83 7d e0 00	 cmp	 DWORD PTR _hr$[ebp], 0
  00361	7d 05		 jge	 SHORT $LN24@AddTexture

; 855  : 			continue;

  00363	e9 23 ff ff ff	 jmp	 $LN8@AddTexture
$LN24@AddTexture:

; 856  : 
; 857  : 		if(ms_bSupportDXT)

  00368	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?ms_bSupportDXT@CGraphicBase@@1_NA ; CGraphicBase::ms_bSupportDXT
  0036f	85 c0		 test	 eax, eax
  00371	74 1f		 je	 SHORT $LN25@AddTexture

; 858  : 			PutImage32(pbDstBuffer, (BYTE*) d3dlr.pBits, uDstSize, d3dlr.Pitch, uDstSize, uDstSize, bResizedAndSuccess);

  00373	ff 75 c8	 push	 DWORD PTR _bResizedAndSuccess$[ebp]
  00376	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  00379	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  0037c	ff 75 98	 push	 DWORD PTR _d3dlr$5[ebp]
  0037f	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  00382	ff 75 9c	 push	 DWORD PTR _d3dlr$5[ebp+4]
  00385	ff 75 d8	 push	 DWORD PTR _pbDstBuffer$[ebp]
  00388	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0038b	e8 00 00 00 00	 call	 ?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z ; CTerrain::PutImage32
  00390	eb 1d		 jmp	 SHORT $LN26@AddTexture
$LN25@AddTexture:

; 859  : 		else
; 860  : 			PutImage16(pbDstBuffer, (BYTE*) d3dlr.pBits, uDstSize, d3dlr.Pitch, uDstSize, uDstSize, bResizedAndSuccess);

  00392	ff 75 c8	 push	 DWORD PTR _bResizedAndSuccess$[ebp]
  00395	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  00398	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  0039b	ff 75 98	 push	 DWORD PTR _d3dlr$5[ebp]
  0039e	ff 75 e8	 push	 DWORD PTR _uDstSize$17[ebp]
  003a1	ff 75 9c	 push	 DWORD PTR _d3dlr$5[ebp+4]
  003a4	ff 75 d8	 push	 DWORD PTR _pbDstBuffer$[ebp]
  003a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003aa	e8 00 00 00 00	 call	 ?PutImage16@CTerrain@@IAEXPAE0JJJJ_N@Z ; CTerrain::PutImage16
$LN26@AddTexture:

; 861  : 
; 862  : 		hr = pkTex->UnlockRect(uMipMapLevel);

  003af	ff 75 dc	 push	 DWORD PTR _uMipMapLevel$16[ebp]
  003b2	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
  003b5	8b 00		 mov	 eax, DWORD PTR [eax]
  003b7	ff 75 f4	 push	 DWORD PTR _pkTex$[ebp]
  003ba	ff 50 44	 call	 DWORD PTR [eax+68]
  003bd	89 45 e0	 mov	 DWORD PTR _hr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003c0	8d 45 ac	 lea	 eax, DWORD PTR _pbSrcBuffer$[ebp]
  003c3	89 45 8c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003c6	8b 45 8c	 mov	 eax, DWORD PTR $T4[ebp]
  003c9	8b 00		 mov	 eax, DWORD PTR [eax]
  003cb	89 45 84	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003ce	8d 45 d8	 lea	 eax, DWORD PTR _pbDstBuffer$[ebp]
  003d1	89 45 88	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003d4	8b 45 88	 mov	 eax, DWORD PTR $T3[ebp]
  003d7	8b 00		 mov	 eax, DWORD PTR [eax]
  003d9	89 45 ac	 mov	 DWORD PTR _pbSrcBuffer$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003dc	8d 45 84	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  003df	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  003e2	8b 45 80	 mov	 eax, DWORD PTR $T1[ebp]
  003e5	8b 00		 mov	 eax, DWORD PTR [eax]
  003e7	89 45 d8	 mov	 DWORD PTR _pbDstBuffer$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 865  : 		uSrcSize=uDstSize;

  003ea	8b 45 e8	 mov	 eax, DWORD PTR _uDstSize$17[ebp]
  003ed	89 45 e4	 mov	 DWORD PTR _uSrcSize$[ebp], eax

; 866  : 	}

  003f0	e9 96 fe ff ff	 jmp	 $LN8@AddTexture
$LN9@AddTexture:

; 867  : 
; 868  : 	m_lpAlphaTexture[byImageNum]=pkTex;

  003f5	0f b6 85 04 40
	01 00		 movzx	 eax, BYTE PTR _byImageNum$[ebp]
  003fc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003ff	8b 55 f4	 mov	 edx, DWORD PTR _pkTex$[ebp]
  00402	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 869  : 
; 870  : 	return pkTex;

  00406	8b 45 f4	 mov	 eax, DWORD PTR _pkTex$[ebp]
$LN1@AddTexture:

; 871  : }

  00409	8b 8d f8 3f 01
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0040f	33 cd		 xor	 ecx, ebp
  00411	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00416	81 c5 fc 3f 01
	00		 add	 ebp, 81916		; 00013ffcH
  0041c	c9		 leave
  0041d	c2 10 00	 ret	 16			; 00000010H
?AddTexture32@CTerrain@@IAEPAUIDirect3DTexture8@@EPAEJJ@Z ENDP ; CTerrain::AddTexture32
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?RAW_CountTiles@CTerrain@@MAEXXZ
_TEXT	SEGMENT
tv95 = -112						; size = 4
tv94 = -108						; size = 4
tv87 = -104						; size = 4
tv79 = -100						; size = 4
tv78 = -96						; size = 4
tv71 = -92						; size = 4
tv515 = -88						; size = 4
tv484 = -84						; size = 4
tv453 = -80						; size = 4
tv448 = -76						; size = 4
tv422 = -72						; size = 4
tv391 = -68						; size = 4
tv386 = -64						; size = 4
tv360 = -60						; size = 4
tv328 = -56						; size = 4
tv298 = -52						; size = 4
tv293 = -48						; size = 4
tv267 = -44						; size = 4
tv236 = -40						; size = 4
tv231 = -36						; size = 4
tv205 = -32						; size = 4
tv173 = -28						; size = 4
_y$1 = -24						; size = 4
_lPatchIndexY$2 = -20					; size = 4
_lPatchIndexX$3 = -16					; size = 4
_x$4 = -12						; size = 4
_this$ = -8						; size = 4
_tilenum$5 = -1						; size = 1
?RAW_CountTiles@CTerrain@@MAEXXZ PROC			; CTerrain::RAW_CountTiles, COMDAT
; _this$ = ecx

; 583  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 70	 sub	 esp, 112		; 00000070H
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 584  : 	for (long y = 0; y < TILEMAP_RAW_YSIZE; ++y)

  0000a	83 65 e8 00	 and	 DWORD PTR _y$1[ebp], 0
  0000e	eb 07		 jmp	 SHORT $LN4@RAW_CountT
$LN2@RAW_CountT:
  00010	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00013	40		 inc	 eax
  00014	89 45 e8	 mov	 DWORD PTR _y$1[ebp], eax
$LN4@RAW_CountT:
  00017	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _y$1[ebp], 258 ; 00000102H
  0001e	0f 8d fb 06 00
	00		 jge	 $LN1@RAW_CountT

; 585  : 	{
; 586  : 		long lPatchIndexY = min(max((y-1)/PATCH_TILE_YSIZE,0), PATCH_YCOUNT - 1);

  00024	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00027	48		 dec	 eax
  00028	99		 cdq
  00029	83 e2 1f	 and	 edx, 31			; 0000001fH
  0002c	03 c2		 add	 eax, edx
  0002e	c1 f8 05	 sar	 eax, 5
  00031	85 c0		 test	 eax, eax
  00033	7e 12		 jle	 SHORT $LN22@RAW_CountT
  00035	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00038	48		 dec	 eax
  00039	99		 cdq
  0003a	83 e2 1f	 and	 edx, 31			; 0000001fH
  0003d	03 c2		 add	 eax, edx
  0003f	c1 f8 05	 sar	 eax, 5
  00042	89 45 a4	 mov	 DWORD PTR tv71[ebp], eax
  00045	eb 04		 jmp	 SHORT $LN23@RAW_CountT
$LN22@RAW_CountT:
  00047	83 65 a4 00	 and	 DWORD PTR tv71[ebp], 0
$LN23@RAW_CountT:
  0004b	83 7d a4 07	 cmp	 DWORD PTR tv71[ebp], 7
  0004f	7d 2f		 jge	 SHORT $LN26@RAW_CountT
  00051	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00054	48		 dec	 eax
  00055	99		 cdq
  00056	83 e2 1f	 and	 edx, 31			; 0000001fH
  00059	03 c2		 add	 eax, edx
  0005b	c1 f8 05	 sar	 eax, 5
  0005e	85 c0		 test	 eax, eax
  00060	7e 12		 jle	 SHORT $LN24@RAW_CountT
  00062	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00065	48		 dec	 eax
  00066	99		 cdq
  00067	83 e2 1f	 and	 edx, 31			; 0000001fH
  0006a	03 c2		 add	 eax, edx
  0006c	c1 f8 05	 sar	 eax, 5
  0006f	89 45 a0	 mov	 DWORD PTR tv78[ebp], eax
  00072	eb 04		 jmp	 SHORT $LN25@RAW_CountT
$LN24@RAW_CountT:
  00074	83 65 a0 00	 and	 DWORD PTR tv78[ebp], 0
$LN25@RAW_CountT:
  00078	8b 45 a0	 mov	 eax, DWORD PTR tv78[ebp]
  0007b	89 45 9c	 mov	 DWORD PTR tv79[ebp], eax
  0007e	eb 07		 jmp	 SHORT $LN27@RAW_CountT
$LN26@RAW_CountT:
  00080	c7 45 9c 07 00
	00 00		 mov	 DWORD PTR tv79[ebp], 7
$LN27@RAW_CountT:
  00087	8b 45 9c	 mov	 eax, DWORD PTR tv79[ebp]
  0008a	89 45 ec	 mov	 DWORD PTR _lPatchIndexY$2[ebp], eax

; 587  : 		for (long x = 0; x < TILEMAP_RAW_XSIZE; ++x)

  0008d	83 65 f4 00	 and	 DWORD PTR _x$4[ebp], 0
  00091	eb 07		 jmp	 SHORT $LN7@RAW_CountT
$LN5@RAW_CountT:
  00093	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  00096	40		 inc	 eax
  00097	89 45 f4	 mov	 DWORD PTR _x$4[ebp], eax
$LN7@RAW_CountT:
  0009a	81 7d f4 02 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 258 ; 00000102H
  000a1	0f 8d 73 06 00
	00		 jge	 $LN6@RAW_CountT

; 588  : 		{
; 589  : 			long lPatchIndexX = min(max((x-1)/(PATCH_TILE_XSIZE), 0), PATCH_XCOUNT - 1);

  000a7	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  000aa	48		 dec	 eax
  000ab	99		 cdq
  000ac	83 e2 1f	 and	 edx, 31			; 0000001fH
  000af	03 c2		 add	 eax, edx
  000b1	c1 f8 05	 sar	 eax, 5
  000b4	85 c0		 test	 eax, eax
  000b6	7e 12		 jle	 SHORT $LN28@RAW_CountT
  000b8	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  000bb	48		 dec	 eax
  000bc	99		 cdq
  000bd	83 e2 1f	 and	 edx, 31			; 0000001fH
  000c0	03 c2		 add	 eax, edx
  000c2	c1 f8 05	 sar	 eax, 5
  000c5	89 45 98	 mov	 DWORD PTR tv87[ebp], eax
  000c8	eb 04		 jmp	 SHORT $LN29@RAW_CountT
$LN28@RAW_CountT:
  000ca	83 65 98 00	 and	 DWORD PTR tv87[ebp], 0
$LN29@RAW_CountT:
  000ce	83 7d 98 07	 cmp	 DWORD PTR tv87[ebp], 7
  000d2	7d 2f		 jge	 SHORT $LN32@RAW_CountT
  000d4	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  000d7	48		 dec	 eax
  000d8	99		 cdq
  000d9	83 e2 1f	 and	 edx, 31			; 0000001fH
  000dc	03 c2		 add	 eax, edx
  000de	c1 f8 05	 sar	 eax, 5
  000e1	85 c0		 test	 eax, eax
  000e3	7e 12		 jle	 SHORT $LN30@RAW_CountT
  000e5	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  000e8	48		 dec	 eax
  000e9	99		 cdq
  000ea	83 e2 1f	 and	 edx, 31			; 0000001fH
  000ed	03 c2		 add	 eax, edx
  000ef	c1 f8 05	 sar	 eax, 5
  000f2	89 45 94	 mov	 DWORD PTR tv94[ebp], eax
  000f5	eb 04		 jmp	 SHORT $LN31@RAW_CountT
$LN30@RAW_CountT:
  000f7	83 65 94 00	 and	 DWORD PTR tv94[ebp], 0
$LN31@RAW_CountT:
  000fb	8b 45 94	 mov	 eax, DWORD PTR tv94[ebp]
  000fe	89 45 90	 mov	 DWORD PTR tv95[ebp], eax
  00101	eb 07		 jmp	 SHORT $LN33@RAW_CountT
$LN32@RAW_CountT:
  00103	c7 45 90 07 00
	00 00		 mov	 DWORD PTR tv95[ebp], 7
$LN33@RAW_CountT:
  0010a	8b 45 90	 mov	 eax, DWORD PTR tv95[ebp]
  0010d	89 45 f0	 mov	 DWORD PTR _lPatchIndexX$3[ebp], eax

; 590  : 			BYTE tilenum = m_abyTileMap[y * TILEMAP_RAW_XSIZE + x];

  00110	69 45 e8 02 01
	00 00		 imul	 eax, DWORD PTR _y$1[ebp], 258
  00117	03 45 f4	 add	 eax, DWORD PTR _x$4[ebp]
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	8a 84 01 16 8a
	00 00		 mov	 al, BYTE PTR [ecx+eax+35350]
  00124	88 45 ff	 mov	 BYTE PTR _tilenum$5[ebp], al

; 591  : 
; 592  : 			++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + lPatchIndexX][tilenum];

  00127	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0012a	8b 4d f0	 mov	 ecx, DWORD PTR _lPatchIndexX$3[ebp]
  0012d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00130	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00133	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  0013d	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00141	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00144	40		 inc	 eax
  00145	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00149	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  0014c	8b 75 f0	 mov	 esi, DWORD PTR _lPatchIndexX$3[ebp]
  0014f	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00152	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00155	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00158	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  0015f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 593  : 
; 594  : 			if ( 0 == y % PATCH_TILE_YSIZE && 0 != y && (TILEMAP_RAW_YSIZE - 2) != y)

  00162	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  00165	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0016a	79 05		 jns	 SHORT $LN66@RAW_CountT
  0016c	48		 dec	 eax
  0016d	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00170	40		 inc	 eax
$LN66@RAW_CountT:
  00171	85 c0		 test	 eax, eax
  00173	0f 85 48 02 00
	00		 jne	 $LN8@RAW_CountT
  00179	83 7d e8 00	 cmp	 DWORD PTR _y$1[ebp], 0
  0017d	0f 84 3e 02 00
	00		 je	 $LN8@RAW_CountT
  00183	81 7d e8 00 01
	00 00		 cmp	 DWORD PTR _y$1[ebp], 256 ; 00000100H
  0018a	0f 84 31 02 00
	00		 je	 $LN8@RAW_CountT

; 595  : 			{
; 596  : 				++m_TerrainSplatPatch.PatchTileCount[min(PATCH_YCOUNT - 1, lPatchIndexY + 1) * PATCH_XCOUNT + lPatchIndexX][tilenum];

  00190	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  00193	40		 inc	 eax
  00194	83 f8 07	 cmp	 eax, 7
  00197	7e 09		 jle	 SHORT $LN34@RAW_CountT
  00199	c7 45 e4 07 00
	00 00		 mov	 DWORD PTR tv173[ebp], 7
  001a0	eb 07		 jmp	 SHORT $LN35@RAW_CountT
$LN34@RAW_CountT:
  001a2	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  001a5	40		 inc	 eax
  001a6	89 45 e4	 mov	 DWORD PTR tv173[ebp], eax
$LN35@RAW_CountT:
  001a9	8b 45 e4	 mov	 eax, DWORD PTR tv173[ebp]
  001ac	8b 4d f0	 mov	 ecx, DWORD PTR _lPatchIndexX$3[ebp]
  001af	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  001b2	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  001b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  001bf	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  001c3	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  001c6	40		 inc	 eax
  001c7	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  001cb	8b 55 e4	 mov	 edx, DWORD PTR tv173[ebp]
  001ce	8b 75 f0	 mov	 esi, DWORD PTR _lPatchIndexX$3[ebp]
  001d1	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  001d4	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  001d7	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  001da	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  001e1	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 597  : 				if ( 0 == x % PATCH_TILE_XSIZE && 0 != x && (TILEMAP_RAW_XSIZE - 2) != x)

  001e4	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  001e7	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  001ec	79 05		 jns	 SHORT $LN67@RAW_CountT
  001ee	48		 dec	 eax
  001ef	83 c8 e0	 or	 eax, -32		; ffffffe0H
  001f2	40		 inc	 eax
$LN67@RAW_CountT:
  001f3	85 c0		 test	 eax, eax
  001f5	0f 85 dd 00 00
	00		 jne	 $LN10@RAW_CountT
  001fb	83 7d f4 00	 cmp	 DWORD PTR _x$4[ebp], 0
  001ff	0f 84 d3 00 00
	00		 je	 $LN10@RAW_CountT
  00205	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 256 ; 00000100H
  0020c	0f 84 c6 00 00
	00		 je	 $LN10@RAW_CountT

; 598  : 				{
; 599  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + min(PATCH_XCOUNT - 1, lPatchIndexX + 1)][tilenum];

  00212	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00215	40		 inc	 eax
  00216	83 f8 07	 cmp	 eax, 7
  00219	7e 09		 jle	 SHORT $LN36@RAW_CountT
  0021b	c7 45 e0 07 00
	00 00		 mov	 DWORD PTR tv205[ebp], 7
  00222	eb 07		 jmp	 SHORT $LN37@RAW_CountT
$LN36@RAW_CountT:
  00224	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00227	40		 inc	 eax
  00228	89 45 e0	 mov	 DWORD PTR tv205[ebp], eax
$LN37@RAW_CountT:
  0022b	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0022e	8b 4d e0	 mov	 ecx, DWORD PTR tv205[ebp]
  00231	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00234	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00237	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023a	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00241	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00245	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00248	40		 inc	 eax
  00249	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0024d	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  00250	8b 75 e0	 mov	 esi, DWORD PTR tv205[ebp]
  00253	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00256	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00259	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0025c	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  00263	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 600  : 					++m_TerrainSplatPatch.PatchTileCount[min(PATCH_YCOUNT - 1, lPatchIndexY + 1) * PATCH_XCOUNT + min(PATCH_XCOUNT - 1, lPatchIndexX + 1)][tilenum];

  00266	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  00269	40		 inc	 eax
  0026a	83 f8 07	 cmp	 eax, 7
  0026d	7e 09		 jle	 SHORT $LN38@RAW_CountT
  0026f	c7 45 dc 07 00
	00 00		 mov	 DWORD PTR tv231[ebp], 7
  00276	eb 07		 jmp	 SHORT $LN39@RAW_CountT
$LN38@RAW_CountT:
  00278	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0027b	40		 inc	 eax
  0027c	89 45 dc	 mov	 DWORD PTR tv231[ebp], eax
$LN39@RAW_CountT:
  0027f	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00282	40		 inc	 eax
  00283	83 f8 07	 cmp	 eax, 7
  00286	7e 09		 jle	 SHORT $LN40@RAW_CountT
  00288	c7 45 d8 07 00
	00 00		 mov	 DWORD PTR tv236[ebp], 7
  0028f	eb 07		 jmp	 SHORT $LN41@RAW_CountT
$LN40@RAW_CountT:
  00291	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00294	40		 inc	 eax
  00295	89 45 d8	 mov	 DWORD PTR tv236[ebp], eax
$LN41@RAW_CountT:
  00298	8b 45 dc	 mov	 eax, DWORD PTR tv231[ebp]
  0029b	8b 4d d8	 mov	 ecx, DWORD PTR tv236[ebp]
  0029e	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  002a1	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  002a4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a7	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  002ae	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  002b2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  002b5	40		 inc	 eax
  002b6	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  002ba	8b 55 dc	 mov	 edx, DWORD PTR tv231[ebp]
  002bd	8b 75 d8	 mov	 esi, DWORD PTR tv236[ebp]
  002c0	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  002c3	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  002c6	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  002c9	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  002d0	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 601  : 				}

  002d3	e9 e4 00 00 00	 jmp	 $LN11@RAW_CountT
$LN10@RAW_CountT:

; 602  : 				else if ( 1 == x % PATCH_TILE_XSIZE && (TILEMAP_RAW_XSIZE -1) != x && 1 != x)

  002d8	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  002db	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  002e0	79 05		 jns	 SHORT $LN68@RAW_CountT
  002e2	48		 dec	 eax
  002e3	83 c8 e0	 or	 eax, -32		; ffffffe0H
  002e6	40		 inc	 eax
$LN68@RAW_CountT:
  002e7	83 f8 01	 cmp	 eax, 1
  002ea	0f 85 cc 00 00
	00		 jne	 $LN11@RAW_CountT
  002f0	81 7d f4 01 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 257 ; 00000101H
  002f7	0f 84 bf 00 00
	00		 je	 $LN11@RAW_CountT
  002fd	83 7d f4 01	 cmp	 DWORD PTR _x$4[ebp], 1
  00301	0f 84 b5 00 00
	00		 je	 $LN11@RAW_CountT

; 603  : 				{
; 604  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + max(0, lPatchIndexX - 1)][tilenum];

  00307	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  0030a	48		 dec	 eax
  0030b	79 06		 jns	 SHORT $LN42@RAW_CountT
  0030d	83 65 d4 00	 and	 DWORD PTR tv267[ebp], 0
  00311	eb 07		 jmp	 SHORT $LN43@RAW_CountT
$LN42@RAW_CountT:
  00313	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00316	48		 dec	 eax
  00317	89 45 d4	 mov	 DWORD PTR tv267[ebp], eax
$LN43@RAW_CountT:
  0031a	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0031d	8b 4d d4	 mov	 ecx, DWORD PTR tv267[ebp]
  00320	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00323	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00326	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00329	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00330	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00334	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00337	40		 inc	 eax
  00338	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0033c	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  0033f	8b 75 d4	 mov	 esi, DWORD PTR tv267[ebp]
  00342	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00345	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00348	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0034b	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  00352	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 605  : 					++m_TerrainSplatPatch.PatchTileCount[min(PATCH_YCOUNT - 1, lPatchIndexY + 1) * PATCH_XCOUNT + max(0, lPatchIndexX - 1)][tilenum];

  00355	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  00358	40		 inc	 eax
  00359	83 f8 07	 cmp	 eax, 7
  0035c	7e 09		 jle	 SHORT $LN44@RAW_CountT
  0035e	c7 45 d0 07 00
	00 00		 mov	 DWORD PTR tv293[ebp], 7
  00365	eb 07		 jmp	 SHORT $LN45@RAW_CountT
$LN44@RAW_CountT:
  00367	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0036a	40		 inc	 eax
  0036b	89 45 d0	 mov	 DWORD PTR tv293[ebp], eax
$LN45@RAW_CountT:
  0036e	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00371	48		 dec	 eax
  00372	79 06		 jns	 SHORT $LN46@RAW_CountT
  00374	83 65 cc 00	 and	 DWORD PTR tv298[ebp], 0
  00378	eb 07		 jmp	 SHORT $LN47@RAW_CountT
$LN46@RAW_CountT:
  0037a	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  0037d	48		 dec	 eax
  0037e	89 45 cc	 mov	 DWORD PTR tv298[ebp], eax
$LN47@RAW_CountT:
  00381	8b 45 d0	 mov	 eax, DWORD PTR tv293[ebp]
  00384	8b 4d cc	 mov	 ecx, DWORD PTR tv298[ebp]
  00387	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0038a	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0038d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00390	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00397	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0039b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0039e	40		 inc	 eax
  0039f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  003a3	8b 55 d0	 mov	 edx, DWORD PTR tv293[ebp]
  003a6	8b 75 cc	 mov	 esi, DWORD PTR tv298[ebp]
  003a9	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  003ac	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  003af	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  003b2	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  003b9	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN11@RAW_CountT:

; 606  : 				}
; 607  : 			}

  003bc	e9 37 03 00 00	 jmp	 $LN9@RAW_CountT
$LN8@RAW_CountT:

; 608  : 			else if ( 1 == y % PATCH_TILE_YSIZE && (TILEMAP_RAW_YSIZE -1) != y && 1 != y)

  003c1	8b 45 e8	 mov	 eax, DWORD PTR _y$1[ebp]
  003c4	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  003c9	79 05		 jns	 SHORT $LN69@RAW_CountT
  003cb	48		 dec	 eax
  003cc	83 c8 e0	 or	 eax, -32		; ffffffe0H
  003cf	40		 inc	 eax
$LN69@RAW_CountT:
  003d0	83 f8 01	 cmp	 eax, 1
  003d3	0f 85 36 02 00
	00		 jne	 $LN13@RAW_CountT
  003d9	81 7d e8 01 01
	00 00		 cmp	 DWORD PTR _y$1[ebp], 257 ; 00000101H
  003e0	0f 84 29 02 00
	00		 je	 $LN13@RAW_CountT
  003e6	83 7d e8 01	 cmp	 DWORD PTR _y$1[ebp], 1
  003ea	0f 84 1f 02 00
	00		 je	 $LN13@RAW_CountT

; 609  : 			{
; 610  : 				++m_TerrainSplatPatch.PatchTileCount[max(0, lPatchIndexY - 1) * PATCH_XCOUNT + lPatchIndexX][tilenum];

  003f0	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  003f3	48		 dec	 eax
  003f4	79 06		 jns	 SHORT $LN48@RAW_CountT
  003f6	83 65 c8 00	 and	 DWORD PTR tv328[ebp], 0
  003fa	eb 07		 jmp	 SHORT $LN49@RAW_CountT
$LN48@RAW_CountT:
  003fc	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  003ff	48		 dec	 eax
  00400	89 45 c8	 mov	 DWORD PTR tv328[ebp], eax
$LN49@RAW_CountT:
  00403	8b 45 c8	 mov	 eax, DWORD PTR tv328[ebp]
  00406	8b 4d f0	 mov	 ecx, DWORD PTR _lPatchIndexX$3[ebp]
  00409	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0040c	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0040f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00412	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00419	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0041d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00420	40		 inc	 eax
  00421	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00425	8b 55 c8	 mov	 edx, DWORD PTR tv328[ebp]
  00428	8b 75 f0	 mov	 esi, DWORD PTR _lPatchIndexX$3[ebp]
  0042b	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  0042e	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00431	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00434	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  0043b	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 611  : 				if ( 0 == x % PATCH_TILE_XSIZE && 0 != x && (TILEMAP_RAW_XSIZE - 2) != x)

  0043e	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  00441	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00446	79 05		 jns	 SHORT $LN70@RAW_CountT
  00448	48		 dec	 eax
  00449	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0044c	40		 inc	 eax
$LN70@RAW_CountT:
  0044d	85 c0		 test	 eax, eax
  0044f	0f 85 d7 00 00
	00		 jne	 $LN15@RAW_CountT
  00455	83 7d f4 00	 cmp	 DWORD PTR _x$4[ebp], 0
  00459	0f 84 cd 00 00
	00		 je	 $LN15@RAW_CountT
  0045f	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 256 ; 00000100H
  00466	0f 84 c0 00 00
	00		 je	 $LN15@RAW_CountT

; 612  : 				{
; 613  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + min(PATCH_XCOUNT - 1, lPatchIndexX + 1)][tilenum];

  0046c	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  0046f	40		 inc	 eax
  00470	83 f8 07	 cmp	 eax, 7
  00473	7e 09		 jle	 SHORT $LN50@RAW_CountT
  00475	c7 45 c4 07 00
	00 00		 mov	 DWORD PTR tv360[ebp], 7
  0047c	eb 07		 jmp	 SHORT $LN51@RAW_CountT
$LN50@RAW_CountT:
  0047e	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00481	40		 inc	 eax
  00482	89 45 c4	 mov	 DWORD PTR tv360[ebp], eax
$LN51@RAW_CountT:
  00485	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  00488	8b 4d c4	 mov	 ecx, DWORD PTR tv360[ebp]
  0048b	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0048e	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00491	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00494	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  0049b	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0049f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  004a2	40		 inc	 eax
  004a3	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  004a7	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  004aa	8b 75 c4	 mov	 esi, DWORD PTR tv360[ebp]
  004ad	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  004b0	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  004b3	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  004b6	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  004bd	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 614  : 					++m_TerrainSplatPatch.PatchTileCount[max(0, lPatchIndexY - 1) * PATCH_XCOUNT + min(PATCH_XCOUNT - 1, lPatchIndexX + 1)][tilenum];

  004c0	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  004c3	48		 dec	 eax
  004c4	79 06		 jns	 SHORT $LN52@RAW_CountT
  004c6	83 65 c0 00	 and	 DWORD PTR tv386[ebp], 0
  004ca	eb 07		 jmp	 SHORT $LN53@RAW_CountT
$LN52@RAW_CountT:
  004cc	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  004cf	48		 dec	 eax
  004d0	89 45 c0	 mov	 DWORD PTR tv386[ebp], eax
$LN53@RAW_CountT:
  004d3	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  004d6	40		 inc	 eax
  004d7	83 f8 07	 cmp	 eax, 7
  004da	7e 09		 jle	 SHORT $LN54@RAW_CountT
  004dc	c7 45 bc 07 00
	00 00		 mov	 DWORD PTR tv391[ebp], 7
  004e3	eb 07		 jmp	 SHORT $LN55@RAW_CountT
$LN54@RAW_CountT:
  004e5	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  004e8	40		 inc	 eax
  004e9	89 45 bc	 mov	 DWORD PTR tv391[ebp], eax
$LN55@RAW_CountT:
  004ec	8b 45 c0	 mov	 eax, DWORD PTR tv386[ebp]
  004ef	8b 4d bc	 mov	 ecx, DWORD PTR tv391[ebp]
  004f2	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  004f5	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  004f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004fb	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00502	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00506	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00509	40		 inc	 eax
  0050a	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0050e	8b 55 c0	 mov	 edx, DWORD PTR tv386[ebp]
  00511	8b 75 bc	 mov	 esi, DWORD PTR tv391[ebp]
  00514	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00517	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0051a	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0051d	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  00524	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 615  : 				}

  00527	e9 de 00 00 00	 jmp	 $LN16@RAW_CountT
$LN15@RAW_CountT:

; 616  : 				else if ( 1 == x % PATCH_TILE_XSIZE && (TILEMAP_RAW_XSIZE -1) != x && 1 != x)

  0052c	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  0052f	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00534	79 05		 jns	 SHORT $LN71@RAW_CountT
  00536	48		 dec	 eax
  00537	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0053a	40		 inc	 eax
$LN71@RAW_CountT:
  0053b	83 f8 01	 cmp	 eax, 1
  0053e	0f 85 c6 00 00
	00		 jne	 $LN16@RAW_CountT
  00544	81 7d f4 01 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 257 ; 00000101H
  0054b	0f 84 b9 00 00
	00		 je	 $LN16@RAW_CountT
  00551	83 7d f4 01	 cmp	 DWORD PTR _x$4[ebp], 1
  00555	0f 84 af 00 00
	00		 je	 $LN16@RAW_CountT

; 617  : 				{
; 618  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + max(0, lPatchIndexX - 1)][tilenum];

  0055b	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  0055e	48		 dec	 eax
  0055f	79 06		 jns	 SHORT $LN56@RAW_CountT
  00561	83 65 b8 00	 and	 DWORD PTR tv422[ebp], 0
  00565	eb 07		 jmp	 SHORT $LN57@RAW_CountT
$LN56@RAW_CountT:
  00567	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  0056a	48		 dec	 eax
  0056b	89 45 b8	 mov	 DWORD PTR tv422[ebp], eax
$LN57@RAW_CountT:
  0056e	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  00571	8b 4d b8	 mov	 ecx, DWORD PTR tv422[ebp]
  00574	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00577	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0057a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0057d	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00584	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00588	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0058b	40		 inc	 eax
  0058c	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00590	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  00593	8b 75 b8	 mov	 esi, DWORD PTR tv422[ebp]
  00596	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00599	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  0059c	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0059f	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  005a6	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 619  : 					++m_TerrainSplatPatch.PatchTileCount[max(0, lPatchIndexY - 1) * PATCH_XCOUNT + max(0, lPatchIndexX - 1)][tilenum];

  005a9	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  005ac	48		 dec	 eax
  005ad	79 06		 jns	 SHORT $LN58@RAW_CountT
  005af	83 65 b4 00	 and	 DWORD PTR tv448[ebp], 0
  005b3	eb 07		 jmp	 SHORT $LN59@RAW_CountT
$LN58@RAW_CountT:
  005b5	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  005b8	48		 dec	 eax
  005b9	89 45 b4	 mov	 DWORD PTR tv448[ebp], eax
$LN59@RAW_CountT:
  005bc	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  005bf	48		 dec	 eax
  005c0	79 06		 jns	 SHORT $LN60@RAW_CountT
  005c2	83 65 b0 00	 and	 DWORD PTR tv453[ebp], 0
  005c6	eb 07		 jmp	 SHORT $LN61@RAW_CountT
$LN60@RAW_CountT:
  005c8	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  005cb	48		 dec	 eax
  005cc	89 45 b0	 mov	 DWORD PTR tv453[ebp], eax
$LN61@RAW_CountT:
  005cf	8b 45 b4	 mov	 eax, DWORD PTR tv448[ebp]
  005d2	8b 4d b0	 mov	 ecx, DWORD PTR tv453[ebp]
  005d5	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  005d8	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  005db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005de	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  005e5	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  005e9	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  005ec	40		 inc	 eax
  005ed	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  005f1	8b 55 b4	 mov	 edx, DWORD PTR tv448[ebp]
  005f4	8b 75 b0	 mov	 esi, DWORD PTR tv453[ebp]
  005f7	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  005fa	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  005fd	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  00600	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  00607	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN16@RAW_CountT:

; 620  : 				}
; 621  : 			}

  0060a	e9 e9 00 00 00	 jmp	 $LN9@RAW_CountT
$LN13@RAW_CountT:

; 622  : 			else
; 623  : 			{
; 624  : 				if ( 0 == x % PATCH_TILE_XSIZE && 0 != x && (TILEMAP_RAW_XSIZE - 2) != x)

  0060f	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  00612	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  00617	79 05		 jns	 SHORT $LN72@RAW_CountT
  00619	48		 dec	 eax
  0061a	83 c8 e0	 or	 eax, -32		; ffffffe0H
  0061d	40		 inc	 eax
$LN72@RAW_CountT:
  0061e	85 c0		 test	 eax, eax
  00620	75 65		 jne	 SHORT $LN18@RAW_CountT
  00622	83 7d f4 00	 cmp	 DWORD PTR _x$4[ebp], 0
  00626	74 5f		 je	 SHORT $LN18@RAW_CountT
  00628	81 7d f4 00 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 256 ; 00000100H
  0062f	74 56		 je	 SHORT $LN18@RAW_CountT

; 625  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + min(PATCH_XCOUNT - 1, lPatchIndexX + 1)][tilenum];

  00631	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00634	40		 inc	 eax
  00635	83 f8 07	 cmp	 eax, 7
  00638	7e 09		 jle	 SHORT $LN62@RAW_CountT
  0063a	c7 45 ac 07 00
	00 00		 mov	 DWORD PTR tv484[ebp], 7
  00641	eb 07		 jmp	 SHORT $LN63@RAW_CountT
$LN62@RAW_CountT:
  00643	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  00646	40		 inc	 eax
  00647	89 45 ac	 mov	 DWORD PTR tv484[ebp], eax
$LN63@RAW_CountT:
  0064a	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  0064d	8b 4d ac	 mov	 ecx, DWORD PTR tv484[ebp]
  00650	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00653	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00656	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00659	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  00660	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  00664	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00667	40		 inc	 eax
  00668	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0066c	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  0066f	8b 75 ac	 mov	 esi, DWORD PTR tv484[ebp]
  00672	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  00675	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  00678	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  0067b	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  00682	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  00685	eb 71		 jmp	 SHORT $LN9@RAW_CountT
$LN18@RAW_CountT:

; 626  : 				else if ( 1 == x % PATCH_TILE_XSIZE && (TILEMAP_RAW_XSIZE -1) != x && 1 != x)

  00687	8b 45 f4	 mov	 eax, DWORD PTR _x$4[ebp]
  0068a	25 1f 00 00 80	 and	 eax, -2147483617	; 8000001fH
  0068f	79 05		 jns	 SHORT $LN73@RAW_CountT
  00691	48		 dec	 eax
  00692	83 c8 e0	 or	 eax, -32		; ffffffe0H
  00695	40		 inc	 eax
$LN73@RAW_CountT:
  00696	83 f8 01	 cmp	 eax, 1
  00699	75 5d		 jne	 SHORT $LN9@RAW_CountT
  0069b	81 7d f4 01 01
	00 00		 cmp	 DWORD PTR _x$4[ebp], 257 ; 00000101H
  006a2	74 54		 je	 SHORT $LN9@RAW_CountT
  006a4	83 7d f4 01	 cmp	 DWORD PTR _x$4[ebp], 1
  006a8	74 4e		 je	 SHORT $LN9@RAW_CountT

; 627  : 					++m_TerrainSplatPatch.PatchTileCount[lPatchIndexY * PATCH_XCOUNT + max(0, lPatchIndexX - 1)][tilenum];

  006aa	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  006ad	48		 dec	 eax
  006ae	79 06		 jns	 SHORT $LN64@RAW_CountT
  006b0	83 65 a8 00	 and	 DWORD PTR tv515[ebp], 0
  006b4	eb 07		 jmp	 SHORT $LN65@RAW_CountT
$LN64@RAW_CountT:
  006b6	8b 45 f0	 mov	 eax, DWORD PTR _lPatchIndexX$3[ebp]
  006b9	48		 dec	 eax
  006ba	89 45 a8	 mov	 DWORD PTR tv515[ebp], eax
$LN65@RAW_CountT:
  006bd	8b 45 ec	 mov	 eax, DWORD PTR _lPatchIndexY$2[ebp]
  006c0	8b 4d a8	 mov	 ecx, DWORD PTR tv515[ebp]
  006c3	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  006c6	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  006c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006cc	8d 84 01 3c 95
	03 00		 lea	 eax, DWORD PTR [ecx+eax+234812]
  006d3	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  006d7	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  006da	40		 inc	 eax
  006db	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  006df	8b 55 ec	 mov	 edx, DWORD PTR _lPatchIndexY$2[ebp]
  006e2	8b 75 a8	 mov	 esi, DWORD PTR tv515[ebp]
  006e5	8d 14 d6	 lea	 edx, DWORD PTR [esi+edx*8]
  006e8	c1 e2 0a	 shl	 edx, 10			; 0000000aH
  006eb	8b 75 f8	 mov	 esi, DWORD PTR _this$[ebp]
  006ee	8d 94 16 3c 95
	03 00		 lea	 edx, DWORD PTR [esi+edx+234812]
  006f5	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
$LN9@RAW_CountT:

; 628  : 			}
; 629  : 
; 630  : 			++m_TerrainSplatPatch.TileCount[tilenum];

  006f8	0f b6 45 ff	 movzx	 eax, BYTE PTR _tilenum$5[ebp]
  006fc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006ff	8b 84 81 3c 91
	03 00		 mov	 eax, DWORD PTR [ecx+eax*4+233788]
  00706	40		 inc	 eax
  00707	0f b6 4d ff	 movzx	 ecx, BYTE PTR _tilenum$5[ebp]
  0070b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0070e	89 84 8a 3c 91
	03 00		 mov	 DWORD PTR [edx+ecx*4+233788], eax

; 631  : 		}

  00715	e9 79 f9 ff ff	 jmp	 $LN5@RAW_CountT
$LN6@RAW_CountT:

; 632  : 	}

  0071a	e9 f1 f8 ff ff	 jmp	 $LN2@RAW_CountT
$LN1@RAW_CountT:

; 633  : }

  0071f	5e		 pop	 esi
  00720	c9		 leave
  00721	c3		 ret	 0
?RAW_CountTiles@CTerrain@@MAEXXZ ENDP			; CTerrain::RAW_CountTiles
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z
_TEXT	SEGMENT
_rSplat$1 = -16						; size = 4
_ulRef$2 = -12						; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
_bBGLoading$ = 8					; size = 1
?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z PROC		; CTerrain::RAW_DeallocateSplats, COMDAT
; _this$ = ecx

; 543  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 544  : 	for (DWORD i = 1; i < GetTextureSet()->GetTextureCount(); ++i)

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$3[ebp], 1
  00010	eb 07		 jmp	 SHORT $LN4@RAW_Deallo
$LN2@RAW_Deallo:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  00015	40		 inc	 eax
  00016	89 45 fc	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@RAW_Deallo:
  00019	e8 00 00 00 00	 call	 ?GetTextureSet@CTerrainImpl@@SAPAVCTextureSet@@XZ ; CTerrainImpl::GetTextureSet
  0001e	8b c8		 mov	 ecx, eax
  00020	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00025	39 45 fc	 cmp	 DWORD PTR _i$3[ebp], eax
  00028	73 54		 jae	 SHORT $LN3@RAW_Deallo

; 545  : 	{
; 546  : 		TTerainSplat & rSplat = m_TerrainSplatPatch.Splats[i];

  0002a	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$3[ebp], 12
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8d 84 01 3c 95
	04 00		 lea	 eax, DWORD PTR [ecx+eax+300348]
  00038	89 45 f0	 mov	 DWORD PTR _rSplat$1[ebp], eax

; 547  : 
; 548  : 		if (m_lpAlphaTexture[i])

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0003e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	83 7c 81 04 00	 cmp	 DWORD PTR [ecx+eax*4+4], 0
  00046	74 22		 je	 SHORT $LN8@RAW_Deallo
$LN7@RAW_Deallo:

; 549  : 		{
; 550  : 			ULONG ulRef;
; 551  : 			do
; 552  : 			{
; 553  : 				ulRef = m_lpAlphaTexture[i]->Release();

  00048	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _i$3[ebp]
  00055	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	ff 74 8a 04	 push	 DWORD PTR [edx+ecx*4+4]
  0005e	ff 50 08	 call	 DWORD PTR [eax+8]
  00061	89 45 f4	 mov	 DWORD PTR _ulRef$2[ebp], eax

; 554  : 			} while(ulRef > 0);

  00064	83 7d f4 00	 cmp	 DWORD PTR _ulRef$2[ebp], 0
  00068	77 de		 ja	 SHORT $LN7@RAW_Deallo
$LN8@RAW_Deallo:

; 555  : 		}
; 556  : 
; 557  : 		rSplat.pd3dTexture = m_lpAlphaTexture[i] = NULL;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	83 64 81 04 00	 and	 DWORD PTR [ecx+eax*4+4], 0
  00075	8b 45 f0	 mov	 eax, DWORD PTR _rSplat$1[ebp]
  00078	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 558  :  	}

  0007c	eb 94		 jmp	 SHORT $LN2@RAW_Deallo
$LN3@RAW_Deallo:

; 559  : 
; 560  : 	memset(&m_TerrainSplatPatch, 0, sizeof(m_TerrainSplatPatch));

  0007e	68 04 10 01 00	 push	 69636			; 00011004H
  00083	6a 00		 push	 0
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	05 3c 91 03 00	 add	 eax, 233788		; 0003913cH
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 _memset
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH

; 561  : }

  00096	c9		 leave
  00097	c2 04 00	 ret	 4
?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z ENDP		; CTerrain::RAW_DeallocateSplats
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?RAW_AllocateSplats@CTerrain@@IAEX_N@Z
_TEXT	SEGMENT
_dwTexCount$ = -12					; size = 4
_t$1 = -8						; size = 4
_this$ = -4						; size = 4
_bBGLoading$ = 8					; size = 1
?RAW_AllocateSplats@CTerrain@@IAEX_N@Z PROC		; CTerrain::RAW_AllocateSplats, COMDAT
; _this$ = ecx

; 564  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 565  : 	RAW_DeallocateSplats(bBGLoading);

  00009	ff 75 08	 push	 DWORD PTR _bBGLoading$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z ; CTerrain::RAW_DeallocateSplats

; 566  : 	DWORD dwTexCount = GetTextureSet()->GetTextureCount();

  00014	e8 00 00 00 00	 call	 ?GetTextureSet@CTerrainImpl@@SAPAVCTextureSet@@XZ ; CTerrainImpl::GetTextureSet
  00019	8b c8		 mov	 ecx, eax
  0001b	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  00020	89 45 f4	 mov	 DWORD PTR _dwTexCount$[ebp], eax

; 567  : 	
; 568  : 	m_TerrainSplatPatch.m_bNeedsUpdate = true;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c6 80 3c a1 04
	00 01		 mov	 BYTE PTR [eax+303420], 1

; 569  : 
; 570  : 	for (DWORD t = 0; t < dwTexCount; ++t)

  0002d	83 65 f8 00	 and	 DWORD PTR _t$1[ebp], 0
  00031	eb 07		 jmp	 SHORT $LN4@RAW_Alloca
$LN2@RAW_Alloca:
  00033	8b 45 f8	 mov	 eax, DWORD PTR _t$1[ebp]
  00036	40		 inc	 eax
  00037	89 45 f8	 mov	 DWORD PTR _t$1[ebp], eax
$LN4@RAW_Alloca:
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _t$1[ebp]
  0003d	3b 45 f4	 cmp	 eax, DWORD PTR _dwTexCount$[ebp]
  00040	73 14		 jae	 SHORT $LN3@RAW_Alloca

; 571  : 		m_TerrainSplatPatch.Splats[t].NeedsUpdate = 1;

  00042	6b 45 f8 0c	 imul	 eax, DWORD PTR _t$1[ebp], 12
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	c7 84 01 40 95
	04 00 01 00 00
	00		 mov	 DWORD PTR [ecx+eax+300352], 1
  00054	eb dd		 jmp	 SHORT $LN2@RAW_Alloca
$LN3@RAW_Alloca:

; 572  : 	
; 573  : 	RAW_CountTiles();

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	ff 50 08	 call	 DWORD PTR [eax+8]

; 574  : 
; 575  : // 	if ( WAIT_OBJECT_0 == LockDataWrite() )
; 576  : 		RAW_GenerateSplat(bBGLoading);

  00061	ff 75 08	 push	 DWORD PTR _bBGLoading$[ebp]
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?RAW_GenerateSplat@CTerrain@@QAEX_N@Z ; CTerrain::RAW_GenerateSplat

; 577  : // 	UnlockDataWrite();
; 578  : 	
; 579  : 	m_TerrainSplatPatch.m_bNeedsUpdate = false;					

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	c6 80 3c a1 04
	00 00		 mov	 BYTE PTR [eax+303420], 0

; 580  : }

  00076	c9		 leave
  00077	c2 04 00	 ret	 4
?RAW_AllocateSplats@CTerrain@@IAEX_N@Z ENDP		; CTerrain::RAW_AllocateSplats
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?Initialize@CTerrain@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_byX$3 = -2						; size = 1
_byY$4 = -1						; size = 1
?Initialize@CTerrain@@IAE_NXZ PROC			; CTerrain::Initialize, COMDAT
; _this$ = ecx

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 48   : 		void			SetReady(bool bReady = true)	{ m_bReady = bReady; }

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c6 80 70 a5 06
	00 00		 mov	 BYTE PTR [eax+435568], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00018	e8 00 00 00 00	 call	 _strlen
  0001d	59		 pop	 ecx
  0001e	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00021	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00027	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 58   : 	m_strName = "";

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 54 a5 06
	00		 add	 ecx, 435540		; 0006a554H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00038	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 59   : 	m_wX = m_wY = 0xFFFF;

  0003d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	66 89 81 6e a5
	06 00		 mov	 WORD PTR [ecx+435566], ax
  0004c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	66 89 81 6c a5
	06 00		 mov	 WORD PTR [ecx+435564], ax

; 60   : 	m_bReady = false;

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c6 80 70 a5 06
	00 00		 mov	 BYTE PTR [eax+435568], 0

; 61   : 	m_bMarked = false;

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	83 a0 d8 c1 06
	00 00		 and	 DWORD PTR [eax+442840], 0

; 62   : 
; 63   : 	for (BYTE byY = 0; byY < PATCH_YCOUNT; ++byY)

  0006f	c6 45 ff 00	 mov	 BYTE PTR _byY$4[ebp], 0
  00073	eb 08		 jmp	 SHORT $LN4@Initialize
$LN2@Initialize:
  00075	8a 45 ff	 mov	 al, BYTE PTR _byY$4[ebp]
  00078	04 01		 add	 al, 1
  0007a	88 45 ff	 mov	 BYTE PTR _byY$4[ebp], al
$LN4@Initialize:
  0007d	0f b6 45 ff	 movzx	 eax, BYTE PTR _byY$4[ebp]
  00081	83 f8 08	 cmp	 eax, 8
  00084	7d 38		 jge	 SHORT $LN3@Initialize

; 64   : 		for (BYTE byX = 0; byX < PATCH_XCOUNT; ++byX)

  00086	c6 45 fe 00	 mov	 BYTE PTR _byX$3[ebp], 0
  0008a	eb 08		 jmp	 SHORT $LN7@Initialize
$LN5@Initialize:
  0008c	8a 45 fe	 mov	 al, BYTE PTR _byX$3[ebp]
  0008f	04 01		 add	 al, 1
  00091	88 45 fe	 mov	 BYTE PTR _byX$3[ebp], al
$LN7@Initialize:
  00094	0f b6 45 fe	 movzx	 eax, BYTE PTR _byX$3[ebp]
  00098	83 f8 08	 cmp	 eax, 8
  0009b	7d 1f		 jge	 SHORT $LN6@Initialize

; 65   : 			m_TerrainPatchList[byY * PATCH_XCOUNT + byX].Clear();

  0009d	0f b6 45 ff	 movzx	 eax, BYTE PTR _byY$4[ebp]
  000a1	0f b6 4d fe	 movzx	 ecx, BYTE PTR _byX$3[ebp]
  000a5	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000a8	6b c0 70	 imul	 eax, eax, 112
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8d 8c 01 d8 a5
	06 00		 lea	 ecx, DWORD PTR [ecx+eax+435672]
  000b5	e8 00 00 00 00	 call	 ?Clear@CTerrainPatch@@QAEXXZ ; CTerrainPatch::Clear
  000ba	eb d0		 jmp	 SHORT $LN5@Initialize
$LN6@Initialize:
  000bc	eb b7		 jmp	 SHORT $LN2@Initialize
$LN3@Initialize:

; 66   : 	
; 67   : 	return true;

  000be	b0 01		 mov	 al, 1

; 68   : }

  000c0	c9		 leave
  000c1	c3		 ret	 0
?Initialize@CTerrain@@IAE_NXZ ENDP			; CTerrain::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?RAW_GenerateSplat@CTerrain@@QAEX_N@Z
_TEXT	SEGMENT
_ulRef$1 = -104						; size = 4
_ulRef$2 = -100						; size = 4
_aptr$ = -96						; size = 4
_lTileMapOffset$3 = -92					; size = 4
_rSplat$4 = -88						; size = 4
_x$5 = -84						; size = 4
_y$6 = -80						; size = 4
_byTileR$7 = -73					; size = 1
_byTileL$8 = -72					; size = 1
_byTileB$9 = -71					; size = 1
_byTileT$10 = -70					; size = 1
_byTileBR$11 = -69					; size = 1
_byTileBL$12 = -68					; size = 1
_byTileTR$13 = -67					; size = 1
_byTileTL$14 = -66					; size = 1
_byTileNum$15 = -65					; size = 1
_this$ = -64						; size = 4
_i$16 = -60						; size = 4
_abyAlphaMap$ = -56					; size = 66564
__$ArrayPad$ = 66508					; size = 4
_bBGLoading$ = 66520					; size = 1
?RAW_GenerateSplat@CTerrain@@QAEX_N@Z PROC		; CTerrain::RAW_GenerateSplat, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8d ac 24 30 fc
	fe ff		 lea	 ebp, DWORD PTR [esp-66512]
  00008	b8 38 04 01 00	 mov	 eax, 66616		; 00010438H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 cc 03 01
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 	if (!m_TerrainSplatPatch.m_bNeedsUpdate)

  00022	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00025	0f b6 80 3c a1
	04 00		 movzx	 eax, BYTE PTR [eax+303420]
  0002c	85 c0		 test	 eax, eax
  0002e	75 05		 jne	 SHORT $LN17@RAW_Genera

; 638  : 		return;

  00030	e9 48 03 00 00	 jmp	 $LN1@RAW_Genera
$LN17@RAW_Genera:

; 639  : 
; 640  : 	m_TerrainSplatPatch.m_bNeedsUpdate = false;

  00035	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c6 80 3c a1 04
	00 00		 mov	 BYTE PTR [eax+303420], 0

; 641  : 
; 642  : 	BYTE abyAlphaMap[SPLATALPHA_RAW_XSIZE * SPLATALPHA_RAW_YSIZE];
; 643  : 	BYTE * aptr;
; 644  : 	
; 645  : 	for (DWORD i = 1; i < GetTextureSet()->GetTextureCount(); ++i)

  0003f	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR _i$16[ebp], 1
  00046	eb 07		 jmp	 SHORT $LN4@RAW_Genera
$LN2@RAW_Genera:
  00048	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  0004b	40		 inc	 eax
  0004c	89 45 c4	 mov	 DWORD PTR _i$16[ebp], eax
$LN4@RAW_Genera:
  0004f	e8 00 00 00 00	 call	 ?GetTextureSet@CTerrainImpl@@SAPAVCTextureSet@@XZ ; CTerrainImpl::GetTextureSet
  00054	8b c8		 mov	 ecx, eax
  00056	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
  0005b	39 45 c4	 cmp	 DWORD PTR _i$16[ebp], eax
  0005e	0f 83 19 03 00
	00		 jae	 $LN1@RAW_Genera

; 646  : 	{
; 647  : 		TTerainSplat & rSplat = m_TerrainSplatPatch.Splats[i];

  00064	6b 45 c4 0c	 imul	 eax, DWORD PTR _i$16[ebp], 12
  00068	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8d 84 01 3c 95
	04 00		 lea	 eax, DWORD PTR [ecx+eax+300348]
  00072	89 45 a8	 mov	 DWORD PTR _rSplat$4[ebp], eax

; 648  : 		
; 649  : 		if (rSplat.NeedsUpdate)

  00075	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00078	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0007c	0f 84 f6 02 00
	00		 je	 $LN18@RAW_Genera

; 650  : 		{
; 651  : 			if (m_TerrainSplatPatch.TileCount[i] > 0)

  00082	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  00085	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 bc 81 3c 91
	03 00 00	 cmp	 DWORD PTR [ecx+eax*4+233788], 0
  00090	0f 86 77 02 00
	00		 jbe	 $LN19@RAW_Genera

; 652  : 			{
; 653  : 				if (rSplat.Active)   // We already have an alpha map which needs to be updated

  00096	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00099	83 38 00	 cmp	 DWORD PTR [eax], 0
  0009c	74 56		 je	 SHORT $LN21@RAW_Genera

; 654  : 				{
; 655  : 					if (m_lpAlphaTexture[i])

  0009e	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000a1	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	83 7c 81 04 00	 cmp	 DWORD PTR [ecx+eax*4+4], 0
  000a9	74 37		 je	 SHORT $LN22@RAW_Genera
$LN7@RAW_Genera:

; 656  : 					{
; 657  : 						ULONG ulRef;
; 658  : 						do
; 659  : 						{
; 660  : 							ulRef = m_lpAlphaTexture[i]->Release();

  000ab	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000ae	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  000b5	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  000b8	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	ff 74 8a 04	 push	 DWORD PTR [edx+ecx*4+4]
  000c1	ff 50 08	 call	 DWORD PTR [eax+8]
  000c4	89 45 9c	 mov	 DWORD PTR _ulRef$2[ebp], eax

; 661  : 							if (ulRef > 0)

  000c7	83 7d 9c 00	 cmp	 DWORD PTR _ulRef$2[ebp], 0
  000cb	76 0f		 jbe	 SHORT $LN5@RAW_Genera

; 662  : 								TraceError(" CTerrain::RAW_GenerateSplat - TileCount > 0 : Alpha Texture Release(%d) ERROR", ulRef);

  000cd	ff 75 9c	 push	 DWORD PTR _ulRef$2[ebp]
  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0EP@MGCDBJBL@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@
  000d5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000da	59		 pop	 ecx
  000db	59		 pop	 ecx
$LN5@RAW_Genera:

; 663  : 						} while(ulRef > 0);

  000dc	83 7d 9c 00	 cmp	 DWORD PTR _ulRef$2[ebp], 0
  000e0	77 c9		 ja	 SHORT $LN7@RAW_Genera
$LN22@RAW_Genera:

; 664  : 					}
; 665  : 
; 666  : 					rSplat.pd3dTexture = m_lpAlphaTexture[i] = NULL;

  000e2	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  000e5	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	83 64 81 04 00	 and	 DWORD PTR [ecx+eax*4+4], 0
  000ed	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  000f0	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN21@RAW_Genera:

; 667  :  				}
; 668  : 
; 669  : 				rSplat.Active = 1;

  000f4	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  000f7	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 670  : 				rSplat.NeedsUpdate = 0;

  000fd	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00100	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 671  : 
; 672  : 				aptr = abyAlphaMap;

  00104	8d 45 c8	 lea	 eax, DWORD PTR _abyAlphaMap$[ebp]
  00107	89 45 a0	 mov	 DWORD PTR _aptr$[ebp], eax

; 673  : 
; 674  : 				for (long y = 0; y < SPLATALPHA_RAW_YSIZE; ++y)

  0010a	83 65 b0 00	 and	 DWORD PTR _y$6[ebp], 0
  0010e	eb 07		 jmp	 SHORT $LN10@RAW_Genera
$LN8@RAW_Genera:
  00110	8b 45 b0	 mov	 eax, DWORD PTR _y$6[ebp]
  00113	40		 inc	 eax
  00114	89 45 b0	 mov	 DWORD PTR _y$6[ebp], eax
$LN10@RAW_Genera:
  00117	81 7d b0 02 01
	00 00		 cmp	 DWORD PTR _y$6[ebp], 258 ; 00000102H
  0011e	0f 8d c8 01 00
	00		 jge	 $LN9@RAW_Genera

; 675  : 				{
; 676  : 					for (long x = 0; x < SPLATALPHA_RAW_XSIZE; ++x)

  00124	83 65 ac 00	 and	 DWORD PTR _x$5[ebp], 0
  00128	eb 07		 jmp	 SHORT $LN13@RAW_Genera
$LN11@RAW_Genera:
  0012a	8b 45 ac	 mov	 eax, DWORD PTR _x$5[ebp]
  0012d	40		 inc	 eax
  0012e	89 45 ac	 mov	 DWORD PTR _x$5[ebp], eax
$LN13@RAW_Genera:
  00131	81 7d ac 02 01
	00 00		 cmp	 DWORD PTR _x$5[ebp], 258 ; 00000102H
  00138	0f 8d a9 01 00
	00		 jge	 $LN12@RAW_Genera

; 677  : 					{
; 678  : 						long lTileMapOffset = y * TILEMAP_RAW_XSIZE + x;

  0013e	69 45 b0 02 01
	00 00		 imul	 eax, DWORD PTR _y$6[ebp], 258
  00145	03 45 ac	 add	 eax, DWORD PTR _x$5[ebp]
  00148	89 45 a4	 mov	 DWORD PTR _lTileMapOffset$3[ebp], eax

; 679  : 						 
; 680  : 						BYTE byTileNum = m_abyTileMap[lTileMapOffset];

  0014b	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  00151	8a 80 16 8a 00
	00		 mov	 al, BYTE PTR [eax+35350]
  00157	88 45 bf	 mov	 BYTE PTR _byTileNum$15[ebp], al

; 681  : 						if (byTileNum == i)

  0015a	0f b6 45 bf	 movzx	 eax, BYTE PTR _byTileNum$15[ebp]
  0015e	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  00161	75 0b		 jne	 SHORT $LN24@RAW_Genera

; 682  :  							*aptr = 0xFF;

  00163	8b 45 a0	 mov	 eax, DWORD PTR _aptr$[ebp]
  00166	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  00169	e9 6d 01 00 00	 jmp	 $LN25@RAW_Genera
$LN24@RAW_Genera:

; 683  : 						else if (byTileNum > i)

  0016e	0f b6 45 bf	 movzx	 eax, BYTE PTR _byTileNum$15[ebp]
  00172	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  00175	0f 86 5a 01 00
	00		 jbe	 $LN26@RAW_Genera

; 684  : 						{
; 685  : 							BYTE byTileTL, byTileTR, byTileBL, byTileBR, byTileT, byTileB, byTileL, byTileR;
; 686  : 
; 687  : 							if ( x > 0 && y > 0 )

  0017b	83 7d ac 00	 cmp	 DWORD PTR _x$5[ebp], 0
  0017f	7e 17		 jle	 SHORT $LN28@RAW_Genera
  00181	83 7d b0 00	 cmp	 DWORD PTR _y$6[ebp], 0
  00185	7e 11		 jle	 SHORT $LN28@RAW_Genera

; 688  : 								byTileTL = m_abyTileMap[lTileMapOffset - TILEMAP_RAW_YSIZE - 1];

  00187	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0018a	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  0018d	8a 80 13 89 00
	00		 mov	 al, BYTE PTR [eax+35091]
  00193	88 45 be	 mov	 BYTE PTR _byTileTL$14[ebp], al
  00196	eb 04		 jmp	 SHORT $LN29@RAW_Genera
$LN28@RAW_Genera:

; 689  : 							else
; 690  : 								byTileTL = 0;

  00198	c6 45 be 00	 mov	 BYTE PTR _byTileTL$14[ebp], 0
$LN29@RAW_Genera:

; 691  : 							if ( x < (SPLATALPHA_RAW_XSIZE - 1) && y > 0 )

  0019c	81 7d ac 01 01
	00 00		 cmp	 DWORD PTR _x$5[ebp], 257 ; 00000101H
  001a3	7d 17		 jge	 SHORT $LN30@RAW_Genera
  001a5	83 7d b0 00	 cmp	 DWORD PTR _y$6[ebp], 0
  001a9	7e 11		 jle	 SHORT $LN30@RAW_Genera

; 692  : 								byTileTR = m_abyTileMap[lTileMapOffset - TILEMAP_RAW_YSIZE + 1];

  001ab	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001ae	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  001b1	8a 80 15 89 00
	00		 mov	 al, BYTE PTR [eax+35093]
  001b7	88 45 bd	 mov	 BYTE PTR _byTileTR$13[ebp], al
  001ba	eb 04		 jmp	 SHORT $LN31@RAW_Genera
$LN30@RAW_Genera:

; 693  : 							else
; 694  : 								byTileTR = 0;

  001bc	c6 45 bd 00	 mov	 BYTE PTR _byTileTR$13[ebp], 0
$LN31@RAW_Genera:

; 695  : 							if ( x > 0 && y < (SPLATALPHA_RAW_YSIZE - 1) )

  001c0	83 7d ac 00	 cmp	 DWORD PTR _x$5[ebp], 0
  001c4	7e 1a		 jle	 SHORT $LN32@RAW_Genera
  001c6	81 7d b0 01 01
	00 00		 cmp	 DWORD PTR _y$6[ebp], 257 ; 00000101H
  001cd	7d 11		 jge	 SHORT $LN32@RAW_Genera

; 696  : 								byTileBL = m_abyTileMap[lTileMapOffset + TILEMAP_RAW_YSIZE - 1];

  001cf	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  001d5	8a 80 17 8b 00
	00		 mov	 al, BYTE PTR [eax+35607]
  001db	88 45 bc	 mov	 BYTE PTR _byTileBL$12[ebp], al
  001de	eb 04		 jmp	 SHORT $LN33@RAW_Genera
$LN32@RAW_Genera:

; 697  : 							else
; 698  : 								byTileBL = 0;

  001e0	c6 45 bc 00	 mov	 BYTE PTR _byTileBL$12[ebp], 0
$LN33@RAW_Genera:

; 699  : 							if ( x < (SPLATALPHA_RAW_XSIZE - 1) && y < (SPLATALPHA_RAW_YSIZE - 1) )

  001e4	81 7d ac 01 01
	00 00		 cmp	 DWORD PTR _x$5[ebp], 257 ; 00000101H
  001eb	7d 1a		 jge	 SHORT $LN34@RAW_Genera
  001ed	81 7d b0 01 01
	00 00		 cmp	 DWORD PTR _y$6[ebp], 257 ; 00000101H
  001f4	7d 11		 jge	 SHORT $LN34@RAW_Genera

; 700  : 								byTileBR = m_abyTileMap[lTileMapOffset + TILEMAP_RAW_YSIZE + 1];

  001f6	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  001f9	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  001fc	8a 80 19 8b 00
	00		 mov	 al, BYTE PTR [eax+35609]
  00202	88 45 bb	 mov	 BYTE PTR _byTileBR$11[ebp], al
  00205	eb 04		 jmp	 SHORT $LN35@RAW_Genera
$LN34@RAW_Genera:

; 701  : 							else
; 702  : 								byTileBR = 0;

  00207	c6 45 bb 00	 mov	 BYTE PTR _byTileBR$11[ebp], 0
$LN35@RAW_Genera:

; 703  : 							if ( y > 0 )

  0020b	83 7d b0 00	 cmp	 DWORD PTR _y$6[ebp], 0
  0020f	7e 11		 jle	 SHORT $LN36@RAW_Genera

; 704  : 								byTileT = m_abyTileMap[lTileMapOffset - TILEMAP_RAW_YSIZE];

  00211	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00214	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  00217	8a 80 14 89 00
	00		 mov	 al, BYTE PTR [eax+35092]
  0021d	88 45 ba	 mov	 BYTE PTR _byTileT$10[ebp], al
  00220	eb 04		 jmp	 SHORT $LN37@RAW_Genera
$LN36@RAW_Genera:

; 705  : 							else
; 706  : 								byTileT = 0;

  00222	c6 45 ba 00	 mov	 BYTE PTR _byTileT$10[ebp], 0
$LN37@RAW_Genera:

; 707  : 							if ( y < (SPLATALPHA_RAW_YSIZE - 1) )

  00226	81 7d b0 01 01
	00 00		 cmp	 DWORD PTR _y$6[ebp], 257 ; 00000101H
  0022d	7d 11		 jge	 SHORT $LN38@RAW_Genera

; 708  : 								byTileB = m_abyTileMap[lTileMapOffset + TILEMAP_RAW_YSIZE];

  0022f	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00232	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  00235	8a 80 18 8b 00
	00		 mov	 al, BYTE PTR [eax+35608]
  0023b	88 45 b9	 mov	 BYTE PTR _byTileB$9[ebp], al
  0023e	eb 04		 jmp	 SHORT $LN39@RAW_Genera
$LN38@RAW_Genera:

; 709  : 							else
; 710  : 								byTileB = 0;

  00240	c6 45 b9 00	 mov	 BYTE PTR _byTileB$9[ebp], 0
$LN39@RAW_Genera:

; 711  : 							if ( x > 0 )

  00244	83 7d ac 00	 cmp	 DWORD PTR _x$5[ebp], 0
  00248	7e 11		 jle	 SHORT $LN40@RAW_Genera

; 712  : 								byTileL = m_abyTileMap[lTileMapOffset - 1];

  0024a	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  00250	8a 80 15 8a 00
	00		 mov	 al, BYTE PTR [eax+35349]
  00256	88 45 b8	 mov	 BYTE PTR _byTileL$8[ebp], al
  00259	eb 04		 jmp	 SHORT $LN41@RAW_Genera
$LN40@RAW_Genera:

; 713  : 							else
; 714  : 								byTileL = 0;

  0025b	c6 45 b8 00	 mov	 BYTE PTR _byTileL$8[ebp], 0
$LN41@RAW_Genera:

; 715  : 							if ( x < (SPLATALPHA_RAW_XSIZE - 1) )

  0025f	81 7d ac 01 01
	00 00		 cmp	 DWORD PTR _x$5[ebp], 257 ; 00000101H
  00266	7d 11		 jge	 SHORT $LN42@RAW_Genera

; 716  : 								byTileR = m_abyTileMap[lTileMapOffset + 1];

  00268	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	03 45 a4	 add	 eax, DWORD PTR _lTileMapOffset$3[ebp]
  0026e	8a 80 17 8a 00
	00		 mov	 al, BYTE PTR [eax+35351]
  00274	88 45 b7	 mov	 BYTE PTR _byTileR$7[ebp], al
  00277	eb 04		 jmp	 SHORT $LN43@RAW_Genera
$LN42@RAW_Genera:

; 717  : 							else
; 718  : 								byTileR = 0;

  00279	c6 45 b7 00	 mov	 BYTE PTR _byTileR$7[ebp], 0
$LN43@RAW_Genera:

; 719  : 							
; 720  : 							if (byTileTL == i || byTileTR == i || byTileBL == i || byTileBR == i ||
; 721  : 								byTileT == i || byTileB == i || byTileL == i || byTileR == i)

  0027d	0f b6 45 be	 movzx	 eax, BYTE PTR _byTileTL$14[ebp]
  00281	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  00284	74 3f		 je	 SHORT $LN46@RAW_Genera
  00286	0f b6 45 bd	 movzx	 eax, BYTE PTR _byTileTR$13[ebp]
  0028a	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  0028d	74 36		 je	 SHORT $LN46@RAW_Genera
  0028f	0f b6 45 bc	 movzx	 eax, BYTE PTR _byTileBL$12[ebp]
  00293	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  00296	74 2d		 je	 SHORT $LN46@RAW_Genera
  00298	0f b6 45 bb	 movzx	 eax, BYTE PTR _byTileBR$11[ebp]
  0029c	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  0029f	74 24		 je	 SHORT $LN46@RAW_Genera
  002a1	0f b6 45 ba	 movzx	 eax, BYTE PTR _byTileT$10[ebp]
  002a5	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  002a8	74 1b		 je	 SHORT $LN46@RAW_Genera
  002aa	0f b6 45 b9	 movzx	 eax, BYTE PTR _byTileB$9[ebp]
  002ae	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  002b1	74 12		 je	 SHORT $LN46@RAW_Genera
  002b3	0f b6 45 b8	 movzx	 eax, BYTE PTR _byTileL$8[ebp]
  002b7	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  002ba	74 09		 je	 SHORT $LN46@RAW_Genera
  002bc	0f b6 45 b7	 movzx	 eax, BYTE PTR _byTileR$7[ebp]
  002c0	3b 45 c4	 cmp	 eax, DWORD PTR _i$16[ebp]
  002c3	75 08		 jne	 SHORT $LN44@RAW_Genera
$LN46@RAW_Genera:

; 722  :  								*aptr = 0xFF;

  002c5	8b 45 a0	 mov	 eax, DWORD PTR _aptr$[ebp]
  002c8	c6 00 ff	 mov	 BYTE PTR [eax], 255	; 000000ffH
  002cb	eb 06		 jmp	 SHORT $LN45@RAW_Genera
$LN44@RAW_Genera:

; 723  : 							else
; 724  :  								*aptr = 0x00;

  002cd	8b 45 a0	 mov	 eax, DWORD PTR _aptr$[ebp]
  002d0	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN45@RAW_Genera:

; 725  : 						}

  002d3	eb 06		 jmp	 SHORT $LN25@RAW_Genera
$LN26@RAW_Genera:

; 726  : 						else
; 727  :  							*aptr = 0x00;

  002d5	8b 45 a0	 mov	 eax, DWORD PTR _aptr$[ebp]
  002d8	c6 00 00	 mov	 BYTE PTR [eax], 0
$LN25@RAW_Genera:

; 728  : 
; 729  :  						++aptr;

  002db	8b 45 a0	 mov	 eax, DWORD PTR _aptr$[ebp]
  002de	40		 inc	 eax
  002df	89 45 a0	 mov	 DWORD PTR _aptr$[ebp], eax

; 730  : 					}

  002e2	e9 43 fe ff ff	 jmp	 $LN11@RAW_Genera
$LN12@RAW_Genera:

; 731  : 				}

  002e7	e9 24 fe ff ff	 jmp	 $LN8@RAW_Genera
$LN9@RAW_Genera:

; 732  : 
; 733  : 
; 734  : 				rSplat.pd3dTexture = AddTexture32(i, abyAlphaMap, SPLATALPHA_RAW_XSIZE, SPLATALPHA_RAW_YSIZE);

  002ec	68 02 01 00 00	 push	 258			; 00000102H
  002f1	68 02 01 00 00	 push	 258			; 00000102H
  002f6	8d 45 c8	 lea	 eax, DWORD PTR _abyAlphaMap$[ebp]
  002f9	50		 push	 eax
  002fa	ff 75 c4	 push	 DWORD PTR _i$16[ebp]
  002fd	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	e8 00 00 00 00	 call	 ?AddTexture32@CTerrain@@IAEPAUIDirect3DTexture8@@EPAEJJ@Z ; CTerrain::AddTexture32
  00305	8b 4d a8	 mov	 ecx, DWORD PTR _rSplat$4[ebp]
  00308	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 735  : 			}

  0030b	eb 6b		 jmp	 SHORT $LN18@RAW_Genera
$LN19@RAW_Genera:

; 736  : 			else
; 737  : 			{
; 738  : 				if (rSplat.Active)

  0030d	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00310	83 38 00	 cmp	 DWORD PTR [eax], 0
  00313	74 56		 je	 SHORT $LN47@RAW_Genera

; 739  : 				{
; 740  : 					if (m_lpAlphaTexture[i])

  00315	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  00318	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0031b	83 7c 81 04 00	 cmp	 DWORD PTR [ecx+eax*4+4], 0
  00320	74 37		 je	 SHORT $LN48@RAW_Genera
$LN16@RAW_Genera:

; 741  : 					{
; 742  : 						ULONG ulRef;
; 743  : 						do
; 744  : 						{
; 745  : 							ulRef = m_lpAlphaTexture[i]->Release();

  00322	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  00325	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00328	8b 44 81 04	 mov	 eax, DWORD PTR [ecx+eax*4+4]
  0032c	8b 4d c4	 mov	 ecx, DWORD PTR _i$16[ebp]
  0032f	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00332	8b 00		 mov	 eax, DWORD PTR [eax]
  00334	ff 74 8a 04	 push	 DWORD PTR [edx+ecx*4+4]
  00338	ff 50 08	 call	 DWORD PTR [eax+8]
  0033b	89 45 98	 mov	 DWORD PTR _ulRef$1[ebp], eax

; 746  : 							if (ulRef > 0)

  0033e	83 7d 98 00	 cmp	 DWORD PTR _ulRef$1[ebp], 0
  00342	76 0f		 jbe	 SHORT $LN14@RAW_Genera

; 747  : 								TraceError(" CTerrain::RAW_GenerateSplat - TileDount 0 : Alpha Texture Release(%d) ERROR", ulRef);

  00344	ff 75 98	 push	 DWORD PTR _ulRef$1[ebp]
  00347	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@EFOOENIC@?5CTerrain?3?3RAW_GenerateSplat?5?9?5@
  0034c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00351	59		 pop	 ecx
  00352	59		 pop	 ecx
$LN14@RAW_Genera:

; 748  : 						} while(ulRef > 0);

  00353	83 7d 98 00	 cmp	 DWORD PTR _ulRef$1[ebp], 0
  00357	77 c9		 ja	 SHORT $LN16@RAW_Genera
$LN48@RAW_Genera:

; 749  : 					}
; 750  : 					
; 751  : 					rSplat.pd3dTexture = m_lpAlphaTexture[i] = NULL;

  00359	8b 45 c4	 mov	 eax, DWORD PTR _i$16[ebp]
  0035c	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0035f	83 64 81 04 00	 and	 DWORD PTR [ecx+eax*4+4], 0
  00364	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00367	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN47@RAW_Genera:

; 752  :  				}
; 753  : 				rSplat.NeedsUpdate = 0;

  0036b	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  0036e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 754  : 				rSplat.Active = 0;

  00372	8b 45 a8	 mov	 eax, DWORD PTR _rSplat$4[ebp]
  00375	83 20 00	 and	 DWORD PTR [eax], 0
$LN18@RAW_Genera:

; 755  : 			}
; 756  : 		}
; 757  : 	}

  00378	e9 cb fc ff ff	 jmp	 $LN2@RAW_Genera
$LN1@RAW_Genera:

; 758  : }

  0037d	8b 8d cc 03 01
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00383	33 cd		 xor	 ecx, ebp
  00385	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0038a	81 c5 d0 03 01
	00		 add	 ebp, 66512		; 000103d0H
  00390	c9		 leave
  00391	c2 04 00	 ret	 4
?RAW_GenerateSplat@CTerrain@@QAEX_N@Z ENDP		; CTerrain::RAW_GenerateSplat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?SetCoordinate@CTerrain@@QAEXGG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wCoordX$ = 8						; size = 2
_wCoordY$ = 12						; size = 2
?SetCoordinate@CTerrain@@QAEXGG@Z PROC			; CTerrain::SetCoordinate, COMDAT
; _this$ = ecx

; 907  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 908  : 	m_wX = wCoordX;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _wCoordX$[ebp]
  0000e	66 89 88 6c a5
	06 00		 mov	 WORD PTR [eax+435564], cx

; 909  : 	m_wY = wCoordY;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	66 8b 4d 0c	 mov	 cx, WORD PTR _wCoordY$[ebp]
  0001c	66 89 88 6e a5
	06 00		 mov	 WORD PTR [eax+435566], cx

; 910  : }

  00023	c9		 leave
  00024	c2 08 00	 ret	 8
?SetCoordinate@CTerrain@@QAEXGG@Z ENDP			; CTerrain::SetCoordinate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?DeallocateMarkedSplats@CTerrain@@QAEXXZ
_TEXT	SEGMENT
_rSplat$ = -12						; size = 4
_ulRef$1 = -8						; size = 4
_this$ = -4						; size = 4
?DeallocateMarkedSplats@CTerrain@@QAEXXZ PROC		; CTerrain::DeallocateMarkedSplats, COMDAT
; _this$ = ecx

; 1177 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1178 : 	TTerainSplat & rSplat = m_MarkedSplatPatch.Splats[0];

  00009	6a 0c		 push	 12			; 0000000cH
  0000b	58		 pop	 eax
  0000c	6b c0 00	 imul	 eax, eax, 0
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8d 84 01 dc c5
	07 00		 lea	 eax, DWORD PTR [ecx+eax+509404]
  00019	89 45 f4	 mov	 DWORD PTR _rSplat$[ebp], eax

; 1179 : 	if (m_lpMarkedTexture)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 b8 e0 d1 07
	00 00		 cmp	 DWORD PTR [eax+512480], 0
  00026	74 20		 je	 SHORT $LN5@Deallocate
$LN4@Deallocate:

; 1180 : 	{
; 1181 : 		ULONG ulRef;
; 1182 : 		do
; 1183 : 		{
; 1184 : 			ulRef = m_lpMarkedTexture->Release();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 80 e0 d1 07
	00		 mov	 eax, DWORD PTR [eax+512480]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	ff b1 e0 d1 07
	00		 push	 DWORD PTR [ecx+512480]
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]
  0003f	89 45 f8	 mov	 DWORD PTR _ulRef$1[ebp], eax

; 1185 : 		} while(ulRef > 0);

  00042	83 7d f8 00	 cmp	 DWORD PTR _ulRef$1[ebp], 0
  00046	77 e0		 ja	 SHORT $LN4@Deallocate
$LN5@Deallocate:

; 1186 : 	}
; 1187 : 
; 1188 : 	rSplat.pd3dTexture = NULL;

  00048	8b 45 f4	 mov	 eax, DWORD PTR _rSplat$[ebp]
  0004b	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 1189 : 	m_lpMarkedTexture = NULL;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 a0 e0 d1 07
	00 00		 and	 DWORD PTR [eax+512480], 0

; 1190 : 	m_bMarked = FALSE;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 a0 d8 c1 06
	00 00		 and	 DWORD PTR [eax+442840], 0

; 1191 : 
; 1192 : 	memset(&m_MarkedSplatPatch, 0, sizeof(m_MarkedSplatPatch));

  00063	68 04 10 01 00	 push	 69636			; 00011004H
  00068	6a 00		 push	 0
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	05 dc c1 06 00	 add	 eax, 442844		; 0006c1dcH
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 _memset
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1193 : }

  0007b	c9		 leave
  0007c	c3		 ret	 0
?DeallocateMarkedSplats@CTerrain@@QAEXXZ ENDP		; CTerrain::DeallocateMarkedSplats
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z
_TEXT	SEGMENT
_d3dlr$ = -24						; size = 8
_rAttrSplat$ = -16					; size = 4
_ulRef$1 = -12						; size = 4
_hr$ = -8						; size = 4
_this$ = -4						; size = 4
_pbyAlphaMap$ = 8					; size = 4
?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z PROC		; CTerrain::AllocateMarkedSplats, COMDAT
; _this$ = ecx

; 1141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1142 : 	TTerainSplat & rAttrSplat = m_MarkedSplatPatch.Splats[0];

  00009	6a 0c		 push	 12			; 0000000cH
  0000b	58		 pop	 eax
  0000c	6b c0 00	 imul	 eax, eax, 0
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8d 84 01 dc c5
	07 00		 lea	 eax, DWORD PTR [ecx+eax+509404]
  00019	89 45 f0	 mov	 DWORD PTR _rAttrSplat$[ebp], eax

; 1143 : 	HRESULT hr;
; 1144 : 
; 1145 : 	if (m_lpMarkedTexture)

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 b8 e0 d1 07
	00 00		 cmp	 DWORD PTR [eax+512480], 0
  00026	74 20		 je	 SHORT $LN7@AllocateMa
$LN4@AllocateMa:

; 1146 : 	{
; 1147 : 		ULONG ulRef;
; 1148 : 		do
; 1149 : 		{
; 1150 : 			ulRef = m_lpMarkedTexture->Release();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 80 e0 d1 07
	00		 mov	 eax, DWORD PTR [eax+512480]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	ff b1 e0 d1 07
	00		 push	 DWORD PTR [ecx+512480]
  0003c	ff 50 08	 call	 DWORD PTR [eax+8]
  0003f	89 45 f4	 mov	 DWORD PTR _ulRef$1[ebp], eax

; 1151 : 		} while(ulRef > 0);

  00042	83 7d f4 00	 cmp	 DWORD PTR _ulRef$1[ebp], 0
  00046	77 e0		 ja	 SHORT $LN4@AllocateMa
$LN7@AllocateMa:

; 1152 : 	}
; 1153 : 
; 1154 : 	do
; 1155 : 	{
; 1156 : 		hr = ms_lpd3dDevice->CreateTexture(ATTRMAP_XSIZE, ATTRMAP_YSIZE, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &m_lpMarkedTexture);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	05 e0 d1 07 00	 add	 eax, 512480		; 0007d1e0H
  00050	50		 push	 eax
  00051	6a 01		 push	 1
  00053	6a 15		 push	 21			; 00000015H
  00055	6a 00		 push	 0
  00057	6a 01		 push	 1
  00059	68 00 01 00 00	 push	 256			; 00000100H
  0005e	68 00 01 00 00	 push	 256			; 00000100H
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00070	ff 50 50	 call	 DWORD PTR [eax+80]
  00073	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1157 : 	} while(FAILED(hr));

  00076	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  0007a	7c cc		 jl	 SHORT $LN7@AllocateMa
$LN10@AllocateMa:

; 1158 : 
; 1159 : 	D3DLOCKED_RECT d3dlr;
; 1160 : 	do
; 1161 : 	{
; 1162 : 		hr = m_lpMarkedTexture->LockRect(0, &d3dlr, 0, 0);

  0007c	6a 00		 push	 0
  0007e	6a 00		 push	 0
  00080	8d 45 e8	 lea	 eax, DWORD PTR _d3dlr$[ebp]
  00083	50		 push	 eax
  00084	6a 00		 push	 0
  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 80 e0 d1 07
	00		 mov	 eax, DWORD PTR [eax+512480]
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	ff b1 e0 d1 07
	00		 push	 DWORD PTR [ecx+512480]
  0009a	ff 50 40	 call	 DWORD PTR [eax+64]
  0009d	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1163 : 	} while(FAILED(hr));

  000a0	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000a4	7c d6		 jl	 SHORT $LN10@AllocateMa

; 1164 : 
; 1165 : 	PutImage32(pbyAlphaMap, (BYTE*) d3dlr.pBits, ATTRMAP_XSIZE, d3dlr.Pitch, ATTRMAP_XSIZE, ATTRMAP_YSIZE);

  000a6	6a 00		 push	 0
  000a8	68 00 01 00 00	 push	 256			; 00000100H
  000ad	68 00 01 00 00	 push	 256			; 00000100H
  000b2	ff 75 e8	 push	 DWORD PTR _d3dlr$[ebp]
  000b5	68 00 01 00 00	 push	 256			; 00000100H
  000ba	ff 75 ec	 push	 DWORD PTR _d3dlr$[ebp+4]
  000bd	ff 75 08	 push	 DWORD PTR _pbyAlphaMap$[ebp]
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ?PutImage32@CTerrain@@IAEXPAE0JJJJ_N@Z ; CTerrain::PutImage32
$LN13@AllocateMa:

; 1166 : 
; 1167 : 	do
; 1168 : 	{
; 1169 : 		hr = m_lpMarkedTexture->UnlockRect(0);

  000c8	6a 00		 push	 0
  000ca	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 80 e0 d1 07
	00		 mov	 eax, DWORD PTR [eax+512480]
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	ff b1 e0 d1 07
	00		 push	 DWORD PTR [ecx+512480]
  000de	ff 50 44	 call	 DWORD PTR [eax+68]
  000e1	89 45 f8	 mov	 DWORD PTR _hr$[ebp], eax

; 1170 : 	} while(FAILED(hr));

  000e4	83 7d f8 00	 cmp	 DWORD PTR _hr$[ebp], 0
  000e8	7c de		 jl	 SHORT $LN13@AllocateMa

; 1171 : 
; 1172 : 	rAttrSplat.pd3dTexture = m_lpMarkedTexture;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR _rAttrSplat$[ebp]
  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	8b 89 e0 d1 07
	00		 mov	 ecx, DWORD PTR [ecx+512480]
  000f6	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1173 : 	m_bMarked = true;

  000f9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	c7 80 d8 c1 06
	00 01 00 00 00	 mov	 DWORD PTR [eax+442840], 1

; 1174 : }

  00106	c9		 leave
  00107	c2 04 00	 ret	 4
?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z ENDP		; CTerrain::AllocateMarkedSplats
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z
_TEXT	SEGMENT
_dwStart$ = -20						; size = 4
_pImage$ = -16						; size = 4
$T1 = -12						; size = 4
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_c_pchMiniMapFileName$ = 8				; size = 4
?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z PROC		; CTerrain::LoadMiniMapTexture, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 72   : 	DWORD dwStart = ELTimer_GetMSec();

  00009	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000e	89 45 ec	 mov	 DWORD PTR _dwStart$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00016	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 73   : 	CGraphicImage * pImage = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer(c_pchMiniMapFileName);

  00019	ff 75 08	 push	 DWORD PTR _c_pchMiniMapFileName$[ebp]
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00024	89 45 f0	 mov	 DWORD PTR _pImage$[ebp], eax

; 74   : 	m_MiniMapGraphicImageInstance.SetImagePointer(pImage);

  00027	ff 75 f0	 push	 DWORD PTR _pImage$[ebp]
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  00033	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 75   : 	
; 76   : 	if (!m_MiniMapGraphicImageInstance.GetTexturePointer()->IsEmpty())

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  00041	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00046	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
  00049	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR tv80[ebp]
  00051	ff 50 04	 call	 DWORD PTR [eax+4]
  00054	0f b6 c0	 movzx	 eax, al
  00057	85 c0		 test	 eax, eax
  00059	75 35		 jne	 SHORT $LN2@LoadMiniMa

; 77   : 	{
; 78   : 		m_lpMiniMapTexture = m_MiniMapGraphicImageInstance.GetTexturePointer()->GetD3DTexture();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  00064	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00069	8b c8		 mov	 ecx, eax
  0006b	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 81 b4 a5 06
	00		 mov	 DWORD PTR [ecx+435636], eax

; 79   : 		Tracef("CTerrain::LoadMiniMapTexture %d ms\n", ELTimer_GetMSec() - dwStart);

  00079	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0007e	2b 45 ec	 sub	 eax, DWORD PTR _dwStart$[ebp]
  00081	50		 push	 eax
  00082	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@KIPOLACJ@CTerrain?3?3LoadMiniMapTexture?5?$CFd@
  00087	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0008c	59		 pop	 ecx
  0008d	59		 pop	 ecx

; 80   : 	}

  0008e	eb 15		 jmp	 SHORT $LN1@LoadMiniMa
$LN2@LoadMiniMa:

; 81   : 	else
; 82   : 	{
; 83   : 		Tracef(" CTerrain::LoadMiniMapTexture - MiniMapTexture Error");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NCADIKFN@?5CTerrain?3?3LoadMiniMapTexture?5?9@
  00095	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0009a	59		 pop	 ecx

; 84   : 		m_lpMiniMapTexture = NULL;

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	83 a0 b4 a5 06
	00 00		 and	 DWORD PTR [eax+435636], 0
$LN1@LoadMiniMa:

; 85   : 	}
; 86   : }

  000a5	c9		 leave
  000a6	c2 04 00	 ret	 4
?LoadMiniMapTexture@CTerrain@@QAEXPBD@Z ENDP		; CTerrain::LoadMiniMapTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?LoadShadowMap@CTerrain@@QAE_NPBD@Z
_TEXT	SEGMENT
_dwStart$ = -36						; size = 4
_this$ = -32						; size = 4
_c_pvData$ = -28					; size = 4
$T2 = -24						; size = 4
_dwShadowMapSize$ = -20					; size = 4
$T3 = -15						; size = 1
$T4 = -14						; size = 1
$T5 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_file$ = 0						; size = 324
__$ArrayPad$ = 324					; size = 4
_c_pszFileName$ = 336					; size = 4
?LoadShadowMap@CTerrain@@QAE_NPBD@Z PROC		; CTerrain::LoadShadowMap, COMDAT
; _this$ = ecx

; 105  : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?LoadShadowMap@CTerrain@@QAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 18	 sub	 esp, 24			; 00000018H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 106  : 	DWORD dwStart = ELTimer_GetMSec();

  00039	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0003e	89 45 dc	 mov	 DWORD PTR _dwStart$[ebp], eax

; 107  : 	Tracef("LoadShadowMap %s ", c_pszFileName);

  00041	ff b5 50 01 00
	00		 push	 DWORD PTR _c_pszFileName$[ebp]
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DNLHKNND@LoadShadowMap?5?$CFs?5@
  0004c	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx

; 108  : 
; 109  : 	CMappedFile file;

  00053	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00056	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  0005b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0005f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00064	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 112  : 	if (!CEterPackManager::Instance().Get(file, c_pszFileName, &c_pvData))

  00067	8d 45 e4	 lea	 eax, DWORD PTR _c_pvData$[ebp]
  0006a	50		 push	 eax
  0006b	ff b5 50 01 00
	00		 push	 DWORD PTR _c_pszFileName$[ebp]
  00071	8d 45 00	 lea	 eax, DWORD PTR _file$[ebp]
  00074	50		 push	 eax
  00075	8b 4d e8	 mov	 ecx, DWORD PTR $T2[ebp]
  00078	e8 00 00 00 00	 call	 ?Get@CEterPackManager@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ; CEterPackManager::Get
  0007d	0f b6 c0	 movzx	 eax, al
  00080	85 c0		 test	 eax, eax
  00082	75 27		 jne	 SHORT $LN2@LoadShadow

; 113  : 	{
; 114  : 		TraceError(" CTerrain::LoadShadowMap - %s OPEN ERROR", c_pszFileName);

  00084	ff b5 50 01 00
	00		 push	 DWORD PTR _c_pszFileName$[ebp]
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@CPMONPNA@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5O@
  0008f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00094	59		 pop	 ecx
  00095	59		 pop	 ecx

; 115  : 		return false;

  00096	c6 45 f3 00	 mov	 BYTE PTR $T5[ebp], 0
  0009a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000a6	8a 45 f3	 mov	 al, BYTE PTR $T5[ebp]
  000a9	eb 7a		 jmp	 SHORT $LN1@LoadShadow
$LN2@LoadShadow:

; 116  : 	}
; 117  : 
; 118  : 	DWORD dwShadowMapSize = sizeof(WORD) * 256 * 256;

  000ab	c7 45 ec 00 00
	02 00		 mov	 DWORD PTR _dwShadowMapSize$[ebp], 131072 ; 00020000H

; 119  : 
; 120  : 	if (file.Size() != dwShadowMapSize)

  000b2	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000b5	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000ba	3b 45 ec	 cmp	 eax, DWORD PTR _dwShadowMapSize$[ebp]
  000bd	74 27		 je	 SHORT $LN3@LoadShadow

; 121  : 	{
; 122  : 		TraceError(" CTerrain::LoadShadowMap - %s SIZE ERROR", c_pszFileName);

  000bf	ff b5 50 01 00
	00		 push	 DWORD PTR _c_pszFileName$[ebp]
  000c5	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@HOIKLCAI@?5CTerrain?3?3LoadShadowMap?5?9?5?$CFs?5S@
  000ca	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000cf	59		 pop	 ecx
  000d0	59		 pop	 ecx

; 123  : 		return false;

  000d1	c6 45 f2 00	 mov	 BYTE PTR $T4[ebp], 0
  000d5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d9	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000dc	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000e1	8a 45 f2	 mov	 al, BYTE PTR $T4[ebp]
  000e4	eb 3f		 jmp	 SHORT $LN1@LoadShadow
$LN3@LoadShadow:

; 124  : 	}
; 125  : 
; 126  : 	memcpy(m_awShadowMap, c_pvData, dwShadowMapSize);

  000e6	ff 75 ec	 push	 DWORD PTR _dwShadowMapSize$[ebp]
  000e9	ff 75 e4	 push	 DWORD PTR _c_pvData$[ebp]
  000ec	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	05 48 a5 04 00	 add	 eax, 304456		; 0004a548H
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 _memcpy
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 127  : 
; 128  : 	Tracef("%d ms\n", ELTimer_GetMSec() - dwStart);

  000fd	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00102	2b 45 dc	 sub	 eax, DWORD PTR _dwStart$[ebp]
  00105	50		 push	 eax
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_06MIKGEFKP@?$CFd?5ms?6@
  0010b	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00110	59		 pop	 ecx
  00111	59		 pop	 ecx

; 129  : 	return true;

  00112	c6 45 f1 01	 mov	 BYTE PTR $T3[ebp], 1
  00116	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0011a	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0011d	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00122	8a 45 f1	 mov	 al, BYTE PTR $T3[ebp]
$LN1@LoadShadow:

; 130  : }

  00125	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00128	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012f	59		 pop	 ecx
  00130	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  00143	c9		 leave
  00144	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadShadowMap@CTerrain@@QAE_NPBD@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadShadowMap@CTerrain@@QAE_NPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadShadowMap@CTerrain@@QAE_NPBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadShadowMap@CTerrain@@QAE_NPBD@Z ENDP		; CTerrain::LoadShadowMap
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?LoadShadowTexture@CTerrain@@QAEXPBD@Z
_TEXT	SEGMENT
_dwStart$ = -20						; size = 4
_pImage$ = -16						; size = 4
$T1 = -12						; size = 4
tv80 = -8						; size = 4
_this$ = -4						; size = 4
_ShadowFileName$ = 8					; size = 4
?LoadShadowTexture@CTerrain@@QAEXPBD@Z PROC		; CTerrain::LoadShadowTexture, COMDAT
; _this$ = ecx

; 89   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 90   : 	DWORD dwStart = ELTimer_GetMSec();

  00009	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0000e	89 45 ec	 mov	 DWORD PTR _dwStart$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00016	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 91   : 	CGraphicImage * pImage = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer(ShadowFileName);

  00019	ff 75 08	 push	 DWORD PTR _ShadowFileName$[ebp]
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00024	89 45 f0	 mov	 DWORD PTR _pImage$[ebp], eax

; 92   : 	m_ShadowGraphicImageInstance.SetImagePointer(pImage);

  00027	ff 75 f0	 push	 DWORD PTR _pImage$[ebp]
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  00033	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 93   : 
; 94   : 	if (!m_ShadowGraphicImageInstance.GetTexturePointer()->IsEmpty())

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  00041	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00046	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
  00049	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR tv80[ebp]
  00051	ff 50 04	 call	 DWORD PTR [eax+4]
  00054	0f b6 c0	 movzx	 eax, al
  00057	85 c0		 test	 eax, eax
  00059	75 20		 jne	 SHORT $LN2@LoadShadow

; 95   : 		m_lpShadowTexture = m_ShadowGraphicImageInstance.GetTexturePointer()->GetD3DTexture();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  00064	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  00069	8b c8		 mov	 ecx, eax
  0006b	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	89 81 44 a5 04
	00		 mov	 DWORD PTR [ecx+304452], eax
  00079	eb 15		 jmp	 SHORT $LN3@LoadShadow
$LN2@LoadShadow:

; 96   : 	else
; 97   : 	{
; 98   : 		TraceError(" CTerrain::LoadShadowTexture - ShadowTexture is Empty");

  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@HIAJBENM@?5CTerrain?3?3LoadShadowTexture?5?9?5@
  00080	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00085	59		 pop	 ecx

; 99   : 		m_lpShadowTexture = NULL;

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 a0 44 a5 04
	00 00		 and	 DWORD PTR [eax+304452], 0
$LN3@LoadShadow:

; 100  : 	}
; 101  : 	Tracef("CTerrain::LoadShadowTexture %d ms\n", ELTimer_GetMSec() - dwStart);

  00090	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00095	2b 45 ec	 sub	 eax, DWORD PTR _dwStart$[ebp]
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@IJFAIKJL@CTerrain?3?3LoadShadowTexture?5?$CFd?5@
  0009e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000a3	59		 pop	 ecx
  000a4	59		 pop	 ecx

; 102  : }

  000a5	c9		 leave
  000a6	c2 04 00	 ret	 4
?LoadShadowTexture@CTerrain@@QAEXPBD@Z ENDP		; CTerrain::LoadShadowTexture
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byWaterNum$ = -1					; size = 1
_wCoordX$ = 8						; size = 2
_wCoordY$ = 12						; size = 2
_plWaterHeight$ = 16					; size = 4
?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z PROC		; CTerrain::GetWaterHeight, COMDAT
; _this$ = ecx

; 530  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 531  : 	BYTE byWaterNum = *(m_abyWaterMap + (wCoordY * WATERMAP_XSIZE) + wCoordX);

  00008	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0000c	c1 e0 07	 shl	 eax, 7
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8d 84 01 1a 8e
	02 00		 lea	 eax, DWORD PTR [ecx+eax+167450]
  00019	0f b7 4d 08	 movzx	 ecx, WORD PTR _wCoordX$[ebp]
  0001d	8a 04 08	 mov	 al, BYTE PTR [eax+ecx]
  00020	88 45 ff	 mov	 BYTE PTR _byWaterNum$[ebp], al

; 532  : 	if (byWaterNum > m_byNumWater)

  00023	0f b6 45 ff	 movzx	 eax, BYTE PTR _byWaterNum$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	0f b6 89 40 a1
	04 00		 movzx	 ecx, BYTE PTR [ecx+303424]
  00031	3b c1		 cmp	 eax, ecx
  00033	7e 26		 jle	 SHORT $LN2@GetWaterHe

; 533  : 	{
; 534  : 		Tracef("CTerrain::GetWaterHeight (X %d, Y %d) ERROR!", wCoordX, wCoordY, m_byNumWater);

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	0f b6 80 40 a1
	04 00		 movzx	 eax, BYTE PTR [eax+303424]
  0003f	50		 push	 eax
  00040	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  00044	50		 push	 eax
  00045	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@IPEKMCGJ@CTerrain?3?3GetWaterHeight?5?$CIX?5?$CFd?0@
  0004f	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 535  : 		return false;

  00057	32 c0		 xor	 al, al
  00059	eb 1a		 jmp	 SHORT $LN1@GetWaterHe
$LN2@GetWaterHe:

; 536  : 	}
; 537  : 	*plWaterHeight = m_lWaterHeight[byWaterNum] / 2;

  0005b	0f b6 45 ff	 movzx	 eax, BYTE PTR _byWaterNum$[ebp]
  0005f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	8b 84 81 44 a1
	04 00		 mov	 eax, DWORD PTR [ecx+eax*4+303428]
  00069	99		 cdq
  0006a	2b c2		 sub	 eax, edx
  0006c	d1 f8		 sar	 eax, 1
  0006e	8b 4d 10	 mov	 ecx, DWORD PTR _plWaterHeight$[ebp]
  00071	89 01		 mov	 DWORD PTR [ecx], eax

; 538  : 
; 539  : 	return true;

  00073	b0 01		 mov	 al, 1
$LN1@GetWaterHe:

; 540  : }

  00075	c9		 leave
  00076	c2 0c 00	 ret	 12			; 0000000cH
?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z ENDP		; CTerrain::GetWaterHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetWaterHeight@CTerrain@@QAEXEPAJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_byWaterNum$ = 8					; size = 1
_plWaterHeight$ = 12					; size = 4
?GetWaterHeight@CTerrain@@QAEXEPAJ@Z PROC		; CTerrain::GetWaterHeight, COMDAT
; _this$ = ecx

; 520  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 521  : 	if (byWaterNum > m_byNumWater)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _byWaterNum$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	0f b6 89 40 a1
	04 00		 movzx	 ecx, BYTE PTR [ecx+303424]
  00015	3b c1		 cmp	 eax, ecx
  00017	7e 1f		 jle	 SHORT $LN2@GetWaterHe

; 522  : 	{
; 523  : 		Tracef("CTerrain::GetWaterHeight WaterNum %d(Total Num %d) ERROR!", byWaterNum, m_byNumWater);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	0f b6 80 40 a1
	04 00		 movzx	 eax, BYTE PTR [eax+303424]
  00023	50		 push	 eax
  00024	0f b6 45 08	 movzx	 eax, BYTE PTR _byWaterNum$[ebp]
  00028	50		 push	 eax
  00029	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@FNOMKIKO@CTerrain?3?3GetWaterHeight?5WaterN@
  0002e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 524  : 		return;

  00036	eb 13		 jmp	 SHORT $LN1@GetWaterHe
$LN2@GetWaterHe:

; 525  : 	}
; 526  : 	*plWaterHeight = m_lWaterHeight[byWaterNum];

  00038	0f b6 45 08	 movzx	 eax, BYTE PTR _byWaterNum$[ebp]
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _plWaterHeight$[ebp]
  0003f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 84 82 44 a1
	04 00		 mov	 eax, DWORD PTR [edx+eax*4+303428]
  00049	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@GetWaterHe:

; 527  : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?GetWaterHeight@CTerrain@@QAEXEPAJ@Z ENDP		; CTerrain::GetWaterHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?isAttrOn@CTerrain@@QAE_NGGE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byMapAttr$ = -2					; size = 1
tv92 = -1						; size = 1
_wCoordX$ = 8						; size = 2
_wCoordY$ = 12						; size = 2
_byAttrFlag$ = 16					; size = 1
?isAttrOn@CTerrain@@QAE_NGGE@Z PROC			; CTerrain::isAttrOn, COMDAT
; _this$ = ecx

; 488  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 489  : 	if (wCoordX >= ATTRMAP_XSIZE || wCoordY >= ATTRMAP_YSIZE)

  00008	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  0000c	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00011	7d 0b		 jge	 SHORT $LN3@isAttrOn
  00013	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  00017	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0001c	7c 25		 jl	 SHORT $LN2@isAttrOn
$LN3@isAttrOn:

; 490  : 	{
; 491  : 		Tracef("CTerrain::isAttrOn Coordiante Error! Return false... Input Coord - X : %d, Y : %d ( Limit X : %d, Y : %d)", wCoordX, wCoordY, ATTRMAP_XSIZE, ATTRMAP_YSIZE);

  0001e	68 00 01 00 00	 push	 256			; 00000100H
  00023	68 00 01 00 00	 push	 256			; 00000100H
  00028	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0002c	50		 push	 eax
  0002d	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0GK@JCKMMDJF@CTerrain?3?3isAttrOn?5Coordiante?5E@
  00037	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0003c	83 c4 14	 add	 esp, 20			; 00000014H

; 492  : 		return false;

  0003f	32 c0		 xor	 al, al
  00041	eb 66		 jmp	 SHORT $LN1@isAttrOn
$LN2@isAttrOn:

; 493  : 	}
; 494  : 	
; 495  : 	BYTE byMapAttr = m_abyAttrMap[wCoordY * ATTRMAP_XSIZE + wCoordX];

  00043	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  00047	c1 e0 08	 shl	 eax, 8
  0004a	0f b7 4d 08	 movzx	 ecx, WORD PTR _wCoordX$[ebp]
  0004e	03 4d f8	 add	 ecx, DWORD PTR _this$[ebp]
  00051	8a 84 01 1a 8e
	01 00		 mov	 al, BYTE PTR [ecx+eax+101914]
  00058	88 45 fe	 mov	 BYTE PTR _byMapAttr$[ebp], al

; 496  : 
; 497  : 	if ( byAttrFlag < 16 )

  0005b	0f b6 45 10	 movzx	 eax, BYTE PTR _byAttrFlag$[ebp]
  0005f	83 f8 10	 cmp	 eax, 16			; 00000010H
  00062	7d 1d		 jge	 SHORT $LN4@isAttrOn

; 498  : 		return (byMapAttr & byAttrFlag) ? true : false;

  00064	0f b6 45 fe	 movzx	 eax, BYTE PTR _byMapAttr$[ebp]
  00068	0f b6 4d 10	 movzx	 ecx, BYTE PTR _byAttrFlag$[ebp]
  0006c	23 c1		 and	 eax, ecx
  0006e	74 06		 je	 SHORT $LN9@isAttrOn
  00070	c6 45 ff 01	 mov	 BYTE PTR tv92[ebp], 1
  00074	eb 04		 jmp	 SHORT $LN10@isAttrOn
$LN9@isAttrOn:
  00076	c6 45 ff 00	 mov	 BYTE PTR tv92[ebp], 0
$LN10@isAttrOn:
  0007a	8a 45 ff	 mov	 al, BYTE PTR tv92[ebp]
  0007d	eb 2a		 jmp	 SHORT $LN1@isAttrOn
  0007f	eb 28		 jmp	 SHORT $LN1@isAttrOn
$LN4@isAttrOn:

; 499  : 	else
; 500  : 	{
; 501  : 		if ( byAttrFlag/16 == byMapAttr/16)

  00081	0f b6 45 10	 movzx	 eax, BYTE PTR _byAttrFlag$[ebp]
  00085	99		 cdq
  00086	83 e2 0f	 and	 edx, 15			; 0000000fH
  00089	03 c2		 add	 eax, edx
  0008b	8b c8		 mov	 ecx, eax
  0008d	c1 f9 04	 sar	 ecx, 4
  00090	0f b6 45 fe	 movzx	 eax, BYTE PTR _byMapAttr$[ebp]
  00094	99		 cdq
  00095	83 e2 0f	 and	 edx, 15			; 0000000fH
  00098	03 c2		 add	 eax, edx
  0009a	c1 f8 04	 sar	 eax, 4
  0009d	3b c8		 cmp	 ecx, eax
  0009f	75 06		 jne	 SHORT $LN6@isAttrOn

; 502  : 			return true;

  000a1	b0 01		 mov	 al, 1
  000a3	eb 04		 jmp	 SHORT $LN1@isAttrOn
  000a5	eb 02		 jmp	 SHORT $LN1@isAttrOn
$LN6@isAttrOn:

; 503  : 		else
; 504  : 			return false;

  000a7	32 c0		 xor	 al, al
$LN1@isAttrOn:

; 505  : 	}
; 506  : }

  000a9	c9		 leave
  000aa	c2 0c 00	 ret	 12			; 0000000cH
?isAttrOn@CTerrain@@QAE_NGGE@Z ENDP			; CTerrain::isAttrOn
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetAttr@CTerrain@@QAEEGG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wCoordX$ = 8						; size = 2
_wCoordY$ = 12						; size = 2
?GetAttr@CTerrain@@QAEEGG@Z PROC			; CTerrain::GetAttr, COMDAT
; _this$ = ecx

; 509  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 510  : 	if (wCoordX >= ATTRMAP_XSIZE || wCoordY >= ATTRMAP_YSIZE)

  00007	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  0000b	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00010	7d 0b		 jge	 SHORT $LN3@GetAttr
  00012	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  00016	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0001b	7c 25		 jl	 SHORT $LN2@GetAttr
$LN3@GetAttr:

; 511  : 	{
; 512  : 		Tracef("CTerrain::GetAttr Coordiante Error! Return 0... Input Coord - X : %d, Y : %d ( Limit X : %d, Y : %d)", wCoordX, wCoordY, ATTRMAP_XSIZE, ATTRMAP_YSIZE);

  0001d	68 00 01 00 00	 push	 256			; 00000100H
  00022	68 00 01 00 00	 push	 256			; 00000100H
  00027	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0002b	50		 push	 eax
  0002c	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0GF@DKPFJAMA@CTerrain?3?3GetAttr?5Coordiante?5Er@
  00036	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  0003b	83 c4 14	 add	 esp, 20			; 00000014H

; 513  : 		return 0;

  0003e	32 c0		 xor	 al, al
  00040	eb 15		 jmp	 SHORT $LN1@GetAttr
$LN2@GetAttr:

; 514  : 	}
; 515  : 	
; 516  : 	return m_abyAttrMap[wCoordY * ATTRMAP_XSIZE + wCoordX];

  00042	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  00046	c1 e0 08	 shl	 eax, 8
  00049	0f b7 4d 08	 movzx	 ecx, WORD PTR _wCoordX$[ebp]
  0004d	03 4d fc	 add	 ecx, DWORD PTR _this$[ebp]
  00050	8a 84 01 1a 8e
	01 00		 mov	 al, BYTE PTR [ecx+eax+101914]
$LN1@GetAttr:

; 517  : }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
?GetAttr@CTerrain@@QAEEGG@Z ENDP			; CTerrain::GetAttr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?LoadAttrMap@CTerrain@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_pszFileName$ = 8					; size = 4
?LoadAttrMap@CTerrain@@QAE_NPBD@Z PROC			; CTerrain::LoadAttrMap, COMDAT
; _this$ = ecx

; 483  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 484  : 	return CTerrainImpl::LoadAttrMap(c_pszFileName);

  00007	ff 75 08	 push	 DWORD PTR _c_pszFileName$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?LoadAttrMap@CTerrainImpl@@IAE_NPBD@Z ; CTerrainImpl::LoadAttrMap

; 485  : }

  00012	c9		 leave
  00013	c2 04 00	 ret	 4
?LoadAttrMap@CTerrain@@QAE_NPBD@Z ENDP			; CTerrain::LoadAttrMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_lMapHeight$ = -12					; size = 4
_lMapWidth$ = -8					; size = 4
_n$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_pv3Normal$ = 16					; size = 4
?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z PROC	; CTerrain::GetNormal, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : 	long lMapWidth = XSIZE * CELLSCALE;

  00009	c7 45 f8 00 64
	00 00		 mov	 DWORD PTR _lMapWidth$[ebp], 25600 ; 00006400H

; 345  : 	long lMapHeight = YSIZE * CELLSCALE;

  00010	c7 45 f4 00 64
	00 00		 mov	 DWORD PTR _lMapHeight$[ebp], 25600 ; 00006400H
$LN2@GetNormal:

; 346  : 	while (ix < 0)

  00017	83 7d 08 00	 cmp	 DWORD PTR _ix$[ebp], 0
  0001b	7d 0b		 jge	 SHORT $LN3@GetNormal

; 347  : 		ix += lMapWidth;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  00020	03 45 f8	 add	 eax, DWORD PTR _lMapWidth$[ebp]
  00023	89 45 08	 mov	 DWORD PTR _ix$[ebp], eax
  00026	eb ef		 jmp	 SHORT $LN2@GetNormal
$LN3@GetNormal:

; 348  : 	
; 349  : 	while (iy < 0)

  00028	83 7d 0c 00	 cmp	 DWORD PTR _iy$[ebp], 0
  0002c	7d 0b		 jge	 SHORT $LN5@GetNormal

; 350  : 		iy += lMapHeight;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  00031	03 45 f4	 add	 eax, DWORD PTR _lMapHeight$[ebp]
  00034	89 45 0c	 mov	 DWORD PTR _iy$[ebp], eax
  00037	eb ef		 jmp	 SHORT $LN3@GetNormal
$LN5@GetNormal:

; 351  : 	
; 352  : 	while (ix > lMapWidth)

  00039	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  0003c	3b 45 f8	 cmp	 eax, DWORD PTR _lMapWidth$[ebp]
  0003f	7e 0b		 jle	 SHORT $LN7@GetNormal

; 353  : 		ix -= lMapWidth;

  00041	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  00044	2b 45 f8	 sub	 eax, DWORD PTR _lMapWidth$[ebp]
  00047	89 45 08	 mov	 DWORD PTR _ix$[ebp], eax
  0004a	eb ed		 jmp	 SHORT $LN5@GetNormal
$LN7@GetNormal:

; 354  : 	
; 355  : 	while (iy > lMapHeight)

  0004c	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  0004f	3b 45 f4	 cmp	 eax, DWORD PTR _lMapHeight$[ebp]
  00052	7e 0b		 jle	 SHORT $LN9@GetNormal

; 356  : 		iy -= lMapHeight;

  00054	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  00057	2b 45 f4	 sub	 eax, DWORD PTR _lMapHeight$[ebp]
  0005a	89 45 0c	 mov	 DWORD PTR _iy$[ebp], eax
  0005d	eb ed		 jmp	 SHORT $LN7@GetNormal
$LN9@GetNormal:

; 357  : 
; 358  : 	ix /= CELLSCALE;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  00062	99		 cdq
  00063	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00068	f7 f9		 idiv	 ecx
  0006a	89 45 08	 mov	 DWORD PTR _ix$[ebp], eax

; 359  : 	iy /= CELLSCALE;

  0006d	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  00070	99		 cdq
  00071	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00076	f7 f9		 idiv	 ecx
  00078	89 45 0c	 mov	 DWORD PTR _iy$[ebp], eax

; 360  : 
; 361  : 	D3DXVECTOR3 v3Noraml;
; 362  : 	char * n = (char*) &m_acNormalMap[(iy * NORMALMAP_XSIZE + ix)*3];

  0007b	69 45 0c 81 00
	00 00		 imul	 eax, DWORD PTR _iy$[ebp], 129
  00082	03 45 08	 add	 eax, DWORD PTR _ix$[ebp]
  00085	6b c0 03	 imul	 eax, eax, 3
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8d 84 01 1a ce
	02 00		 lea	 eax, DWORD PTR [ecx+eax+183834]
  00092	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 363  : 	pv3Normal->x = -((float)*n++) * 0.007874016f;

  00095	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00098	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0009b	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0009f	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000a6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c010204
  000ae	8b 45 10	 mov	 eax, DWORD PTR _pv3Normal$[ebp]
  000b1	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  000b5	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000b8	40		 inc	 eax
  000b9	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 364  : 	pv3Normal->y = ((float)*n++) * 0.007874016f;

  000bc	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000bf	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000c2	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000c6	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c010204
  000ce	8b 45 10	 mov	 eax, DWORD PTR _pv3Normal$[ebp]
  000d1	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0
  000d6	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000d9	40		 inc	 eax
  000da	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 365  : 	pv3Normal->z = ((float)*n++) * 0.007874016f;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000e0	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000e3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c010204
  000ef	8b 45 10	 mov	 eax, DWORD PTR _pv3Normal$[ebp]
  000f2	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  000fa	40		 inc	 eax
  000fb	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 366  : 
; 367  : 	return true;

  000fe	b0 01		 mov	 al, 1

; 368  : }

  00100	c9		 leave
  00101	c2 0c 00	 ret	 12			; 0000000cH
?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z ENDP	; CTerrain::GetNormal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?GetHeight@CTerrain@@QAEMHH@Z
_TEXT	SEGMENT
tv287 = -60						; size = 4
tv276 = -56						; size = 4
_h2$ = -52						; size = 4
_yslope$ = -48						; size = 4
_ydist$ = -44						; size = 4
_xslope$ = -40						; size = 4
_xdist$ = -36						; size = 4
_h1$ = -32						; size = 4
_ooscale$ = -28						; size = 4
_h3$ = -24						; size = 4
_x2$ = -20						; size = 4
_y2$ = -16						; size = 4
_this$ = -12						; size = 4
$T1 = -8						; size = 2
$T2 = -6						; size = 2
$T3 = -4						; size = 2
$T4 = -2						; size = 2
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?GetHeight@CTerrain@@QAEMHH@Z PROC			; CTerrain::GetHeight, COMDAT
; _this$ = ecx

; 371  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 372  : 	//if (0 == CELLSCALE)
; 373  : 		//return 0.0f;
; 374  : 
; 375  : 	x -= m_wX * XSIZE * CELLSCALE;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  00013	c1 e0 07	 shl	 eax, 7
  00016	69 c0 c8 00 00
	00		 imul	 eax, eax, 200
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001f	2b c8		 sub	 ecx, eax
  00021	89 4d 08	 mov	 DWORD PTR _x$[ebp], ecx

; 376  : 	y -= m_wY * YSIZE * CELLSCALE;

  00024	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  0002e	c1 e0 07	 shl	 eax, 7
  00031	69 c0 c8 00 00
	00		 imul	 eax, eax, 200
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _y$[ebp]
  0003a	2b c8		 sub	 ecx, eax
  0003c	89 4d 0c	 mov	 DWORD PTR _y$[ebp], ecx

; 377  : 
; 378  : 	if (x < 0 || y < 0 || x > XSIZE * CELLSCALE || y > XSIZE * CELLSCALE)

  0003f	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00043	7c 18		 jl	 SHORT $LN3@GetHeight
  00045	83 7d 0c 00	 cmp	 DWORD PTR _y$[ebp], 0
  00049	7c 12		 jl	 SHORT $LN3@GetHeight
  0004b	81 7d 08 00 64
	00 00		 cmp	 DWORD PTR _x$[ebp], 25600 ; 00006400H
  00052	7f 09		 jg	 SHORT $LN3@GetHeight
  00054	81 7d 0c 00 64
	00 00		 cmp	 DWORD PTR _y$[ebp], 25600 ; 00006400H
  0005b	7e 07		 jle	 SHORT $LN2@GetHeight
$LN3@GetHeight:

; 379  : 		return 0.0f;

  0005d	d9 ee		 fldz
  0005f	e9 04 02 00 00	 jmp	 $LN1@GetHeight
$LN2@GetHeight:

; 380  : 
; 381  : 	long	xdist;				/* x mod size of tile */
; 382  : 	long	ydist;				/* y mod size of tile */
; 383  : 	float	xslope, yslope;		/* slopes of heights between vertices */
; 384  : 	
; 385  : 	float	h1, h2, h3;
; 386  : 	long	x2, y2;
; 387  : 	float	ooscale;
; 388  : 
; 389  : 	/* Find out the distance relative to the top left vertex of a tile */
; 390  : 	xdist = x % CELLSCALE;

  00064	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00067	99		 cdq
  00068	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0006d	f7 f9		 idiv	 ecx
  0006f	89 55 dc	 mov	 DWORD PTR _xdist$[ebp], edx

; 391  : 	ydist = y % CELLSCALE;

  00072	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00075	99		 cdq
  00076	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0007b	f7 f9		 idiv	 ecx
  0007d	89 55 d4	 mov	 DWORD PTR _ydist$[ebp], edx

; 392  : 	
; 393  : 	/* Convert into pixel coordinates */
; 394  : 	ooscale = 1.0f / ((float)CELLSCALE);

  00080	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3ba3d70a
  00088	f3 0f 11 45 e4	 movss	 DWORD PTR _ooscale$[ebp], xmm0

; 395  : 	x /= CELLSCALE;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00090	99		 cdq
  00091	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  00096	f7 f9		 idiv	 ecx
  00098	89 45 08	 mov	 DWORD PTR _x$[ebp], eax

; 396  : 	y /= CELLSCALE;

  0009b	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  0009e	99		 cdq
  0009f	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  000a4	f7 f9		 idiv	 ecx
  000a6	89 45 0c	 mov	 DWORD PTR _y$[ebp], eax

; 397  : 
; 398  : 	x2 = x; y2 = y;

  000a9	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000ac	89 45 ec	 mov	 DWORD PTR _x2$[ebp], eax
  000af	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000b2	89 45 f0	 mov	 DWORD PTR _y2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  000b5	0f bf 45 f0	 movsx	 eax, WORD PTR _y2$[ebp]
  000b9	40		 inc	 eax
  000ba	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  000c0	0f bf 4d ec	 movsx	 ecx, WORD PTR _x2$[ebp]
  000c4	03 c1		 add	 eax, ecx
  000c6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  000d1	66 89 45 fe	 mov	 WORD PTR $T4[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 400  : 	h1 = (float) GetHeightMapValue(x2, y2) * m_fHeightScale;

  000d5	0f b7 45 fe	 movzx	 eax, WORD PTR $T4[ebp]
  000d9	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000dd	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  000e8	f3 0f 11 45 e0	 movss	 DWORD PTR _h1$[ebp], xmm0

; 401  : 	
; 402  : 	/* Get the height and color of the pixel at the bottom right corner */
; 403  : 	x2 = x + 1;

  000ed	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  000f0	40		 inc	 eax
  000f1	89 45 ec	 mov	 DWORD PTR _x2$[ebp], eax

; 404  : 	y2 = y + 1;

  000f4	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  000f7	40		 inc	 eax
  000f8	89 45 f0	 mov	 DWORD PTR _y2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  000fb	0f bf 45 f0	 movsx	 eax, WORD PTR _y2$[ebp]
  000ff	40		 inc	 eax
  00100	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00106	0f bf 4d ec	 movsx	 ecx, WORD PTR _x2$[ebp]
  0010a	03 c1		 add	 eax, ecx
  0010c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00117	66 89 45 fc	 mov	 WORD PTR $T3[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 406  : 	h2 = (float) GetHeightMapValue(x2, y2) * m_fHeightScale;

  0011b	0f b7 45 fc	 movzx	 eax, WORD PTR $T3[ebp]
  0011f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00123	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00126	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  0012e	f3 0f 11 45 cc	 movss	 DWORD PTR _h2$[ebp], xmm0

; 407  : 	
; 408  : 	/* Left triangle */
; 409  : 	if (xdist <= ydist)

  00133	8b 45 dc	 mov	 eax, DWORD PTR _xdist$[ebp]
  00136	3b 45 d4	 cmp	 eax, DWORD PTR _ydist$[ebp]
  00139	0f 8f 97 00 00
	00		 jg	 $LN4@GetHeight

; 410  :     {
; 411  : 		x2 = x;

  0013f	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00142	89 45 ec	 mov	 DWORD PTR _x2$[ebp], eax

; 412  : 		y2 = y + 1;

  00145	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  00148	40		 inc	 eax
  00149	89 45 f0	 mov	 DWORD PTR _y2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0014c	0f bf 45 f0	 movsx	 eax, WORD PTR _y2$[ebp]
  00150	40		 inc	 eax
  00151	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00157	0f bf 4d ec	 movsx	 ecx, WORD PTR _x2$[ebp]
  0015b	03 c1		 add	 eax, ecx
  0015d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00168	66 89 45 fa	 mov	 WORD PTR $T2[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 414  : 		h3 = (float) GetHeightMapValue(x2, y2) * m_fHeightScale;

  0016c	0f b7 45 fa	 movzx	 eax, WORD PTR $T2[ebp]
  00170	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00174	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00177	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  0017f	f3 0f 11 45 e8	 movss	 DWORD PTR _h3$[ebp], xmm0

; 415  : 
; 416  : 		/* Get the height of the pixel at the bottom left corner */
; 417  : 		xslope = (h2 - h3) * ooscale;

  00184	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _h2$[ebp]
  00189	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _h3$[ebp]
  0018e	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _ooscale$[ebp]
  00193	f3 0f 11 45 d8	 movss	 DWORD PTR _xslope$[ebp], xmm0

; 418  : 		yslope = (h3 - h1) * ooscale;

  00198	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _h3$[ebp]
  0019d	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _h1$[ebp]
  001a2	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _ooscale$[ebp]
  001a7	f3 0f 11 45 d0	 movss	 DWORD PTR _yslope$[ebp], xmm0

; 419  : 
; 420  : 		return (h1 + (xdist * xslope + ydist * yslope));

  001ac	f3 0f 2a 45 dc	 cvtsi2ss xmm0, DWORD PTR _xdist$[ebp]
  001b1	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _xslope$[ebp]
  001b6	f3 0f 2a 4d d4	 cvtsi2ss xmm1, DWORD PTR _ydist$[ebp]
  001bb	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _yslope$[ebp]
  001c0	f3 0f 58 c1	 addss	 xmm0, xmm1
  001c4	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _h1$[ebp]
  001c9	f3 0f 11 45 c8	 movss	 DWORD PTR tv276[ebp], xmm0
  001ce	d9 45 c8	 fld	 DWORD PTR tv276[ebp]
  001d1	e9 92 00 00 00	 jmp	 $LN1@GetHeight
$LN4@GetHeight:

; 421  :     }
; 422  : 	
; 423  : 	/* Right triangle */
; 424  : 	x2 = x + 1;

  001d6	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  001d9	40		 inc	 eax
  001da	89 45 ec	 mov	 DWORD PTR _x2$[ebp], eax

; 425  : 	y2 = y;

  001dd	8b 45 0c	 mov	 eax, DWORD PTR _y$[ebp]
  001e0	89 45 f0	 mov	 DWORD PTR _y2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  001e3	0f bf 45 f0	 movsx	 eax, WORD PTR _y2$[ebp]
  001e7	40		 inc	 eax
  001e8	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  001ee	0f bf 4d ec	 movsx	 ecx, WORD PTR _x2$[ebp]
  001f2	03 c1		 add	 eax, ecx
  001f4	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  001ff	66 89 45 f8	 mov	 WORD PTR $T1[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 427  : 	h3 = (float) GetHeightMapValue(x2, y2) * m_fHeightScale;

  00203	0f b7 45 f8	 movzx	 eax, WORD PTR $T1[ebp]
  00207	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0020b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0020e	f3 0f 59 80 38
	91 03 00	 mulss	 xmm0, DWORD PTR [eax+233784]
  00216	f3 0f 11 45 e8	 movss	 DWORD PTR _h3$[ebp], xmm0

; 428  : 
; 429  : 	/* Get the height of the pixel at the top right corner */
; 430  : 	xslope = (h3 - h1) * ooscale;

  0021b	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _h3$[ebp]
  00220	f3 0f 5c 45 e0	 subss	 xmm0, DWORD PTR _h1$[ebp]
  00225	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _ooscale$[ebp]
  0022a	f3 0f 11 45 d8	 movss	 DWORD PTR _xslope$[ebp], xmm0

; 431  : 	yslope = (h2 - h3) * ooscale;

  0022f	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _h2$[ebp]
  00234	f3 0f 5c 45 e8	 subss	 xmm0, DWORD PTR _h3$[ebp]
  00239	f3 0f 59 45 e4	 mulss	 xmm0, DWORD PTR _ooscale$[ebp]
  0023e	f3 0f 11 45 d0	 movss	 DWORD PTR _yslope$[ebp], xmm0

; 432  : 	
; 433  : 	return (h1 + (xdist * xslope + ydist * yslope));

  00243	f3 0f 2a 45 dc	 cvtsi2ss xmm0, DWORD PTR _xdist$[ebp]
  00248	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _xslope$[ebp]
  0024d	f3 0f 2a 4d d4	 cvtsi2ss xmm1, DWORD PTR _ydist$[ebp]
  00252	f3 0f 59 4d d0	 mulss	 xmm1, DWORD PTR _yslope$[ebp]
  00257	f3 0f 58 c1	 addss	 xmm0, xmm1
  0025b	f3 0f 58 45 e0	 addss	 xmm0, DWORD PTR _h1$[ebp]
  00260	f3 0f 11 45 c4	 movss	 DWORD PTR tv287[ebp], xmm0
  00265	d9 45 c4	 fld	 DWORD PTR tv287[ebp]
$LN1@GetHeight:

; 434  : }

  00268	c9		 leave
  00269	c2 08 00	 ret	 8
?GetHeight@CTerrain@@QAEMHH@Z ENDP			; CTerrain::GetHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?WE_GetHeightMapValue@CTerrain@@QAEGFF@Z
_TEXT	SEGMENT
_this$ = -108						; size = 4
$T1 = -104						; size = 2
$T2 = -102						; size = 2
$T3 = -100						; size = 2
$T4 = -98						; size = 2
$T5 = -96						; size = 2
$T6 = -94						; size = 2
$T7 = -92						; size = 2
$T8 = -90						; size = 2
$T9 = -88						; size = 2
$T10 = -86						; size = 2
$T11 = -84						; size = 2
$T12 = -82						; size = 2
$T13 = -80						; size = 2
$T14 = -78						; size = 2
$T15 = -76						; size = 2
$T16 = -74						; size = 2
$T17 = -72						; size = 2
$T18 = -70						; size = 2
$T19 = -68						; size = 2
$T20 = -66						; size = 2
$T21 = -64						; size = 2
$T22 = -62						; size = 2
$T23 = -60						; size = 2
$T24 = -58						; size = 2
$T25 = -56						; size = 2
$T26 = -54						; size = 2
_sTerrainCouuntY$ = -52					; size = 2
$T27 = -48						; size = 2
$T28 = -46						; size = 2
$T29 = -44						; size = 2
$T30 = -42						; size = 2
$T31 = -40						; size = 2
$T32 = -38						; size = 2
$T33 = -36						; size = 2
$T34 = -34						; size = 2
$T35 = -32						; size = 2
$T36 = -30						; size = 2
$T37 = -28						; size = 2
$T38 = -26						; size = 2
$T39 = -24						; size = 2
$T40 = -22						; size = 2
$T41 = -20						; size = 2
$T42 = -18						; size = 2
_sTerrainCouuntX$ = -16					; size = 2
_pTerrain$ = -12					; size = 4
_this$ = -8						; size = 4
_byTerrainNum$ = -1					; size = 1
_sX$ = 8						; size = 2
_sY$ = 12						; size = 2
?WE_GetHeightMapValue@CTerrain@@QAEGFF@Z PROC		; CTerrain::WE_GetHeightMapValue, COMDAT
; _this$ = ecx

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 144  : 	if (sX>=-1 && sY>=-1 && sX<HEIGHTMAP_RAW_XSIZE-1 && sY<HEIGHTMAP_RAW_YSIZE-1)

  00009	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	7c 48		 jl	 SHORT $LN2@WE_GetHeig
  00012	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00016	83 f8 ff	 cmp	 eax, -1
  00019	7c 3f		 jl	 SHORT $LN2@WE_GetHeig
  0001b	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  0001f	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  00024	7d 34		 jge	 SHORT $LN2@WE_GetHeig
  00026	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  0002a	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0002f	7d 29		 jge	 SHORT $LN2@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00031	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00035	40		 inc	 eax
  00036	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0003c	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00040	03 c1		 add	 eax, ecx
  00042	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0004d	66 89 45 9a	 mov	 WORD PTR $T2[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 145  : 		return GetHeightMapValue(sX,sY);

  00051	66 8b 45 9a	 mov	 ax, WORD PTR $T2[ebp]
  00055	e9 c9 0b 00 00	 jmp	 $LN1@WE_GetHeig
$LN2@WE_GetHeig:

; 146  : 
; 147  : 	BYTE byTerrainNum;
; 148  : 	if ( !m_pOwnerOutdoorMap->GetTerrainNumFromCoord(m_wX, m_wY, &byTerrainNum) )

  0005a	8d 45 ff	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  0005d	50		 push	 eax
  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  00068	50		 push	 eax
  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  00073	50		 push	 eax
  00074	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  0007d	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  00082	0f b6 c0	 movzx	 eax, al
  00085	85 c0		 test	 eax, eax
  00087	75 27		 jne	 SHORT $LN3@WE_GetHeig

; 149  : 	{
; 150  : 		Tracef("CTerrain::WE_GetHeightMapValue : Can't Get TerrainNum from Coord %d, %d", m_wX, m_wY);

  00089	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  00093	50		 push	 eax
  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@CCJJGEPA@CTerrain?3?3WE_GetHeightMapValue?5@
  000a4	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000a9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 151  : 		byTerrainNum = 4;

  000ac	c6 45 ff 04	 mov	 BYTE PTR _byTerrainNum$[ebp], 4
$LN3@WE_GetHeig:

; 152  : 	}
; 153  : 	
; 154  : 	short sTerrainCouuntX, sTerrainCouuntY;
; 155  : 	m_pOwnerOutdoorMap->GetTerrainCount(&sTerrainCouuntX, &sTerrainCouuntY);

  000b0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 80 b8 a5 06
	00		 mov	 eax, DWORD PTR [eax+435640]
  000b9	89 45 94	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h

; 140  : 			*psTerrainCountX = m_sTerrainCountX;

  000bc	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	66 8b 40 70	 mov	 ax, WORD PTR [eax+112]
  000c3	66 89 45 f0	 mov	 WORD PTR _sTerrainCouuntX$[ebp], ax

; 141  : 			*psTerrainCountY = m_sTerrainCountY;

  000c7	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	66 8b 40 72	 mov	 ax, WORD PTR [eax+114]
  000ce	66 89 45 cc	 mov	 WORD PTR _sTerrainCouuntY$[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 157  : 	CTerrain * pTerrain = NULL;

  000d2	83 65 f4 00	 and	 DWORD PTR _pTerrain$[ebp], 0

; 158  : 
; 159  : 	if (sY < -1)

  000d6	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  000da	83 f8 ff	 cmp	 eax, -1
  000dd	0f 8d ad 04 00
	00		 jge	 $LN4@WE_GetHeig

; 160  : 	{
; 161  : 		if (m_wY <= 0)

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  000ed	85 c0		 test	 eax, eax
  000ef	0f 8f c6 01 00
	00		 jg	 $LN6@WE_GetHeig

; 162  : 		{
; 163  : 			if ( sX < -1)

  000f5	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  000f9	83 f8 ff	 cmp	 eax, -1
  000fc	0f 8d bb 00 00
	00		 jge	 $LN8@WE_GetHeig

; 164  : 			{
; 165  : 				if (m_wX <= 0)

  00102	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00105	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  0010c	85 c0		 test	 eax, eax
  0010e	7f 2d		 jg	 SHORT $LN10@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00110	83 c8 ff	 or	 eax, -1
  00113	98		 cwde
  00114	40		 inc	 eax
  00115	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0011b	83 c9 ff	 or	 ecx, -1
  0011e	0f bf c9	 movsx	 ecx, cx
  00121	03 c1		 add	 eax, ecx
  00123	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0012e	66 89 45 98	 mov	 WORD PTR $T1[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 166  : 					return GetHeightMapValue(-1, -1);

  00132	66 8b 45 98	 mov	 ax, WORD PTR $T1[ebp]
  00136	e9 e8 0a 00 00	 jmp	 $LN1@WE_GetHeig
  0013b	eb 7b		 jmp	 SHORT $LN11@WE_GetHeig
$LN10@WE_GetHeig:

; 167  : 				else
; 168  : 				{
; 169  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 1, &pTerrain))

  0013d	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00140	50		 push	 eax
  00141	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00145	48		 dec	 eax
  00146	50		 push	 eax
  00147	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00150	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00155	85 c0		 test	 eax, eax
  00157	75 2d		 jne	 SHORT $LN12@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00159	83 c8 ff	 or	 eax, -1
  0015c	98		 cwde
  0015d	40		 inc	 eax
  0015e	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00164	83 c9 ff	 or	 ecx, -1
  00167	0f bf c9	 movsx	 ecx, cx
  0016a	03 c1		 add	 eax, ecx
  0016c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00177	66 89 45 ee	 mov	 WORD PTR $T42[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 170  : 						return GetHeightMapValue(-1, -1);

  0017b	66 8b 45 ee	 mov	 ax, WORD PTR $T42[ebp]
  0017f	e9 9f 0a 00 00	 jmp	 $LN1@WE_GetHeig
  00184	eb 32		 jmp	 SHORT $LN11@WE_GetHeig
$LN12@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00186	83 c8 ff	 or	 eax, -1
  00189	98		 cwde
  0018a	40		 inc	 eax
  0018b	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 172  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, -1);

  00191	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00195	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0019b	0f bf c9	 movsx	 ecx, cx
  0019e	03 c1		 add	 eax, ecx
  001a0	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  001a3	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  001ab	66 89 45 ec	 mov	 WORD PTR $T41[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 172  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, -1);

  001af	66 8b 45 ec	 mov	 ax, WORD PTR $T41[ebp]
  001b3	e9 6b 0a 00 00	 jmp	 $LN1@WE_GetHeig
$LN11@WE_GetHeig:

; 173  : 				}
; 174  : 			}

  001b8	e9 f9 00 00 00	 jmp	 $LN9@WE_GetHeig
$LN8@WE_GetHeig:

; 175  : 			else if (sX >= HEIGHTMAP_RAW_XSIZE - 1)

  001bd	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  001c1	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  001c6	0f 8c c1 00 00
	00		 jl	 $LN14@WE_GetHeig

; 176  : 			{
; 177  : 				if (m_wX >= sTerrainCouuntX - 1)

  001cc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001cf	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  001d6	0f bf 4d f0	 movsx	 ecx, WORD PTR _sTerrainCouuntX$[ebp]
  001da	49		 dec	 ecx
  001db	3b c1		 cmp	 eax, ecx
  001dd	7c 2f		 jl	 SHORT $LN16@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  001df	83 c8 ff	 or	 eax, -1
  001e2	98		 cwde
  001e3	40		 inc	 eax
  001e4	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  001ea	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  001ef	0f bf c9	 movsx	 ecx, cx
  001f2	03 c1		 add	 eax, ecx
  001f4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  001ff	66 89 45 ea	 mov	 WORD PTR $T40[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 178  : 					return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, -1);

  00203	66 8b 45 ea	 mov	 ax, WORD PTR $T40[ebp]
  00207	e9 17 0a 00 00	 jmp	 $LN1@WE_GetHeig
  0020c	eb 7d		 jmp	 SHORT $LN17@WE_GetHeig
$LN16@WE_GetHeig:

; 179  : 				else
; 180  : 				{
; 181  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 1, &pTerrain))

  0020e	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00211	50		 push	 eax
  00212	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00216	40		 inc	 eax
  00217	50		 push	 eax
  00218	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0021b	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00221	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00226	85 c0		 test	 eax, eax
  00228	75 2f		 jne	 SHORT $LN18@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0022a	83 c8 ff	 or	 eax, -1
  0022d	98		 cwde
  0022e	40		 inc	 eax
  0022f	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00235	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0023a	0f bf c9	 movsx	 ecx, cx
  0023d	03 c1		 add	 eax, ecx
  0023f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0024a	66 89 45 e8	 mov	 WORD PTR $T39[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 182  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, -1);

  0024e	66 8b 45 e8	 mov	 ax, WORD PTR $T39[ebp]
  00252	e9 cc 09 00 00	 jmp	 $LN1@WE_GetHeig
  00257	eb 32		 jmp	 SHORT $LN17@WE_GetHeig
$LN18@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00259	83 c8 ff	 or	 eax, -1
  0025c	98		 cwde
  0025d	40		 inc	 eax
  0025e	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 184  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, -1);

  00264	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00268	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0026e	0f bf c9	 movsx	 ecx, cx
  00271	03 c1		 add	 eax, ecx
  00273	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00276	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0027e	66 89 45 e6	 mov	 WORD PTR $T38[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 184  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, -1);

  00282	66 8b 45 e6	 mov	 ax, WORD PTR $T38[ebp]
  00286	e9 98 09 00 00	 jmp	 $LN1@WE_GetHeig
$LN17@WE_GetHeig:

; 185  : 				}
; 186  : 			}

  0028b	eb 29		 jmp	 SHORT $LN9@WE_GetHeig
$LN14@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0028d	83 c8 ff	 or	 eax, -1
  00290	98		 cwde
  00291	40		 inc	 eax
  00292	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00298	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  0029c	03 c1		 add	 eax, ecx
  0029e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  002a1	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  002a9	66 89 45 e4	 mov	 WORD PTR $T37[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 188  : 				return GetHeightMapValue(sX, -1);

  002ad	66 8b 45 e4	 mov	 ax, WORD PTR $T37[ebp]
  002b1	e9 6d 09 00 00	 jmp	 $LN1@WE_GetHeig
$LN9@WE_GetHeig:

; 189  : 		}

  002b6	e9 d0 02 00 00	 jmp	 $LN7@WE_GetHeig
$LN6@WE_GetHeig:

; 190  : 		else
; 191  : 		{
; 192  : 			if (sX < -1)

  002bb	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  002bf	83 f8 ff	 cmp	 eax, -1
  002c2	0f 8d 1b 01 00
	00		 jge	 $LN20@WE_GetHeig

; 193  : 			{
; 194  : 				if (m_wX <= 0)

  002c8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002cb	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  002d2	85 c0		 test	 eax, eax
  002d4	0f 8f 81 00 00
	00		 jg	 $LN22@WE_GetHeig

; 195  : 				{
; 196  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 3, &pTerrain))

  002da	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  002dd	50		 push	 eax
  002de	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  002e2	83 e8 03	 sub	 eax, 3
  002e5	50		 push	 eax
  002e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002e9	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  002ef	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  002f4	85 c0		 test	 eax, eax
  002f6	75 2d		 jne	 SHORT $LN24@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  002f8	83 c8 ff	 or	 eax, -1
  002fb	98		 cwde
  002fc	40		 inc	 eax
  002fd	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00303	83 c9 ff	 or	 ecx, -1
  00306	0f bf c9	 movsx	 ecx, cx
  00309	03 c1		 add	 eax, ecx
  0030b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030e	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00316	66 89 45 e2	 mov	 WORD PTR $T36[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 197  : 						return GetHeightMapValue(-1, -1);

  0031a	66 8b 45 e2	 mov	 ax, WORD PTR $T36[ebp]
  0031e	e9 00 09 00 00	 jmp	 $LN1@WE_GetHeig
  00323	eb 31		 jmp	 SHORT $LN25@WE_GetHeig
$LN24@WE_GetHeig:

; 199  : 						return pTerrain->GetHeightMapValue(-1, sY + YSIZE);

  00325	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00329	05 80 00 00 00	 add	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0032e	98		 cwde
  0032f	40		 inc	 eax
  00330	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00336	83 c9 ff	 or	 ecx, -1
  00339	0f bf c9	 movsx	 ecx, cx
  0033c	03 c1		 add	 eax, ecx
  0033e	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00341	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00349	66 89 45 e0	 mov	 WORD PTR $T35[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 199  : 						return pTerrain->GetHeightMapValue(-1, sY + YSIZE);

  0034d	66 8b 45 e0	 mov	 ax, WORD PTR $T35[ebp]
  00351	e9 cd 08 00 00	 jmp	 $LN1@WE_GetHeig
$LN25@WE_GetHeig:

; 200  : 				}

  00356	e9 83 00 00 00	 jmp	 $LN23@WE_GetHeig
$LN22@WE_GetHeig:

; 201  : 				else
; 202  : 				{
; 203  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 4, &pTerrain))

  0035b	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0035e	50		 push	 eax
  0035f	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00363	83 e8 04	 sub	 eax, 4
  00366	50		 push	 eax
  00367	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0036a	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00370	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00375	85 c0		 test	 eax, eax
  00377	75 2d		 jne	 SHORT $LN26@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00379	83 c8 ff	 or	 eax, -1
  0037c	98		 cwde
  0037d	40		 inc	 eax
  0037e	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00384	83 c9 ff	 or	 ecx, -1
  00387	0f bf c9	 movsx	 ecx, cx
  0038a	03 c1		 add	 eax, ecx
  0038c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0038f	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00397	66 89 45 de	 mov	 WORD PTR $T34[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 204  : 						return GetHeightMapValue(-1, -1);

  0039b	66 8b 45 de	 mov	 ax, WORD PTR $T34[ebp]
  0039f	e9 7f 08 00 00	 jmp	 $LN1@WE_GetHeig
  003a4	eb 38		 jmp	 SHORT $LN23@WE_GetHeig
$LN26@WE_GetHeig:

; 206  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY + YSIZE);

  003a6	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  003aa	05 80 00 00 00	 add	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  003af	98		 cwde
  003b0	40		 inc	 eax
  003b1	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 206  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY + YSIZE);

  003b7	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  003bb	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  003c1	0f bf c9	 movsx	 ecx, cx
  003c4	03 c1		 add	 eax, ecx
  003c6	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  003c9	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  003d1	66 89 45 dc	 mov	 WORD PTR $T33[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 206  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY + YSIZE);

  003d5	66 8b 45 dc	 mov	 ax, WORD PTR $T33[ebp]
  003d9	e9 45 08 00 00	 jmp	 $LN1@WE_GetHeig
$LN23@WE_GetHeig:

; 207  : 				}
; 208  : 			}

  003de	e9 a8 01 00 00	 jmp	 $LN7@WE_GetHeig
$LN20@WE_GetHeig:

; 209  : 			else if (sX >= HEIGHTMAP_RAW_XSIZE - 1)

  003e3	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  003e7	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  003ec	0f 8c 21 01 00
	00		 jl	 $LN28@WE_GetHeig

; 210  : 			{
; 211  : 				if (m_wX >= sTerrainCouuntX)

  003f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003f5	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  003fc	0f bf 4d f0	 movsx	 ecx, WORD PTR _sTerrainCouuntX$[ebp]
  00400	3b c1		 cmp	 eax, ecx
  00402	0f 8c 85 00 00
	00		 jl	 $LN30@WE_GetHeig

; 212  : 				{
; 213  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 3, &pTerrain))

  00408	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0040b	50		 push	 eax
  0040c	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00410	83 e8 03	 sub	 eax, 3
  00413	50		 push	 eax
  00414	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00417	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  0041d	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00422	85 c0		 test	 eax, eax
  00424	75 2f		 jne	 SHORT $LN32@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00426	83 c8 ff	 or	 eax, -1
  00429	98		 cwde
  0042a	40		 inc	 eax
  0042b	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00431	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00436	0f bf c9	 movsx	 ecx, cx
  00439	03 c1		 add	 eax, ecx
  0043b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0043e	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00446	66 89 45 da	 mov	 WORD PTR $T32[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 214  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, -1);

  0044a	66 8b 45 da	 mov	 ax, WORD PTR $T32[ebp]
  0044e	e9 d0 07 00 00	 jmp	 $LN1@WE_GetHeig
  00453	eb 33		 jmp	 SHORT $LN33@WE_GetHeig
$LN32@WE_GetHeig:

; 216  : 						return pTerrain->GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY + YSIZE);

  00455	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00459	05 80 00 00 00	 add	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0045e	98		 cwde
  0045f	40		 inc	 eax
  00460	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00466	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0046b	0f bf c9	 movsx	 ecx, cx
  0046e	03 c1		 add	 eax, ecx
  00470	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00473	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0047b	66 89 45 d8	 mov	 WORD PTR $T31[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 216  : 						return pTerrain->GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY + YSIZE);

  0047f	66 8b 45 d8	 mov	 ax, WORD PTR $T31[ebp]
  00483	e9 9b 07 00 00	 jmp	 $LN1@WE_GetHeig
$LN33@WE_GetHeig:

; 217  : 				}

  00488	e9 84 00 00 00	 jmp	 $LN31@WE_GetHeig
$LN30@WE_GetHeig:

; 218  : 				else
; 219  : 				{
; 220  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 2, &pTerrain))

  0048d	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00490	50		 push	 eax
  00491	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00495	48		 dec	 eax
  00496	48		 dec	 eax
  00497	50		 push	 eax
  00498	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0049b	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  004a1	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  004a6	85 c0		 test	 eax, eax
  004a8	75 2f		 jne	 SHORT $LN34@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  004aa	83 c8 ff	 or	 eax, -1
  004ad	98		 cwde
  004ae	40		 inc	 eax
  004af	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  004b5	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  004ba	0f bf c9	 movsx	 ecx, cx
  004bd	03 c1		 add	 eax, ecx
  004bf	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  004c2	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  004ca	66 89 45 d6	 mov	 WORD PTR $T30[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 221  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, -1);

  004ce	66 8b 45 d6	 mov	 ax, WORD PTR $T30[ebp]
  004d2	e9 4c 07 00 00	 jmp	 $LN1@WE_GetHeig
  004d7	eb 38		 jmp	 SHORT $LN31@WE_GetHeig
$LN34@WE_GetHeig:

; 223  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY + YSIZE);

  004d9	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  004dd	05 80 00 00 00	 add	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  004e2	98		 cwde
  004e3	40		 inc	 eax
  004e4	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 223  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY + YSIZE);

  004ea	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  004ee	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  004f4	0f bf c9	 movsx	 ecx, cx
  004f7	03 c1		 add	 eax, ecx
  004f9	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  004fc	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00504	66 89 45 d4	 mov	 WORD PTR $T29[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 223  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY + YSIZE);

  00508	66 8b 45 d4	 mov	 ax, WORD PTR $T29[ebp]
  0050c	e9 12 07 00 00	 jmp	 $LN1@WE_GetHeig
$LN31@WE_GetHeig:

; 224  : 				}
; 225  : 			}

  00511	eb 78		 jmp	 SHORT $LN7@WE_GetHeig
$LN28@WE_GetHeig:

; 226  : 			else
; 227  : 			{
; 228  : 				if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 3, &pTerrain))

  00513	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00516	50		 push	 eax
  00517	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  0051b	83 e8 03	 sub	 eax, 3
  0051e	50		 push	 eax
  0051f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00522	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00528	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0052d	85 c0		 test	 eax, eax
  0052f	75 2b		 jne	 SHORT $LN36@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00531	83 c8 ff	 or	 eax, -1
  00534	98		 cwde
  00535	40		 inc	 eax
  00536	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0053c	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00540	03 c1		 add	 eax, ecx
  00542	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00545	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0054d	66 89 45 d2	 mov	 WORD PTR $T28[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 229  : 					return GetHeightMapValue(sX, -1);

  00551	66 8b 45 d2	 mov	 ax, WORD PTR $T28[ebp]
  00555	e9 c9 06 00 00	 jmp	 $LN1@WE_GetHeig
  0055a	eb 2f		 jmp	 SHORT $LN7@WE_GetHeig
$LN36@WE_GetHeig:

; 231  : 					return pTerrain->GetHeightMapValue(sX, sY + YSIZE);

  0055c	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00560	05 80 00 00 00	 add	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00565	98		 cwde
  00566	40		 inc	 eax
  00567	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0056d	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00571	03 c1		 add	 eax, ecx
  00573	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00576	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0057e	66 89 45 d0	 mov	 WORD PTR $T27[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 231  : 					return pTerrain->GetHeightMapValue(sX, sY + YSIZE);

  00582	66 8b 45 d0	 mov	 ax, WORD PTR $T27[ebp]
  00586	e9 98 06 00 00	 jmp	 $LN1@WE_GetHeig
$LN7@WE_GetHeig:

; 232  : 			}
; 233  : 		}
; 234  : 	}

  0058b	e9 93 06 00 00	 jmp	 $LN1@WE_GetHeig
$LN4@WE_GetHeig:

; 235  : 	else if (sY >= HEIGHTMAP_RAW_YSIZE - 1)

  00590	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00594	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  00599	0f 8c ce 04 00
	00		 jl	 $LN38@WE_GetHeig

; 236  : 	{
; 237  : 		if (m_wY >= sTerrainCouuntY - 1)

  0059f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005a2	0f b7 80 6e a5
	06 00		 movzx	 eax, WORD PTR [eax+435566]
  005a9	0f bf 4d cc	 movsx	 ecx, WORD PTR _sTerrainCouuntY$[ebp]
  005ad	49		 dec	 ecx
  005ae	3b c1		 cmp	 eax, ecx
  005b0	0f 8c d7 01 00
	00		 jl	 $LN40@WE_GetHeig

; 238  : 		{
; 239  : 			if (sX < -1)

  005b6	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  005ba	83 f8 ff	 cmp	 eax, -1
  005bd	0f 8d c1 00 00
	00		 jge	 $LN42@WE_GetHeig

; 240  : 			{
; 241  : 				if (m_wX <= 0)

  005c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  005c6	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  005cd	85 c0		 test	 eax, eax
  005cf	7f 2f		 jg	 SHORT $LN44@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  005d1	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  005d6	98		 cwde
  005d7	40		 inc	 eax
  005d8	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  005de	83 c9 ff	 or	 ecx, -1
  005e1	0f bf c9	 movsx	 ecx, cx
  005e4	03 c1		 add	 eax, ecx
  005e6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  005e9	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  005f1	66 89 45 ca	 mov	 WORD PTR $T26[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 242  : 					return GetHeightMapValue(-1, HEIGHTMAP_RAW_XSIZE - 1);

  005f5	66 8b 45 ca	 mov	 ax, WORD PTR $T26[ebp]
  005f9	e9 25 06 00 00	 jmp	 $LN1@WE_GetHeig
  005fe	eb 7f		 jmp	 SHORT $LN45@WE_GetHeig
$LN44@WE_GetHeig:

; 243  : 				else
; 244  : 				{
; 245  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 1, &pTerrain))

  00600	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00603	50		 push	 eax
  00604	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00608	48		 dec	 eax
  00609	50		 push	 eax
  0060a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0060d	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00613	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00618	85 c0		 test	 eax, eax
  0061a	75 2f		 jne	 SHORT $LN46@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0061c	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00621	98		 cwde
  00622	40		 inc	 eax
  00623	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00629	83 c9 ff	 or	 ecx, -1
  0062c	0f bf c9	 movsx	 ecx, cx
  0062f	03 c1		 add	 eax, ecx
  00631	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00634	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0063c	66 89 45 c8	 mov	 WORD PTR $T25[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 246  : 						return GetHeightMapValue(-1, HEIGHTMAP_RAW_XSIZE - 1);

  00640	66 8b 45 c8	 mov	 ax, WORD PTR $T25[ebp]
  00644	e9 da 05 00 00	 jmp	 $LN1@WE_GetHeig
  00649	eb 34		 jmp	 SHORT $LN45@WE_GetHeig
$LN46@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0064b	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00650	98		 cwde
  00651	40		 inc	 eax
  00652	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 248  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, HEIGHTMAP_RAW_YSIZE - 1);

  00658	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  0065c	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00662	0f bf c9	 movsx	 ecx, cx
  00665	03 c1		 add	 eax, ecx
  00667	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  0066a	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00672	66 89 45 c6	 mov	 WORD PTR $T24[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 248  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, HEIGHTMAP_RAW_YSIZE - 1);

  00676	66 8b 45 c6	 mov	 ax, WORD PTR $T24[ebp]
  0067a	e9 a4 05 00 00	 jmp	 $LN1@WE_GetHeig
$LN45@WE_GetHeig:

; 249  : 				}
; 250  : 			}

  0067f	e9 04 01 00 00	 jmp	 $LN43@WE_GetHeig
$LN42@WE_GetHeig:

; 251  : 			else if (sX >= HEIGHTMAP_RAW_XSIZE - 1)

  00684	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  00688	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  0068d	0f 8c ca 00 00
	00		 jl	 $LN48@WE_GetHeig

; 252  : 			{
; 253  : 				if (m_wX >= sTerrainCouuntX - 1)

  00693	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00696	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  0069d	0f bf 4d f0	 movsx	 ecx, WORD PTR _sTerrainCouuntX$[ebp]
  006a1	49		 dec	 ecx
  006a2	3b c1		 cmp	 eax, ecx
  006a4	7c 34		 jl	 SHORT $LN50@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  006a6	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  006ab	98		 cwde
  006ac	40		 inc	 eax
  006ad	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  006b3	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  006b8	0f bf c9	 movsx	 ecx, cx
  006bb	03 c1		 add	 eax, ecx
  006bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  006c0	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  006c8	66 89 45 c4	 mov	 WORD PTR $T23[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 254  : 					return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, HEIGHTMAP_RAW_YSIZE - 1);

  006cc	66 8b 45 c4	 mov	 ax, WORD PTR $T23[ebp]
  006d0	e9 4e 05 00 00	 jmp	 $LN1@WE_GetHeig
  006d5	e9 81 00 00 00	 jmp	 $LN51@WE_GetHeig
$LN50@WE_GetHeig:

; 255  : 				else
; 256  : 				{
; 257  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 1, &pTerrain))

  006da	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  006dd	50		 push	 eax
  006de	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  006e2	40		 inc	 eax
  006e3	50		 push	 eax
  006e4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  006e7	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  006ed	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  006f2	85 c0		 test	 eax, eax
  006f4	75 31		 jne	 SHORT $LN52@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  006f6	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  006fb	98		 cwde
  006fc	40		 inc	 eax
  006fd	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00703	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00708	0f bf c9	 movsx	 ecx, cx
  0070b	03 c1		 add	 eax, ecx
  0070d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00710	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00718	66 89 45 c2	 mov	 WORD PTR $T22[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 258  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, HEIGHTMAP_RAW_YSIZE - 1);

  0071c	66 8b 45 c2	 mov	 ax, WORD PTR $T22[ebp]
  00720	e9 fe 04 00 00	 jmp	 $LN1@WE_GetHeig
  00725	eb 34		 jmp	 SHORT $LN51@WE_GetHeig
$LN52@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00727	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  0072c	98		 cwde
  0072d	40		 inc	 eax
  0072e	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 260  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, HEIGHTMAP_RAW_YSIZE - 1);

  00734	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00738	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0073e	0f bf c9	 movsx	 ecx, cx
  00741	03 c1		 add	 eax, ecx
  00743	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00746	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0074e	66 89 45 c0	 mov	 WORD PTR $T21[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 260  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, HEIGHTMAP_RAW_YSIZE - 1);

  00752	66 8b 45 c0	 mov	 ax, WORD PTR $T21[ebp]
  00756	e9 c8 04 00 00	 jmp	 $LN1@WE_GetHeig
$LN51@WE_GetHeig:

; 261  : 				}
; 262  : 			}

  0075b	eb 2b		 jmp	 SHORT $LN43@WE_GetHeig
$LN48@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0075d	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00762	98		 cwde
  00763	40		 inc	 eax
  00764	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0076a	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  0076e	03 c1		 add	 eax, ecx
  00770	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00773	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0077b	66 89 45 be	 mov	 WORD PTR $T20[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 264  : 				return GetHeightMapValue(sX, HEIGHTMAP_RAW_YSIZE - 1);

  0077f	66 8b 45 be	 mov	 ax, WORD PTR $T20[ebp]
  00783	e9 9b 04 00 00	 jmp	 $LN1@WE_GetHeig
$LN43@WE_GetHeig:

; 265  : 		}

  00788	e9 db 02 00 00	 jmp	 $LN41@WE_GetHeig
$LN40@WE_GetHeig:

; 266  : 		else
; 267  : 		{
; 268  : 			if (sX < -1)

  0078d	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  00791	83 f8 ff	 cmp	 eax, -1
  00794	0f 8d 1e 01 00
	00		 jge	 $LN54@WE_GetHeig

; 269  : 			{
; 270  : 				if (m_wX <= 0)

  0079a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0079d	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  007a4	85 c0		 test	 eax, eax
  007a6	0f 8f 83 00 00
	00		 jg	 $LN56@WE_GetHeig

; 271  : 				{
; 272  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 3, &pTerrain))

  007ac	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  007af	50		 push	 eax
  007b0	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  007b4	83 c0 03	 add	 eax, 3
  007b7	50		 push	 eax
  007b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  007bb	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  007c1	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  007c6	85 c0		 test	 eax, eax
  007c8	75 2f		 jne	 SHORT $LN58@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  007ca	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  007cf	98		 cwde
  007d0	40		 inc	 eax
  007d1	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  007d7	83 c9 ff	 or	 ecx, -1
  007da	0f bf c9	 movsx	 ecx, cx
  007dd	03 c1		 add	 eax, ecx
  007df	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  007e2	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  007ea	66 89 45 bc	 mov	 WORD PTR $T19[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 273  : 						return GetHeightMapValue(-1, HEIGHTMAP_RAW_YSIZE - 1);

  007ee	66 8b 45 bc	 mov	 ax, WORD PTR $T19[ebp]
  007f2	e9 2c 04 00 00	 jmp	 $LN1@WE_GetHeig
  007f7	eb 31		 jmp	 SHORT $LN59@WE_GetHeig
$LN58@WE_GetHeig:

; 275  : 						return pTerrain->GetHeightMapValue(-1, sY - YSIZE);

  007f9	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  007fd	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00802	98		 cwde
  00803	40		 inc	 eax
  00804	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0080a	83 c9 ff	 or	 ecx, -1
  0080d	0f bf c9	 movsx	 ecx, cx
  00810	03 c1		 add	 eax, ecx
  00812	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00815	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0081d	66 89 45 ba	 mov	 WORD PTR $T18[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 275  : 						return pTerrain->GetHeightMapValue(-1, sY - YSIZE);

  00821	66 8b 45 ba	 mov	 ax, WORD PTR $T18[ebp]
  00825	e9 f9 03 00 00	 jmp	 $LN1@WE_GetHeig
$LN59@WE_GetHeig:

; 276  : 				}

  0082a	e9 84 00 00 00	 jmp	 $LN57@WE_GetHeig
$LN56@WE_GetHeig:

; 277  : 				else
; 278  : 				{
; 279  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 2, &pTerrain))

  0082f	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00832	50		 push	 eax
  00833	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00837	40		 inc	 eax
  00838	40		 inc	 eax
  00839	50		 push	 eax
  0083a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0083d	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00843	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00848	85 c0		 test	 eax, eax
  0084a	75 2f		 jne	 SHORT $LN60@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  0084c	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00851	98		 cwde
  00852	40		 inc	 eax
  00853	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00859	83 c9 ff	 or	 ecx, -1
  0085c	0f bf c9	 movsx	 ecx, cx
  0085f	03 c1		 add	 eax, ecx
  00861	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00864	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0086c	66 89 45 b8	 mov	 WORD PTR $T17[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 280  : 						return GetHeightMapValue(-1, HEIGHTMAP_RAW_XSIZE - 1);

  00870	66 8b 45 b8	 mov	 ax, WORD PTR $T17[ebp]
  00874	e9 aa 03 00 00	 jmp	 $LN1@WE_GetHeig
  00879	eb 38		 jmp	 SHORT $LN57@WE_GetHeig
$LN60@WE_GetHeig:

; 282  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY - YSIZE);

  0087b	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  0087f	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00884	98		 cwde
  00885	40		 inc	 eax
  00886	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 282  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY - YSIZE);

  0088c	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00890	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00896	0f bf c9	 movsx	 ecx, cx
  00899	03 c1		 add	 eax, ecx
  0089b	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  0089e	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  008a6	66 89 45 b6	 mov	 WORD PTR $T16[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 282  : 						return pTerrain->GetHeightMapValue(sX + XSIZE, sY - YSIZE);

  008aa	66 8b 45 b6	 mov	 ax, WORD PTR $T16[ebp]
  008ae	e9 70 03 00 00	 jmp	 $LN1@WE_GetHeig
$LN57@WE_GetHeig:

; 283  : 				}
; 284  : 			}

  008b3	e9 b0 01 00 00	 jmp	 $LN41@WE_GetHeig
$LN54@WE_GetHeig:

; 285  : 			else if (sX >= HEIGHTMAP_RAW_XSIZE - 1)

  008b8	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  008bc	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  008c1	0f 8c 27 01 00
	00		 jl	 $LN62@WE_GetHeig

; 286  : 			{
; 287  : 				if (m_wX >= sTerrainCouuntX - 1)

  008c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008ca	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  008d1	0f bf 4d f0	 movsx	 ecx, WORD PTR _sTerrainCouuntX$[ebp]
  008d5	49		 dec	 ecx
  008d6	3b c1		 cmp	 eax, ecx
  008d8	0f 8c 87 00 00
	00		 jl	 $LN64@WE_GetHeig

; 288  : 				{
; 289  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 3, &pTerrain))

  008de	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  008e1	50		 push	 eax
  008e2	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  008e6	83 c0 03	 add	 eax, 3
  008e9	50		 push	 eax
  008ea	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  008ed	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  008f3	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  008f8	85 c0		 test	 eax, eax
  008fa	75 31		 jne	 SHORT $LN66@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  008fc	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00901	98		 cwde
  00902	40		 inc	 eax
  00903	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00909	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  0090e	0f bf c9	 movsx	 ecx, cx
  00911	03 c1		 add	 eax, ecx
  00913	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00916	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  0091e	66 89 45 b4	 mov	 WORD PTR $T15[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 290  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, HEIGHTMAP_RAW_YSIZE - 1);

  00922	66 8b 45 b4	 mov	 ax, WORD PTR $T15[ebp]
  00926	e9 f8 02 00 00	 jmp	 $LN1@WE_GetHeig
  0092b	eb 33		 jmp	 SHORT $LN67@WE_GetHeig
$LN66@WE_GetHeig:

; 292  : 						return pTerrain->GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY - YSIZE);

  0092d	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00931	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00936	98		 cwde
  00937	40		 inc	 eax
  00938	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  0093e	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00943	0f bf c9	 movsx	 ecx, cx
  00946	03 c1		 add	 eax, ecx
  00948	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  0094b	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00953	66 89 45 b2	 mov	 WORD PTR $T14[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 292  : 						return pTerrain->GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY - YSIZE);

  00957	66 8b 45 b2	 mov	 ax, WORD PTR $T14[ebp]
  0095b	e9 c3 02 00 00	 jmp	 $LN1@WE_GetHeig
$LN67@WE_GetHeig:

; 293  : 				}

  00960	e9 87 00 00 00	 jmp	 $LN65@WE_GetHeig
$LN64@WE_GetHeig:

; 294  : 				else
; 295  : 				{
; 296  : 					if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 4, &pTerrain))

  00965	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00968	50		 push	 eax
  00969	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  0096d	83 c0 04	 add	 eax, 4
  00970	50		 push	 eax
  00971	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00974	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  0097a	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0097f	85 c0		 test	 eax, eax
  00981	75 31		 jne	 SHORT $LN68@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00983	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00988	98		 cwde
  00989	40		 inc	 eax
  0098a	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00990	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00995	0f bf c9	 movsx	 ecx, cx
  00998	03 c1		 add	 eax, ecx
  0099a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0099d	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  009a5	66 89 45 b0	 mov	 WORD PTR $T13[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 297  : 						return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, HEIGHTMAP_RAW_YSIZE - 1);

  009a9	66 8b 45 b0	 mov	 ax, WORD PTR $T13[ebp]
  009ad	e9 71 02 00 00	 jmp	 $LN1@WE_GetHeig
  009b2	eb 38		 jmp	 SHORT $LN65@WE_GetHeig
$LN68@WE_GetHeig:

; 299  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY - YSIZE);

  009b4	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  009b8	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  009bd	98		 cwde
  009be	40		 inc	 eax
  009bf	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 299  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY - YSIZE);

  009c5	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  009c9	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  009cf	0f bf c9	 movsx	 ecx, cx
  009d2	03 c1		 add	 eax, ecx
  009d4	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  009d7	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  009df	66 89 45 ae	 mov	 WORD PTR $T12[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 299  : 						return pTerrain->GetHeightMapValue(sX - XSIZE, sY - YSIZE);

  009e3	66 8b 45 ae	 mov	 ax, WORD PTR $T12[ebp]
  009e7	e9 37 02 00 00	 jmp	 $LN1@WE_GetHeig
$LN65@WE_GetHeig:

; 300  : 				}
; 301  : 			}

  009ec	eb 7a		 jmp	 SHORT $LN41@WE_GetHeig
$LN62@WE_GetHeig:

; 302  : 			else
; 303  : 			{
; 304  : 				if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 3, &pTerrain))

  009ee	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  009f1	50		 push	 eax
  009f2	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  009f6	83 c0 03	 add	 eax, 3
  009f9	50		 push	 eax
  009fa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  009fd	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00a03	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00a08	85 c0		 test	 eax, eax
  00a0a	75 2d		 jne	 SHORT $LN70@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00a0c	b8 82 00 00 00	 mov	 eax, 130		; 00000082H
  00a11	98		 cwde
  00a12	40		 inc	 eax
  00a13	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00a19	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00a1d	03 c1		 add	 eax, ecx
  00a1f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a22	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00a2a	66 89 45 ac	 mov	 WORD PTR $T11[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 305  : 					return GetHeightMapValue(sX, HEIGHTMAP_RAW_YSIZE - 1);

  00a2e	66 8b 45 ac	 mov	 ax, WORD PTR $T11[ebp]
  00a32	e9 ec 01 00 00	 jmp	 $LN1@WE_GetHeig
  00a37	eb 2f		 jmp	 SHORT $LN41@WE_GetHeig
$LN70@WE_GetHeig:

; 307  : 					return pTerrain->GetHeightMapValue(sX, sY - YSIZE);

  00a39	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00a3d	2d 80 00 00 00	 sub	 eax, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00a42	98		 cwde
  00a43	40		 inc	 eax
  00a44	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00a4a	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00a4e	03 c1		 add	 eax, ecx
  00a50	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00a53	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00a5b	66 89 45 aa	 mov	 WORD PTR $T10[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 307  : 					return pTerrain->GetHeightMapValue(sX, sY - YSIZE);

  00a5f	66 8b 45 aa	 mov	 ax, WORD PTR $T10[ebp]
  00a63	e9 bb 01 00 00	 jmp	 $LN1@WE_GetHeig
$LN41@WE_GetHeig:

; 308  : 			}
; 309  : 		}
; 310  : 	}

  00a68	e9 b6 01 00 00	 jmp	 $LN1@WE_GetHeig
$LN38@WE_GetHeig:

; 311  : 	else
; 312  : 	{
; 313  : 		if (sX < -1)

  00a6d	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  00a71	83 f8 ff	 cmp	 eax, -1
  00a74	0f 8d bb 00 00
	00		 jge	 $LN72@WE_GetHeig

; 314  : 		{
; 315  : 			if (m_wX <= 0)

  00a7a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00a7d	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  00a84	85 c0		 test	 eax, eax
  00a86	7f 2d		 jg	 SHORT $LN74@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00a88	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00a8c	40		 inc	 eax
  00a8d	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00a93	83 c9 ff	 or	 ecx, -1
  00a96	0f bf c9	 movsx	 ecx, cx
  00a99	03 c1		 add	 eax, ecx
  00a9b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00a9e	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00aa6	66 89 45 a8	 mov	 WORD PTR $T9[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 316  : 				return GetHeightMapValue(-1, sY);

  00aaa	66 8b 45 a8	 mov	 ax, WORD PTR $T9[ebp]
  00aae	e9 70 01 00 00	 jmp	 $LN1@WE_GetHeig
  00ab3	eb 7b		 jmp	 SHORT $LN75@WE_GetHeig
$LN74@WE_GetHeig:

; 317  : 			else
; 318  : 			{
; 319  : 				if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum - 1, &pTerrain))

  00ab5	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00ab8	50		 push	 eax
  00ab9	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00abd	48		 dec	 eax
  00abe	50		 push	 eax
  00abf	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00ac2	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00ac8	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00acd	85 c0		 test	 eax, eax
  00acf	75 2d		 jne	 SHORT $LN76@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00ad1	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00ad5	40		 inc	 eax
  00ad6	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00adc	83 c9 ff	 or	 ecx, -1
  00adf	0f bf c9	 movsx	 ecx, cx
  00ae2	03 c1		 add	 eax, ecx
  00ae4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae7	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00aef	66 89 45 a6	 mov	 WORD PTR $T8[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 320  : 					return GetHeightMapValue(-1, sY);

  00af3	66 8b 45 a6	 mov	 ax, WORD PTR $T8[ebp]
  00af7	e9 27 01 00 00	 jmp	 $LN1@WE_GetHeig
  00afc	eb 32		 jmp	 SHORT $LN75@WE_GetHeig
$LN76@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00afe	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00b02	40		 inc	 eax
  00b03	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 322  : 					return pTerrain->GetHeightMapValue(sX + XSIZE, sY);

  00b09	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00b0d	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00b13	0f bf c9	 movsx	 ecx, cx
  00b16	03 c1		 add	 eax, ecx
  00b18	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00b1b	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00b23	66 89 45 a4	 mov	 WORD PTR $T7[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 322  : 					return pTerrain->GetHeightMapValue(sX + XSIZE, sY);

  00b27	66 8b 45 a4	 mov	 ax, WORD PTR $T7[ebp]
  00b2b	e9 f3 00 00 00	 jmp	 $LN1@WE_GetHeig
$LN75@WE_GetHeig:

; 323  : 			}
; 324  : 		}

  00b30	e9 ee 00 00 00	 jmp	 $LN1@WE_GetHeig
$LN72@WE_GetHeig:

; 325  : 		else if (sX >= HEIGHTMAP_RAW_XSIZE - 1)

  00b35	0f bf 45 08	 movsx	 eax, WORD PTR _sX$[ebp]
  00b39	3d 82 00 00 00	 cmp	 eax, 130		; 00000082H
  00b3e	0f 8c bb 00 00
	00		 jl	 $LN78@WE_GetHeig

; 326  : 		{
; 327  : 			if (m_wX >= sTerrainCouuntX - 1)

  00b44	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b47	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  00b4e	0f bf 4d f0	 movsx	 ecx, WORD PTR _sTerrainCouuntX$[ebp]
  00b52	49		 dec	 ecx
  00b53	3b c1		 cmp	 eax, ecx
  00b55	7c 2f		 jl	 SHORT $LN80@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00b57	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00b5b	40		 inc	 eax
  00b5c	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00b62	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00b67	0f bf c9	 movsx	 ecx, cx
  00b6a	03 c1		 add	 eax, ecx
  00b6c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00b6f	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00b77	66 89 45 a2	 mov	 WORD PTR $T6[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 328  : 				return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY);

  00b7b	66 8b 45 a2	 mov	 ax, WORD PTR $T6[ebp]
  00b7f	e9 9f 00 00 00	 jmp	 $LN1@WE_GetHeig
  00b84	eb 77		 jmp	 SHORT $LN81@WE_GetHeig
$LN80@WE_GetHeig:

; 329  : 			else
; 330  : 			{
; 331  : 				if (!m_pOwnerOutdoorMap->GetTerrainPointer(byTerrainNum + 1, &pTerrain))

  00b86	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00b89	50		 push	 eax
  00b8a	0f b6 45 ff	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00b8e	40		 inc	 eax
  00b8f	50		 push	 eax
  00b90	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00b93	8b 88 b8 a5 06
	00		 mov	 ecx, DWORD PTR [eax+435640]
  00b99	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00b9e	85 c0		 test	 eax, eax
  00ba0	75 2c		 jne	 SHORT $LN82@WE_GetHeig
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00ba2	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00ba6	40		 inc	 eax
  00ba7	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00bad	b9 82 00 00 00	 mov	 ecx, 130		; 00000082H
  00bb2	0f bf c9	 movsx	 ecx, cx
  00bb5	03 c1		 add	 eax, ecx
  00bb7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00bba	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00bc2	66 89 45 a0	 mov	 WORD PTR $T5[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 332  : 					return GetHeightMapValue(HEIGHTMAP_RAW_XSIZE - 1, sY);

  00bc6	66 8b 45 a0	 mov	 ax, WORD PTR $T5[ebp]
  00bca	eb 57		 jmp	 SHORT $LN1@WE_GetHeig
  00bcc	eb 2f		 jmp	 SHORT $LN81@WE_GetHeig
$LN82@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00bce	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00bd2	40		 inc	 eax
  00bd3	69 c0 83 00 00
	00		 imul	 eax, eax, 131
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 334  : 					return pTerrain->GetHeightMapValue(sX - XSIZE, sY);

  00bd9	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00bdd	81 e9 80 00 00
	00		 sub	 ecx, 128		; 00000080H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00be3	0f bf c9	 movsx	 ecx, cx
  00be6	03 c1		 add	 eax, ecx
  00be8	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00beb	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00bf3	66 89 45 9e	 mov	 WORD PTR $T4[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 334  : 					return pTerrain->GetHeightMapValue(sX - XSIZE, sY);

  00bf7	66 8b 45 9e	 mov	 ax, WORD PTR $T4[ebp]
  00bfb	eb 26		 jmp	 SHORT $LN1@WE_GetHeig
$LN81@WE_GetHeig:

; 335  : 			}
; 336  : 		}

  00bfd	eb 24		 jmp	 SHORT $LN1@WE_GetHeig
$LN78@WE_GetHeig:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 153  : 	return m_awRawHeightMap[(sy+1) * HEIGHTMAP_RAW_XSIZE + sx+1];

  00bff	0f bf 45 0c	 movsx	 eax, WORD PTR _sY$[ebp]
  00c03	40		 inc	 eax
  00c04	69 c0 83 00 00
	00		 imul	 eax, eax, 131
  00c0a	0f bf 4d 08	 movsx	 ecx, WORD PTR _sX$[ebp]
  00c0e	03 c1		 add	 eax, ecx
  00c10	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00c13	66 8b 84 41 06
	04 00 00	 mov	 ax, WORD PTR [ecx+eax*2+1030]
  00c1b	66 89 45 9c	 mov	 WORD PTR $T3[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 338  : 			return GetHeightMapValue(sX, sY);

  00c1f	66 8b 45 9c	 mov	 ax, WORD PTR $T3[ebp]
$LN1@WE_GetHeig:

; 339  : 	}
; 340  : }

  00c23	c9		 leave
  00c24	c2 08 00	 ret	 8
?WE_GetHeightMapValue@CTerrain@@QAEGFF@Z ENDP		; CTerrain::WE_GetHeightMapValue
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ PROC	; CTerrain::CopySettingFromGlobalSetting, COMDAT
; _this$ = ecx

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h

; 255  : 		const long		GetViewRadius()			{ return m_lViewRadius;		}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 b8 a5 06
	00		 mov	 eax, DWORD PTR [eax+435640]
  00012	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00015	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 138  : 	m_lViewRadius	= m_pOwnerOutdoorMap->GetViewRadius();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  0001e	89 88 34 91 03
	00		 mov	 DWORD PTR [eax+233780], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h

; 256  : 		const float		GetHeightScale()		{ return m_fHeightScale;	}

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 80 b8 a5 06
	00		 mov	 eax, DWORD PTR [eax+435640]
  0002d	f3 0f 10 40 6c	 movss	 xmm0, DWORD PTR [eax+108]
  00032	f3 0f 11 45 f4	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 139  : 	m_fHeightScale	= m_pOwnerOutdoorMap->GetHeightScale();

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR $T1[ebp]
  0003f	f3 0f 11 80 38
	91 03 00	 movss	 DWORD PTR [eax+233784], xmm0

; 140  : }

  00047	c9		 leave
  00048	c3		 ret	 0
?CopySettingFromGlobalSetting@CTerrain@@QAEXXZ ENDP	; CTerrain::CopySettingFromGlobalSetting
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?CalculateTerrainPatch@CTerrain@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_byPatchNumX$1 = -8					; size = 1
_byPatchNumY$2 = -4					; size = 1
?CalculateTerrainPatch@CTerrain@@QAEXXZ PROC		; CTerrain::CalculateTerrainPatch, COMDAT
; _this$ = ecx

; 913  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 914  : 	for (BYTE byPatchNumY = 0; byPatchNumY < PATCH_YCOUNT; ++byPatchNumY)

  00009	c6 45 fc 00	 mov	 BYTE PTR _byPatchNumY$2[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@CalculateT
$LN2@CalculateT:
  0000f	8a 45 fc	 mov	 al, BYTE PTR _byPatchNumY$2[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 fc	 mov	 BYTE PTR _byPatchNumY$2[ebp], al
$LN4@CalculateT:
  00017	0f b6 45 fc	 movzx	 eax, BYTE PTR _byPatchNumY$2[ebp]
  0001b	83 f8 08	 cmp	 eax, 8
  0001e	7d 29		 jge	 SHORT $LN1@CalculateT

; 915  : 		for (BYTE byPatchNumX = 0; byPatchNumX < PATCH_XCOUNT; ++byPatchNumX)

  00020	c6 45 f8 00	 mov	 BYTE PTR _byPatchNumX$1[ebp], 0
  00024	eb 08		 jmp	 SHORT $LN7@CalculateT
$LN5@CalculateT:
  00026	8a 45 f8	 mov	 al, BYTE PTR _byPatchNumX$1[ebp]
  00029	04 01		 add	 al, 1
  0002b	88 45 f8	 mov	 BYTE PTR _byPatchNumX$1[ebp], al
$LN7@CalculateT:
  0002e	0f b6 45 f8	 movzx	 eax, BYTE PTR _byPatchNumX$1[ebp]
  00032	83 f8 08	 cmp	 eax, 8
  00035	7d 10		 jge	 SHORT $LN6@CalculateT

; 916  : 			_CalculateTerrainPatch(byPatchNumX, byPatchNumY);

  00037	ff 75 fc	 push	 DWORD PTR _byPatchNumY$2[ebp]
  0003a	ff 75 f8	 push	 DWORD PTR _byPatchNumX$1[ebp]
  0003d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_CalculateTerrainPatch@CTerrain@@IAEXEE@Z ; CTerrain::_CalculateTerrainPatch
  00045	eb df		 jmp	 SHORT $LN5@CalculateT
$LN6@CalculateT:
  00047	eb c6		 jmp	 SHORT $LN2@CalculateT
$LN1@CalculateT:

; 917  : }

  00049	c9		 leave
  0004a	c3		 ret	 0
?CalculateTerrainPatch@CTerrain@@QAEXXZ ENDP		; CTerrain::CalculateTerrainPatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?LoadHeightMap@CTerrain@@QAE_NPBD@Z
_TEXT	SEGMENT
_dwStart$ = -16						; size = 4
_this$ = -12						; size = 4
_x$1 = -8						; size = 2
_y$2 = -4						; size = 2
_c_pszFileName$ = 8					; size = 4
?LoadHeightMap@CTerrain@@QAE_NPBD@Z PROC		; CTerrain::LoadHeightMap, COMDAT
; _this$ = ecx

; 471  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 472  : 	CTerrainImpl::LoadHeightMap(c_pszFileName);

  00009	ff 75 08	 push	 DWORD PTR _c_pszFileName$[ebp]
  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?LoadHeightMap@CTerrainImpl@@IAE_NPBD@Z ; CTerrainImpl::LoadHeightMap

; 473  : 	DWORD dwStart = ELTimer_GetMSec();

  00014	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00019	89 45 f0	 mov	 DWORD PTR _dwStart$[ebp], eax

; 474  : 	for (WORD y = 0; y < NORMALMAP_YSIZE; ++y)

  0001c	33 c0		 xor	 eax, eax
  0001e	66 89 45 fc	 mov	 WORD PTR _y$2[ebp], ax
  00022	eb 0c		 jmp	 SHORT $LN4@LoadHeight
$LN2@LoadHeight:
  00024	66 8b 45 fc	 mov	 ax, WORD PTR _y$2[ebp]
  00028	66 83 c0 01	 add	 ax, 1
  0002c	66 89 45 fc	 mov	 WORD PTR _y$2[ebp], ax
$LN4@LoadHeight:
  00030	0f b7 45 fc	 movzx	 eax, WORD PTR _y$2[ebp]
  00034	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  00039	7d 35		 jge	 SHORT $LN3@LoadHeight

; 475  : 		for (WORD x = 0; x < NORMALMAP_XSIZE; ++x)

  0003b	33 c0		 xor	 eax, eax
  0003d	66 89 45 f8	 mov	 WORD PTR _x$1[ebp], ax
  00041	eb 0c		 jmp	 SHORT $LN7@LoadHeight
$LN5@LoadHeight:
  00043	66 8b 45 f8	 mov	 ax, WORD PTR _x$1[ebp]
  00047	66 83 c0 01	 add	 ax, 1
  0004b	66 89 45 f8	 mov	 WORD PTR _x$1[ebp], ax
$LN7@LoadHeight:
  0004f	0f b7 45 f8	 movzx	 eax, WORD PTR _x$1[ebp]
  00053	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  00058	7d 14		 jge	 SHORT $LN6@LoadHeight

; 476  : 			CalculateNormal(x, y);

  0005a	0f b7 45 fc	 movzx	 eax, WORD PTR _y$2[ebp]
  0005e	50		 push	 eax
  0005f	0f b7 45 f8	 movzx	 eax, WORD PTR _x$1[ebp]
  00063	50		 push	 eax
  00064	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?CalculateNormal@CTerrain@@IAEXJJ@Z ; CTerrain::CalculateNormal
  0006c	eb d5		 jmp	 SHORT $LN5@LoadHeight
$LN6@LoadHeight:
  0006e	eb b4		 jmp	 SHORT $LN2@LoadHeight
$LN3@LoadHeight:

; 477  : 		
; 478  : 	Tracef("LoadHeightMap::CalculateNormal %d ms\n", ELTimer_GetMSec() - dwStart);

  00070	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00075	2b 45 f0	 sub	 eax, DWORD PTR _dwStart$[ebp]
  00078	50		 push	 eax
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@DNKMEFFO@LoadHeightMap?3?3CalculateNormal?5@
  0007e	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00083	59		 pop	 ecx
  00084	59		 pop	 ecx

; 479  : 	return true;

  00085	b0 01		 mov	 al, 1

; 480  : }

  00087	c9		 leave
  00088	c2 04 00	 ret	 4
?LoadHeightMap@CTerrain@@QAE_NPBD@Z ENDP		; CTerrain::LoadHeightMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z
_TEXT	SEGMENT
_dwStart$ = -8						; size = 4
_this$ = -4						; size = 4
_c_pszFileName$ = 8					; size = 4
_bBGLoading$ = 12					; size = 1
?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z PROC		; CTerrain::RAW_LoadTileMap, COMDAT
; _this$ = ecx

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 	CTerrainImpl::RAW_LoadTileMap(c_pszFileName);

  00008	ff 75 08	 push	 DWORD PTR _c_pszFileName$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?RAW_LoadTileMap@CTerrainImpl@@IAE_NPBD@Z ; CTerrainImpl::RAW_LoadTileMap

; 464  : 	DWORD dwStart = ELTimer_GetMSec();

  00013	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  00018	89 45 f8	 mov	 DWORD PTR _dwStart$[ebp], eax

; 465  : 	RAW_AllocateSplats(bBGLoading);

  0001b	ff 75 0c	 push	 DWORD PTR _bBGLoading$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?RAW_AllocateSplats@CTerrain@@IAEX_N@Z ; CTerrain::RAW_AllocateSplats

; 466  : 	Tracef("CTerrain::RAW_AllocateSplats %d\n", ELTimer_GetMSec() - dwStart);

  00026	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  0002b	2b 45 f8	 sub	 eax, DWORD PTR _dwStart$[ebp]
  0002e	50		 push	 eax
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BJJCGNIJ@CTerrain?3?3RAW_AllocateSplats?5?$CFd@
  00034	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx

; 467  : 	return true;

  0003b	b0 01		 mov	 al, 1

; 468  : }

  0003d	c9		 leave
  0003e	c2 08 00	 ret	 8
?RAW_LoadTileMap@CTerrain@@QAE_NPBD_N@Z ENDP		; CTerrain::RAW_LoadTileMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pOwnerOutdoorMap$ = 8					; size = 4
?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z PROC	; CTerrain::SetMapOutDoor, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	m_pOwnerOutdoorMap=pOwnerOutdoorMap;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pOwnerOutdoorMap$[ebp]
  0000d	89 88 b8 a5 06
	00		 mov	 DWORD PTR [eax+435640], ecx

; 46   : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetMapOutDoor@CTerrain@@QAEXPAVCMapOutdoor@@@Z ENDP	; CTerrain::SetMapOutDoor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ?Clear@CTerrain@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CTerrain@@UAEXXZ PROC				; CTerrain::Clear, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 	DeallocateMarkedSplats();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?DeallocateMarkedSplats@CTerrain@@QAEXXZ ; CTerrain::DeallocateMarkedSplats

; 51   : 	CTerrainImpl::Clear();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Clear@CTerrainImpl@@MAEXXZ ; CTerrainImpl::Clear

; 52   :   	Initialize();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?Initialize@CTerrain@@IAE_NXZ ; CTerrain::Initialize

; 53   : }

  0001f	c9		 leave
  00020	c3		 ret	 0
?Clear@CTerrain@@UAEXXZ ENDP				; CTerrain::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ??1CTerrain@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTerrain@@UAE@XZ PROC				; CTerrain::~CTerrain, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTerrain@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTerrain@@6BCTerrainImpl@@@
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 80 50 a5 06
	00 00 00 00 00	 mov	 DWORD PTR [eax+435536], OFFSET ??_7CTerrain@@6BCGraphicBase@@@

; 38   : 	DeallocateMarkedSplats();

  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?DeallocateMarkedSplats@CTerrain@@QAEXXZ ; CTerrain::DeallocateMarkedSplats

; 39   : 	RAW_DeallocateSplats();

  00044	6a 00		 push	 0
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?RAW_DeallocateSplats@CTerrain@@IAEX_N@Z ; CTerrain::RAW_DeallocateSplats

; 40   : 	Clear();

  0004e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?Clear@CTerrain@@UAEXXZ	; CTerrain::Clear

; 41   : }

  00056	68 00 00 00 00	 push	 OFFSET ??1CTerrainPatch@@QAE@XZ ; CTerrainPatch::~CTerrainPatch
  0005b	6a 40		 push	 64			; 00000040H
  0005d	6a 70		 push	 112			; 00000070H
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	05 d8 a5 06 00	 add	 eax, 435672		; 0006a5d8H
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	81 c1 cc a5 06
	00		 add	 ecx, 435660		; 0006a5ccH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00076	e8 00 00 00 00	 call	 ?_Tidy@?$vector@KV?$allocator@K@std@@@std@@AAEXXZ ; std::vector<unsigned long,std::allocator<unsigned long> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 41   : }

  0007b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  00084	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00089	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  00092	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	81 c1 54 a5 06
	00		 add	 ecx, 435540		; 0006a554H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000a0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 41   : }

  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	81 c1 50 a5 06
	00		 add	 ecx, 435536		; 0006a550H
  000ae	e8 00 00 00 00	 call	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
  000b3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	e8 00 00 00 00	 call	 ??1CTerrainImpl@@UAE@XZ	; CTerrainImpl::~CTerrainImpl
  000bb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000be	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c5	59		 pop	 ecx
  000c6	c9		 leave
  000c7	c3		 ret	 0
  000c8	cc		 int	 3
  000c9	cc		 int	 3
  000ca	cc		 int	 3
  000cb	cc		 int	 3
  000cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CTerrain@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTerrain@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTerrain@@UAE@XZ ENDP				; CTerrain::~CTerrain
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp
;	COMDAT ??0CTerrain@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTerrain@@QAE@XZ PROC				; CTerrain::CTerrain, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTerrain@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CTerrainImpl@@QAE@XZ	; CTerrainImpl::CTerrainImpl
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 50 a5 06
	00		 add	 ecx, 435536		; 0006a550H
  0003d	e8 00 00 00 00	 call	 ??0CGraphicBase@@QAE@XZ	; CGraphicBase::CGraphicBase
  00042	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTerrain@@6BCTerrainImpl@@@
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 80 50 a5 06
	00 00 00 00 00	 mov	 DWORD PTR [eax+435536], OFFSET ??_7CTerrain@@6BCGraphicBase@@@
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	81 c1 54 a5 06
	00		 add	 ecx, 435540		; 0006a554H
  00065	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0006a	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00071	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  00077	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0007c	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  00089	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0008e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	05 cc a5 06 00	 add	 eax, 435660		; 0006a5ccH
  0009a	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0009d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a3	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  000a9	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  000ac	83 20 00	 and	 DWORD PTR [eax], 0
  000af	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  000b2	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  000b6	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  000b9	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.cpp

; 30   : {

  000bd	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000c1	68 00 00 00 00	 push	 OFFSET ??1CTerrainPatch@@QAE@XZ ; CTerrainPatch::~CTerrainPatch
  000c6	68 00 00 00 00	 push	 OFFSET ??0CTerrainPatch@@QAE@XZ ; CTerrainPatch::CTerrainPatch
  000cb	6a 40		 push	 64			; 00000040H
  000cd	6a 70		 push	 112			; 00000070H
  000cf	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	05 d8 a5 06 00	 add	 eax, 435672		; 0006a5d8H
  000d7	50		 push	 eax
  000d8	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  000dd	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 31   : 	memset(&m_lpAlphaTexture, 0, sizeof(m_lpAlphaTexture));

  000e1	68 00 04 00 00	 push	 1024			; 00000400H
  000e6	6a 00		 push	 0
  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	83 c0 04	 add	 eax, 4
  000ee	50		 push	 eax
  000ef	e8 00 00 00 00	 call	 _memset
  000f4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 32   : 	memset(&m_lpMarkedTexture, 0, sizeof(m_lpMarkedTexture));

  000f7	6a 04		 push	 4
  000f9	6a 00		 push	 0
  000fb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	05 e0 d1 07 00	 add	 eax, 512480		; 0007d1e0H
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 _memset
  00109	83 c4 0c	 add	 esp, 12			; 0000000cH

; 33   : 	Initialize();

  0010c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010f	e8 00 00 00 00	 call	 ?Initialize@CTerrain@@IAE_NXZ ; CTerrain::Initialize

; 34   : }

  00114	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00118	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00125	59		 pop	 ecx
  00126	c9		 leave
  00127	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTerrain@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CTerrainImpl@@UAE@XZ	; CTerrainImpl::~CTerrainImpl
__unwindfunclet$??0CTerrain@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 50 a5 06
	00		 add	 ecx, 435536		; 0006a550H
  00011	e9 00 00 00 00	 jmp	 ??1CGraphicBase@@UAE@XZ	; CGraphicBase::~CGraphicBase
__unwindfunclet$??0CTerrain@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 54 a5 06
	00		 add	 ecx, 435540		; 0006a554H
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CTerrain@@QAE@XZ$3:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 74 a5 06
	00		 add	 ecx, 435572		; 0006a574H
  0002d	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CTerrain@@QAE@XZ$4:
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	81 c1 94 a5 06
	00		 add	 ecx, 435604		; 0006a594H
  0003b	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CTerrain@@QAE@XZ$5:
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	81 c1 cc a5 06
	00		 add	 ecx, 435660		; 0006a5ccH
  00049	e9 00 00 00 00	 jmp	 ??1?$vector@KV?$allocator@K@std@@@std@@QAE@XZ ; std::vector<unsigned long,std::allocator<unsigned long> >::~vector<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0CTerrain@@QAE@XZ$6:
  0004e	68 00 00 00 00	 push	 OFFSET ??1CTerrainPatch@@QAE@XZ ; CTerrainPatch::~CTerrainPatch
  00053	6a 40		 push	 64			; 00000040H
  00055	6a 70		 push	 112			; 00000070H
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	05 d8 a5 06 00	 add	 eax, 435672		; 0006a5d8H
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
__ehhandler$??0CTerrain@@QAE@XZ:
  0006b	90		 npad	 1
  0006c	90		 npad	 1
  0006d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00071	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00074	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00077	33 c8		 xor	 ecx, eax
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTerrain@@QAE@XZ
  00083	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTerrain@@QAE@XZ ENDP				; CTerrain::CTerrain
; Function compile flags: /Odspy
;	COMDAT ??1SHardwareTransformPatch@CTerrainPatch@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SHardwareTransformPatch@CTerrainPatch@@QAE@XZ PROC	; CTerrainPatch::SHardwareTransformPatch::~SHardwareTransformPatch, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
  0000f	c9		 leave
  00010	c3		 ret	 0
??1SHardwareTransformPatch@CTerrainPatch@@QAE@XZ ENDP	; CTerrainPatch::SHardwareTransformPatch::~SHardwareTransformPatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
;	COMDAT ??1CTerrainPatch@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CTerrainPatch@@QAE@XZ PROC				; CTerrainPatch::~CTerrainPatch, COMDAT
; _this$ = ecx

; 57   : 	~CTerrainPatch()									{ Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CTerrainPatch@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Clear@CTerrainPatch@@QAEXXZ ; CTerrainPatch::Clear
  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00034	e8 00 00 00 00	 call	 ??1SSoftwareTransformPatch@CTerrainPatch@@QAE@XZ ; CTerrainPatch::SSoftwareTransformPatch::~SSoftwareTransformPatch
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0003f	e8 00 00 00 00	 call	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
  00044	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 c1 24	 add	 ecx, 36			; 00000024H
  0004a	e8 00 00 00 00	 call	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	c9		 leave
  0005b	c3		 ret	 0
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CTerrainPatch@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CTerrainPatch@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CTerrainPatch@@QAE@XZ ENDP				; CTerrainPatch::~CTerrainPatch
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
;	COMDAT ??0CTerrainPatch@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CTerrainPatch@@QAE@XZ PROC				; CTerrainPatch::CTerrainPatch, COMDAT
; _this$ = ecx

; 56   : 	CTerrainPatch()									{ Clear(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTerrainPatch@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 24	 add	 ecx, 36			; 00000024H
  0002d	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  00032	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 c0 4c	 add	 eax, 76			; 0000004cH
  0003c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0CGraphicVertexBuffer@@QAE@XZ ; CGraphicVertexBuffer::CGraphicVertexBuffer
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00051	e8 00 00 00 00	 call	 ??0SSoftwareTransformPatch@CTerrainPatch@@QAE@XZ ; CTerrainPatch::SSoftwareTransformPatch::SSoftwareTransformPatch
  00056	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?Clear@CTerrainPatch@@QAEXXZ ; CTerrainPatch::Clear
  00062	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	c9		 leave
  00075	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTerrainPatch@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 24	 add	 ecx, 36			; 00000024H
  00006	e9 00 00 00 00	 jmp	 ??1CGraphicVertexBuffer@@UAE@XZ ; CGraphicVertexBuffer::~CGraphicVertexBuffer
__unwindfunclet$??0CTerrainPatch@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00011	e9 00 00 00 00	 jmp	 ??1SHardwareTransformPatch@CTerrainPatch@@QAE@XZ
__unwindfunclet$??0CTerrainPatch@@QAE@XZ$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 6c	 add	 ecx, 108		; 0000006cH
  0001c	e9 00 00 00 00	 jmp	 ??1SSoftwareTransformPatch@CTerrainPatch@@QAE@XZ ; CTerrainPatch::SSoftwareTransformPatch::~SSoftwareTransformPatch
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
__ehhandler$??0CTerrainPatch@@QAE@XZ:
  00026	90		 npad	 1
  00027	90		 npad	 1
  00028	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002f	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTerrainPatch@@QAE@XZ
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTerrainPatch@@QAE@XZ ENDP				; CTerrainPatch::CTerrainPatch
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
