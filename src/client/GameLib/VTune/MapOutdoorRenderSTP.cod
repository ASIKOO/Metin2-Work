; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
PUBLIC	?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState
PUBLIC	?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Initialize
PUBLIC	?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ ; CMapOutdoor::__SoftwareTransformPatch_Create
PUBLIC	?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Destroy
PUBLIC	?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline
PUBLIC	?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
PUBLIC	?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
PUBLIC	?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream
PUBLIC	?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
PUBLIC	?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
PUBLIC	?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
PUBLIC	?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat
PUBLIC	?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
PUBLIC	??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z		; std::_Refancy<int *,0>
PUBLIC	??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Make_heap_unchecked<int *,std::less<void> >
PUBLIC	??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
PUBLIC	??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
PUBLIC	??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<int *,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	__real@3acccccd
PUBLIC	__real@3e000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@4144ec4c
PUBLIC	__real@437f0000
PUBLIC	__real@44480000
PUBLIC	__real@453b8000
PUBLIC	__real@45480000
PUBLIC	__real@459c4000
PUBLIC	__real@461c4000
PUBLIC	__real@bacccccd
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_D3DXVec3Transform@12:PROC
EXTRN	_D3DXVec3TransformCoord@12:PROC
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	?GetBackBufferSize@CGraphicBase@@SAXPAI0@Z:PROC	; CGraphicBase::GetBackBufferSize
EXTRN	?IsTLVertexClipping@CGraphicBase@@SA_NXZ:PROC	; CGraphicBase::IsTLVertexClipping
EXTRN	?IsFastTNL@CGraphicBase@@SA_NXZ:PROC		; CGraphicBase::IsFastTNL
EXTRN	?GetFogNearDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogNearDistance
EXTRN	?GetFogFarDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogFarDistance
EXTRN	?GetTextureCount@CTextureSet@@QAEKXZ:PROC	; CTextureSet::GetTextureCount
EXTRN	?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z:PROC ; CTextureSet::GetTexture
EXTRN	?IsIn@CTerrainPatchProxy@@QAE_NABUD3DXVECTOR3@@M@Z:PROC ; CTerrainPatchProxy::IsIn
EXTRN	?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ:PROC ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr
EXTRN	?SoftwareTransformPatch_UpdateTerrainLighting@CTerrainPatchProxy@@QAEXKABU_D3DLIGHT8@@ABU_D3DMATERIAL8@@@Z:PROC ; CTerrainPatchProxy::SoftwareTransformPatch_UpdateTerrainLighting
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::SelectIndexBuffer
EXTRN	?__GetNoFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetNoFogDistance
EXTRN	?__GetFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetFogDistance
EXTRN	?GetMaterial@CStateManager@@QAEXPAU_D3DMATERIAL8@@@Z:PROC ; CStateManager::GetMaterial
EXTRN	?GetLight@CStateManager@@QAEXKPAU_D3DLIGHT8@@@Z:PROC ; CStateManager::GetLight
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetBestFiltering@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetBestFiltering
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z:PROC ; CStateManager::GetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__chkstk:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A:DWORD ; CGraphicBase::ms_lpd3dDevice
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA:BYTE	; CSpeedTreeWrapper::ms_bSelfShadowOn
EXTRN	?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A:DWORD ; CTerrainImpl::ms_pTextureSet
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@bacccccd
CONST	SEGMENT
__real@bacccccd DD 0bacccccdr			; -0.0015625
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@45480000
CONST	SEGMENT
__real@45480000 DD 045480000r			; 3200
CONST	ENDS
;	COMDAT __real@453b8000
CONST	SEGMENT
__real@453b8000 DD 0453b8000r			; 3000
CONST	ENDS
;	COMDAT __real@44480000
CONST	SEGMENT
__real@44480000 DD 044480000r			; 800
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@4144ec4c
CONST	SEGMENT
__real@4144ec4c DD 04144ec4cr			; 12.3077
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e000000
CONST	SEGMENT
__real@3e000000 DD 03e000000r			; 0.125
CONST	ENDS
;	COMDAT __real@3acccccd
CONST	SEGMENT
__real@3acccccd DD 03acccccdr			; 0.0015625
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0
__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
__Tmp$2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__Tmp$6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
$T9 = -32						; size = 4
__Tmp$10 = -28						; size = 4
$T11 = -24						; size = 4
$T12 = -20						; size = 4
tv79 = -16						; size = 4
tv71 = -12						; size = 4
tv89 = -8						; size = 4
$T13 = -3						; size = 1
$T14 = -2						; size = 1
$T15 = -1						; size = 1
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Med3_unchecked<int *,std::less<void> >, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00010	7d 09		 jge	 SHORT $LN8@Med3_unche
  00012	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN9@Med3_unche
$LN8@Med3_unche:
  0001b	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN9@Med3_unche:
  0001f	8a 45 f8	 mov	 al, BYTE PTR tv89[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T15[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 2e		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00033	8b 45 ec	 mov	 eax, DWORD PTR $T12[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 e4	 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00044	8b 4d e8	 mov	 ecx, DWORD PTR $T11[ebp]
  00047	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0004b	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0004e	89 45 e0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00051	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00054	8b 4d e0	 mov	 ecx, DWORD PTR $T9[ebp]
  00057	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00059	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0005b	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00065	7d 09		 jge	 SHORT $LN27@Med3_unche
  00067	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0006e	eb 04		 jmp	 SHORT $LN28@Med3_unche
$LN27@Med3_unche:
  00070	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN28@Med3_unche:
  00074	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  00077	88 45 fe	 mov	 BYTE PTR $T14[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  0007a	0f b6 45 fe	 movzx	 eax, BYTE PTR $T14[ebp]
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 83 00 00
	00		 je	 $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00086	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00089	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0008c	8b 45 dc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
  00091	89 45 d4	 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00094	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00097	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0009a	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009d	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
  000a0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a4	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  000a7	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000aa	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000ad	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  000b0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000b4	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000be	7d 09		 jge	 SHORT $LN46@Med3_unche
  000c0	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  000c7	eb 04		 jmp	 SHORT $LN47@Med3_unche
$LN46@Med3_unche:
  000c9	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN47@Med3_unche:
  000cd	8a 45 f0	 mov	 al, BYTE PTR tv79[ebp]
  000d0	88 45 fd	 mov	 BYTE PTR $T13[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000d3	0f b6 45 fd	 movzx	 eax, BYTE PTR $T13[ebp]
  000d7	85 c0		 test	 eax, eax
  000d9	74 2e		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000db	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000e1	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000e4	8b 00		 mov	 eax, DWORD PTR [eax]
  000e6	89 45 c4	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000e9	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ec	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000ef	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000f2	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp]
  000f5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000f7	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000f9	8d 45 c4	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  000fc	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000ff	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00102	8b 4d c0	 mov	 ecx, DWORD PTR $T1[ebp]
  00105	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00107	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  00109	c9		 leave
  0010a	c3		 ret	 0
??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Med3_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Dest_ch$ = -16					; size = 4
__Last_ch$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  00021	ff 75 f8	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	8b 45 f0	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002a	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  00036	c9		 leave
  00037	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<int *,std::less<void> >, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00012	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00016	0f 8e a4 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	40		 inc	 eax
  00020	c1 f8 03	 sar	 eax, 3
  00023	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00029	d1 e0		 shl	 eax, 1
  0002b	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0002e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00031	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00037	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0003a	50		 push	 eax
  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00041	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00044	50		 push	 eax
  00045	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00050	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00053	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00059	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0005c	50		 push	 eax
  0005d	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00063	c1 e0 02	 shl	 eax, 2
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00069	2b c8		 sub	 ecx, eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00074	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0007d	c1 e0 02	 shl	 eax, 2
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00083	2b c8		 sub	 ecx, eax
  00085	51		 push	 ecx
  00086	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00089	c1 e0 02	 shl	 eax, 2
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0008f	2b c8		 sub	 ecx, eax
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0009a	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000a0	c1 e0 02	 shl	 eax, 2
  000a3	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b c8		 sub	 ecx, eax
  000a8	51		 push	 ecx
  000a9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b2	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000be	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000c0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c3	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000c6	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000c9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000d4	c9		 leave
  000d5	c3		 ret	 0
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Val$4 = -8						; size = 4
$T5 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<int *,std::less<void> >, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 02	 cmp	 eax, 2
  00012	7c 50		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00023	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f8	 mov	 DWORD PTR __Val$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Val$4[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00031	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6219 :     *_Dest      = _STD move(*_First);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00041	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00044	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  00047	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0004a	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00050	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00053	c1 f8 02	 sar	 eax, 2
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
  00061	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Pop_heap_u:

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }
; 6233 : }

  00064	c9		 leave
  00065	c3		 ret	 0
??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
__Top$ = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
tv158 = -32						; size = 4
__Max_sequence_non_leaf$ = -28				; size = 4
tv138 = -24						; size = 4
__Idx$6 = -20						; size = 4
__Hole$ = -16						; size = 4
__Idx$ = -12						; size = 4
__Pred$ = -8						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000a	89 45 d0	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00010	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00013	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00016	48		 dec	 eax
  00017	d1 f8		 sar	 eax, 1
  00019	89 45 e4	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001c	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001f	3b 45 e4	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00022	7d 63		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00024	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00027	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002b	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00034	8b 55 f4	 mov	 edx, DWORD PTR __Idx$[ebp]
  00037	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0003a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0003d	3b 44 96 fc	 cmp	 eax, DWORD PTR [esi+edx*4-4]
  00041	7d 09		 jge	 SHORT $LN9@Pop_heap_h
  00043	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv138[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN10@Pop_heap_h
$LN9@Pop_heap_h:
  0004c	83 65 e8 00	 and	 DWORD PTR tv138[ebp], 0
$LN10@Pop_heap_h:
  00050	8a 45 e8	 mov	 al, BYTE PTR tv138[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00061	48		 dec	 eax
  00062	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00068	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0006e	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00071	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00077	8b 55 d8	 mov	 edx, DWORD PTR $T4[ebp]
  0007a	8b 12		 mov	 edx, DWORD PTR [edx]
  0007c	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6203 :         _Hole             = _Idx;

  0007f	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00082	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  00085	eb 95		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00087	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  0008a	3b 45 e4	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0008d	75 35		 jne	 SHORT $LN5@Pop_heap_h
  0008f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00092	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00097	79 05		 jns	 SHORT $LN37@Pop_heap_h
  00099	48		 dec	 eax
  0009a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009d	40		 inc	 eax
$LN37@Pop_heap_h:
  0009e	85 c0		 test	 eax, eax
  000a0	75 22		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a2	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000a8	8d 44 81 fc	 lea	 eax, DWORD PTR [ecx+eax*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ac	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000af	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b5	8b 55 d4	 mov	 edx, DWORD PTR $T3[ebp]
  000b8	8b 12		 mov	 edx, DWORD PTR [edx]
  000ba	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6208 :         _Hole             = _Bottom - 1;

  000bd	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000c0	48		 dec	 eax
  000c1	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c4	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000c7	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000ca	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  000cd	88 45 f8	 mov	 BYTE PTR __Pred$[ebp], al
  000d0	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d3	89 45 f0	 mov	 DWORD PTR __Hole$[ebp], eax

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000d6	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d9	48		 dec	 eax
  000da	d1 f8		 sar	 eax, 1
  000dc	89 45 ec	 mov	 DWORD PTR __Idx$6[ebp], eax
  000df	eb 09		 jmp	 SHORT $LN24@Pop_heap_h
$LN22@Pop_heap_h:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  000e4	48		 dec	 eax
  000e5	d1 f8		 sar	 eax, 1
  000e7	89 45 ec	 mov	 DWORD PTR __Idx$6[ebp], eax
$LN24@Pop_heap_h:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000ea	8b 45 d0	 mov	 eax, DWORD PTR __Top$[ebp]
  000ed	3b 45 f0	 cmp	 eax, DWORD PTR __Hole$[ebp]
  000f0	7d 4d		 jge	 SHORT $LN23@Pop_heap_h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000f2	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  000f5	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000f8	8b 55 dc	 mov	 edx, DWORD PTR $T5[ebp]
  000fb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fe	3b 02		 cmp	 eax, DWORD PTR [edx]
  00100	7d 09		 jge	 SHORT $LN28@Pop_heap_h
  00102	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv158[ebp], 1
  00109	eb 04		 jmp	 SHORT $LN29@Pop_heap_h
$LN28@Pop_heap_h:
  0010b	83 65 e0 00	 and	 DWORD PTR tv158[ebp], 0
$LN29@Pop_heap_h:
  0010f	8a 45 e0	 mov	 al, BYTE PTR tv158[ebp]
  00112	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00115	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	74 22		 je	 SHORT $LN23@Pop_heap_h

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0011d	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  00120	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00123	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00126	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00129	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  0012c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0012f	8b 55 cc	 mov	 edx, DWORD PTR $T2[ebp]
  00132	8b 12		 mov	 edx, DWORD PTR [edx]
  00134	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6081 :         _Hole             = _Idx;

  00137	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  0013a	89 45 f0	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  0013d	eb a2		 jmp	 SHORT $LN22@Pop_heap_h
$LN23@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013f	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00142	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00145	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  00148	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0014b	8b 55 c8	 mov	 edx, DWORD PTR $T1[ebp]
  0014e	8b 12		 mov	 edx, DWORD PTR [edx]
  00150	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6212 : }

  00153	5e		 pop	 esi
  00154	c9		 leave
  00155	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Refancy<std::pair<float,long> *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Refancy<std::pair<float,long> *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -180						; size = 4
__Tmp$2 = -176						; size = 4
$T3 = -172						; size = 4
$T4 = -168						; size = 4
$T5 = -164						; size = 4
__Tmp$6 = -160						; size = 4
$T7 = -156						; size = 4
$T8 = -152						; size = 4
$T9 = -148						; size = 4
__Tmp$10 = -144						; size = 4
$T11 = -140						; size = 4
$T12 = -136						; size = 4
$T13 = -132						; size = 4
__Tmp$14 = -128						; size = 4
$T15 = -124						; size = 4
$T16 = -120						; size = 4
$T17 = -116						; size = 4
__Tmp$18 = -112						; size = 4
$T19 = -108						; size = 4
$T20 = -104						; size = 4
$T21 = -100						; size = 4
$T22 = -96						; size = 4
$T23 = -92						; size = 4
__Tmp$24 = -88						; size = 4
$T25 = -84						; size = 4
$T26 = -80						; size = 4
__Left$ = -76						; size = 4
__Right$ = -72						; size = 4
$T27 = -68						; size = 4
__Tmp$28 = -64						; size = 4
$T29 = -60						; size = 4
$T30 = -56						; size = 4
__Right$ = -52						; size = 4
__Left$ = -48						; size = 4
__Right$ = -44						; size = 4
__Left$ = -40						; size = 4
__Right$ = -36						; size = 4
__Left$ = -32						; size = 4
__Left$ = -28						; size = 4
__Right$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
__Right$ = -4						; size = 4
__Left$ = 0						; size = 4
__Left$ = 4						; size = 4
tv167 = 8						; size = 4
tv157 = 12						; size = 4
__Left$ = 16						; size = 4
tv146 = 20						; size = 4
tv137 = 24						; size = 4
tv131 = 28						; size = 4
tv91 = 32						; size = 4
tv83 = 36						; size = 4
tv214 = 40						; size = 4
__Mid$ = 44						; size = 4
__First$ = 48						; size = 4
__First$ = 52						; size = 4
__First$ = 56						; size = 4
__First$ = 60						; size = 4
__First$ = 64						; size = 4
__First$ = 68						; size = 4
__First$ = 72						; size = 4
__First$ = 76						; size = 4
$T31 = 80						; size = 1
$T32 = 81						; size = 1
$T33 = 82						; size = 1
$T34 = 83						; size = 1
$T35 = 84						; size = 1
$T36 = 85						; size = 1
$T37 = 86						; size = 1
$T38 = 87						; size = 1
__Glast$ = 88						; size = 4
__Gfirst$ = 92						; size = 4
__Plast$ = 96						; size = 4
__Pfirst$ = 100						; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000b	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  00011	c1 f8 02	 sar	 eax, 2
  00014	d1 f8		 sar	 eax, 1
  00016	8b 4d 74	 mov	 ecx, DWORD PTR __First$[ebp]
  00019	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0001c	89 45 2c	 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0001f	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00022	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00025	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  00028	83 e8 04	 sub	 eax, 4
  0002b	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0002e	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  00031	ff 75 48	 push	 DWORD PTR __First$[ebp]
  00034	ff 75 2c	 push	 DWORD PTR __Mid$[ebp]
  00037	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00042	8b 45 2c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00045	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00048	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0004b	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0004e	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00057	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  0005a	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0005d	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00060	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00063	0f 83 86 00 00
	00		 jae	 $LN4@Partition_
  00069	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0006c	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0006f	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00072	83 e8 04	 sub	 eax, 4
  00075	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00078	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0007b	89 45 e8	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0007e	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00081	8b 4d e8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00088	7d 09		 jge	 SHORT $LN42@Partition_
  0008a	c7 45 28 01 00
	00 00		 mov	 DWORD PTR tv214[ebp], 1
  00091	eb 04		 jmp	 SHORT $LN43@Partition_
$LN42@Partition_:
  00093	83 65 28 00	 and	 DWORD PTR tv214[ebp], 0
$LN43@Partition_:
  00097	8a 45 28	 mov	 al, BYTE PTR tv214[ebp]
  0009a	88 45 50	 mov	 BYTE PTR $T31[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0009d	0f b6 45 50	 movzx	 eax, BYTE PTR $T31[ebp]
  000a1	85 c0		 test	 eax, eax
  000a3	75 4a		 jne	 SHORT $LN4@Partition_
  000a5	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000a8	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  000ab	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  000ae	83 e8 04	 sub	 eax, 4
  000b1	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000b4	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000b7	89 45 e4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ba	8b 45 e4	 mov	 eax, DWORD PTR __Left$[ebp]
  000bd	8b 4d 3c	 mov	 ecx, DWORD PTR __First$[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000c4	7d 09		 jge	 SHORT $LN49@Partition_
  000c6	c7 45 24 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  000cd	eb 04		 jmp	 SHORT $LN50@Partition_
$LN49@Partition_:
  000cf	83 65 24 00	 and	 DWORD PTR tv83[ebp], 0
$LN50@Partition_:
  000d3	8a 45 24	 mov	 al, BYTE PTR tv83[ebp]
  000d6	88 45 57	 mov	 BYTE PTR $T38[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000d9	0f b6 45 57	 movzx	 eax, BYTE PTR $T38[ebp]
  000dd	85 c0		 test	 eax, eax
  000df	75 0e		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  000e1	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000e4	83 e8 04	 sub	 eax, 4
  000e7	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  000ea	e9 6e ff ff ff	 jmp	 $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000ef	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000f2	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  000f5	73 71		 jae	 SHORT $LN5@Partition_
  000f7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000fa	89 45 dc	 mov	 DWORD PTR __Right$[ebp], eax
  000fd	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00100	89 45 e0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00103	8b 45 e0	 mov	 eax, DWORD PTR __Left$[ebp]
  00106	8b 4d dc	 mov	 ecx, DWORD PTR __Right$[ebp]
  00109	8b 00		 mov	 eax, DWORD PTR [eax]
  0010b	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0010d	7d 09		 jge	 SHORT $LN54@Partition_
  0010f	c7 45 20 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00116	eb 04		 jmp	 SHORT $LN55@Partition_
$LN54@Partition_:
  00118	83 65 20 00	 and	 DWORD PTR tv91[ebp], 0
$LN55@Partition_:
  0011c	8a 45 20	 mov	 al, BYTE PTR tv91[ebp]
  0011f	88 45 56	 mov	 BYTE PTR $T37[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00122	0f b6 45 56	 movzx	 eax, BYTE PTR $T37[ebp]
  00126	85 c0		 test	 eax, eax
  00128	75 3e		 jne	 SHORT $LN5@Partition_
  0012a	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0012d	89 45 d4	 mov	 DWORD PTR __Right$[ebp], eax
  00130	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00133	89 45 d8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00136	8b 45 d8	 mov	 eax, DWORD PTR __Left$[ebp]
  00139	8b 4d d4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00140	7d 09		 jge	 SHORT $LN59@Partition_
  00142	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00149	eb 04		 jmp	 SHORT $LN60@Partition_
$LN59@Partition_:
  0014b	83 65 1c 00	 and	 DWORD PTR tv131[ebp], 0
$LN60@Partition_:
  0014f	8a 45 1c	 mov	 al, BYTE PTR tv131[ebp]
  00152	88 45 55	 mov	 BYTE PTR $T36[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00155	0f b6 45 55	 movzx	 eax, BYTE PTR $T36[ebp]
  00159	85 c0		 test	 eax, eax
  0015b	75 0b		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  0015d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00160	83 c0 04	 add	 eax, 4
  00163	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  00166	eb 87		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  00168	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0016b	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  0016e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00171	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00174	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  00176	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00179	83 c0 04	 add	 eax, 4
  0017c	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  0017f	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00182	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00185	0f 83 ba 00 00
	00		 jae	 $LN10@Partition_

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0018b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0018e	89 45 d0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00191	8b 45 d0	 mov	 eax, DWORD PTR __Left$[ebp]
  00194	8b 4d 5c	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0019b	7d 09		 jge	 SHORT $LN64@Partition_
  0019d	c7 45 18 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  001a4	eb 04		 jmp	 SHORT $LN65@Partition_
$LN64@Partition_:
  001a6	83 65 18 00	 and	 DWORD PTR tv137[ebp], 0
$LN65@Partition_:
  001aa	8a 45 18	 mov	 al, BYTE PTR tv137[ebp]
  001ad	88 45 54	 mov	 BYTE PTR $T35[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  001b0	0f b6 45 54	 movzx	 eax, BYTE PTR $T35[ebp]
  001b4	85 c0		 test	 eax, eax
  001b6	74 07		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  001b8	eb bc		 jmp	 SHORT $LN9@Partition_
  001ba	e9 81 00 00 00	 jmp	 $LN16@Partition_
$LN15@Partition_:

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  001bf	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  001c2	89 45 cc	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001c5	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001c8	8b 4d cc	 mov	 ecx, DWORD PTR __Right$[ebp]
  001cb	8b 00		 mov	 eax, DWORD PTR [eax]
  001cd	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001cf	7d 09		 jge	 SHORT $LN69@Partition_
  001d1	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  001d8	eb 04		 jmp	 SHORT $LN70@Partition_
$LN69@Partition_:
  001da	83 65 14 00	 and	 DWORD PTR tv146[ebp], 0
$LN70@Partition_:
  001de	8a 45 14	 mov	 al, BYTE PTR tv146[ebp]
  001e1	88 45 53	 mov	 BYTE PTR $T34[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  001e4	0f b6 45 53	 movzx	 eax, BYTE PTR $T34[ebp]
  001e8	85 c0		 test	 eax, eax
  001ea	74 04		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  001ec	eb 57		 jmp	 SHORT $LN10@Partition_
  001ee	eb 50		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  001f0	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001f3	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  001f6	74 3f		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  001f8	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001fb	89 45 10	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001fe	8b 45 10	 mov	 eax, DWORD PTR __Left$[ebp]
  00201	89 45 c8	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00204	8b 45 c8	 mov	 eax, DWORD PTR $T30[ebp]
  00207	8b 00		 mov	 eax, DWORD PTR [eax]
  00209	89 45 c0	 mov	 DWORD PTR __Tmp$28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0020c	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0020f	89 45 c4	 mov	 DWORD PTR $T29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00212	8b 45 10	 mov	 eax, DWORD PTR __Left$[ebp]
  00215	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  00218	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0021a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0021c	8d 45 c0	 lea	 eax, DWORD PTR __Tmp$28[ebp]
  0021f	89 45 bc	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00222	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00225	8b 4d bc	 mov	 ecx, DWORD PTR $T27[ebp]
  00228	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0022a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  0022c	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0022f	83 c0 04	 add	 eax, 4
  00232	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  00235	eb 09		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  00237	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0023a	83 c0 04	 add	 eax, 4
  0023d	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  00240	e9 31 ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  00245	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  00247	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0024a	83 e8 04	 sub	 eax, 4
  0024d	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  00250	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00253	3b 45 58	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00256	0f 83 eb 00 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0025c	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0025f	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00262	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00265	83 e8 04	 sub	 eax, 4
  00268	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0026b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0026e	89 45 b8	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00271	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00274	8b 4d b8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00277	8b 00		 mov	 eax, DWORD PTR [eax]
  00279	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0027b	7d 09		 jge	 SHORT $LN90@Partition_
  0027d	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv157[ebp], 1
  00284	eb 04		 jmp	 SHORT $LN91@Partition_
$LN90@Partition_:
  00286	83 65 0c 00	 and	 DWORD PTR tv157[ebp], 0
$LN91@Partition_:
  0028a	8a 45 0c	 mov	 al, BYTE PTR tv157[ebp]
  0028d	88 45 52	 mov	 BYTE PTR $T33[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00290	0f b6 45 52	 movzx	 eax, BYTE PTR $T33[ebp]
  00294	85 c0		 test	 eax, eax
  00296	74 07		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00298	eb ad		 jmp	 SHORT $LN12@Partition_
  0029a	e9 a3 00 00 00	 jmp	 $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0029f	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002a2	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  002a5	8b 45 34	 mov	 eax, DWORD PTR __First$[ebp]
  002a8	83 e8 04	 sub	 eax, 4
  002ab	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  002ae	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002b1	89 45 b4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  002b4	8b 45 b4	 mov	 eax, DWORD PTR __Left$[ebp]
  002b7	8b 4d 34	 mov	 ecx, DWORD PTR __First$[ebp]
  002ba	8b 00		 mov	 eax, DWORD PTR [eax]
  002bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
  002be	7d 09		 jge	 SHORT $LN97@Partition_
  002c0	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  002c7	eb 04		 jmp	 SHORT $LN98@Partition_
$LN97@Partition_:
  002c9	83 65 08 00	 and	 DWORD PTR tv167[ebp], 0
$LN98@Partition_:
  002cd	8a 45 08	 mov	 al, BYTE PTR tv167[ebp]
  002d0	88 45 51	 mov	 BYTE PTR $T32[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  002d3	0f b6 45 51	 movzx	 eax, BYTE PTR $T32[ebp]
  002d7	85 c0		 test	 eax, eax
  002d9	74 04		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  002db	eb 6a		 jmp	 SHORT $LN13@Partition_
  002dd	eb 63		 jmp	 SHORT $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  002df	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002e2	83 e8 04	 sub	 eax, 4
  002e5	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  002e8	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002eb	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  002ee	8b 45 30	 mov	 eax, DWORD PTR __First$[ebp]
  002f1	83 e8 04	 sub	 eax, 4
  002f4	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  002f7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002fa	3b 45 30	 cmp	 eax, DWORD PTR __First$[ebp]
  002fd	74 43		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  002ff	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00302	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00305	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00308	83 e8 04	 sub	 eax, 4
  0030b	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  0030e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00311	89 45 04	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00314	8b 45 04	 mov	 eax, DWORD PTR __Left$[ebp]
  00317	89 45 b0	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0031a	8b 45 b0	 mov	 eax, DWORD PTR $T26[ebp]
  0031d	8b 00		 mov	 eax, DWORD PTR [eax]
  0031f	89 45 a8	 mov	 DWORD PTR __Tmp$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00322	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00325	89 45 ac	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00328	8b 45 04	 mov	 eax, DWORD PTR __Left$[ebp]
  0032b	8b 4d ac	 mov	 ecx, DWORD PTR $T25[ebp]
  0032e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00330	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00332	8d 45 a8	 lea	 eax, DWORD PTR __Tmp$24[ebp]
  00335	89 45 a4	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00338	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  0033b	8b 4d a4	 mov	 ecx, DWORD PTR $T23[ebp]
  0033e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00340	89 08		 mov	 DWORD PTR [eax], ecx
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  00342	e9 00 ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  00347	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0034a	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  0034d	75 31		 jne	 SHORT $LN26@Partition_
  0034f	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00352	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00355	75 29		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00357	8d 45 64	 lea	 eax, DWORD PTR __Pfirst$[ebp]
  0035a	89 45 a0	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0035d	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00360	8b 4d a0	 mov	 ecx, DWORD PTR $T22[ebp]
  00363	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00365	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00367	8d 45 60	 lea	 eax, DWORD PTR __Plast$[ebp]
  0036a	89 45 9c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0036d	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00370	8b 4d 9c	 mov	 ecx, DWORD PTR $T21[ebp]
  00373	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00375	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00378	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0037b	e9 d4 01 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  00380	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00383	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  00386	0f 85 9c 00 00
	00		 jne	 $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  0038c	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0038f	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00392	74 3a		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  00394	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00397	89 45 fc	 mov	 DWORD PTR __Right$[ebp], eax
  0039a	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0039d	89 45 00	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003a0	8b 45 00	 mov	 eax, DWORD PTR __Left$[ebp]
  003a3	89 45 98	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003a6	8b 45 98	 mov	 eax, DWORD PTR $T20[ebp]
  003a9	8b 00		 mov	 eax, DWORD PTR [eax]
  003ab	89 45 90	 mov	 DWORD PTR __Tmp$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003ae	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  003b1	89 45 94	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003b4	8b 45 00	 mov	 eax, DWORD PTR __Left$[ebp]
  003b7	8b 4d 94	 mov	 ecx, DWORD PTR $T19[ebp]
  003ba	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003bc	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003be	8d 45 90	 lea	 eax, DWORD PTR __Tmp$18[ebp]
  003c1	89 45 8c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  003c4	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  003c7	8b 4d 8c	 mov	 ecx, DWORD PTR $T17[ebp]
  003ca	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003cc	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  003ce	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  003d1	83 c0 04	 add	 eax, 4
  003d4	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  003d7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003da	89 45 f8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003dd	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  003e0	89 45 88	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003e3	8b 45 88	 mov	 eax, DWORD PTR $T16[ebp]
  003e6	8b 00		 mov	 eax, DWORD PTR [eax]
  003e8	89 45 80	 mov	 DWORD PTR __Tmp$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003eb	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  003ee	89 45 84	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003f1	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  003f4	8b 4d 84	 mov	 ecx, DWORD PTR $T15[ebp]
  003f7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003f9	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003fb	8d 45 80	 lea	 eax, DWORD PTR __Tmp$14[ebp]
  003fe	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00404	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00407	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  0040d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0040f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  00411	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00414	83 c0 04	 add	 eax, 4
  00417	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  0041a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0041d	83 c0 04	 add	 eax, 4
  00420	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
  00423	e9 27 01 00 00	 jmp	 $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00428	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0042b	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  0042e	0f 85 c3 00 00
	00		 jne	 $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  00434	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00437	83 e8 04	 sub	 eax, 4
  0043a	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
  0043d	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00440	83 e8 04	 sub	 eax, 4
  00443	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00446	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00449	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  0044c	74 4c		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  0044e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00451	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00454	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00457	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0045d	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00463	8b 00		 mov	 eax, DWORD PTR [eax]
  00465	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0046b	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  0046e	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00474	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00477	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  0047d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0047f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00481	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$10[ebp]
  00487	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0048d	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00490	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00496	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00498	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  0049a	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0049d	83 e8 04	 sub	 eax, 4
  004a0	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
  004a3	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  004a6	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  004a9	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  004ac	89 45 f0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004af	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  004b2	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  004b8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  004be	8b 00		 mov	 eax, DWORD PTR [eax]
  004c0	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004c6	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  004c9	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  004cf	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  004d2	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  004d8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004da	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004dc	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$6[ebp]
  004e2	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  004e8	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  004eb	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  004f1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004f3	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  004f5	eb 58		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  004f7	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  004fa	83 e8 04	 sub	 eax, 4
  004fd	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00500	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00509	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0050f	8b 00		 mov	 eax, DWORD PTR [eax]
  00511	89 85 50 ff ff
	ff		 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00517	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0051a	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00520	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00523	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00529	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0052b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0052d	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$2[ebp]
  00533	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00539	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0053c	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00542	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00544	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  00546	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00549	83 c0 04	 add	 eax, 4
  0054c	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  0054f	e9 20 fc ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  00554	83 c5 68	 add	 ebp, 104		; 00000068H
  00557	c9		 leave
  00558	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Val$2 = -16						; size = 4
$T3 = -12						; size = 4
__Bottom$ = -8						; size = 4
__Hole$4 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<int *,std::less<void> >, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00012	8b 45 f8	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax
$LN4@Make_heap_:
  0001a	83 7d fc 00	 cmp	 DWORD PTR __Hole$4[ebp], 0
  0001e	7e 3a		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  00023	48		 dec	 eax
  00024	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00030	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 f0	 mov	 DWORD PTR __Val$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003b	8d 45 f0	 lea	 eax, DWORD PTR __Val$2[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  00041	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00044	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00047	ff 75 f8	 push	 DWORD PTR __Bottom$[ebp]
  0004a	ff 75 fc	 push	 DWORD PTR __Hole$4[ebp]
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
  00055	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  00058	eb c0		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  0005a	c9		 leave
  0005b	c3		 ret	 0
??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
tv71 = -36						; size = 4
tv92 = -32						; size = 4
__Val$6 = -28						; size = 4
__Dest$ = -24						; size = 4
__Prev$7 = -20						; size = 4
__Last$ = -16						; size = 4
__Mid$8 = -12						; size = 4
__Hole$9 = -8						; size = 4
$T10 = -2						; size = 1
$T11 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<int *,std::less<void> >, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000c	0f 84 1d 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00012	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Mid$8[ebp], eax
$LN4@Insertion_:
  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f4	 mov	 DWORD PTR __Mid$8[ebp], eax
  00021	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00027	0f 84 02 01 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00030	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00033	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00036	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00039	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e4	 mov	 DWORD PTR __Val$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	8b 4d e4	 mov	 ecx, DWORD PTR __Val$6[ebp]
  00047	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00049	7d 09		 jge	 SHORT $LN17@Insertion_
  0004b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00052	eb 04		 jmp	 SHORT $LN18@Insertion_
$LN17@Insertion_:
  00054	83 65 e0 00	 and	 DWORD PTR tv92[ebp], 0
$LN18@Insertion_:
  00058	8a 45 e0	 mov	 al, BYTE PTR tv92[ebp]
  0005b	88 45 ff	 mov	 BYTE PTR $T11[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0005e	0f b6 45 ff	 movzx	 eax, BYTE PTR $T11[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 66		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00066	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00069	83 c0 04	 add	 eax, 4
  0006c	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
  0006f	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00072	89 45 e8	 mov	 DWORD PTR __Dest$[ebp], eax
  00075	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00078	89 45 f0	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  0007b	ff 75 e8	 push	 DWORD PTR __Dest$[ebp]
  0007e	ff 75 f0	 push	 DWORD PTR __Last$[ebp]
  00081	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00084	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	eb 2c		 jmp	 SHORT $LN20@Insertion_
$LN21@Insertion_:

; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  0008e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00091	3b 45 f0	 cmp	 eax, DWORD PTR __Last$[ebp]
  00094	74 24		 je	 SHORT $LN20@Insertion_

; 4701 :         *--_Dest = _STD move(*--_Last);

  00096	8b 45 f0	 mov	 eax, DWORD PTR __Last$[ebp]
  00099	83 e8 04	 sub	 eax, 4
  0009c	89 45 f0	 mov	 DWORD PTR __Last$[ebp], eax
  0009f	8b 45 e8	 mov	 eax, DWORD PTR __Dest$[ebp]
  000a2	83 e8 04	 sub	 eax, 4
  000a5	89 45 e8	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a8	8b 45 f0	 mov	 eax, DWORD PTR __Last$[ebp]
  000ab	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4701 :         *--_Dest = _STD move(*--_Last);

  000ae	8b 45 e8	 mov	 eax, DWORD PTR __Dest$[ebp]
  000b1	8b 4d d4	 mov	 ecx, DWORD PTR $T4[ebp]
  000b4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b6	89 08		 mov	 DWORD PTR [eax], ecx

; 4702 :     }

  000b8	eb d4		 jmp	 SHORT $LN21@Insertion_
$LN20@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ba	8d 45 e4	 lea	 eax, DWORD PTR __Val$6[ebp]
  000bd	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000c0	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000c3	8b 4d d0	 mov	 ecx, DWORD PTR $T3[ebp]
  000c6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c8	89 08		 mov	 DWORD PTR [eax], ecx

; 7420 :             } else { // look for insertion point after first

  000ca	eb 5e		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000cc	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  000cf	89 45 ec	 mov	 DWORD PTR __Prev$7[ebp], eax
  000d2	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000d4	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000d7	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
$LN7@Insertion_:
  000da	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000dd	83 e8 04	 sub	 eax, 4
  000e0	89 45 ec	 mov	 DWORD PTR __Prev$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e3	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000e6	8b 4d e4	 mov	 ecx, DWORD PTR __Val$6[ebp]
  000e9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000eb	7d 09		 jge	 SHORT $LN32@Insertion_
  000ed	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  000f4	eb 04		 jmp	 SHORT $LN33@Insertion_
$LN32@Insertion_:
  000f6	83 65 dc 00	 and	 DWORD PTR tv71[ebp], 0
$LN33@Insertion_:
  000fa	8a 45 dc	 mov	 al, BYTE PTR tv71[ebp]
  000fd	88 45 fe	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00100	0f b6 45 fe	 movzx	 eax, BYTE PTR $T10[ebp]
  00104	85 c0		 test	 eax, eax
  00106	74 12		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00108	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  0010b	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  0010e	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00111	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
  00114	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 7423 :                 }

  00118	eb ba		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0011a	8d 45 e4	 lea	 eax, DWORD PTR __Val$6[ebp]
  0011d	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  00120	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00123	8b 4d c8	 mov	 ecx, DWORD PTR $T1[ebp]
  00126	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00128	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Insertion_:

; 7426 :             }
; 7427 :         }

  0012a	e9 e9 fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  0012f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  00132	c9		 leave
  00133	c3		 ret	 0
??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z PROC		; std::_Refancy<int *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ENDP		; std::_Refancy<int *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<int *,std::less<void> >, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00012	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00014	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00017	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<int *,std::less<void> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00025	e9 c1 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002a	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  0002e	7f 45		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00030	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00036	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00039	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Make_heap_unchecked<int *,std::less<void> >
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00044	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00047	eb 09		 jmp	 SHORT $LN64@Sort_unche
$LN62@Sort_unche:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  0004c	83 e8 04	 sub	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN64@Sort_unche:
  00052	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00055	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00058	c1 f8 02	 sar	 eax, 2
  0005b	83 f8 02	 cmp	 eax, 2
  0005e	7c 13		 jl	 SHORT $LN61@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00060	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00063	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00066	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<int *,std::less<void> >
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00071	eb d6		 jmp	 SHORT $LN62@Sort_unche
$LN61@Sort_unche:

; 7548 :             return;

  00073	eb 76		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  00075	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00078	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0007b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007e	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0008a	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  0008d	d1 f8		 sar	 eax, 1
  0008f	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00092	c1 f9 02	 sar	 ecx, 2
  00095	03 c1		 add	 eax, ecx
  00097	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0009a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0009d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a0	c1 f8 02	 sar	 eax, 2
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b 4d f8	 sub	 ecx, DWORD PTR __Mid$1[ebp+4]
  000a9	c1 f9 02	 sar	 ecx, 2
  000ac	3b c1		 cmp	 eax, ecx
  000ae	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000b0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000b6	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000b9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000c7	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000ca	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000cc	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cf	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000d2	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000d5	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000d8	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000e0	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000e3	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000e6	e9 1b ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000eb	c9		 leave
  000ec	c3		 ret	 0
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z
_TEXT	SEGMENT
__It$ = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -48						; size = 4
__Ptr$3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Ptr$6 = -32						; size = 4
tv144 = -28						; size = 4
__Count2$7 = -24					; size = 4
__First$ = -20						; size = 4
__First$ = -16						; size = 4
__UFirst$ = -12						; size = 4
__UMid$8 = -8						; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z PROC ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >, COMDAT

; 6725 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 e0	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6728 :     auto _UFirst                = _Get_unwrapped(_First);

  00018	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 d4	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00030	8b 45 cc	 mov	 eax, DWORD PTR $T1[ebp]
  00033	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00036	c1 f8 03	 sar	 eax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6729 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

  00039	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@upper_boun:

; 6730 : 
; 6731 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0003c	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00040	0f 8e 92 00 00
	00		 jle	 $LN3@upper_boun

; 6732 :         _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00046	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	d1 f8		 sar	 eax, 1
  0004e	89 45 e8	 mov	 DWORD PTR __Count2$7[ebp], eax

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  00051	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00054	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00057	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR __First$[ebp]
  0005d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00060	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  00063	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00066	89 45 f8	 mov	 DWORD PTR __UMid$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00069	8b 45 f8	 mov	 eax, DWORD PTR __UMid$8[ebp]
  0006c	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  0006f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00073	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00076	77 23		 ja	 SHORT $LN36@upper_boun
  00078	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __UMid$8[ebp]
  0007e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00082	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00085	77 0e		 ja	 SHORT $LN35@upper_boun
  00087	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR __UMid$8[ebp]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00093	7c 06		 jl	 SHORT $LN36@upper_boun
$LN35@upper_boun:
  00095	83 65 e4 00	 and	 DWORD PTR tv144[ebp], 0
  00099	eb 07		 jmp	 SHORT $LN37@upper_boun
$LN36@upper_boun:
  0009b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv144[ebp], 1
$LN37@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6734 :         if (_Pred(_Val, *_UMid)) {

  000a2	0f b6 45 e4	 movzx	 eax, BYTE PTR tv144[ebp]
  000a6	85 c0		 test	 eax, eax
  000a8	74 08		 je	 SHORT $LN4@upper_boun

; 6735 :             _Count = _Count2;

  000aa	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  000ad	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 6736 :         } else { // try top half

  000b0	eb 21		 jmp	 SHORT $LN5@upper_boun
$LN4@upper_boun:

; 6737 :             _UFirst = _Next_iter(_UMid);

  000b2	8b 45 f8	 mov	 eax, DWORD PTR __UMid$8[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000bb	83 c0 08	 add	 eax, 8
  000be	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6737 :             _UFirst = _Next_iter(_UMid);

  000c1	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000c4	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 6738 :             _Count -= _Count2 + 1;

  000c7	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  000ca	40		 inc	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ce	2b c8		 sub	 ecx, eax
  000d0	89 4d fc	 mov	 DWORD PTR __Count$[ebp], ecx
$LN5@upper_boun:

; 6739 :         }
; 6740 :     }

  000d3	e9 64 ff ff ff	 jmp	 $LN2@upper_boun
$LN3@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  000d8	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000db	89 45 c8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  000de	ff 75 c8	 push	 DWORD PTR __It$[ebp]
  000e1	e8 00 00 00 00	 call	 ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
  000e6	59		 pop	 ecx
  000e7	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6743 :     return _First;

  000ea	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000f0	89 08		 mov	 DWORD PTR [eax], ecx
  000f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 6744 : }

  000f5	c9		 leave
  000f6	c3		 ret	 0
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ENDP ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::emplace_back<int const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z PROC ; std::_Const_cast<std::pair<float,long> const >, COMDAT

; 292  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 294  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ENDP ; std::_Const_cast<std::pair<float,long> const >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -52						; size = 1
$T2 = -48						; size = 4
$T3 = -44						; size = 4
__Ptr$4 = -40						; size = 4
__Last$ = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
__Ptr$7 = -24						; size = 4
__First$ = -20						; size = 4
__UFirst$8 = -16					; size = 4
__ULast$9 = -12						; size = 4
__Pred$ = -8						; size = 1
$T10 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 7575 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last) { // order [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 7576 :     _STD sort(_First, _Last, less<>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
  0000b	8a 45 ff	 mov	 al, BYTE PTR $T10[ebp]
  0000e	88 45 f8	 mov	 BYTE PTR __Pred$[ebp], al
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	89 45 dc	 mov	 DWORD PTR __Last$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001d	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  00020	89 45 e8	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00023	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00029	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  0002c	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  0002f	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00032	89 45 f0	 mov	 DWORD PTR __UFirst$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00035	8b 45 dc	 mov	 eax, DWORD PTR __Last$[ebp]
  00038	89 45 d8	 mov	 DWORD PTR __Ptr$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  0003e	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00041	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00044	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  00047	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0004a	89 45 f4	 mov	 DWORD PTR __ULast$9[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  0004d	8a 45 f8	 mov	 al, BYTE PTR __Pred$[ebp]
  00050	88 45 cc	 mov	 BYTE PTR $T1[ebp], al
  00053	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  00056	8b 45 f4	 mov	 eax, DWORD PTR __ULast$9[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR __UFirst$8[ebp]
  0005c	c1 f8 02	 sar	 eax, 2
  0005f	50		 push	 eax
  00060	ff 75 f4	 push	 DWORD PTR __ULast$9[ebp]
  00063	ff 75 f0	 push	 DWORD PTR __UFirst$8[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 7577 : }

  0006e	c9		 leave
  0006f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z
_TEXT	SEGMENT
__It$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Ptr$5 = -20						; size = 4
$T6 = -16						; size = 4
__Ptr$7 = -12						; size = 4
__First$ = -8						; size = 4
$T8 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>, COMDAT

; 5478 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  00015	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00018	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR __Ptr$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$5[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00027	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  0002a	33 c0		 xor	 eax, eax
  0002c	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
  0002f	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00032	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 5439 :     for (; _First != _Last; ++_First) {

  00035	eb 09		 jmp	 SHORT $LN26@find
$LN24@find:
  00037	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
$LN26@find:
  00040	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00043	3b 45 e0	 cmp	 eax, DWORD PTR $T2[ebp]
  00046	74 10		 je	 SHORT $LN21@find

; 5440 :         if (*_First == _Val) {

  00048	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0004b	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00052	75 02		 jne	 SHORT $LN27@find

; 5441 :             break;

  00054	eb 02		 jmp	 SHORT $LN21@find
$LN27@find:

; 5442 :         }
; 5443 :     }

  00056	eb df		 jmp	 SHORT $LN24@find
$LN21@find:

; 5479 :     _Adl_verify_range(_First, _Last);
; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  00058	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0005b	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0005e	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  00061	89 45 d8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00064	ff 75 d8	 push	 DWORD PTR __It$[ebp]
  00067	e8 00 00 00 00	 call	 ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ; std::_Refancy<int *,0>
  0006c	59		 pop	 ecx
  0006d	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5481 :     return _First;

  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5482 : }

  0007b	c9		 leave
  0007c	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_akDstVertex$ = -128					; size = 4
_fScreenHalfWidth$ = -124				; size = 4
_fScreenHalfHeight$ = -120				; size = 4
_akPosition$ = -116					; size = 4
tv84 = -112						; size = 4
_sPatchNum$ = -108					; size = 4
_wCoordY$ = -104					; size = 2
_wCoordX$ = -100					; size = 2
_dwVBSize$ = -96					; size = 4
_akSrcVertex$ = -92					; size = 4
___t$ = -88						; size = 4
_pTerrain$ = -84					; size = 4
_ucTerrainNum$ = -80					; size = 1
___n$ = -76						; size = 4
$T1 = -70						; size = 2
_pTerrainPatchProxy$ = -68				; size = 4
_uIndex$2 = -64						; size = 4
_pkVB$ = -60						; size = 4
$T3 = -53						; size = 1
_this$ = -52						; size = 4
_pkPosition$ = -48					; size = 4
_m4Frustum$ = -44					; size = 64
_akTransVertex$ = 20					; size = 4624
__$ArrayPad$ = 4644					; size = 4
_rkTPRS$ = 4656						; size = 4
_patchnum$ = 4660					; size = 4
_wPrimitiveCount$ = 4664				; size = 2
_ePrimitiveType$ = 4668					; size = 4
?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone, COMDAT
; _this$ = ecx

; 271  : {

  00000	55		 push	 ebp
  00001	8d ac 24 d8 ed
	ff ff		 lea	 ebp, DWORD PTR [esp-4648]
  00008	b8 a8 12 00 00	 mov	 eax, 4776		; 000012a8H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 24 12 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 272  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone");
; 273  : 
; 274  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00024	6b 85 34 12 00
	00 1c		 imul	 eax, DWORD PTR _patchnum$[ebp], 28
  0002b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00031	89 45 bc	 mov	 DWORD PTR _pTerrainPatchProxy$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00034	8b 45 bc	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00037	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0003a	88 45 cb	 mov	 BYTE PTR $T3[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 276  : 	if (!pTerrainPatchProxy->isUsed())

  0003d	0f b6 45 cb	 movzx	 eax, BYTE PTR $T3[ebp]
  00041	85 c0		 test	 eax, eax
  00043	75 05		 jne	 SHORT $LN5@SoftwareTr

; 277  : 		return;

  00045	e9 79 02 00 00	 jmp	 $LN1@SoftwareTr
$LN5@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 173  : 	short GetPatchNum()																{ return m_sPatchNum; }

  0004a	8b 45 bc	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  0004d	66 8b 40 06	 mov	 ax, WORD PTR [eax+6]
  00051	66 89 45 ba	 mov	 WORD PTR $T1[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 279  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();

  00055	0f bf 45 ba	 movsx	 eax, WORD PTR $T1[ebp]
  00059	89 45 94	 mov	 DWORD PTR _sPatchNum$[ebp], eax

; 280  : 	if (sPatchNum < 0)

  0005c	83 7d 94 00	 cmp	 DWORD PTR _sPatchNum$[ebp], 0
  00060	7d 05		 jge	 SHORT $LN6@SoftwareTr

; 281  : 		return;

  00062	e9 5c 02 00 00	 jmp	 $LN1@SoftwareTr
$LN6@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  00067	8b 45 bc	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  0006a	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  0006d	88 45 b0	 mov	 BYTE PTR _ucTerrainNum$[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 284  : 	if (0xFF == ucTerrainNum)

  00070	0f b6 45 b0	 movzx	 eax, BYTE PTR _ucTerrainNum$[ebp]
  00074	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00079	75 05		 jne	 SHORT $LN7@SoftwareTr

; 285  : 		return;

  0007b	e9 43 02 00 00	 jmp	 $LN1@SoftwareTr
$LN7@SoftwareTr:

; 286  : 
; 287  : 	CTerrain * pTerrain;
; 288  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  00080	8d 45 ac	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00083	50		 push	 eax
  00084	ff 75 b0	 push	 DWORD PTR _ucTerrainNum$[ebp]
  00087	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0008f	85 c0		 test	 eax, eax
  00091	75 05		 jne	 SHORT $LN8@SoftwareTr

; 289  : 		return;

  00093	e9 2b 02 00 00	 jmp	 $LN1@SoftwareTr
$LN8@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  00098	8b 45 ac	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  0009b	66 8b 80 6c a5
	06 00		 mov	 ax, WORD PTR [eax+435564]
  000a2	66 89 45 9c	 mov	 WORD PTR _wCoordX$[ebp], ax

; 93   : 			*usCoordY = m_wY;

  000a6	8b 45 ac	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  000a9	66 8b 80 6e a5
	06 00		 mov	 ax, WORD PTR [eax+435566]
  000b0	66 89 45 98	 mov	 WORD PTR _wCoordY$[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 294  : 	SoftwareTransformPatch_SSourceVertex* akSrcVertex=pTerrainPatchProxy->SoftwareTransformPatch_GetTerrainVertexDataPtr();

  000b4	8b 4d bc	 mov	 ecx, DWORD PTR _pTerrainPatchProxy$[ebp]
  000b7	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr
  000bc	89 45 a4	 mov	 DWORD PTR _akSrcVertex$[ebp], eax

; 295  : 	if (!akSrcVertex)

  000bf	83 7d a4 00	 cmp	 DWORD PTR _akSrcVertex$[ebp], 0
  000c3	75 05		 jne	 SHORT $LN9@SoftwareTr

; 296  : 		return;

  000c5	e9 f9 01 00 00	 jmp	 $LN1@SoftwareTr
$LN9@SoftwareTr:

; 297  : 	
; 298  : 	float fScreenHalfWidth=rkTPRS.m_fScreenHalfWidth;

  000ca	8b 85 30 12 00
	00		 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  000d0	f3 0f 10 80 7c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+380]
  000d8	f3 0f 11 45 84	 movss	 DWORD PTR _fScreenHalfWidth$[ebp], xmm0

; 299  : 	float fScreenHalfHeight=rkTPRS.m_fScreenHalfHeight;

  000dd	8b 85 30 12 00
	00		 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  000e3	f3 0f 10 80 80
	01 00 00	 movss	 xmm0, DWORD PTR [eax+384]
  000eb	f3 0f 11 45 88	 movss	 DWORD PTR _fScreenHalfHeight$[ebp], xmm0

; 300  : 
; 301  : 	D3DXMATRIX m4Frustum=rkTPRS.m_m4Frustum;

  000f0	8b b5 30 12 00
	00		 mov	 esi, DWORD PTR _rkTPRS$[ebp]
  000f6	83 c6 40	 add	 esi, 64			; 00000040H
  000f9	6a 10		 push	 16			; 00000010H
  000fb	59		 pop	 ecx
  000fc	8d 7d d4	 lea	 edi, DWORD PTR _m4Frustum$[ebp]
  000ff	f3 a5		 rep movsd

; 302  : 
; 303  : 	SoftwareTransformPatch_STVertex akTransVertex[CTerrainPatch::TERRAIN_VERTEX_COUNT];

  00101	c7 45 b4 21 01
	00 00		 mov	 DWORD PTR ___n$[ebp], 289 ; 00000121H
  00108	8d 45 14	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  0010b	89 45 a8	 mov	 DWORD PTR ___t$[ebp], eax
$LN22@SoftwareTr:
  0010e	8b 45 b4	 mov	 eax, DWORD PTR ___n$[ebp]
  00111	89 45 90	 mov	 DWORD PTR tv84[ebp], eax
  00114	8b 45 b4	 mov	 eax, DWORD PTR ___n$[ebp]
  00117	48		 dec	 eax
  00118	89 45 b4	 mov	 DWORD PTR ___n$[ebp], eax
  0011b	83 7d 90 00	 cmp	 DWORD PTR tv84[ebp], 0
  0011f	76 0b		 jbe	 SHORT $LN23@SoftwareTr
  00121	8b 45 a8	 mov	 eax, DWORD PTR ___t$[ebp]
  00124	83 c0 10	 add	 eax, 16			; 00000010H
  00127	89 45 a8	 mov	 DWORD PTR ___t$[ebp], eax
  0012a	eb e2		 jmp	 SHORT $LN22@SoftwareTr
$LN23@SoftwareTr:

; 304  : 
; 305  : 	D3DXVECTOR4* akPosition=(D3DXVECTOR4*)akTransVertex;

  0012c	8d 45 14	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  0012f	89 45 8c	 mov	 DWORD PTR _akPosition$[ebp], eax

; 306  : 	D3DXVECTOR4* pkPosition;
; 307  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  00132	83 65 c0 00	 and	 DWORD PTR _uIndex$2[ebp], 0
  00136	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  00138	8b 45 c0	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0013b	40		 inc	 eax
  0013c	89 45 c0	 mov	 DWORD PTR _uIndex$2[ebp], eax
$LN4@SoftwareTr:
  0013f	81 7d c0 21 01
	00 00		 cmp	 DWORD PTR _uIndex$2[ebp], 289 ; 00000121H
  00146	0f 84 9d 00 00
	00		 je	 $LN3@SoftwareTr

; 308  : 	{		
; 309  : 		pkPosition=akPosition+uIndex;

  0014c	8b 45 c0	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0014f	c1 e0 04	 shl	 eax, 4
  00152	03 45 8c	 add	 eax, DWORD PTR _akPosition$[ebp]
  00155	89 45 d0	 mov	 DWORD PTR _pkPosition$[ebp], eax

; 310  : 		D3DXVec3Transform(pkPosition, &akSrcVertex[uIndex].kPosition, &m4Frustum);

  00158	8d 45 d4	 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  0015b	50		 push	 eax
  0015c	6b 45 c0 1c	 imul	 eax, DWORD PTR _uIndex$2[ebp], 28
  00160	03 45 a4	 add	 eax, DWORD PTR _akSrcVertex$[ebp]
  00163	50		 push	 eax
  00164	ff 75 d0	 push	 DWORD PTR _pkPosition$[ebp]
  00167	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 311  : 		pkPosition->w=1.0f/pkPosition->w;

  0016c	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  0016f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00177	f3 0f 5e 40 0c	 divss	 xmm0, DWORD PTR [eax+12]
  0017c	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  0017f	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 312  : 		pkPosition->z*=pkPosition->w;

  00184	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  00187	8b 4d d0	 mov	 ecx, DWORD PTR _pkPosition$[ebp]
  0018a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0018f	f3 0f 59 41 0c	 mulss	 xmm0, DWORD PTR [ecx+12]
  00194	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  00197	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 313  : 		pkPosition->y=(pkPosition->y*pkPosition->w-1.0f)*fScreenHalfHeight;	

  0019c	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  0019f	8b 4d d0	 mov	 ecx, DWORD PTR _pkPosition$[ebp]
  001a2	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001a7	f3 0f 59 41 0c	 mulss	 xmm0, DWORD PTR [ecx+12]
  001ac	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  001b4	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _fScreenHalfHeight$[ebp]
  001b9	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  001bc	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 314  : 		pkPosition->x=(pkPosition->x*pkPosition->w+1.0f)*fScreenHalfWidth;

  001c1	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  001c4	8b 4d d0	 mov	 ecx, DWORD PTR _pkPosition$[ebp]
  001c7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001cb	f3 0f 59 41 0c	 mulss	 xmm0, DWORD PTR [ecx+12]
  001d0	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  001d8	f3 0f 59 45 84	 mulss	 xmm0, DWORD PTR _fScreenHalfWidth$[ebp]
  001dd	8b 45 d0	 mov	 eax, DWORD PTR _pkPosition$[ebp]
  001e0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 315  : 	}

  001e4	e9 4f ff ff ff	 jmp	 $LN2@SoftwareTr
$LN3@SoftwareTr:

; 316  : 	
; 317  : 
; 318  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBNone[m_kSTPD.m_dwNonePos++];

  001e9	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	8b 80 04 0a 00
	00		 mov	 eax, DWORD PTR [eax+2564]
  001f2	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  001f5	8b 84 81 e0 09
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2528]
  001fc	89 45 c4	 mov	 DWORD PTR _pkVB$[ebp], eax
  001ff	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00202	8b 80 04 0a 00
	00		 mov	 eax, DWORD PTR [eax+2564]
  00208	40		 inc	 eax
  00209	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0020c	89 81 04 0a 00
	00		 mov	 DWORD PTR [ecx+2564], eax

; 319  : 	m_kSTPD.m_dwNonePos%=SoftwareTransformPatch_SData::NONE_VB_NUM;

  00212	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00215	8b 80 04 0a 00
	00		 mov	 eax, DWORD PTR [eax+2564]
  0021b	33 d2		 xor	 edx, edx
  0021d	6a 08		 push	 8
  0021f	59		 pop	 ecx
  00220	f7 f1		 div	 ecx
  00222	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00225	89 90 04 0a 00
	00		 mov	 DWORD PTR [eax+2564], edx

; 320  : 	if (!pkVB)

  0022b	83 7d c4 00	 cmp	 DWORD PTR _pkVB$[ebp], 0
  0022f	75 05		 jne	 SHORT $LN10@SoftwareTr

; 321  : 		return;

  00231	e9 8d 00 00 00	 jmp	 $LN1@SoftwareTr
$LN10@SoftwareTr:

; 322  : 
; 323  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_STVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;

  00236	c7 45 a0 10 12
	00 00		 mov	 DWORD PTR _dwVBSize$[ebp], 4624 ; 00001210H

; 324  : 	SoftwareTransformPatch_STVertex* akDstVertex;
; 325  : 	if (FAILED(

  0023d	68 00 20 00 00	 push	 8192			; 00002000H
  00242	8d 45 80	 lea	 eax, DWORD PTR _akDstVertex$[ebp]
  00245	50		 push	 eax
  00246	ff 75 a0	 push	 DWORD PTR _dwVBSize$[ebp]
  00249	6a 00		 push	 0
  0024b	8b 45 c4	 mov	 eax, DWORD PTR _pkVB$[ebp]
  0024e	8b 00		 mov	 eax, DWORD PTR [eax]
  00250	ff 75 c4	 push	 DWORD PTR _pkVB$[ebp]
  00253	ff 50 2c	 call	 DWORD PTR [eax+44]
  00256	85 c0		 test	 eax, eax
  00258	7d 02		 jge	 SHORT $LN11@SoftwareTr

; 326  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, D3DLOCK_DISCARD)
; 327  : 	)) return;

  0025a	eb 67		 jmp	 SHORT $LN1@SoftwareTr
$LN11@SoftwareTr:

; 328  : 
; 329  : 	memcpy(akDstVertex, akTransVertex, dwVBSize);

  0025c	ff 75 a0	 push	 DWORD PTR _dwVBSize$[ebp]
  0025f	8d 45 14	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  00262	50		 push	 eax
  00263	ff 75 80	 push	 DWORD PTR _akDstVertex$[ebp]
  00266	e8 00 00 00 00	 call	 _memcpy
  0026b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 330  : 
; 331  : 	pkVB->Unlock();

  0026e	8b 45 c4	 mov	 eax, DWORD PTR _pkVB$[ebp]
  00271	8b 00		 mov	 eax, DWORD PTR [eax]
  00273	ff 75 c4	 push	 DWORD PTR _pkVB$[ebp]
  00276	ff 50 30	 call	 DWORD PTR [eax+48]

; 332  : 
; 333  : 	STATEMANAGER.SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_STVertex));

  00279	6a 10		 push	 16			; 00000010H
  0027b	ff 75 c4	 push	 DWORD PTR _pkVB$[ebp]
  0027e	6a 00		 push	 0
  00280	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00286	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 334  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  0028b	0f b7 85 38 12
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00292	50		 push	 eax
  00293	6a 00		 push	 0
  00295	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00298	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  0029e	6a 00		 push	 0
  002a0	ff b5 3c 12 00
	00		 push	 DWORD PTR _ePrimitiveType$[ebp]
  002a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ac	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 335  : 	ms_faceCount += wPrimitiveCount;

  002b1	0f b7 85 38 12
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  002b8	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  002be	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount
$LN1@SoftwareTr:

; 336  : }

  002c3	5f		 pop	 edi
  002c4	5e		 pop	 esi
  002c5	8b 8d 24 12 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002cb	33 cd		 xor	 ecx, ebp
  002cd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d2	81 c5 28 12 00
	00		 add	 ebp, 4648		; 00001228H
  002d8	c9		 leave
  002d9	c2 10 00	 ret	 16			; 00000010H
?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z
_TEXT	SEGMENT
$T1 = -124						; size = 4
$T2 = -120						; size = 4
$T3 = -116						; size = 4
_this$ = -112						; size = 4
_iPrevRenderedSplatNum$ = -108				; size = 4
$T4 = -104						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
_aIterator$8 = -88					; size = 4
tv92 = -84						; size = 4
$T9 = -80						; size = 4
___param0$ = -76					; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
___param0$ = -56					; size = 4
$T14 = -52						; size = 4
___param0$ = -48					; size = 4
_ucTerrainNum$ = -44					; size = 1
_iCurRenderedSplatNum$ = -40				; size = 4
tv517 = -36						; size = 4
__My_data$15 = -32					; size = 4
__My_data$16 = -28					; size = 4
__My_data$17 = -24					; size = 4
_rTexture$18 = -20					; size = 4
_rTerrainSplatPatch$ = -16				; size = 4
_sPatchNum$ = -12					; size = 4
___t$ = -8						; size = 4
_rSplat$19 = -4						; size = 4
___n$ = 0						; size = 4
_wCoordX$ = 4						; size = 2
_wCoordY$ = 8						; size = 2
$T20 = 14						; size = 2
_isDynamicShadow$ = 16					; size = 1
_pTerrainPatchProxy$ = 20				; size = 4
_pTerrain$ = 24						; size = 4
$T21 = 30						; size = 1
$T22 = 31						; size = 1
_j$23 = 32						; size = 4
_isFirst$ = 39						; size = 1
_this$ = 40						; size = 4
_akTransVertex$ = 44					; size = 16184
__$ArrayPad$ = 16228					; size = 4
_rkTPRS$ = 16240					; size = 4
_patchnum$ = 16244					; size = 4
_wPrimitiveCount$ = 16248				; size = 2
_ePrimitiveType$ = 16252				; size = 4
_isFogEnable$ = 16256					; size = 1
?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat, COMDAT
; _this$ = ecx

; 133  : {

  00000	55		 push	 ebp
  00001	8d ac 24 98 c0
	ff ff		 lea	 ebp, DWORD PTR [esp-16232]
  00008	b8 e4 3f 00 00	 mov	 eax, 16356		; 00003fe4H
  0000d	e8 00 00 00 00	 call	 __chkstk
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	89 85 64 3f 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001f	89 4d 28	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 	assert(NULL!=m_pTerrainPatchProxyList && "CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat");
; 135  : 
; 136  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00022	6b 85 74 3f 00
	00 1c		 imul	 eax, DWORD PTR _patchnum$[ebp], 28
  00029	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  0002f	89 45 14	 mov	 DWORD PTR _pTerrainPatchProxy$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00032	8b 45 14	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00035	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00038	88 45 1f	 mov	 BYTE PTR $T22[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 138  : 	if (!pTerrainPatchProxy->isUsed())

  0003b	0f b6 45 1f	 movzx	 eax, BYTE PTR $T22[ebp]
  0003f	85 c0		 test	 eax, eax
  00041	75 05		 jne	 SHORT $LN5@SoftwareTr

; 139  : 		return;

  00043	e9 7b 05 00 00	 jmp	 $LN1@SoftwareTr
$LN5@SoftwareTr:

; 140  : 
; 141  : 	bool isDynamicShadow = pTerrainPatchProxy->IsIn(rkTPRS.m_v3Player, 3000.0f);

  00048	51		 push	 ecx
  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@453b8000
  00051	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00056	8b 85 70 3f 00
	00		 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0005c	05 6c 01 00 00	 add	 eax, 364		; 0000016cH
  00061	50		 push	 eax
  00062	8b 4d 14	 mov	 ecx, DWORD PTR _pTerrainPatchProxy$[ebp]
  00065	e8 00 00 00 00	 call	 ?IsIn@CTerrainPatchProxy@@QAE_NABUD3DXVECTOR3@@M@Z ; CTerrainPatchProxy::IsIn
  0006a	88 45 10	 mov	 BYTE PTR _isDynamicShadow$[ebp], al

; 142  : 
; 143  : 	if (!m_bDrawChrShadow)

  0006d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00070	0f b6 80 32 01
	00 00		 movzx	 eax, BYTE PTR [eax+306]
  00077	85 c0		 test	 eax, eax
  00079	75 04		 jne	 SHORT $LN6@SoftwareTr

; 144  : 		isDynamicShadow = false;

  0007b	c6 45 10 00	 mov	 BYTE PTR _isDynamicShadow$[ebp], 0
$LN6@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 173  : 	short GetPatchNum()																{ return m_sPatchNum; }

  0007f	8b 45 14	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00082	66 8b 40 06	 mov	 ax, WORD PTR [eax+6]
  00086	66 89 45 0e	 mov	 WORD PTR $T20[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 146  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();

  0008a	0f bf 45 0e	 movsx	 eax, WORD PTR $T20[ebp]
  0008e	89 45 f4	 mov	 DWORD PTR _sPatchNum$[ebp], eax

; 147  : 
; 148  : 	if (sPatchNum < 0)

  00091	83 7d f4 00	 cmp	 DWORD PTR _sPatchNum$[ebp], 0
  00095	7d 05		 jge	 SHORT $LN7@SoftwareTr

; 149  : 		return;

  00097	e9 27 05 00 00	 jmp	 $LN1@SoftwareTr
$LN7@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  0009c	8b 45 14	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  0009f	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  000a2	88 45 d4	 mov	 BYTE PTR _ucTerrainNum$[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 153  : 	if (0xFF == ucTerrainNum)

  000a5	0f b6 45 d4	 movzx	 eax, BYTE PTR _ucTerrainNum$[ebp]
  000a9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  000ae	75 05		 jne	 SHORT $LN8@SoftwareTr

; 154  : 		return;

  000b0	e9 0e 05 00 00	 jmp	 $LN1@SoftwareTr
$LN8@SoftwareTr:

; 155  : 
; 156  : 	CTerrain * pTerrain;
; 157  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  000b5	8d 45 18	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 d4	 push	 DWORD PTR _ucTerrainNum$[ebp]
  000bc	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000c4	85 c0		 test	 eax, eax
  000c6	75 05		 jne	 SHORT $LN9@SoftwareTr

; 158  : 		return;

  000c8	e9 f6 04 00 00	 jmp	 $LN1@SoftwareTr
$LN9@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  000cd	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  000d0	66 8b 80 6c a5
	06 00		 mov	 ax, WORD PTR [eax+435564]
  000d7	66 89 45 04	 mov	 WORD PTR _wCoordX$[ebp], ax

; 93   : 			*usCoordY = m_wY;

  000db	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  000de	66 8b 80 6e a5
	06 00		 mov	 ax, WORD PTR [eax+435566]
  000e5	66 89 45 08	 mov	 WORD PTR _wCoordY$[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 86   : 		TTerrainSplatPatch &	GetTerrainSplatPatch() {return m_TerrainSplatPatch;}

  000e9	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  000ec	05 3c 91 03 00	 add	 eax, 233788		; 0003913cH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 163  : 	TTerrainSplatPatch & rTerrainSplatPatch = pTerrain->GetTerrainSplatPatch();

  000f1	89 45 f0	 mov	 DWORD PTR _rTerrainSplatPatch$[ebp], eax

; 164  : 	
; 165  : 	SoftwareTransformPatch_STLVertex akTransVertex[CTerrainPatch::TERRAIN_VERTEX_COUNT];

  000f4	c7 45 00 21 01
	00 00		 mov	 DWORD PTR ___n$[ebp], 289 ; 00000121H
  000fb	8d 45 2c	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  000fe	89 45 f8	 mov	 DWORD PTR ___t$[ebp], eax
$LN39@SoftwareTr:
  00101	8b 45 00	 mov	 eax, DWORD PTR ___n$[ebp]
  00104	89 45 ac	 mov	 DWORD PTR tv92[ebp], eax
  00107	8b 45 00	 mov	 eax, DWORD PTR ___n$[ebp]
  0010a	48		 dec	 eax
  0010b	89 45 00	 mov	 DWORD PTR ___n$[ebp], eax
  0010e	83 7d ac 00	 cmp	 DWORD PTR tv92[ebp], 0
  00112	76 0b		 jbe	 SHORT $LN40@SoftwareTr
  00114	8b 45 f8	 mov	 eax, DWORD PTR ___t$[ebp]
  00117	83 c0 38	 add	 eax, 56			; 00000038H
  0011a	89 45 f8	 mov	 DWORD PTR ___t$[ebp], eax
  0011d	eb e2		 jmp	 SHORT $LN39@SoftwareTr
$LN40@SoftwareTr:

; 166  : 	if (!__SoftwareTransformPatch_SetTransform(rkTPRS, akTransVertex, *pTerrainPatchProxy, wCoordX, wCoordY, isFogEnable, isDynamicShadow))

  0011f	ff 75 10	 push	 DWORD PTR _isDynamicShadow$[ebp]
  00122	ff b5 80 3f 00
	00		 push	 DWORD PTR _isFogEnable$[ebp]
  00128	0f b7 45 08	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0012c	50		 push	 eax
  0012d	0f b7 45 04	 movzx	 eax, WORD PTR _wCoordX$[ebp]
  00131	50		 push	 eax
  00132	ff 75 14	 push	 DWORD PTR _pTerrainPatchProxy$[ebp]
  00135	8d 45 2c	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  00138	50		 push	 eax
  00139	ff b5 70 3f 00
	00		 push	 DWORD PTR _rkTPRS$[ebp]
  0013f	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00142	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
  00147	0f b6 c0	 movzx	 eax, al
  0014a	85 c0		 test	 eax, eax
  0014c	75 05		 jne	 SHORT $LN10@SoftwareTr

; 167  : 		return;

  0014e	e9 70 04 00 00	 jmp	 $LN1@SoftwareTr
$LN10@SoftwareTr:

; 168  : 	
; 169  : 	if (!__SoftwareTransformPatch_SetSplatStream(akTransVertex))

  00153	8d 45 2c	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  00156	50		 push	 eax
  00157	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
  0015f	0f b6 c0	 movzx	 eax, al
  00162	85 c0		 test	 eax, eax
  00164	75 05		 jne	 SHORT $LN11@SoftwareTr

; 170  : 		return;

  00166	e9 58 04 00 00	 jmp	 $LN1@SoftwareTr
$LN11@SoftwareTr:

; 171  : 	
; 172  : 	if (isFogEnable)

  0016b	0f b6 85 80 3f
	00 00		 movzx	 eax, BYTE PTR _isFogEnable$[ebp]
  00172	85 c0		 test	 eax, eax
  00174	74 35		 je	 SHORT $LN12@SoftwareTr

; 173  : 	{
; 174  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00176	6a 02		 push	 2
  00178	6a 02		 push	 2
  0017a	6a 00		 push	 0
  0017c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00182	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 175  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_TFACTOR);

  00187	6a 03		 push	 3
  00189	6a 03		 push	 3
  0018b	6a 00		 push	 0
  0018d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00193	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 176  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_BLENDDIFFUSEALPHA);

  00198	6a 0c		 push	 12			; 0000000cH
  0019a	6a 01		 push	 1
  0019c	6a 00		 push	 0
  0019e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001a4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 177  : 	}

  001a9	eb 33		 jmp	 SHORT $LN13@SoftwareTr
$LN12@SoftwareTr:

; 178  : 	else
; 179  : 	{
; 180  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  001ab	6a 02		 push	 2
  001ad	6a 02		 push	 2
  001af	6a 00		 push	 0
  001b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001b7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 181  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  001bc	6a 00		 push	 0
  001be	6a 03		 push	 3
  001c0	6a 00		 push	 0
  001c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 182  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  001cd	6a 02		 push	 2
  001cf	6a 01		 push	 1
  001d1	6a 00		 push	 0
  001d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN13@SoftwareTr:

; 183  : 	}
; 184  : 
; 185  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  001de	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  001e1	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  001e7	89 45 94	 mov	 DWORD PTR _iPrevRenderedSplatNum$[ebp], eax

; 186  : 	
; 187  : 	bool isFirst=true;

  001ea	c6 45 27 01	 mov	 BYTE PTR _isFirst$[ebp], 1

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  001ee	c7 45 20 01 00
	00 00		 mov	 DWORD PTR _j$23[ebp], 1
  001f5	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  001f7	8b 45 20	 mov	 eax, DWORD PTR _j$23[ebp]
  001fa	40		 inc	 eax
  001fb	89 45 20	 mov	 DWORD PTR _j$23[ebp], eax
$LN4@SoftwareTr:
  001fe	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00201	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  00204	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
  0020a	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 188  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  0020f	39 45 20	 cmp	 DWORD PTR _j$23[ebp], eax
  00212	0f 83 0e 02 00
	00		 jae	 $LN3@SoftwareTr

; 189  : 	{
; 190  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];

  00218	6b 45 20 0c	 imul	 eax, DWORD PTR _j$23[ebp], 12
  0021c	8b 4d f0	 mov	 ecx, DWORD PTR _rTerrainSplatPatch$[ebp]
  0021f	8d 84 01 00 04
	01 00		 lea	 eax, DWORD PTR [ecx+eax+66560]
  00226	89 45 fc	 mov	 DWORD PTR _rSplat$19[ebp], eax

; 191  : 		
; 192  : 		if (!rSplat.Active)

  00229	8b 45 fc	 mov	 eax, DWORD PTR _rSplat$19[ebp]
  0022c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0022f	75 02		 jne	 SHORT $LN14@SoftwareTr

; 193  : 			continue;

  00231	eb c4		 jmp	 SHORT $LN2@SoftwareTr
$LN14@SoftwareTr:

; 194  : 		
; 195  : 		if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)

  00233	8b 45 f4	 mov	 eax, DWORD PTR _sPatchNum$[ebp]
  00236	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  00239	8b 4d f0	 mov	 ecx, DWORD PTR _rTerrainSplatPatch$[ebp]
  0023c	8d 84 01 00 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1024]
  00243	8b 4d 20	 mov	 ecx, DWORD PTR _j$23[ebp]
  00246	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  0024a	75 02		 jne	 SHORT $LN15@SoftwareTr

; 196  : 			continue;

  0024c	eb a9		 jmp	 SHORT $LN2@SoftwareTr
$LN15@SoftwareTr:

; 197  : 		
; 198  : 		const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);

  0024e	ff 75 20	 push	 DWORD PTR _j$23[ebp]
  00251	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00254	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  0025a	e8 00 00 00 00	 call	 ?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ; CTextureSet::GetTexture
  0025f	89 45 ec	 mov	 DWORD PTR _rTexture$18[ebp], eax

; 199  : 		
; 200  : 		if (isFirst)

  00262	0f b6 45 27	 movzx	 eax, BYTE PTR _isFirst$[ebp]
  00266	85 c0		 test	 eax, eax
  00268	74 74		 je	 SHORT $LN16@SoftwareTr

; 201  : 		{
; 202  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG2);

  0026a	6a 03		 push	 3
  0026c	6a 04		 push	 4
  0026e	6a 01		 push	 1
  00270	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00276	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 203  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  0027b	8b 45 ec	 mov	 eax, DWORD PTR _rTexture$18[ebp]
  0027e	ff 70 18	 push	 DWORD PTR [eax+24]
  00281	6a 00		 push	 0
  00283	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00289	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 204  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  0028e	8b 45 fc	 mov	 eax, DWORD PTR _rSplat$19[ebp]
  00291	ff 70 08	 push	 DWORD PTR [eax+8]
  00294	6a 01		 push	 1
  00296	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0029c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 205  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  002a1	0f b7 85 78 3f
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  002a8	50		 push	 eax
  002a9	6a 00		 push	 0
  002ab	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  002ae	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  002b4	6a 00		 push	 0
  002b6	ff b5 7c 3f 00
	00		 push	 DWORD PTR _ePrimitiveType$[ebp]
  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002c2	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 206  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  002c7	6a 02		 push	 2
  002c9	6a 04		 push	 4
  002cb	6a 01		 push	 1
  002cd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002d3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 207  : 			isFirst=false;

  002d8	c6 45 27 00	 mov	 BYTE PTR _isFirst$[ebp], 0

; 208  : 		}

  002dc	eb 4c		 jmp	 SHORT $LN17@SoftwareTr
$LN16@SoftwareTr:

; 209  : 		else
; 210  : 		{
; 211  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  002de	8b 45 ec	 mov	 eax, DWORD PTR _rTexture$18[ebp]
  002e1	ff 70 18	 push	 DWORD PTR [eax+24]
  002e4	6a 00		 push	 0
  002e6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ec	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 212  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  002f1	8b 45 fc	 mov	 eax, DWORD PTR _rSplat$19[ebp]
  002f4	ff 70 08	 push	 DWORD PTR [eax+8]
  002f7	6a 01		 push	 1
  002f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ff	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 213  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);			

  00304	0f b7 85 78 3f
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  0030b	50		 push	 eax
  0030c	6a 00		 push	 0
  0030e	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00311	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  00317	6a 00		 push	 0
  00319	ff b5 7c 3f 00
	00		 push	 DWORD PTR _ePrimitiveType$[ebp]
  0031f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00325	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN17@SoftwareTr:

; 216  : 		std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);

  0032a	8b 45 20	 mov	 eax, DWORD PTR _j$23[ebp]
  0032d	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00330	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00333	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00338	89 45 e8	 mov	 DWORD PTR __My_data$17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0033b	8b 45 e8	 mov	 eax, DWORD PTR __My_data$17[ebp]
  0033e	89 45 8c	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00341	8b 45 e8	 mov	 eax, DWORD PTR __My_data$17[ebp]
  00344	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00347	89 45 d0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0034a	8b 45 d0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0034d	89 45 cc	 mov	 DWORD PTR $T14[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00350	8d 45 cc	 lea	 eax, DWORD PTR $T14[ebp]
  00353	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00356	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00359	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  0035e	89 45 e4	 mov	 DWORD PTR __My_data$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00361	8b 45 e4	 mov	 eax, DWORD PTR __My_data$16[ebp]
  00364	89 45 88	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00367	8b 45 e4	 mov	 eax, DWORD PTR __My_data$16[ebp]
  0036a	8b 00		 mov	 eax, DWORD PTR [eax]
  0036c	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0036f	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00372	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00375	8d 45 c4	 lea	 eax, DWORD PTR $T13[ebp]
  00378	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 216  : 		std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);

  0037b	8d 45 c0	 lea	 eax, DWORD PTR $T12[ebp]
  0037e	50		 push	 eax
  0037f	8b 45 bc	 mov	 eax, DWORD PTR $T11[ebp]
  00382	ff 30		 push	 DWORD PTR [eax]
  00384	8b 45 b8	 mov	 eax, DWORD PTR $T10[ebp]
  00387	ff 30		 push	 DWORD PTR [eax]
  00389	8d 45 a8	 lea	 eax, DWORD PTR _aIterator$8[ebp]
  0038c	50		 push	 eax
  0038d	e8 00 00 00 00	 call	 ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  00392	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00395	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00398	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  0039d	89 45 e0	 mov	 DWORD PTR __My_data$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  003a0	8b 45 e0	 mov	 eax, DWORD PTR __My_data$15[ebp]
  003a3	89 45 84	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  003a6	8b 45 e0	 mov	 eax, DWORD PTR __My_data$15[ebp]
  003a9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003ac	89 45 b4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  003af	8b 45 b4	 mov	 eax, DWORD PTR ___param0$[ebp]
  003b2	89 45 b0	 mov	 DWORD PTR $T9[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  003b5	8d 45 b0	 lea	 eax, DWORD PTR $T9[ebp]
  003b8	89 45 98	 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  003bb	8b 45 98	 mov	 eax, DWORD PTR $T4[ebp]
  003be	8b 4d a8	 mov	 ecx, DWORD PTR _aIterator$8[ebp]
  003c1	3b 08		 cmp	 ecx, DWORD PTR [eax]
  003c3	75 09		 jne	 SHORT $LN164@SoftwareTr
  003c5	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv517[ebp], 1
  003cc	eb 04		 jmp	 SHORT $LN165@SoftwareTr
$LN164@SoftwareTr:
  003ce	83 65 dc 00	 and	 DWORD PTR tv517[ebp], 0
$LN165@SoftwareTr:
  003d2	8a 45 dc	 mov	 al, BYTE PTR tv517[ebp]
  003d5	88 45 1e	 mov	 BYTE PTR $T21[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 217  : 		if (aIterator == m_RenderedTextureNumVector.end())

  003d8	0f b6 45 1e	 movzx	 eax, BYTE PTR $T21[ebp]
  003dc	85 c0		 test	 eax, eax
  003de	74 18		 je	 SHORT $LN170@SoftwareTr

; 218  : 			m_RenderedTextureNumVector.push_back(j);

  003e0	8b 45 20	 mov	 eax, DWORD PTR _j$23[ebp]
  003e3	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  003e6	8d 45 a4	 lea	 eax, DWORD PTR $T7[ebp]
  003e9	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 218  : 			m_RenderedTextureNumVector.push_back(j);

  003ea	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003ed	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  003f3	e8 00 00 00 00	 call	 ??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
$LN170@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 219  : 		++m_iRenderedSplatNum;

  003f8	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  003fb	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00401	40		 inc	 eax
  00402	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00405	89 81 88 09 00
	00		 mov	 DWORD PTR [ecx+2440], eax

; 220  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  0040b	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0040e	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00411	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00417	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  0041d	7c 02		 jl	 SHORT $LN19@SoftwareTr

; 221  : 			break;

  0041f	eb 05		 jmp	 SHORT $LN3@SoftwareTr
$LN19@SoftwareTr:

; 222  : 	}	

  00421	e9 d1 fd ff ff	 jmp	 $LN2@SoftwareTr
$LN3@SoftwareTr:

; 223  : 
; 224  : 	// 
; 225  : 	if (m_bDrawShadow)

  00426	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00429	0f b6 80 31 01
	00 00		 movzx	 eax, BYTE PTR [eax+305]
  00430	85 c0		 test	 eax, eax
  00432	0f 84 50 01 00
	00		 je	 $LN20@SoftwareTr

; 226  : 	{	
; 227  : 		__SoftwareTransformPatch_SetShadowStream(akTransVertex);

  00438	8d 45 2c	 lea	 eax, DWORD PTR _akTransVertex$[ebp]
  0043b	50		 push	 eax
  0043c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0043f	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream

; 228  : 		__SoftwareTransformPatch_ApplyStaticShadowRenderState();

  00444	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00447	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState

; 229  : 
; 230  : 		if (isDynamicShadow)

  0044c	0f b6 45 10	 movzx	 eax, BYTE PTR _isDynamicShadow$[ebp]
  00450	85 c0		 test	 eax, eax
  00452	74 0a		 je	 SHORT $LN21@SoftwareTr

; 231  : 			__SoftwareTransformPatch_ApplyDynamicShadowRenderState();

  00454	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00457	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
  0045c	eb 08		 jmp	 SHORT $LN22@SoftwareTr
$LN21@SoftwareTr:

; 232  : 		else
; 233  : 			__SoftwareTransformPatch_ApplyFogShadowRenderState();

  0045e	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
$LN22@SoftwareTr:

; 234  : 
; 235  : 		if (isFogEnable)

  00466	0f b6 85 80 3f
	00 00		 movzx	 eax, BYTE PTR _isFogEnable$[ebp]
  0046d	85 c0		 test	 eax, eax
  0046f	0f 84 8a 00 00
	00		 je	 $LN23@SoftwareTr

; 236  : 		{
; 237  : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, TRUE);

  00475	6a 01		 push	 1
  00477	6a 1c		 push	 28			; 0000001cH
  00479	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0047f	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 238  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, 0xFFFFFFFF);

  00484	6a ff		 push	 -1
  00486	6a 22		 push	 34			; 00000022H
  00488	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0048e	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 94   : 		LPDIRECT3DTEXTURE8		GetShadowTexture()						{ return m_lpShadowTexture; }

  00493	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00496	8b 80 44 a5 04
	00		 mov	 eax, DWORD PTR [eax+304452]
  0049c	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 239  : 			STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());

  0049f	ff 75 a0	 push	 DWORD PTR $T6[ebp]
  004a2	6a 00		 push	 0
  004a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004aa	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 240  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  004af	0f b7 85 78 3f
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  004b6	50		 push	 eax
  004b7	6a 00		 push	 0
  004b9	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  004bc	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  004c2	6a 00		 push	 0
  004c4	ff b5 7c 3f 00
	00		 push	 DWORD PTR _ePrimitiveType$[ebp]
  004ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004d0	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 241  : 			STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, rkTPRS.m_dwFogColor);

  004d5	8b 85 70 3f 00
	00		 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  004db	ff b0 78 01 00
	00		 push	 DWORD PTR [eax+376]
  004e1	6a 22		 push	 34			; 00000022H
  004e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004e9	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 242  : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  004ee	6a 00		 push	 0
  004f0	6a 1c		 push	 28			; 0000001cH
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004f8	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 243  : 		}

  004fd	eb 42		 jmp	 SHORT $LN24@SoftwareTr
$LN23@SoftwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 94   : 		LPDIRECT3DTEXTURE8		GetShadowTexture()						{ return m_lpShadowTexture; }

  004ff	8b 45 18	 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00502	8b 80 44 a5 04
	00		 mov	 eax, DWORD PTR [eax+304452]
  00508	89 45 9c	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 246  : 			STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());

  0050b	ff 75 9c	 push	 DWORD PTR $T5[ebp]
  0050e	6a 00		 push	 0
  00510	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00516	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 247  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  0051b	0f b7 85 78 3f
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00522	50		 push	 eax
  00523	6a 00		 push	 0
  00525	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00528	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  0052e	6a 00		 push	 0
  00530	ff b5 7c 3f 00
	00		 push	 DWORD PTR _ePrimitiveType$[ebp]
  00536	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0053c	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN24@SoftwareTr:

; 248  : 		}
; 249  : 
; 250  : 		if (isDynamicShadow)

  00541	0f b6 45 10	 movzx	 eax, BYTE PTR _isDynamicShadow$[ebp]
  00545	85 c0		 test	 eax, eax
  00547	74 0a		 je	 SHORT $LN25@SoftwareTr

; 251  : 			__SoftwareTransformPatch_RestoreDynamicShadowRenderState();

  00549	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0054c	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
  00551	eb 08		 jmp	 SHORT $LN26@SoftwareTr
$LN25@SoftwareTr:

; 252  : 		else
; 253  : 			__SoftwareTransformPatch_RestoreFogShadowRenderState();

  00553	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00556	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
$LN26@SoftwareTr:

; 254  : 		
; 255  : 		ms_faceCount += wPrimitiveCount;

  0055b	0f b7 85 78 3f
	00 00		 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00562	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  00568	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 256  :   		++m_iRenderedSplatNum;

  0056d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00570	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00576	40		 inc	 eax
  00577	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0057a	89 81 88 09 00
	00		 mov	 DWORD PTR [ecx+2440], eax

; 257  : 
; 258  : 		
; 259  : 
; 260  : 		__SoftwareTransformPatch_RestoreStaticShadowRenderState();

  00580	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00583	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
$LN20@SoftwareTr:

; 261  : 	}
; 262  : 
; 263  : 	++m_iRenderedPatchNum;

  00588	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0058b	8b 80 8c 09 00
	00		 mov	 eax, DWORD PTR [eax+2444]
  00591	40		 inc	 eax
  00592	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00595	89 81 8c 09 00
	00		 mov	 DWORD PTR [ecx+2444], eax

; 264  : 
; 265  : 	int iCurRenderedSplatNum=m_iRenderedSplatNum-iPrevRenderedSplatNum;

  0059b	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0059e	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  005a4	2b 45 94	 sub	 eax, DWORD PTR _iPrevRenderedSplatNum$[ebp]
  005a7	89 45 d8	 mov	 DWORD PTR _iCurRenderedSplatNum$[ebp], eax

; 266  : 
; 267  : 	m_iRenderedSplatNumSqSum+=iCurRenderedSplatNum*iCurRenderedSplatNum;

  005aa	8b 45 d8	 mov	 eax, DWORD PTR _iCurRenderedSplatNum$[ebp]
  005ad	0f af 45 d8	 imul	 eax, DWORD PTR _iCurRenderedSplatNum$[ebp]
  005b1	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  005b4	03 81 84 09 00
	00		 add	 eax, DWORD PTR [ecx+2436]
  005ba	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  005bd	89 81 84 09 00
	00		 mov	 DWORD PTR [ecx+2436], eax
$LN1@SoftwareTr:

; 268  : }

  005c3	8b 8d 64 3f 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  005c9	33 cd		 xor	 ecx, ebp
  005cb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  005d0	81 c5 68 3f 00
	00		 add	 ebp, 16232		; 00003f68H
  005d6	c9		 leave
  005d7	c2 14 00	 ret	 20			; 00000014H
?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	STATEMANAGER.SetTexture(1, NULL);

  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00011	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 392  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00016	6a 01		 push	 1
  00018	6a 02		 push	 2
  0001a	6a 01		 push	 1
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00022	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 393  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00027	6a 02		 push	 2
  00029	6a 01		 push	 1
  0002b	6a 01		 push	 1
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00033	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 394  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00038	6a 02		 push	 2
  0003a	6a 05		 push	 5
  0003c	6a 01		 push	 1
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00044	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 395  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00049	6a 02		 push	 2
  0004b	6a 04		 push	 4
  0004d	6a 01		 push	 1
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00055	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 396  : 
; 397  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  0005a	6a 03		 push	 3
  0005c	6a 0d		 push	 13			; 0000000dH
  0005e	6a 01		 push	 1
  00060	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00066	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 398  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  0006b	6a 03		 push	 3
  0006d	6a 0e		 push	 14			; 0000000eH
  0006f	6a 01		 push	 1
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00077	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 399  : }

  0007c	c9		 leave
  0007d	c3		 ret	 0
?__SoftwareTransformPatch_RestoreDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreDynamicShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState, COMDAT
; _this$ = ecx

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 355  :  	STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff b0 d4 01 00
	00		 push	 DWORD PTR [eax+468]
  00010	6a 01		 push	 1
  00012	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00018	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 356  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0001d	6a 02		 push	 2
  0001f	6a 02		 push	 2
  00021	6a 01		 push	 1
  00023	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00029	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 357  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  0002e	6a 01		 push	 1
  00030	6a 03		 push	 3
  00032	6a 01		 push	 1
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0003a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 358  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  0003f	6a 04		 push	 4
  00041	6a 01		 push	 1
  00043	6a 01		 push	 1
  00045	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0004b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 359  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);

  00050	6a 01		 push	 1
  00052	6a 05		 push	 5
  00054	6a 01		 push	 1
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 360  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00061	6a 02		 push	 2
  00063	6a 04		 push	 4
  00065	6a 01		 push	 1
  00067	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 361  : 
; 362  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  00072	6a 03		 push	 3
  00074	6a 0d		 push	 13			; 0000000dH
  00076	6a 01		 push	 1
  00078	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 363  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);

  00083	6a 03		 push	 3
  00085	6a 0e		 push	 14			; 0000000eH
  00087	6a 01		 push	 1
  00089	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 364  : }

  00094	c9		 leave
  00095	c3		 ret	 0
?__SoftwareTransformPatch_ApplyDynamicShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyDynamicShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState, COMDAT
; _this$ = ecx

; 404  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 405  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00007	6a 00		 push	 0
  00009	6a 1c		 push	 28			; 0000001cH
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00011	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 406  : 	
; 407  : 	STATEMANAGER.SetTexture(1, NULL);

  00016	6a 00		 push	 0
  00018	6a 01		 push	 1
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00020	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 408  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00025	6a 01		 push	 1
  00027	6a 02		 push	 2
  00029	6a 01		 push	 1
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00031	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 409  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00036	6a 02		 push	 2
  00038	6a 01		 push	 1
  0003a	6a 01		 push	 1
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00042	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 410  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00047	6a 02		 push	 2
  00049	6a 05		 push	 5
  0004b	6a 01		 push	 1
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00053	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 411  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00058	6a 02		 push	 2
  0005a	6a 04		 push	 4
  0005c	6a 01		 push	 1
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00064	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 412  : }

  00069	c9		 leave
  0006a	c3		 ret	 0
?__SoftwareTransformPatch_RestoreFogShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreFogShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState, COMDAT
; _this$ = ecx

; 367  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 368  : 	STATEMANAGER.SetTexture(1, NULL);

  00007	6a 00		 push	 0
  00009	6a 01		 push	 1
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00011	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 369  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00016	6a 01		 push	 1
  00018	6a 02		 push	 2
  0001a	6a 01		 push	 1
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00022	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 370  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00027	6a 02		 push	 2
  00029	6a 01		 push	 1
  0002b	6a 01		 push	 1
  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00033	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 371  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_CURRENT);

  00038	6a 01		 push	 1
  0003a	6a 05		 push	 5
  0003c	6a 01		 push	 1
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00044	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 372  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00049	6a 02		 push	 2
  0004b	6a 04		 push	 4
  0004d	6a 01		 push	 1
  0004f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00055	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 373  : }

  0005a	c9		 leave
  0005b	c3		 ret	 0
?__SoftwareTransformPatch_ApplyFogShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyFogShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00007	6a 02		 push	 2
  00009	6a 02		 push	 2
  0000b	6a 00		 push	 0
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00013	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 377  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00018	6a 02		 push	 2
  0001a	6a 01		 push	 1
  0001c	6a 00		 push	 0
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 378  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00029	6a 02		 push	 2
  0002b	6a 05		 push	 5
  0002d	6a 00		 push	 0
  0002f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00035	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 379  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0003a	6a 02		 push	 2
  0003c	6a 04		 push	 4
  0003e	6a 00		 push	 0
  00040	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00046	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 380  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  0004b	6a 01		 push	 1
  0004d	6a 0d		 push	 13			; 0000000dH
  0004f	6a 00		 push	 0
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00057	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 381  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  0005c	6a 01		 push	 1
  0005e	6a 0e		 push	 14			; 0000000eH
  00060	6a 00		 push	 0
  00062	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00068	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 382  : 	
; 383  : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  0006d	6a 05		 push	 5
  0006f	6a 13		 push	 19			; 00000013H
  00071	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00077	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 384  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  0007c	6a 06		 push	 6
  0007e	6a 14		 push	 20			; 00000014H
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00086	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 385  : }

  0008b	c9		 leave
  0008c	c3		 ret	 0
?__SoftwareTransformPatch_RestoreStaticShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreStaticShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState, COMDAT
; _this$ = ecx

; 339  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  : 	STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);

  00007	6a 01		 push	 1
  00009	6a 13		 push	 19			; 00000013H
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00011	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 341  : 	STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

  00016	6a 03		 push	 3
  00018	6a 14		 push	 20			; 00000014H
  0001a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00020	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 342  : 	
; 343  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00025	6a 02		 push	 2
  00027	6a 02		 push	 2
  00029	6a 00		 push	 0
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00031	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 344  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  00036	6a 00		 push	 0
  00038	6a 03		 push	 3
  0003a	6a 00		 push	 0
  0003c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00042	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 345  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00047	6a 04		 push	 4
  00049	6a 01		 push	 1
  0004b	6a 00		 push	 0
  0004d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00053	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 346  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00058	6a 02		 push	 2
  0005a	6a 05		 push	 5
  0005c	6a 00		 push	 0
  0005e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00064	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 347  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00069	6a 02		 push	 2
  0006b	6a 04		 push	 4
  0006d	6a 00		 push	 0
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 348  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  0007a	6a 03		 push	 3
  0007c	6a 0d		 push	 13			; 0000000dH
  0007e	6a 00		 push	 0
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00086	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 349  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);	

  0008b	6a 03		 push	 3
  0008d	6a 0e		 push	 14			; 0000000eH
  0008f	6a 00		 push	 0
  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00097	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 350  : 
; 351  : }

  0009c	c9		 leave
  0009d	c3		 ret	 0
?__SoftwareTransformPatch_ApplyStaticShadowRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyStaticShadowRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z
_TEXT	SEGMENT
_akDstVertex$ = -28					; size = 4
_dwVBSize$ = -24					; size = 4
_pkDstVertex$ = -20					; size = 4
_pkSrcVertex$ = -16					; size = 4
_uIndex$1 = -12						; size = 4
_pkVB$ = -8						; size = 4
_this$ = -4						; size = 4
_akSrcVertex$ = 8					; size = 4
?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream, COMDAT
; _this$ = ecx

; 701  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 702  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBSplat[m_kSTPD.m_dwSplatPos++];

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 84 81 c0 09
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2496]
  0001e	89 45 f8	 mov	 DWORD PTR _pkVB$[ebp], eax
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  0002a	40		 inc	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 81 00 0a 00
	00		 mov	 DWORD PTR [ecx+2560], eax

; 703  : 	m_kSTPD.m_dwSplatPos%=SoftwareTransformPatch_SData::SPLAT_VB_NUM;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  0003d	33 d2		 xor	 edx, edx
  0003f	6a 08		 push	 8
  00041	59		 pop	 ecx
  00042	f7 f1		 div	 ecx
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 90 00 0a 00
	00		 mov	 DWORD PTR [eax+2560], edx

; 704  : 	if (!pkVB)

  0004d	83 7d f8 00	 cmp	 DWORD PTR _pkVB$[ebp], 0
  00051	75 07		 jne	 SHORT $LN5@SoftwareTr

; 705  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	e9 c1 00 00 00	 jmp	 $LN1@SoftwareTr
$LN5@SoftwareTr:

; 706  : 	
; 707  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;

  0005a	c7 45 e8 28 2d
	00 00		 mov	 DWORD PTR _dwVBSize$[ebp], 11560 ; 00002d28H

; 708  : 	SoftwareTransformPatch_SSplatVertex* akDstVertex;
; 709  : 	if (FAILED(

  00061	6a 00		 push	 0
  00063	8d 45 e4	 lea	 eax, DWORD PTR _akDstVertex$[ebp]
  00066	50		 push	 eax
  00067	ff 75 e8	 push	 DWORD PTR _dwVBSize$[ebp]
  0006a	6a 00		 push	 0
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _pkVB$[ebp]
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  00074	ff 50 2c	 call	 DWORD PTR [eax+44]
  00077	85 c0		 test	 eax, eax
  00079	7d 07		 jge	 SHORT $LN6@SoftwareTr

; 710  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, 0)//D3DLOCK_DISCARD)
; 711  : 	)) return false;

  0007b	32 c0		 xor	 al, al
  0007d	e9 99 00 00 00	 jmp	 $LN1@SoftwareTr
$LN6@SoftwareTr:

; 712  : 
; 713  : 	SoftwareTransformPatch_STLVertex* pkSrcVertex;
; 714  : 	SoftwareTransformPatch_SSplatVertex* pkDstVertex;
; 715  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  00082	83 65 f4 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  00086	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  00088	8b 45 f4	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0008b	40		 inc	 eax
  0008c	89 45 f4	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN4@SoftwareTr:
  0008f	81 7d f4 21 01
	00 00		 cmp	 DWORD PTR _uIndex$1[ebp], 289 ; 00000121H
  00096	74 5c		 je	 SHORT $LN3@SoftwareTr

; 716  : 	{
; 717  : 		pkSrcVertex=akSrcVertex+uIndex;

  00098	6b 45 f4 38	 imul	 eax, DWORD PTR _uIndex$1[ebp], 56
  0009c	03 45 08	 add	 eax, DWORD PTR _akSrcVertex$[ebp]
  0009f	89 45 f0	 mov	 DWORD PTR _pkSrcVertex$[ebp], eax

; 718  : 		pkDstVertex=akDstVertex+uIndex;

  000a2	6b 45 f4 28	 imul	 eax, DWORD PTR _uIndex$1[ebp], 40
  000a6	03 45 e4	 add	 eax, DWORD PTR _akDstVertex$[ebp]
  000a9	89 45 ec	 mov	 DWORD PTR _pkDstVertex$[ebp], eax

; 719  : 		pkDstVertex->kPosition=pkSrcVertex->kPosition;

  000ac	8b 75 f0	 mov	 esi, DWORD PTR _pkSrcVertex$[ebp]
  000af	8b 7d ec	 mov	 edi, DWORD PTR _pkDstVertex$[ebp]
  000b2	a5		 movsd
  000b3	a5		 movsd
  000b4	a5		 movsd
  000b5	a5		 movsd

; 720  : 		pkDstVertex->dwDiffuse=pkSrcVertex->dwDiffuse;

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _pkDstVertex$[ebp]
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR _pkSrcVertex$[ebp]
  000bc	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  000bf	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 721  : 		pkDstVertex->dwSpecular=pkSrcVertex->dwFog;

  000c2	8b 45 ec	 mov	 eax, DWORD PTR _pkDstVertex$[ebp]
  000c5	8b 4d f0	 mov	 ecx, DWORD PTR _pkSrcVertex$[ebp]
  000c8	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  000cb	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 722  : 		pkDstVertex->kTex1=pkSrcVertex->kTexStaticShadow;

  000ce	8b 45 f0	 mov	 eax, DWORD PTR _pkSrcVertex$[ebp]
  000d1	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000d4	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  000d7	8b 55 ec	 mov	 edx, DWORD PTR _pkDstVertex$[ebp]
  000da	89 4a 18	 mov	 DWORD PTR [edx+24], ecx
  000dd	89 42 1c	 mov	 DWORD PTR [edx+28], eax

; 723  : 		pkDstVertex->kTex2=pkSrcVertex->kTexDynamicShadow;

  000e0	8b 45 f0	 mov	 eax, DWORD PTR _pkSrcVertex$[ebp]
  000e3	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  000e6	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  000e9	8b 55 ec	 mov	 edx, DWORD PTR _pkDstVertex$[ebp]
  000ec	89 4a 20	 mov	 DWORD PTR [edx+32], ecx
  000ef	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 724  : 	}	

  000f2	eb 94		 jmp	 SHORT $LN2@SoftwareTr
$LN3@SoftwareTr:

; 725  : 	pkVB->Unlock();

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _pkVB$[ebp]
  000f7	8b 00		 mov	 eax, DWORD PTR [eax]
  000f9	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  000fc	ff 50 30	 call	 DWORD PTR [eax+48]

; 726  : 
; 727  : 
; 728  : 	ms_lpd3dDevice->SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_SSplatVertex));

  000ff	6a 28		 push	 40			; 00000028H
  00101	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  00104	6a 00		 push	 0
  00106	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00113	ff 90 4c 01 00
	00		 call	 DWORD PTR [eax+332]

; 729  : 	return true;

  00119	b0 01		 mov	 al, 1
$LN1@SoftwareTr:

; 730  : }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	c9		 leave
  0011e	c2 04 00	 ret	 4
?__SoftwareTransformPatch_SetShadowStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetShadowStream
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z
_TEXT	SEGMENT
_akDstVertex$ = -20					; size = 4
_dwVBSize$ = -16					; size = 4
_uIndex$1 = -12						; size = 4
_pkVB$ = -8						; size = 4
_this$ = -4						; size = 4
_akSrcVertex$ = 8					; size = 4
?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream, COMDAT
; _this$ = ecx

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 680  : 	IDirect3DVertexBuffer8* pkVB=m_kSTPD.m_pkVBSplat[m_kSTPD.m_dwSplatPos++];

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 84 81 c0 09
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2496]
  0001e	89 45 f8	 mov	 DWORD PTR _pkVB$[ebp], eax
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  0002a	40		 inc	 eax
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 81 00 0a 00
	00		 mov	 DWORD PTR [ecx+2560], eax

; 681  : 	m_kSTPD.m_dwSplatPos%=SoftwareTransformPatch_SData::SPLAT_VB_NUM;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 80 00 0a 00
	00		 mov	 eax, DWORD PTR [eax+2560]
  0003d	33 d2		 xor	 edx, edx
  0003f	6a 08		 push	 8
  00041	59		 pop	 ecx
  00042	f7 f1		 div	 ecx
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 90 00 0a 00
	00		 mov	 DWORD PTR [eax+2560], edx

; 682  : 	if (!pkVB)

  0004d	83 7d f8 00	 cmp	 DWORD PTR _pkVB$[ebp], 0
  00051	75 04		 jne	 SHORT $LN5@SoftwareTr

; 683  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 6f		 jmp	 SHORT $LN1@SoftwareTr
$LN5@SoftwareTr:

; 684  : 
; 685  : 	DWORD dwVBSize=sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT;

  00057	c7 45 f0 28 2d
	00 00		 mov	 DWORD PTR _dwVBSize$[ebp], 11560 ; 00002d28H

; 686  : 	SoftwareTransformPatch_SSplatVertex* akDstVertex;
; 687  : 	if (FAILED(

  0005e	6a 00		 push	 0
  00060	8d 45 ec	 lea	 eax, DWORD PTR _akDstVertex$[ebp]
  00063	50		 push	 eax
  00064	ff 75 f0	 push	 DWORD PTR _dwVBSize$[ebp]
  00067	6a 00		 push	 0
  00069	8b 45 f8	 mov	 eax, DWORD PTR _pkVB$[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  00071	ff 50 2c	 call	 DWORD PTR [eax+44]
  00074	85 c0		 test	 eax, eax
  00076	7d 04		 jge	 SHORT $LN6@SoftwareTr

; 688  : 		pkVB->Lock(0, dwVBSize, (BYTE**)&akDstVertex, 0)//D3DLOCK_DISCARD)
; 689  : 	)) return false;

  00078	32 c0		 xor	 al, al
  0007a	eb 4a		 jmp	 SHORT $LN1@SoftwareTr
$LN6@SoftwareTr:

; 690  : 
; 691  : 	for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  0007c	83 65 f4 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  00080	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  00082	8b 45 f4	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  00085	40		 inc	 eax
  00086	89 45 f4	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN4@SoftwareTr:
  00089	81 7d f4 21 01
	00 00		 cmp	 DWORD PTR _uIndex$1[ebp], 289 ; 00000121H
  00090	74 15		 je	 SHORT $LN3@SoftwareTr

; 692  : 		*(akDstVertex+uIndex)=*((SoftwareTransformPatch_SSplatVertex*)(akSrcVertex+uIndex));

  00092	6b 75 f4 38	 imul	 esi, DWORD PTR _uIndex$1[ebp], 56
  00096	03 75 08	 add	 esi, DWORD PTR _akSrcVertex$[ebp]
  00099	6b 7d f4 28	 imul	 edi, DWORD PTR _uIndex$1[ebp], 40
  0009d	03 7d ec	 add	 edi, DWORD PTR _akDstVertex$[ebp]
  000a0	6a 0a		 push	 10			; 0000000aH
  000a2	59		 pop	 ecx
  000a3	f3 a5		 rep movsd
  000a5	eb db		 jmp	 SHORT $LN2@SoftwareTr
$LN3@SoftwareTr:

; 693  : 		
; 694  : 	pkVB->Unlock();

  000a7	8b 45 f8	 mov	 eax, DWORD PTR _pkVB$[ebp]
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  000af	ff 50 30	 call	 DWORD PTR [eax+48]

; 695  : 
; 696  : 	STATEMANAGER.SetStreamSource(0, pkVB, sizeof(SoftwareTransformPatch_SSplatVertex));

  000b2	6a 28		 push	 40			; 00000028H
  000b4	ff 75 f8	 push	 DWORD PTR _pkVB$[ebp]
  000b7	6a 00		 push	 0
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000bf	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 697  : 	return true;

  000c4	b0 01		 mov	 al, 1
$LN1@SoftwareTr:

; 698  : }

  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	c9		 leave
  000c9	c2 04 00	 ret	 4
?__SoftwareTransformPatch_SetSplatStream@CMapOutdoor@@IAE_NPAUSoftwareTransformPatch_STLVertex@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetSplatStream
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z
_TEXT	SEGMENT
tv452 = -380						; size = 8
tv378 = -372						; size = 8
_kWorkVertex$1 = -364					; size = 56
_fFogLenInv$2 = -308					; size = 4
_fFogFar$3 = -304					; size = 4
_kWorkVertex$4 = -300					; size = 56
_fAlphaPatternX$ = -244					; size = 4
_fTilePatternX$ = -240					; size = 4
_fTilePatternY$ = -236					; size = 4
_fShadowPatternY$ = -232				; size = 4
_fLocalY$5 = -228					; size = 4
_fShadowPatternX$ = -224				; size = 4
_fLocalX$6 = -220					; size = 4
_fAlphaBiasY$ = -216					; size = 4
_fAlphaPatternY$ = -212					; size = 4
_fAlphaBiasX$ = -208					; size = 4
_fScreenHalfHeight$ = -204				; size = 4
_fScreenHalfWidth$ = -200				; size = 4
_fTerrainBaseY$ = -196					; size = 4
_fTerrainBaseX$ = -192					; size = 4
_fLocalY$7 = -188					; size = 4
_fLocalX$8 = -184					; size = 4
tv449 = -180						; size = 4
tv375 = -176						; size = 4
_fFogCur$9 = -172					; size = 4
_uIndex$10 = -168					; size = 4
_akSrcVertex$ = -164					; size = 4
_uIndex$11 = -160					; size = 4
_uIndex$12 = -156					; size = 4
_this$ = -152						; size = 4
_pkSrcPosition$ = -148					; size = 4
_m4DynamicShadow$13 = -144				; size = 64
_m4Frustum$ = -80					; size = 64
_v3Shadow$14 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
_akTransVertex$ = 12					; size = 4
_rkTerrainPatchProxy$ = 16				; size = 4
_uTerrainX$ = 20					; size = 4
_uTerrainY$ = 24					; size = 4
_isFogEnable$ = 28					; size = 1
_isDynamicShadow$ = 32					; size = 1
?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_SetTransform, COMDAT
; _this$ = ecx

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 7c 01 00
	00		 sub	 esp, 380		; 0000017cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 8d 68 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 558  : 	SoftwareTransformPatch_SSourceVertex* akSrcVertex=rkTerrainPatchProxy.SoftwareTransformPatch_GetTerrainVertexDataPtr();

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _rkTerrainPatchProxy$[ebp]
  0001e	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_GetTerrainVertexDataPtr@CTerrainPatchProxy@@QAEPAUSoftwareTransformPatch_SSourceVertex@@XZ ; CTerrainPatchProxy::SoftwareTransformPatch_GetTerrainVertexDataPtr
  00023	89 85 5c ff ff
	ff		 mov	 DWORD PTR _akSrcVertex$[ebp], eax

; 559  : 	if (!akSrcVertex)

  00029	83 bd 5c ff ff
	ff 00		 cmp	 DWORD PTR _akSrcVertex$[ebp], 0
  00030	75 07		 jne	 SHORT $LN11@SoftwareTr

; 560  : 		return false;

  00032	32 c0		 xor	 al, al
  00034	e9 74 07 00 00	 jmp	 $LN1@SoftwareTr
$LN11@SoftwareTr:

; 561  : 	
; 562  : 	rkTerrainPatchProxy.SoftwareTransformPatch_UpdateTerrainLighting(

  00039	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0003c	05 28 01 00 00	 add	 eax, 296		; 00000128H
  00041	50		 push	 eax
  00042	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00045	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0004a	50		 push	 eax
  0004b	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00051	ff b0 08 0a 00
	00		 push	 DWORD PTR [eax+2568]
  00057	8b 4d 10	 mov	 ecx, DWORD PTR _rkTerrainPatchProxy$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SoftwareTransformPatch_UpdateTerrainLighting@CTerrainPatchProxy@@QAEXKABU_D3DLIGHT8@@ABU_D3DMATERIAL8@@@Z ; CTerrainPatchProxy::SoftwareTransformPatch_UpdateTerrainLighting

; 563  : 		m_kSTPD.m_dwLightVersion, 
; 564  : 		rkTPRS.m_kLight, rkTPRS.m_kMtrl);
; 565  : 	
; 566  : 	D3DXVECTOR3* pkSrcPosition;
; 567  : 
; 568  : 	float fTilePatternX=+1/640.0f;

  0005f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3acccccd
  00067	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _fTilePatternX$[ebp], xmm0

; 569  : 	float fTilePatternY=-1/640.0f;

  0006f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bacccccd
  00077	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fTilePatternY$[ebp], xmm0

; 570  : 
; 571  : 	float fTerrainBaseX=-(float) (uTerrainX * CTerrainImpl::TERRAIN_XSIZE)+m_fTerrainTexCoordBase * 12.30769f;

  0007f	69 45 14 00 64
	00 00		 imul	 eax, DWORD PTR _uTerrainX$[ebp], 25600
  00086	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv375[ebp], eax
  0008c	f2 0f 2a 85 50
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv375[ebp]
  00094	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv375[ebp]
  0009a	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0009d	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000a6	f2 0f 11 85 8c
	fe ff ff	 movsd	 QWORD PTR tv378[ebp], xmm0
  000ae	f2 0f 5a 85 8c
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv378[ebp]
  000b6	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000bd	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c3	f3 0f 10 88 08
	09 00 00	 movss	 xmm1, DWORD PTR [eax+2312]
  000cb	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@4144ec4c
  000d3	f3 0f 58 c1	 addss	 xmm0, xmm1
  000d7	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fTerrainBaseX$[ebp], xmm0

; 572  : 	float fTerrainBaseY=+(float) (uTerrainY * CTerrainImpl::TERRAIN_YSIZE)+m_fTerrainTexCoordBase * 12.30769f;	

  000df	69 45 18 00 64
	00 00		 imul	 eax, DWORD PTR _uTerrainY$[ebp], 25600
  000e6	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv449[ebp], eax
  000ec	f2 0f 2a 85 4c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv449[ebp]
  000f4	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv449[ebp]
  000fa	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000fd	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00106	f2 0f 11 85 84
	fe ff ff	 movsd	 QWORD PTR tv452[ebp], xmm0
  0010e	f2 0f 5a 85 84
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv452[ebp]
  00116	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011c	f3 0f 10 88 08
	09 00 00	 movss	 xmm1, DWORD PTR [eax+2312]
  00124	f3 0f 59 0d 00
	00 00 00	 mulss	 xmm1, DWORD PTR __real@4144ec4c
  0012c	f3 0f 58 c1	 addss	 xmm0, xmm1
  00130	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fTerrainBaseY$[ebp], xmm0

; 573  : 
; 574  : 	float fScreenHalfWidth=rkTPRS.m_fScreenHalfWidth;

  00138	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0013b	f3 0f 10 80 7c
	01 00 00	 movss	 xmm0, DWORD PTR [eax+380]
  00143	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fScreenHalfWidth$[ebp], xmm0

; 575  : 	float fScreenHalfHeight=rkTPRS.m_fScreenHalfHeight;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0014e	f3 0f 10 80 80
	01 00 00	 movss	 xmm0, DWORD PTR [eax+384]
  00156	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fScreenHalfHeight$[ebp], xmm0

; 576  : 
; 577  : 	float fAlphaPatternX=m_matSplatAlpha._11;

  0015e	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00164	f3 0f 10 80 c8
	07 00 00	 movss	 xmm0, DWORD PTR [eax+1992]
  0016c	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _fAlphaPatternX$[ebp], xmm0

; 578  : 	float fAlphaPatternY=m_matSplatAlpha._22;

  00174	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0017a	f3 0f 10 80 dc
	07 00 00	 movss	 xmm0, DWORD PTR [eax+2012]
  00182	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fAlphaPatternY$[ebp], xmm0

; 579  : 	float fAlphaBiasX=m_matSplatAlpha._41;

  0018a	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00190	f3 0f 10 80 f8
	07 00 00	 movss	 xmm0, DWORD PTR [eax+2040]
  00198	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fAlphaBiasX$[ebp], xmm0

; 580  : 	float fAlphaBiasY=m_matSplatAlpha._42;	

  001a0	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001a6	f3 0f 10 80 fc
	07 00 00	 movss	 xmm0, DWORD PTR [eax+2044]
  001ae	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fAlphaBiasY$[ebp], xmm0

; 581  : 	float fShadowPatternX=+m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_XSIZE / (CTerrainImpl::XSIZE));		

  001b6	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001bc	f3 0f 10 80 08
	09 00 00	 movss	 xmm0, DWORD PTR [eax+2312]
  001c4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e000000
  001cc	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fShadowPatternX$[ebp], xmm0

; 582  : 	float fShadowPatternY=-m_fTerrainTexCoordBase * ((float) CTerrainImpl::PATCH_YSIZE / (CTerrainImpl::YSIZE));	

  001d4	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001da	f3 0f 10 80 08
	09 00 00	 movss	 xmm0, DWORD PTR [eax+2312]
  001e2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001e9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3e000000
  001f1	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _fShadowPatternY$[ebp], xmm0

; 583  : 
; 584  : 	D3DXMATRIX m4Frustum=rkTPRS.m_m4Frustum;

  001f9	8b 75 08	 mov	 esi, DWORD PTR _rkTPRS$[ebp]
  001fc	83 c6 40	 add	 esi, 64			; 00000040H
  001ff	6a 10		 push	 16			; 00000010H
  00201	59		 pop	 ecx
  00202	8d 7d b0	 lea	 edi, DWORD PTR _m4Frustum$[ebp]
  00205	f3 a5		 rep movsd

; 585  : 	
; 586  : 	if (isFogEnable)

  00207	0f b6 45 1c	 movzx	 eax, BYTE PTR _isFogEnable$[ebp]
  0020b	85 c0		 test	 eax, eax
  0020d	0f 84 f5 02 00
	00		 je	 $LN12@SoftwareTr

; 587  : 	{
; 588  : 		float fFogCur;
; 589  : 		float fFogFar=rkTPRS.m_fFogFarTransZ;

  00213	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00216	f3 0f 10 80 90
	01 00 00	 movss	 xmm0, DWORD PTR [eax+400]
  0021e	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _fFogFar$3[ebp], xmm0

; 590  : 		float fFogLenInv=rkTPRS.m_fFogLenInv;

  00226	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00229	f3 0f 10 80 94
	01 00 00	 movss	 xmm0, DWORD PTR [eax+404]
  00231	f3 0f 11 85 cc
	fe ff ff	 movss	 DWORD PTR _fFogLenInv$2[ebp], xmm0

; 591  : 
; 592  : 		float fLocalX;
; 593  : 		float fLocalY;
; 594  : 
; 595  : 		SoftwareTransformPatch_STLVertex kWorkVertex; 
; 596  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  00239	83 a5 64 ff ff
	ff 00		 and	 DWORD PTR _uIndex$12[ebp], 0
  00240	eb 0d		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  00242	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _uIndex$12[ebp]
  00248	40		 inc	 eax
  00249	89 85 64 ff ff
	ff		 mov	 DWORD PTR _uIndex$12[ebp], eax
$LN4@SoftwareTr:
  0024f	81 bd 64 ff ff
	ff 21 01 00 00	 cmp	 DWORD PTR _uIndex$12[ebp], 289 ; 00000121H
  00259	0f 84 a4 02 00
	00		 je	 $LN3@SoftwareTr

; 597  : 		{		
; 598  : 			pkSrcPosition=&akSrcVertex[uIndex].kPosition;

  0025f	6b 85 64 ff ff
	ff 1c		 imul	 eax, DWORD PTR _uIndex$12[ebp], 28
  00266	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _akSrcVertex$[ebp]
  0026c	89 85 6c ff ff
	ff		 mov	 DWORD PTR _pkSrcPosition$[ebp], eax

; 599  : 			D3DXVec3Transform(&kWorkVertex.kPosition, pkSrcPosition, &m4Frustum);

  00272	8d 45 b0	 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  00275	50		 push	 eax
  00276	ff b5 6c ff ff
	ff		 push	 DWORD PTR _pkSrcPosition$[ebp]
  0027c	8d 85 d4 fe ff
	ff		 lea	 eax, DWORD PTR _kWorkVertex$4[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 600  : 			fLocalX=pkSrcPosition->x+fTerrainBaseX;

  00288	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  0028e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00292	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _fTerrainBaseX$[ebp]
  0029a	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fLocalX$8[ebp], xmm0

; 601  : 			fLocalY=pkSrcPosition->y+fTerrainBaseY;	

  002a2	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  002a8	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002ad	f3 0f 58 85 3c
	ff ff ff	 addss	 xmm0, DWORD PTR _fTerrainBaseY$[ebp]
  002b5	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fLocalY$7[ebp], xmm0

; 602  : 			kWorkVertex.kPosition.w=1.0f/kWorkVertex.kPosition.w;

  002bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002c5	f3 0f 5e 85 e0
	fe ff ff	 divss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+12]
  002cd	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+12], xmm0

; 603  : 			kWorkVertex.kPosition.x*=kWorkVertex.kPosition.w;

  002d5	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$4[ebp]
  002dd	f3 0f 59 85 e0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+12]
  002e5	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp], xmm0

; 604  : 			kWorkVertex.kPosition.y*=kWorkVertex.kPosition.w;

  002ed	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+4]
  002f5	f3 0f 59 85 e0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+12]
  002fd	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+4], xmm0

; 605  : 			kWorkVertex.kPosition.z*=kWorkVertex.kPosition.w;

  00305	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+8]
  0030d	f3 0f 59 85 e0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+12]
  00315	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+8], xmm0

; 606  : 			kWorkVertex.kPosition.x=(kWorkVertex.kPosition.x+1.0f)*fScreenHalfWidth;

  0031d	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$4[ebp]
  00325	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  0032d	f3 0f 59 85 38
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfWidth$[ebp]
  00335	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp], xmm0

; 607  : 			kWorkVertex.kPosition.y=(kWorkVertex.kPosition.y-1.0f)*fScreenHalfHeight;			

  0033d	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+4]
  00345	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0034d	f3 0f 59 85 34
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfHeight$[ebp]
  00355	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+4], xmm0

; 608  : 			kWorkVertex.dwDiffuse=akSrcVertex[uIndex].dwDiffuse;

  0035d	6b 85 64 ff ff
	ff 1c		 imul	 eax, DWORD PTR _uIndex$12[ebp], 28
  00364	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _akSrcVertex$[ebp]
  0036a	8b 44 01 18	 mov	 eax, DWORD PTR [ecx+eax+24]
  0036e	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+16], eax

; 609  : 			kWorkVertex.kTexTile.x=pkSrcPosition->x*fTilePatternX;

  00374	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  0037a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0037e	f3 0f 59 85 10
	ff ff ff	 mulss	 xmm0, DWORD PTR _fTilePatternX$[ebp]
  00386	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+24], xmm0

; 610  : 			kWorkVertex.kTexTile.y=pkSrcPosition->y*fTilePatternY;	

  0038e	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  00394	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00399	f3 0f 59 85 14
	ff ff ff	 mulss	 xmm0, DWORD PTR _fTilePatternY$[ebp]
  003a1	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+28], xmm0

; 611  : 			kWorkVertex.kTexAlpha.x=fLocalX*fAlphaPatternX+fAlphaBiasX;

  003a9	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalX$8[ebp]
  003b1	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternX$[ebp]
  003b9	f3 0f 58 85 30
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasX$[ebp]
  003c1	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+32], xmm0

; 612  : 			kWorkVertex.kTexAlpha.y=fLocalY*fAlphaPatternY+fAlphaBiasY;

  003c9	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalY$7[ebp]
  003d1	f3 0f 59 85 2c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternY$[ebp]
  003d9	f3 0f 58 85 28
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasY$[ebp]
  003e1	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+36], xmm0

; 613  : 			kWorkVertex.kTexStaticShadow.x=fLocalX*fShadowPatternX;

  003e9	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalX$8[ebp]
  003f1	f3 0f 59 85 20
	ff ff ff	 mulss	 xmm0, DWORD PTR _fShadowPatternX$[ebp]
  003f9	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+40], xmm0

; 614  : 			kWorkVertex.kTexStaticShadow.y=fLocalY*fShadowPatternY;

  00401	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalY$7[ebp]
  00409	f3 0f 59 85 18
	ff ff ff	 mulss	 xmm0, DWORD PTR _fShadowPatternY$[ebp]
  00411	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+44], xmm0

; 615  : 			kWorkVertex.kTexDynamicShadow.x=0.0f;

  00419	0f 57 c0	 xorps	 xmm0, xmm0
  0041c	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+48], xmm0

; 616  : 			kWorkVertex.kTexDynamicShadow.y=0.0f;

  00424	0f 57 c0	 xorps	 xmm0, xmm0
  00427	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _kWorkVertex$4[ebp+52], xmm0

; 617  : 
; 618  : 			fFogCur=(fFogFar-kWorkVertex.kPosition.z)*fFogLenInv;

  0042f	f3 0f 10 85 d0
	fe ff ff	 movss	 xmm0, DWORD PTR _fFogFar$3[ebp]
  00437	f3 0f 5c 85 dc
	fe ff ff	 subss	 xmm0, DWORD PTR _kWorkVertex$4[ebp+8]
  0043f	f3 0f 59 85 cc
	fe ff ff	 mulss	 xmm0, DWORD PTR _fFogLenInv$2[ebp]
  00447	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fFogCur$9[ebp], xmm0

; 619  : 			if (fFogCur<0.0f)

  0044f	0f 57 c0	 xorps	 xmm0, xmm0
  00452	0f 2f 85 54 ff
	ff ff		 comiss	 xmm0, DWORD PTR _fFogCur$9[ebp]
  00459	76 1f		 jbe	 SHORT $LN14@SoftwareTr

; 620  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=0x0000000|(kWorkVertex.dwDiffuse&0xffffff);

  0045b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _kWorkVertex$4[ebp+16]
  00461	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00466	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+16], eax
  0046c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _kWorkVertex$4[ebp+16]
  00472	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+20], eax
  00478	eb 6f		 jmp	 SHORT $LN17@SoftwareTr
$LN14@SoftwareTr:

; 621  : 			else if (fFogCur>1.0f)

  0047a	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fFogCur$9[ebp]
  00482	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00489	76 24		 jbe	 SHORT $LN16@SoftwareTr

; 622  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=0xFF000000|(kWorkVertex.dwDiffuse&0xffffff);

  0048b	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _kWorkVertex$4[ebp+16]
  00491	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00496	0d 00 00 00 ff	 or	 eax, -16777216		; ff000000H
  0049b	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+16], eax
  004a1	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _kWorkVertex$4[ebp+16]
  004a7	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+20], eax
  004ad	eb 3a		 jmp	 SHORT $LN17@SoftwareTr
$LN16@SoftwareTr:

; 623  : 			else
; 624  : 				kWorkVertex.dwFog=kWorkVertex.dwDiffuse=BYTE(255.0f*fFogCur)<<24|(kWorkVertex.dwDiffuse&0xffffff);

  004af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437f0000
  004b7	f3 0f 59 85 54
	ff ff ff	 mulss	 xmm0, DWORD PTR _fFogCur$9[ebp]
  004bf	f3 0f 2c c0	 cvttss2si eax, xmm0
  004c3	0f b6 c0	 movzx	 eax, al
  004c6	c1 e0 18	 shl	 eax, 24			; 00000018H
  004c9	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _kWorkVertex$4[ebp+16]
  004cf	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  004d5	0b c1		 or	 eax, ecx
  004d7	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+16], eax
  004dd	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _kWorkVertex$4[ebp+16]
  004e3	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$4[ebp+20], eax
$LN17@SoftwareTr:

; 625  : 
; 626  : 			*(akTransVertex+uIndex)=kWorkVertex;

  004e9	6b bd 64 ff ff
	ff 38		 imul	 edi, DWORD PTR _uIndex$12[ebp], 56
  004f0	03 7d 0c	 add	 edi, DWORD PTR _akTransVertex$[ebp]
  004f3	6a 0e		 push	 14			; 0000000eH
  004f5	59		 pop	 ecx
  004f6	8d b5 d4 fe ff
	ff		 lea	 esi, DWORD PTR _kWorkVertex$4[ebp]
  004fc	f3 a5		 rep movsd

; 627  : 		}

  004fe	e9 3f fd ff ff	 jmp	 $LN2@SoftwareTr
$LN3@SoftwareTr:

; 628  : 	}

  00503	e9 17 02 00 00	 jmp	 $LN6@SoftwareTr
$LN12@SoftwareTr:

; 629  : 	else
; 630  : 	{
; 631  : 		float fLocalX;
; 632  : 		float fLocalY;
; 633  : 		
; 634  : 		SoftwareTransformPatch_STLVertex kWorkVertex; 
; 635  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  00508	83 a5 60 ff ff
	ff 00		 and	 DWORD PTR _uIndex$11[ebp], 0
  0050f	eb 0d		 jmp	 SHORT $LN7@SoftwareTr
$LN5@SoftwareTr:
  00511	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _uIndex$11[ebp]
  00517	40		 inc	 eax
  00518	89 85 60 ff ff
	ff		 mov	 DWORD PTR _uIndex$11[ebp], eax
$LN7@SoftwareTr:
  0051e	81 bd 60 ff ff
	ff 21 01 00 00	 cmp	 DWORD PTR _uIndex$11[ebp], 289 ; 00000121H
  00528	0f 84 f1 01 00
	00		 je	 $LN6@SoftwareTr

; 636  : 		{		
; 637  : 			pkSrcPosition=&akSrcVertex[uIndex].kPosition;

  0052e	6b 85 60 ff ff
	ff 1c		 imul	 eax, DWORD PTR _uIndex$11[ebp], 28
  00535	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _akSrcVertex$[ebp]
  0053b	89 85 6c ff ff
	ff		 mov	 DWORD PTR _pkSrcPosition$[ebp], eax

; 638  : 			D3DXVec3Transform(&kWorkVertex.kPosition, pkSrcPosition, &m4Frustum);

  00541	8d 45 b0	 lea	 eax, DWORD PTR _m4Frustum$[ebp]
  00544	50		 push	 eax
  00545	ff b5 6c ff ff
	ff		 push	 DWORD PTR _pkSrcPosition$[ebp]
  0054b	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR _kWorkVertex$1[ebp]
  00551	50		 push	 eax
  00552	e8 00 00 00 00	 call	 _D3DXVec3Transform@12

; 639  : 			fLocalX=pkSrcPosition->x+fTerrainBaseX;

  00557	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  0055d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00561	f3 0f 58 85 40
	ff ff ff	 addss	 xmm0, DWORD PTR _fTerrainBaseX$[ebp]
  00569	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fLocalX$6[ebp], xmm0

; 640  : 			fLocalY=pkSrcPosition->y+fTerrainBaseY;	

  00571	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  00577	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0057c	f3 0f 58 85 3c
	ff ff ff	 addss	 xmm0, DWORD PTR _fTerrainBaseY$[ebp]
  00584	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fLocalY$5[ebp], xmm0

; 641  : 			kWorkVertex.kPosition.w=1.0f/kWorkVertex.kPosition.w;

  0058c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00594	f3 0f 5e 85 a0
	fe ff ff	 divss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+12]
  0059c	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+12], xmm0

; 642  : 			kWorkVertex.kPosition.x*=kWorkVertex.kPosition.w;

  005a4	f3 0f 10 85 94
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$1[ebp]
  005ac	f3 0f 59 85 a0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+12]
  005b4	f3 0f 11 85 94
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp], xmm0

; 643  : 			kWorkVertex.kPosition.y*=kWorkVertex.kPosition.w;

  005bc	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+4]
  005c4	f3 0f 59 85 a0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+12]
  005cc	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+4], xmm0

; 644  : 			kWorkVertex.kPosition.z*=kWorkVertex.kPosition.w;

  005d4	f3 0f 10 85 9c
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+8]
  005dc	f3 0f 59 85 a0
	fe ff ff	 mulss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+12]
  005e4	f3 0f 11 85 9c
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+8], xmm0

; 645  : 			kWorkVertex.kPosition.x=(kWorkVertex.kPosition.x+1.0f)*fScreenHalfWidth;

  005ec	f3 0f 10 85 94
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$1[ebp]
  005f4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  005fc	f3 0f 59 85 38
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfWidth$[ebp]
  00604	f3 0f 11 85 94
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp], xmm0

; 646  : 			kWorkVertex.kPosition.y=(kWorkVertex.kPosition.y-1.0f)*fScreenHalfHeight;

  0060c	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _kWorkVertex$1[ebp+4]
  00614	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  0061c	f3 0f 59 85 34
	ff ff ff	 mulss	 xmm0, DWORD PTR _fScreenHalfHeight$[ebp]
  00624	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+4], xmm0

; 647  : 			kWorkVertex.dwDiffuse=akSrcVertex[uIndex].dwDiffuse;

  0062c	6b 85 60 ff ff
	ff 1c		 imul	 eax, DWORD PTR _uIndex$11[ebp], 28
  00633	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR _akSrcVertex$[ebp]
  00639	8b 44 01 18	 mov	 eax, DWORD PTR [ecx+eax+24]
  0063d	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _kWorkVertex$1[ebp+16], eax

; 648  : 			kWorkVertex.dwFog=0xffffffff;

  00643	83 8d a8 fe ff
	ff ff		 or	 DWORD PTR _kWorkVertex$1[ebp+20], -1

; 649  : 			kWorkVertex.kTexTile.x=pkSrcPosition->x*fTilePatternX;

  0064a	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  00650	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00654	f3 0f 59 85 10
	ff ff ff	 mulss	 xmm0, DWORD PTR _fTilePatternX$[ebp]
  0065c	f3 0f 11 85 ac
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+24], xmm0

; 650  : 			kWorkVertex.kTexTile.y=pkSrcPosition->y*fTilePatternY;	

  00664	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR _pkSrcPosition$[ebp]
  0066a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0066f	f3 0f 59 85 14
	ff ff ff	 mulss	 xmm0, DWORD PTR _fTilePatternY$[ebp]
  00677	f3 0f 11 85 b0
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+28], xmm0

; 651  : 			kWorkVertex.kTexAlpha.x=fLocalX*fAlphaPatternX+fAlphaBiasX;

  0067f	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalX$6[ebp]
  00687	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternX$[ebp]
  0068f	f3 0f 58 85 30
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasX$[ebp]
  00697	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+32], xmm0

; 652  : 			kWorkVertex.kTexAlpha.y=fLocalY*fAlphaPatternY+fAlphaBiasY;

  0069f	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalY$5[ebp]
  006a7	f3 0f 59 85 2c
	ff ff ff	 mulss	 xmm0, DWORD PTR _fAlphaPatternY$[ebp]
  006af	f3 0f 58 85 28
	ff ff ff	 addss	 xmm0, DWORD PTR _fAlphaBiasY$[ebp]
  006b7	f3 0f 11 85 b8
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+36], xmm0

; 653  : 			kWorkVertex.kTexStaticShadow.x=fLocalX*fShadowPatternX;

  006bf	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalX$6[ebp]
  006c7	f3 0f 59 85 20
	ff ff ff	 mulss	 xmm0, DWORD PTR _fShadowPatternX$[ebp]
  006cf	f3 0f 11 85 bc
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+40], xmm0

; 654  : 			kWorkVertex.kTexStaticShadow.y=fLocalY*fShadowPatternY;

  006d7	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fLocalY$5[ebp]
  006df	f3 0f 59 85 18
	ff ff ff	 mulss	 xmm0, DWORD PTR _fShadowPatternY$[ebp]
  006e7	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+44], xmm0

; 655  : 			kWorkVertex.kTexDynamicShadow.x=0.0f;

  006ef	0f 57 c0	 xorps	 xmm0, xmm0
  006f2	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+48], xmm0

; 656  : 			kWorkVertex.kTexDynamicShadow.y=0.0f;

  006fa	0f 57 c0	 xorps	 xmm0, xmm0
  006fd	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _kWorkVertex$1[ebp+52], xmm0

; 657  : 
; 658  : 			*(akTransVertex+uIndex)=kWorkVertex;

  00705	6b bd 60 ff ff
	ff 38		 imul	 edi, DWORD PTR _uIndex$11[ebp], 56
  0070c	03 7d 0c	 add	 edi, DWORD PTR _akTransVertex$[ebp]
  0070f	6a 0e		 push	 14			; 0000000eH
  00711	59		 pop	 ecx
  00712	8d b5 94 fe ff
	ff		 lea	 esi, DWORD PTR _kWorkVertex$1[ebp]
  00718	f3 a5		 rep movsd

; 659  : 		}		

  0071a	e9 f2 fd ff ff	 jmp	 $LN5@SoftwareTr
$LN6@SoftwareTr:

; 660  : 	}
; 661  : 
; 662  : 	if (isDynamicShadow)

  0071f	0f b6 45 20	 movzx	 eax, BYTE PTR _isDynamicShadow$[ebp]
  00723	85 c0		 test	 eax, eax
  00725	0f 84 80 00 00
	00		 je	 $LN9@SoftwareTr

; 663  : 	{
; 664  : 		D3DXMATRIX m4DynamicShadow=rkTPRS.m_m4DynamicShadow;

  0072b	8b 75 08	 mov	 esi, DWORD PTR _rkTPRS$[ebp]
  0072e	81 c6 80 00 00
	00		 add	 esi, 128		; 00000080H
  00734	6a 10		 push	 16			; 00000010H
  00736	59		 pop	 ecx
  00737	8d bd 70 ff ff
	ff		 lea	 edi, DWORD PTR _m4DynamicShadow$13[ebp]
  0073d	f3 a5		 rep movsd

; 665  : 
; 666  : 		D3DXVECTOR3 v3Shadow;
; 667  : 		for (UINT uIndex=0; uIndex!=CTerrainPatch::TERRAIN_VERTEX_COUNT; ++uIndex)

  0073f	83 a5 58 ff ff
	ff 00		 and	 DWORD PTR _uIndex$10[ebp], 0
  00746	eb 0d		 jmp	 SHORT $LN10@SoftwareTr
$LN8@SoftwareTr:
  00748	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR _uIndex$10[ebp]
  0074e	40		 inc	 eax
  0074f	89 85 58 ff ff
	ff		 mov	 DWORD PTR _uIndex$10[ebp], eax
$LN10@SoftwareTr:
  00755	81 bd 58 ff ff
	ff 21 01 00 00	 cmp	 DWORD PTR _uIndex$10[ebp], 289 ; 00000121H
  0075f	74 4a		 je	 SHORT $LN9@SoftwareTr

; 668  : 		{
; 669  : 			D3DXVec3TransformCoord(&v3Shadow, &akSrcVertex[uIndex].kPosition, &m4DynamicShadow);

  00761	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR _m4DynamicShadow$13[ebp]
  00767	50		 push	 eax
  00768	6b 85 58 ff ff
	ff 1c		 imul	 eax, DWORD PTR _uIndex$10[ebp], 28
  0076f	03 85 5c ff ff
	ff		 add	 eax, DWORD PTR _akSrcVertex$[ebp]
  00775	50		 push	 eax
  00776	8d 45 f0	 lea	 eax, DWORD PTR _v3Shadow$14[ebp]
  00779	50		 push	 eax
  0077a	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 670  : 			akTransVertex[uIndex].kTexDynamicShadow.x=v3Shadow.x;

  0077f	6b 85 58 ff ff
	ff 38		 imul	 eax, DWORD PTR _uIndex$10[ebp], 56
  00786	8b 4d 0c	 mov	 ecx, DWORD PTR _akTransVertex$[ebp]
  00789	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Shadow$14[ebp]
  0078e	f3 0f 11 44 01
	30		 movss	 DWORD PTR [ecx+eax+48], xmm0

; 671  : 			akTransVertex[uIndex].kTexDynamicShadow.y=v3Shadow.y;

  00794	6b 85 58 ff ff
	ff 38		 imul	 eax, DWORD PTR _uIndex$10[ebp], 56
  0079b	8b 4d 0c	 mov	 ecx, DWORD PTR _akTransVertex$[ebp]
  0079e	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Shadow$14[ebp+4]
  007a3	f3 0f 11 44 01
	34		 movss	 DWORD PTR [ecx+eax+52], xmm0

; 672  : 		}

  007a9	eb 9d		 jmp	 SHORT $LN8@SoftwareTr
$LN9@SoftwareTr:

; 673  : 	}
; 674  : 
; 675  : 	return true;

  007ab	b0 01		 mov	 al, 1
$LN1@SoftwareTr:

; 676  : }

  007ad	5f		 pop	 edi
  007ae	5e		 pop	 esi
  007af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007b2	33 cd		 xor	 ecx, ebp
  007b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007b9	c9		 leave
  007ba	c2 1c 00	 ret	 28			; 0000001cH
?__SoftwareTransformPatch_SetTransform@CMapOutdoor@@IAE_NAAUSoftwareTransformPatch_SRenderState@1@PAUSoftwareTransformPatch_STLVertex@1@AAVCTerrainPatchProxy@@II_N3@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_SetTransform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z
_TEXT	SEGMENT
tv465 = -416						; size = 8
tv455 = -408						; size = 8
_dwA$1 = -400						; size = 4
_dwG$2 = -396						; size = 4
_dwR$3 = -392						; size = 4
_fFogLenInv$ = -388					; size = 4
_fz$ = -384						; size = 4
_fz$ = -380						; size = 4
_uScreenHeight$ = -376					; size = 4
_uScreenWidth$ = -372					; size = 4
_dwB$4 = -368						; size = 4
tv301 = -364						; size = 4
tv451 = -360						; size = 4
tv461 = -356						; size = 4
_fFogNear$ = -352					; size = 4
_fFogFar$ = -348					; size = 4
tv300 = -344						; size = 4
tv290 = -340						; size = 4
tv289 = -336						; size = 4
tv279 = -332						; size = 4
tv278 = -328						; size = 4
tv268 = -324						; size = 4
tv267 = -320						; size = 4
_this$ = -316						; size = 4
_this$ = -312						; size = 4
_m4View$ = -308						; size = 64
_matT$5 = -244						; size = 64
$T6 = -180						; size = 64
_m4Proj$ = -116						; size = 64
_kFogNearVector$ = -52					; size = 12
_kFogFarVector$ = -40					; size = 12
$T7 = -28						; size = 12
$T8 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_rkTPRS$ = 8						; size = 4
?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 01 00
	00		 sub	 esp, 416		; 000001a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 	memset(&rkTPRS, 0, sizeof(rkTPRS));

  0001b	68 98 01 00 00	 push	 408			; 00000198H
  00020	6a 00		 push	 0
  00022	ff 75 08	 push	 DWORD PTR _rkTPRS$[ebp]
  00025	e8 00 00 00 00	 call	 _memset
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 504  : 
; 505  : 	if (mc_pEnvironmentData)

  0002d	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00037	0f 84 47 02 00
	00		 je	 $LN2@SoftwareTr

; 507  : 		rkTPRS.m_dwFogColor = mc_pEnvironmentData->FogColor;

  0003d	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00046	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  0004b	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00051	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00057	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0005b	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00062	72 0c		 jb	 SHORT $LN9@SoftwareTr
  00064	c7 85 bc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv268[ebp], 255 ; 000000ffH
  0006e	eb 48		 jmp	 SHORT $LN10@SoftwareTr
$LN9@SoftwareTr:
  00070	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00076	0f 57 c0	 xorps	 xmm0, xmm0
  00079	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0007c	72 09		 jb	 SHORT $LN7@SoftwareTr
  0007e	83 a5 c0 fe ff
	ff 00		 and	 DWORD PTR tv267[ebp], 0
  00085	eb 25		 jmp	 SHORT $LN8@SoftwareTr
$LN7@SoftwareTr:
  00087	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0008d	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00091	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00099	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000a1	e8 00 00 00 00	 call	 __ftoui3
  000a6	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv267[ebp], eax
$LN8@SoftwareTr:
  000ac	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv267[ebp]
  000b2	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv268[ebp], eax
$LN10@SoftwareTr:
  000b8	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv268[ebp]
  000be	89 85 78 fe ff
	ff		 mov	 DWORD PTR _dwR$3[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  000c4	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000ca	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000cf	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000d6	72 0c		 jb	 SHORT $LN13@SoftwareTr
  000d8	c7 85 b4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv279[ebp], 255 ; 000000ffH
  000e2	eb 4a		 jmp	 SHORT $LN14@SoftwareTr
$LN13@SoftwareTr:
  000e4	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000ea	0f 57 c0	 xorps	 xmm0, xmm0
  000ed	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  000f1	72 09		 jb	 SHORT $LN11@SoftwareTr
  000f3	83 a5 b8 fe ff
	ff 00		 and	 DWORD PTR tv278[ebp], 0
  000fa	eb 26		 jmp	 SHORT $LN12@SoftwareTr
$LN11@SoftwareTr:
  000fc	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00102	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00107	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0010f	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00117	e8 00 00 00 00	 call	 __ftoui3
  0011c	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv278[ebp], eax
$LN12@SoftwareTr:
  00122	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv278[ebp]
  00128	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv279[ebp], eax
$LN14@SoftwareTr:
  0012e	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR tv279[ebp]
  00134	89 85 74 fe ff
	ff		 mov	 DWORD PTR _dwG$2[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0013a	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00140	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00145	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0014c	72 0c		 jb	 SHORT $LN17@SoftwareTr
  0014e	c7 85 ac fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv290[ebp], 255 ; 000000ffH
  00158	eb 4a		 jmp	 SHORT $LN18@SoftwareTr
$LN17@SoftwareTr:
  0015a	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00160	0f 57 c0	 xorps	 xmm0, xmm0
  00163	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00167	72 09		 jb	 SHORT $LN15@SoftwareTr
  00169	83 a5 b0 fe ff
	ff 00		 and	 DWORD PTR tv289[ebp], 0
  00170	eb 26		 jmp	 SHORT $LN16@SoftwareTr
$LN15@SoftwareTr:
  00172	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00178	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0017d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00185	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0018d	e8 00 00 00 00	 call	 __ftoui3
  00192	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
$LN16@SoftwareTr:
  00198	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv289[ebp]
  0019e	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
$LN18@SoftwareTr:
  001a4	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv290[ebp]
  001aa	89 85 90 fe ff
	ff		 mov	 DWORD PTR _dwB$4[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  001b0	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001b6	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001bb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001c2	72 0c		 jb	 SHORT $LN21@SoftwareTr
  001c4	c7 85 94 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv301[ebp], 255 ; 000000ffH
  001ce	eb 4a		 jmp	 SHORT $LN22@SoftwareTr
$LN21@SoftwareTr:
  001d0	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001d6	0f 57 c0	 xorps	 xmm0, xmm0
  001d9	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  001dd	72 09		 jb	 SHORT $LN19@SoftwareTr
  001df	83 a5 a8 fe ff
	ff 00		 and	 DWORD PTR tv300[ebp], 0
  001e6	eb 26		 jmp	 SHORT $LN20@SoftwareTr
$LN19@SoftwareTr:
  001e8	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ee	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001f3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001fb	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00203	e8 00 00 00 00	 call	 __ftoui3
  00208	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv300[ebp], eax
$LN20@SoftwareTr:
  0020e	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv300[ebp]
  00214	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv301[ebp], eax
$LN22@SoftwareTr:
  0021a	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv301[ebp]
  00220	89 85 70 fe ff
	ff		 mov	 DWORD PTR _dwA$1[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00226	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$2[ebp]
  0022c	c1 e0 08	 shl	 eax, 8
  0022f	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$3[ebp]
  00235	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00238	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$1[ebp]
  0023e	c1 e2 18	 shl	 edx, 24			; 00000018H
  00241	0b d1		 or	 edx, ecx
  00243	0b d0		 or	 edx, eax
  00245	0b 95 90 fe ff
	ff		 or	 edx, DWORD PTR _dwB$4[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 507  : 		rkTPRS.m_dwFogColor = mc_pEnvironmentData->FogColor;

  0024b	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0024e	89 90 78 01 00
	00		 mov	 DWORD PTR [eax+376], edx

; 508  : 		rkTPRS.m_fFogNearDistance = mc_pEnvironmentData->GetFogNearDistance();

  00254	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0025a	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0025d	e8 00 00 00 00	 call	 ?GetFogNearDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogNearDistance
  00262	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00265	d9 98 84 01 00
	00		 fstp	 DWORD PTR [eax+388]

; 509  : 		rkTPRS.m_fFogFarDistance = mc_pEnvironmentData->GetFogFarDistance();

  0026b	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00271	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00274	e8 00 00 00 00	 call	 ?GetFogFarDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogFarDistance
  00279	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0027c	d9 98 88 01 00
	00		 fstp	 DWORD PTR [eax+392]

; 510  : 	}

  00282	eb 30		 jmp	 SHORT $LN3@SoftwareTr
$LN2@SoftwareTr:

; 511  : 	else
; 512  : 	{
; 513  : 		rkTPRS.m_dwFogColor = 0xffffffff;

  00284	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00287	83 88 78 01 00
	00 ff		 or	 DWORD PTR [eax+376], -1

; 514  : 		rkTPRS.m_fFogNearDistance = 5000.0f;

  0028e	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00291	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  00299	f3 0f 11 80 84
	01 00 00	 movss	 DWORD PTR [eax+388], xmm0

; 515  : 		rkTPRS.m_fFogFarDistance = 10000.0f;

  002a1	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  002a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  002ac	f3 0f 11 80 88
	01 00 00	 movss	 DWORD PTR [eax+392], xmm0
$LN3@SoftwareTr:

; 516  : 	}
; 517  : 
; 518  : 	UINT uScreenWidth;
; 519  : 	UINT uScreenHeight;
; 520  : 	CScreen::GetBackBufferSize(&uScreenWidth, &uScreenHeight);

  002b4	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR _uScreenHeight$[ebp]
  002ba	50		 push	 eax
  002bb	8d 85 8c fe ff
	ff		 lea	 eax, DWORD PTR _uScreenWidth$[ebp]
  002c1	50		 push	 eax
  002c2	e8 00 00 00 00	 call	 ?GetBackBufferSize@CGraphicBase@@SAXPAI0@Z ; CGraphicBase::GetBackBufferSize
  002c7	59		 pop	 ecx
  002c8	59		 pop	 ecx

; 521  : 
; 522  : 	rkTPRS.m_fScreenHalfWidth = +float(uScreenWidth) / 2.0f;

  002c9	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _uScreenWidth$[ebp]
  002cf	89 85 98 fe ff
	ff		 mov	 DWORD PTR tv451[ebp], eax
  002d5	f2 0f 2a 85 98
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv451[ebp]
  002dd	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  002e3	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  002e6	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  002ef	f2 0f 11 85 68
	fe ff ff	 movsd	 QWORD PTR tv455[ebp], xmm0
  002f7	f2 0f 5a 85 68
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv455[ebp]
  002ff	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00307	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0030a	f3 0f 11 80 7c
	01 00 00	 movss	 DWORD PTR [eax+380], xmm0

; 523  : 	rkTPRS.m_fScreenHalfHeight = -float(uScreenHeight) / 2.0f;

  00312	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR _uScreenHeight$[ebp]
  00318	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv461[ebp], eax
  0031e	f2 0f 2a 85 9c
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv461[ebp]
  00326	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv461[ebp]
  0032c	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0032f	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00338	f2 0f 11 85 60
	fe ff ff	 movsd	 QWORD PTR tv465[ebp], xmm0
  00340	f2 0f 5a 85 60
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv465[ebp]
  00348	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0034f	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00357	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0035a	f3 0f 11 80 80
	01 00 00	 movss	 DWORD PTR [eax+384], xmm0

; 524  : 
; 525  : 	STATEMANAGER.GetLight(0, &rkTPRS.m_kLight);

  00362	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00365	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0036a	50		 push	 eax
  0036b	6a 00		 push	 0
  0036d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00373	e8 00 00 00 00	 call	 ?GetLight@CStateManager@@QAEXKPAU_D3DLIGHT8@@@Z ; CStateManager::GetLight

; 526  : 	STATEMANAGER.GetMaterial(&rkTPRS.m_kMtrl);

  00378	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0037b	05 28 01 00 00	 add	 eax, 296		; 00000128H
  00380	50		 push	 eax
  00381	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00387	e8 00 00 00 00	 call	 ?GetMaterial@CStateManager@@QAEXPAU_D3DMATERIAL8@@@Z ; CStateManager::GetMaterial

; 527  : 
; 528  : 	D3DXMATRIX m4View;STATEMANAGER.GetTransform(D3DTS_VIEW, &m4View);

  0038c	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _m4View$[ebp]
  00392	50		 push	 eax
  00393	6a 02		 push	 2
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0039b	e8 00 00 00 00	 call	 ?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z ; CStateManager::GetTransform

; 529  : 	D3DXMATRIX m4Proj;STATEMANAGER.GetTransform(D3DTS_PROJECTION, &m4Proj);

  003a0	8d 45 8c	 lea	 eax, DWORD PTR _m4Proj$[ebp]
  003a3	50		 push	 eax
  003a4	6a 03		 push	 3
  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ac	e8 00 00 00 00	 call	 ?GetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PAU_D3DMATRIX@@@Z ; CStateManager::GetTransform

; 530  : 	
; 531  : 	D3DXMatrixMultiply(&rkTPRS.m_m4Frustum, &m4View, &m4Proj);

  003b1	8d 45 8c	 lea	 eax, DWORD PTR _m4Proj$[ebp]
  003b4	50		 push	 eax
  003b5	8d 85 cc fe ff
	ff		 lea	 eax, DWORD PTR _m4View$[ebp]
  003bb	50		 push	 eax
  003bc	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  003bf	83 c0 40	 add	 eax, 64			; 00000040H
  003c2	50		 push	 eax
  003c3	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 532  : 
; 533  : 	rkTPRS.m_v3Player.x = +m_v3Player.x;

  003c8	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  003cb	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003d1	8b 89 a8 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3752]
  003d7	89 88 6c 01 00
	00		 mov	 DWORD PTR [eax+364], ecx

; 534  : 	rkTPRS.m_v3Player.y = -m_v3Player.y;

  003dd	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003e3	f3 0f 10 80 ac
	0e 00 00	 movss	 xmm0, DWORD PTR [eax+3756]
  003eb	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003f2	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  003f5	f3 0f 11 80 70
	01 00 00	 movss	 DWORD PTR [eax+368], xmm0

; 535  : 	rkTPRS.m_v3Player.z = +m_v3Player.z;

  003fd	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00400	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00406	8b 89 b0 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3760]
  0040c	89 88 74 01 00
	00		 mov	 DWORD PTR [eax+372], ecx

; 536  : 
; 537  : 	rkTPRS.m_m4Proj = m4Proj;

  00412	6a 10		 push	 16			; 00000010H
  00414	59		 pop	 ecx
  00415	8d 75 8c	 lea	 esi, DWORD PTR _m4Proj$[ebp]
  00418	8b 7d 08	 mov	 edi, DWORD PTR _rkTPRS$[ebp]
  0041b	f3 a5		 rep movsd

; 538  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  0041d	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00423	05 88 08 00 00	 add	 eax, 2184		; 00000888H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00428	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 538  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  00429	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0042f	05 c8 08 00 00	 add	 eax, 2248		; 000008c8H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 580  :     D3DXMatrixMultiply(&matT, this, &mat);

  00434	50		 push	 eax
  00435	8d 85 0c ff ff
	ff		 lea	 eax, DWORD PTR _matT$5[ebp]
  0043b	50		 push	 eax
  0043c	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 581  :     return matT;

  00441	6a 10		 push	 16			; 00000010H
  00443	59		 pop	 ecx
  00444	8d b5 0c ff ff
	ff		 lea	 esi, DWORD PTR _matT$5[ebp]
  0044a	8d bd 4c ff ff
	ff		 lea	 edi, DWORD PTR $T6[ebp]
  00450	f3 a5		 rep movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 538  : 	rkTPRS.m_m4DynamicShadow = m_matLightView * m_matDynamicShadowScale;

  00452	8b 7d 08	 mov	 edi, DWORD PTR _rkTPRS$[ebp]
  00455	81 c7 80 00 00
	00		 add	 edi, 128		; 00000080H
  0045b	6a 10		 push	 16			; 00000010H
  0045d	59		 pop	 ecx
  0045e	8d b5 4c ff ff
	ff		 lea	 esi, DWORD PTR $T6[ebp]
  00464	f3 a5		 rep movsd

; 541  : 	D3DXVec3TransformCoord(&kFogNearVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogNearDistance), &rkTPRS.m_m4Proj);

  00466	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00469	f3 0f 10 80 84
	01 00 00	 movss	 xmm0, DWORD PTR [eax+388]
  00471	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00478	f3 0f 11 85 84
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00480	0f 57 c0	 xorps	 xmm0, xmm0
  00483	f3 0f 11 45 f0	 movss	 DWORD PTR $T8[ebp], xmm0

; 181  :     y = fy;

  00488	0f 57 c0	 xorps	 xmm0, xmm0
  0048b	f3 0f 11 45 f4	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 182  :     z = fz;

  00490	f3 0f 10 85 84
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00498	f3 0f 11 45 f8	 movss	 DWORD PTR $T8[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 541  : 	D3DXVec3TransformCoord(&kFogNearVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogNearDistance), &rkTPRS.m_m4Proj);

  0049d	ff 75 08	 push	 DWORD PTR _rkTPRS$[ebp]
  004a0	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  004a3	50		 push	 eax
  004a4	8d 45 cc	 lea	 eax, DWORD PTR _kFogNearVector$[ebp]
  004a7	50		 push	 eax
  004a8	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 544  : 	D3DXVec3TransformCoord(&kFogFarVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogFarDistance), &rkTPRS.m_m4Proj);

  004ad	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  004b0	f3 0f 10 80 88
	01 00 00	 movss	 xmm0, DWORD PTR [eax+392]
  004b8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  004bf	f3 0f 11 85 80
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  004c7	0f 57 c0	 xorps	 xmm0, xmm0
  004ca	f3 0f 11 45 e4	 movss	 DWORD PTR $T7[ebp], xmm0

; 181  :     y = fy;

  004cf	0f 57 c0	 xorps	 xmm0, xmm0
  004d2	f3 0f 11 45 e8	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 182  :     z = fz;

  004d7	f3 0f 10 85 80
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  004df	f3 0f 11 45 ec	 movss	 DWORD PTR $T7[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 544  : 	D3DXVec3TransformCoord(&kFogFarVector, &D3DXVECTOR3(0.0f, 0.0f, -rkTPRS.m_fFogFarDistance), &rkTPRS.m_m4Proj);

  004e4	ff 75 08	 push	 DWORD PTR _rkTPRS$[ebp]
  004e7	8d 45 e4	 lea	 eax, DWORD PTR $T7[ebp]
  004ea	50		 push	 eax
  004eb	8d 45 d8	 lea	 eax, DWORD PTR _kFogFarVector$[ebp]
  004ee	50		 push	 eax
  004ef	e8 00 00 00 00	 call	 _D3DXVec3TransformCoord@12

; 545  : 	
; 546  : 	float fFogNear = kFogNearVector.z;

  004f4	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _kFogNearVector$[ebp+8]
  004f9	f3 0f 11 85 a0
	fe ff ff	 movss	 DWORD PTR _fFogNear$[ebp], xmm0

; 547  : 	float fFogFar = kFogFarVector.z;

  00501	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _kFogFarVector$[ebp+8]
  00506	f3 0f 11 85 a4
	fe ff ff	 movss	 DWORD PTR _fFogFar$[ebp], xmm0

; 548  : 	float fFogLenInv = 1.0f / (fFogFar-fFogNear);

  0050e	f3 0f 10 85 a4
	fe ff ff	 movss	 xmm0, DWORD PTR _fFogFar$[ebp]
  00516	f3 0f 5c 85 a0
	fe ff ff	 subss	 xmm0, DWORD PTR _fFogNear$[ebp]
  0051e	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00526	f3 0f 5e c8	 divss	 xmm1, xmm0
  0052a	f3 0f 11 8d 7c
	fe ff ff	 movss	 DWORD PTR _fFogLenInv$[ebp], xmm1

; 549  : 	
; 550  : 	rkTPRS.m_fFogNearTransZ = fFogNear;

  00532	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00535	f3 0f 10 85 a0
	fe ff ff	 movss	 xmm0, DWORD PTR _fFogNear$[ebp]
  0053d	f3 0f 11 80 8c
	01 00 00	 movss	 DWORD PTR [eax+396], xmm0

; 551  : 	rkTPRS.m_fFogFarTransZ = fFogFar;

  00545	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  00548	f3 0f 10 85 a4
	fe ff ff	 movss	 xmm0, DWORD PTR _fFogFar$[ebp]
  00550	f3 0f 11 80 90
	01 00 00	 movss	 DWORD PTR [eax+400], xmm0

; 552  : 	rkTPRS.m_fFogLenInv = fFogLenInv;

  00558	8b 45 08	 mov	 eax, DWORD PTR _rkTPRS$[ebp]
  0055b	f3 0f 10 85 7c
	fe ff ff	 movss	 xmm0, DWORD PTR _fFogLenInv$[ebp]
  00563	f3 0f 11 80 94
	01 00 00	 movss	 DWORD PTR [eax+404], xmm0

; 553  : 
; 554  : }

  0056b	5f		 pop	 edi
  0056c	5e		 pop	 esi
  0056d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00570	33 cd		 xor	 ecx, ebp
  00572	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00577	c9		 leave
  00578	c2 04 00	 ret	 4
?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_uIndex$1 = -12						; size = 4
_uIndex$2 = -8						; size = 4
_this$ = -4						; size = 4
?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Destroy, COMDAT
; _this$ = ecx

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 786  : 	{
; 787  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00009	83 65 f8 00	 and	 DWORD PTR _uIndex$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 f8	 mov	 DWORD PTR _uIndex$2[ebp], eax
$LN4@SoftwareTr:
  00016	83 7d f8 08	 cmp	 DWORD PTR _uIndex$2[ebp], 8
  0001a	74 31		 je	 SHORT $LN3@SoftwareTr

; 788  : 		{
; 789  : 			if (m_kSTPD.m_pkVBSplat[uIndex])

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 bc 81 c0 09
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+2496], 0
  0002a	74 1f		 je	 SHORT $LN8@SoftwareTr

; 790  : 				m_kSTPD.m_pkVBSplat[uIndex]->Release();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 84 81 c0 09
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2496]
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _uIndex$2[ebp]
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	ff b4 8a c0 09
	00 00		 push	 DWORD PTR [edx+ecx*4+2496]
  00048	ff 50 08	 call	 DWORD PTR [eax+8]
$LN8@SoftwareTr:

; 791  : 		}

  0004b	eb c2		 jmp	 SHORT $LN2@SoftwareTr
$LN3@SoftwareTr:

; 792  : 	}
; 793  : 
; 794  : 	{
; 795  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  0004d	83 65 f4 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  00051	eb 07		 jmp	 SHORT $LN7@SoftwareTr
$LN5@SoftwareTr:
  00053	8b 45 f4	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  00056	40		 inc	 eax
  00057	89 45 f4	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN7@SoftwareTr:
  0005a	83 7d f4 08	 cmp	 DWORD PTR _uIndex$1[ebp], 8
  0005e	74 31		 je	 SHORT $LN6@SoftwareTr

; 796  : 		{
; 797  : 			if (m_kSTPD.m_pkVBNone[uIndex])

  00060	8b 45 f4	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 bc 81 e0 09
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+2528], 0
  0006e	74 1f		 je	 SHORT $LN9@SoftwareTr

; 798  : 				m_kSTPD.m_pkVBNone[uIndex]->Release();

  00070	8b 45 f4	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 84 81 e0 09
	00 00		 mov	 eax, DWORD PTR [ecx+eax*4+2528]
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _uIndex$1[ebp]
  00080	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	ff b4 8a e0 09
	00 00		 push	 DWORD PTR [edx+ecx*4+2528]
  0008c	ff 50 08	 call	 DWORD PTR [eax+8]
$LN9@SoftwareTr:

; 799  : 		}

  0008f	eb c2		 jmp	 SHORT $LN5@SoftwareTr
$LN6@SoftwareTr:

; 800  : 	}
; 801  : 	__SoftwareTransformPatch_Initialize();

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Initialize

; 802  : }

  00099	c9		 leave
  0009a	c3		 ret	 0
?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uIndex$1 = -8						; size = 4
_uIndex$2 = -4						; size = 4
?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Create, COMDAT
; _this$ = ecx

; 749  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 750  : 	{
; 751  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00009	83 65 fc 00	 and	 DWORD PTR _uIndex$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 fc	 mov	 DWORD PTR _uIndex$2[ebp], eax
$LN4@SoftwareTr:
  00016	83 7d fc 08	 cmp	 DWORD PTR _uIndex$2[ebp], 8
  0001a	74 39		 je	 SHORT $LN3@SoftwareTr

; 752  : 		{
; 753  : 			assert(NULL==m_kSTPD.m_pkVBSplat[uIndex]);
; 754  : 			if (FAILED(

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8d 84 81 c0 09
	00 00		 lea	 eax, DWORD PTR [ecx+eax*4+2496]
  00029	50		 push	 eax
  0002a	6a 02		 push	 2
  0002c	68 c4 02 00 00	 push	 708			; 000002c4H
  00031	68 08 02 00 00	 push	 520			; 00000208H
  00036	68 28 2d 00 00	 push	 11560			; 00002d28H
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00048	ff 50 5c	 call	 DWORD PTR [eax+92]
  0004b	85 c0		 test	 eax, eax
  0004d	7d 04		 jge	 SHORT $LN8@SoftwareTr

; 755  : 				ms_lpd3dDevice->CreateVertexBuffer(
; 756  : 					sizeof(SoftwareTransformPatch_SSplatVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT, 
; 757  : 					D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY, 
; 758  : 					D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX2, 
; 759  : 					D3DPOOL_SYSTEMMEM, 
; 760  : 					&m_kSTPD.m_pkVBSplat[uIndex]
; 761  : 				)
; 762  : 			)) return false;

  0004f	32 c0		 xor	 al, al
  00051	eb 4d		 jmp	 SHORT $LN1@SoftwareTr
$LN8@SoftwareTr:

; 763  : 		}

  00053	eb ba		 jmp	 SHORT $LN2@SoftwareTr
$LN3@SoftwareTr:

; 764  : 	}
; 765  : 
; 766  : 	{
; 767  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  00055	83 65 f8 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  00059	eb 07		 jmp	 SHORT $LN7@SoftwareTr
$LN5@SoftwareTr:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0005e	40		 inc	 eax
  0005f	89 45 f8	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN7@SoftwareTr:
  00062	83 7d f8 08	 cmp	 DWORD PTR _uIndex$1[ebp], 8
  00066	74 36		 je	 SHORT $LN6@SoftwareTr

; 768  : 		{
; 769  : 			assert(NULL==m_kSTPD.m_pkVBNone[uIndex]);
; 770  : 			if (FAILED(

  00068	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8d 84 81 e0 09
	00 00		 lea	 eax, DWORD PTR [ecx+eax*4+2528]
  00075	50		 push	 eax
  00076	6a 02		 push	 2
  00078	6a 04		 push	 4
  0007a	68 08 02 00 00	 push	 520			; 00000208H
  0007f	68 10 12 00 00	 push	 4624			; 00001210H
  00084	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00089	8b 00		 mov	 eax, DWORD PTR [eax]
  0008b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lpd3dDevice@CGraphicBase@@1PAUIDirect3DDevice8@@A ; CGraphicBase::ms_lpd3dDevice
  00091	ff 50 5c	 call	 DWORD PTR [eax+92]
  00094	85 c0		 test	 eax, eax
  00096	7d 04		 jge	 SHORT $LN9@SoftwareTr

; 771  : 				ms_lpd3dDevice->CreateVertexBuffer(
; 772  : 					sizeof(SoftwareTransformPatch_STVertex)*CTerrainPatch::TERRAIN_VERTEX_COUNT, 
; 773  : 					D3DUSAGE_DYNAMIC|D3DUSAGE_WRITEONLY, 
; 774  : 					D3DFVF_XYZRHW, 
; 775  : 					D3DPOOL_SYSTEMMEM, 
; 776  : 					&m_kSTPD.m_pkVBNone[uIndex]
; 777  : 				)
; 778  : 			)) return false;

  00098	32 c0		 xor	 al, al
  0009a	eb 04		 jmp	 SHORT $LN1@SoftwareTr
$LN9@SoftwareTr:

; 779  : 		}

  0009c	eb bd		 jmp	 SHORT $LN5@SoftwareTr
$LN6@SoftwareTr:

; 780  : 	}
; 781  : 	return true;

  0009e	b0 01		 mov	 al, 1
$LN1@SoftwareTr:

; 782  : }

  000a0	c9		 leave
  000a1	c3		 ret	 0
?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_uIndex$1 = -8						; size = 4
_uIndex$2 = -4						; size = 4
?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_Initialize, COMDAT
; _this$ = ecx

; 733  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 734  : 	{
; 735  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::SPLAT_VB_NUM; ++uIndex)

  00009	83 65 fc 00	 and	 DWORD PTR _uIndex$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@SoftwareTr
$LN2@SoftwareTr:
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 fc	 mov	 DWORD PTR _uIndex$2[ebp], eax
$LN4@SoftwareTr:
  00016	83 7d fc 08	 cmp	 DWORD PTR _uIndex$2[ebp], 8
  0001a	74 10		 je	 SHORT $LN3@SoftwareTr

; 736  : 			m_kSTPD.m_pkVBSplat[uIndex]=NULL;	

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _uIndex$2[ebp]
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	83 a4 81 c0 09
	00 00 00	 and	 DWORD PTR [ecx+eax*4+2496], 0
  0002a	eb e3		 jmp	 SHORT $LN2@SoftwareTr
$LN3@SoftwareTr:

; 737  : 		m_kSTPD.m_dwSplatPos=0;

  0002c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 a0 00 0a 00
	00 00		 and	 DWORD PTR [eax+2560], 0

; 738  : 	}
; 739  : 
; 740  : 	{
; 741  : 		for (UINT uIndex=0; uIndex!=SoftwareTransformPatch_SData::NONE_VB_NUM; ++uIndex)

  00036	83 65 f8 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  0003a	eb 07		 jmp	 SHORT $LN7@SoftwareTr
$LN5@SoftwareTr:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0003f	40		 inc	 eax
  00040	89 45 f8	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN7@SoftwareTr:
  00043	83 7d f8 08	 cmp	 DWORD PTR _uIndex$1[ebp], 8
  00047	74 10		 je	 SHORT $LN6@SoftwareTr

; 742  : 			m_kSTPD.m_pkVBNone[uIndex]=NULL;	

  00049	8b 45 f8	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	83 a4 81 e0 09
	00 00 00	 and	 DWORD PTR [ecx+eax*4+2528], 0
  00057	eb e3		 jmp	 SHORT $LN5@SoftwareTr
$LN6@SoftwareTr:

; 743  : 		m_kSTPD.m_dwNonePos=0;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 a0 04 0a 00
	00 00		 and	 DWORD PTR [eax+2564], 0

; 744  : 	}
; 745  : }

  00063	c9		 leave
  00064	c3		 ret	 0
?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
_this$ = -8						; size = 4
__My_data$8 = -4					; size = 4
_dwFogEnable$ = 8					; size = 4
?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z PROC ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState, COMDAT
; _this$ = ecx

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 471  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  00009	6a 01		 push	 1
  0000b	68 89 00 00 00	 push	 137			; 00000089H
  00010	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00016	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 472  : 
; 473  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0001b	6a 02		 push	 2
  0001d	6a 02		 push	 2
  0001f	6a 00		 push	 0
  00021	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00027	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 474  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  0002c	6a 01		 push	 1
  0002e	6a 03		 push	 3
  00030	6a 00		 push	 0
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00038	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 475  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  0003d	6a 04		 push	 4
  0003f	6a 01		 push	 1
  00041	6a 00		 push	 0
  00043	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00049	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 476  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0004e	6a 02		 push	 2
  00050	6a 05		 push	 5
  00052	6a 00		 push	 0
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0005a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 477  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0005f	6a 02		 push	 2
  00061	6a 04		 push	 4
  00063	6a 00		 push	 0
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0006b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 478  : 
; 479  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00070	6a 01		 push	 1
  00072	6a 02		 push	 2
  00074	6a 01		 push	 1
  00076	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 480  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00081	6a 02		 push	 2
  00083	6a 01		 push	 1
  00085	6a 01		 push	 1
  00087	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 481  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00092	6a 02		 push	 2
  00094	6a 05		 push	 5
  00096	6a 01		 push	 1
  00098	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 482  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  000a3	6a 02		 push	 2
  000a5	6a 04		 push	 4
  000a7	6a 01		 push	 1
  000a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000af	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 483  : 
; 484  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  000b4	ff 75 08	 push	 DWORD PTR _dwFogEnable$[ebp]
  000b7	6a 1c		 push	 28			; 0000001cH
  000b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000bf	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  000cc	89 45 fc	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000cf	8b 45 fc	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000d2	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000d5	8b 45 fc	 mov	 eax, DWORD PTR __My_data$8[ebp]
  000d8	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000db	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  000de	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  000e1	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000e4	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  000e7	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  000ea	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  000f2	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000f5	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  000f8	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  000fb	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  000fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00100	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00103	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00106	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00109	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0010c	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 486  : 	std::sort(m_RenderedTextureNumVector.begin(),m_RenderedTextureNumVector.end());

  0010f	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00112	ff 30		 push	 DWORD PTR [eax]
  00114	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00117	ff 30		 push	 DWORD PTR [eax]
  00119	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
  0011e	59		 pop	 ecx
  0011f	59		 pop	 ecx

; 487  : 
; 488  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  00120	6a 3c		 push	 60			; 0000003cH
  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00128	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 489  : 
; 490  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  0012d	6a 1b		 push	 27			; 0000001bH
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00135	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 491  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  0013a	6a 0f		 push	 15			; 0000000fH
  0013c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00142	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 492  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAREF);

  00147	6a 18		 push	 24			; 00000018H
  00149	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0014f	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 493  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  00154	6a 19		 push	 25			; 00000019H
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0015c	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 494  : 
; 495  : 	STATEMANAGER.RestoreRenderState(D3DRS_SOFTWAREVERTEXPROCESSING);

  00161	68 99 00 00 00	 push	 153			; 00000099H
  00166	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0016c	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 496  : 	
; 497  : 	// Render State & TextureStageState
; 498  : 	//////////////////////////////////////////////////////////////////////////
; 499  : }

  00171	c9		 leave
  00172	c2 04 00	 ret	 4
?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ENDP ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_dwB$1 = -64						; size = 4
_dwA$2 = -60						; size = 4
_dwR$3 = -56						; size = 4
_dwG$4 = -52						; size = 4
_dwFogColor$ = -48					; size = 4
_isSoftwareVertexClipping$ = -44			; size = 4
tv295 = -40						; size = 4
tv294 = -36						; size = 4
tv284 = -32						; size = 4
tv283 = -28						; size = 4
tv273 = -24						; size = 4
tv272 = -20						; size = 4
tv262 = -16						; size = 4
tv261 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState, COMDAT
; _this$ = ecx

; 415  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 416  : 	DWORD dwFogColor=0xffffffff;

  00009	83 4d d0 ff	 or	 DWORD PTR _dwFogColor$[ebp], -1

; 417  : 	if (mc_pEnvironmentData)

  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00014	0f 84 87 01 00
	00		 je	 $LN2@SoftwareTr

; 418  : 		dwFogColor=mc_pEnvironmentData->FogColor;

  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00020	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00025	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0002f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00036	72 09		 jb	 SHORT $LN9@SoftwareTr
  00038	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR tv262[ebp], 255 ; 000000ffH
  0003f	eb 36		 jmp	 SHORT $LN10@SoftwareTr
$LN9@SoftwareTr:
  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0004a	72 06		 jb	 SHORT $LN7@SoftwareTr
  0004c	83 65 f4 00	 and	 DWORD PTR tv261[ebp], 0
  00050	eb 1f		 jmp	 SHORT $LN8@SoftwareTr
$LN7@SoftwareTr:
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00059	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00061	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00069	e8 00 00 00 00	 call	 __ftoui3
  0006e	89 45 f4	 mov	 DWORD PTR tv261[ebp], eax
$LN8@SoftwareTr:
  00071	8b 45 f4	 mov	 eax, DWORD PTR tv261[ebp]
  00074	89 45 f0	 mov	 DWORD PTR tv262[ebp], eax
$LN10@SoftwareTr:
  00077	8b 45 f0	 mov	 eax, DWORD PTR tv262[ebp]
  0007a	89 45 c8	 mov	 DWORD PTR _dwR$3[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00080	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00085	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0008c	72 09		 jb	 SHORT $LN13@SoftwareTr
  0008e	c7 45 e8 ff 00
	00 00		 mov	 DWORD PTR tv273[ebp], 255 ; 000000ffH
  00095	eb 38		 jmp	 SHORT $LN14@SoftwareTr
$LN13@SoftwareTr:
  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	0f 57 c0	 xorps	 xmm0, xmm0
  0009d	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  000a1	72 06		 jb	 SHORT $LN11@SoftwareTr
  000a3	83 65 ec 00	 and	 DWORD PTR tv272[ebp], 0
  000a7	eb 20		 jmp	 SHORT $LN12@SoftwareTr
$LN11@SoftwareTr:
  000a9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b1	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000b9	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000c1	e8 00 00 00 00	 call	 __ftoui3
  000c6	89 45 ec	 mov	 DWORD PTR tv272[ebp], eax
$LN12@SoftwareTr:
  000c9	8b 45 ec	 mov	 eax, DWORD PTR tv272[ebp]
  000cc	89 45 e8	 mov	 DWORD PTR tv273[ebp], eax
$LN14@SoftwareTr:
  000cf	8b 45 e8	 mov	 eax, DWORD PTR tv273[ebp]
  000d2	89 45 cc	 mov	 DWORD PTR _dwG$4[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000dd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000e4	72 09		 jb	 SHORT $LN17@SoftwareTr
  000e6	c7 45 e0 ff 00
	00 00		 mov	 DWORD PTR tv284[ebp], 255 ; 000000ffH
  000ed	eb 38		 jmp	 SHORT $LN18@SoftwareTr
$LN17@SoftwareTr:
  000ef	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	0f 57 c0	 xorps	 xmm0, xmm0
  000f5	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  000f9	72 06		 jb	 SHORT $LN15@SoftwareTr
  000fb	83 65 e4 00	 and	 DWORD PTR tv283[ebp], 0
  000ff	eb 20		 jmp	 SHORT $LN16@SoftwareTr
$LN15@SoftwareTr:
  00101	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00104	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00109	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00111	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00119	e8 00 00 00 00	 call	 __ftoui3
  0011e	89 45 e4	 mov	 DWORD PTR tv283[ebp], eax
$LN16@SoftwareTr:
  00121	8b 45 e4	 mov	 eax, DWORD PTR tv283[ebp]
  00124	89 45 e0	 mov	 DWORD PTR tv284[ebp], eax
$LN18@SoftwareTr:
  00127	8b 45 e0	 mov	 eax, DWORD PTR tv284[ebp]
  0012a	89 45 c0	 mov	 DWORD PTR _dwB$1[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0012d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00130	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00135	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0013c	72 09		 jb	 SHORT $LN21@SoftwareTr
  0013e	c7 45 d8 ff 00
	00 00		 mov	 DWORD PTR tv295[ebp], 255 ; 000000ffH
  00145	eb 38		 jmp	 SHORT $LN22@SoftwareTr
$LN21@SoftwareTr:
  00147	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	0f 57 c0	 xorps	 xmm0, xmm0
  0014d	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00151	72 06		 jb	 SHORT $LN19@SoftwareTr
  00153	83 65 dc 00	 and	 DWORD PTR tv294[ebp], 0
  00157	eb 20		 jmp	 SHORT $LN20@SoftwareTr
$LN19@SoftwareTr:
  00159	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00161	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00169	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00171	e8 00 00 00 00	 call	 __ftoui3
  00176	89 45 dc	 mov	 DWORD PTR tv294[ebp], eax
$LN20@SoftwareTr:
  00179	8b 45 dc	 mov	 eax, DWORD PTR tv294[ebp]
  0017c	89 45 d8	 mov	 DWORD PTR tv295[ebp], eax
$LN22@SoftwareTr:
  0017f	8b 45 d8	 mov	 eax, DWORD PTR tv295[ebp]
  00182	89 45 c4	 mov	 DWORD PTR _dwA$2[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00185	8b 45 cc	 mov	 eax, DWORD PTR _dwG$4[ebp]
  00188	c1 e0 08	 shl	 eax, 8
  0018b	8b 4d c8	 mov	 ecx, DWORD PTR _dwR$3[ebp]
  0018e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00191	8b 55 c4	 mov	 edx, DWORD PTR _dwA$2[ebp]
  00194	c1 e2 18	 shl	 edx, 24			; 00000018H
  00197	0b d1		 or	 edx, ecx
  00199	0b d0		 or	 edx, eax
  0019b	0b 55 c0	 or	 edx, DWORD PTR _dwB$1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 418  : 		dwFogColor=mc_pEnvironmentData->FogColor;

  0019e	89 55 d0	 mov	 DWORD PTR _dwFogColor$[ebp], edx
$LN2@SoftwareTr:

; 419  : 
; 420  : 	BOOL isSoftwareVertexClipping=FALSE;

  001a1	83 65 d4 00	 and	 DWORD PTR _isSoftwareVertexClipping$[ebp], 0

; 421  : 	if (!IsTLVertexClipping())

  001a5	e8 00 00 00 00	 call	 ?IsTLVertexClipping@CGraphicBase@@SA_NXZ ; CGraphicBase::IsTLVertexClipping
  001aa	0f b6 c0	 movzx	 eax, al
  001ad	85 c0		 test	 eax, eax
  001af	75 07		 jne	 SHORT $LN3@SoftwareTr

; 422  : 		isSoftwareVertexClipping=TRUE;

  001b1	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _isSoftwareVertexClipping$[ebp], 1
$LN3@SoftwareTr:

; 423  : 	
; 424  : 	STATEMANAGER.SaveRenderState(D3DRS_SOFTWAREVERTEXPROCESSING, isSoftwareVertexClipping);

  001b8	ff 75 d4	 push	 DWORD PTR _isSoftwareVertexClipping$[ebp]
  001bb	68 99 00 00 00	 push	 153			; 00000099H
  001c0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001c6	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 425  : 	
; 426  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  001cb	6a 01		 push	 1
  001cd	6a 1b		 push	 27			; 0000001bH
  001cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001d5	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 427  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  001da	6a 01		 push	 1
  001dc	6a 0f		 push	 15			; 0000000fH
  001de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001e4	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 428  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAREF, 0x00000000);

  001e9	6a 00		 push	 0
  001eb	6a 18		 push	 24			; 00000018H
  001ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001f3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 429  : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  001f8	6a 05		 push	 5
  001fa	6a 19		 push	 25			; 00000019H
  001fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00202	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 430  : 
; 431  : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, dwFogColor);

  00207	ff 75 d0	 push	 DWORD PTR _dwFogColor$[ebp]
  0020a	6a 3c		 push	 60			; 0000003cH
  0020c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00212	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 432  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00217	6a 00		 push	 0
  00219	68 89 00 00 00	 push	 137			; 00000089H
  0021e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00224	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 433  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00229	6a 00		 push	 0
  0022b	6a 1c		 push	 28			; 0000001cH
  0022d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00233	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 434  : 
; 435  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00238	6a 02		 push	 2
  0023a	6a 02		 push	 2
  0023c	6a 00		 push	 0
  0023e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00244	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 436  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

  00249	6a 00		 push	 0
  0024b	6a 03		 push	 3
  0024d	6a 00		 push	 0
  0024f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00255	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 437  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0025a	6a 02		 push	 2
  0025c	6a 01		 push	 1
  0025e	6a 00		 push	 0
  00260	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00266	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 438  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0026b	6a 02		 push	 2
  0026d	6a 05		 push	 5
  0026f	6a 00		 push	 0
  00271	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00277	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 439  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0027c	6a 02		 push	 2
  0027e	6a 04		 push	 4
  00280	6a 00		 push	 0
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00288	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 440  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  0028d	6a 01		 push	 1
  0028f	6a 0d		 push	 13			; 0000000dH
  00291	6a 00		 push	 0
  00293	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00299	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 441  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  0029e	6a 01		 push	 1
  002a0	6a 0e		 push	 14			; 0000000eH
  002a2	6a 00		 push	 0
  002a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002aa	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 442  : 	STATEMANAGER.SetBestFiltering(0);

  002af	6a 00		 push	 0
  002b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002b7	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 443  : 
; 444  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  002bc	6a 01		 push	 1
  002be	6a 02		 push	 2
  002c0	6a 01		 push	 1
  002c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002c8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 445  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_TEXTURE);

  002cd	6a 02		 push	 2
  002cf	6a 03		 push	 3
  002d1	6a 01		 push	 1
  002d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002d9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 446  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  002de	6a 02		 push	 2
  002e0	6a 01		 push	 1
  002e2	6a 01		 push	 1
  002e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002ea	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 447  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  002ef	6a 02		 push	 2
  002f1	6a 05		 push	 5
  002f3	6a 01		 push	 1
  002f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002fb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 448  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  00300	6a 01		 push	 1
  00302	6a 06		 push	 6
  00304	6a 01		 push	 1
  00306	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0030c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 449  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00311	6a 02		 push	 2
  00313	6a 04		 push	 4
  00315	6a 01		 push	 1
  00317	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0031d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 450  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);

  00322	6a 03		 push	 3
  00324	6a 0d		 push	 13			; 0000000dH
  00326	6a 01		 push	 1
  00328	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0032e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 451  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);

  00333	6a 03		 push	 3
  00335	6a 0e		 push	 14			; 0000000eH
  00337	6a 01		 push	 1
  00339	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0033f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 452  : 	STATEMANAGER.SetBestFiltering(1);

  00344	6a 01		 push	 1
  00346	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034c	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 453  : 	
; 454  : 	CSpeedTreeWrapper::ms_bSelfShadowOn = true;

  00351	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA, 1 ; CSpeedTreeWrapper::ms_bSelfShadowOn

; 455  : 
; 456  : 	// Render State & TextureStageState
; 457  : 	//////////////////////////////////////////////////////////////////////////
; 458  : 
; 459  : 	m_iRenderedSplatNumSqSum = 0;

  00358	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0035b	83 a0 84 09 00
	00 00		 and	 DWORD PTR [eax+2436], 0

; 460  : 	m_iRenderedPatchNum = 0;

  00362	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00365	83 a0 8c 09 00
	00 00		 and	 DWORD PTR [eax+2444], 0

; 461  : 	m_iRenderedSplatNum = 0;

  0036c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0036f	83 a0 88 09 00
	00 00		 and	 DWORD PTR [eax+2440], 0

; 462  : 	m_RenderedTextureNumVector.clear();

  00376	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00379	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
  0037f	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 463  : 
; 464  : 	m_matWorldForCommonUse._41 = 0.0f;

  00384	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00387	0f 57 c0	 xorps	 xmm0, xmm0
  0038a	f3 0f 11 80 78
	07 00 00	 movss	 DWORD PTR [eax+1912], xmm0

; 465  : 	m_matWorldForCommonUse._42 = 0.0f;

  00392	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00395	0f 57 c0	 xorps	 xmm0, xmm0
  00398	f3 0f 11 80 7c
	07 00 00	 movss	 DWORD PTR [eax+1916], xmm0

; 466  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  003a0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003a3	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  003a8	50		 push	 eax
  003a9	68 00 01 00 00	 push	 256			; 00000100H
  003ae	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003b4	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 467  : }

  003b9	c9		 leave
  003ba	c3		 ret	 0
?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp
;	COMDAT ?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
$T1 = -172						; size = 4
_fog_near$ = -168					; size = 8
_fog_far$ = -160					; size = 8
___param0$ = -152					; size = 4
_dwFogEnable$ = -148					; size = 4
$T2 = -144						; size = 4
$T3 = -140						; size = 4
$T4 = -136						; size = 4
$T5 = -132						; size = 4
$T6 = -128						; size = 4
$T7 = -124						; size = 4
$T8 = -120						; size = 4
$T9 = -116						; size = 4
$T10 = -112						; size = 4
$T11 = -108						; size = 4
$T12 = -104						; size = 4
$T13 = -100						; size = 4
$T14 = -96						; size = 4
$T15 = -92						; size = 4
$T16 = -88						; size = 4
$T17 = -84						; size = 4
$T18 = -80						; size = 4
__First$ = -76						; size = 4
__Last$ = -72						; size = 4
$T19 = -68						; size = 1
$T20 = -64						; size = 4
$T21 = -60						; size = 4
$T22 = -56						; size = 4
___param0$ = -52					; size = 4
$T23 = -48						; size = 4
$T24 = -44						; size = 4
___param0$ = -40					; size = 4
$T25 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T26 = -24						; size = 1
$T27 = -20						; size = 4
$T28 = -16						; size = 4
$T29 = -12						; size = 4
___param0$ = -8						; size = 4
$T30 = -4						; size = 4
$T31 = 0						; size = 4
___param0$ = 4						; size = 4
$T32 = 8						; size = 4
$T33 = 12						; size = 4
$T34 = 16						; size = 4
$T35 = 20						; size = 4
$T36 = 24						; size = 4
$T37 = 28						; size = 4
$T38 = 32						; size = 4
$T39 = 36						; size = 4
$T40 = 40						; size = 4
tv567 = 44						; size = 4
tv581 = 48						; size = 4
__My_data$41 = 52					; size = 4
_far_it$ = 56						; size = 4
_fLODLevel2Distance$ = 60				; size = 4
_fLODLevel1Distance$ = 64				; size = 4
tv520 = 68						; size = 4
tv527 = 72						; size = 4
_near_it$ = 76						; size = 4
tv453 = 80						; size = 4
tv460 = 84						; size = 4
__My_data$42 = 88					; size = 4
__My_data$43 = 92					; size = 4
__My_data$44 = 96					; size = 4
__My_data$45 = 100					; size = 4
$T46 = 106						; size = 1
$T47 = 107						; size = 1
$T48 = 108						; size = 1
$T49 = 109						; size = 1
$T50 = 110						; size = 1
$T51 = 111						; size = 1
_wPrimitiveCount$ = 112					; size = 2
_ePrimitiveType$ = 116					; size = 4
_it$ = 120						; size = 4
_this$ = 124						; size = 4
_byCUrrentLODLevel$ = 131				; size = 1
_kTPRS$ = 132						; size = 408
__$ArrayPad$ = 540					; size = 4
?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch, COMDAT
; _this$ = ecx

; 21   : {	

  00000	55		 push	 ebp
  00001	8d ac 24 e0 fd
	ff ff		 lea	 ebp, DWORD PTR [esp-544]
  00008	81 ec cc 02 00
	00		 sub	 esp, 716		; 000002ccH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 1c 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 7c	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00023	89 45 a4	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 24   : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00026	6a 1c		 push	 28			; 0000001cH
  00028	8b 4d a4	 mov	 ecx, DWORD PTR $T15[ebp]
  0002b	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  00030	89 85 6c ff ff
	ff		 mov	 DWORD PTR _dwFogEnable$[ebp], eax

; 25   : 
; 26   : 	__SoftwareTransformPatch_ApplyRenderState();

  00036	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_ApplyRenderState@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_ApplyRenderState

; 27   : 
; 28   : 	__SoftwareTransformPatch_BuildPipeline(kTPRS);

  0003e	8d 85 84 00 00
	00		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  00044	50		 push	 eax
  00045	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_BuildPipeline@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@@Z ; CMapOutdoor::__SoftwareTransformPatch_BuildPipeline

; 29   : 
; 30   : 	std::pair<float, long> fog_far(kTPRS.m_fFogFarDistance+800.0f, 0);

  0004d	83 65 20 00	 and	 DWORD PTR $T38[ebp], 0
  00051	f3 0f 10 85 0c
	02 00 00	 movss	 xmm0, DWORD PTR _kTPRS$[ebp+392]
  00059	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@44480000
  00061	f3 0f 11 45 28	 movss	 DWORD PTR $T40[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00066	8d 45 28	 lea	 eax, DWORD PTR $T40[ebp]
  00069	89 45 24	 mov	 DWORD PTR $T39[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0006c	8b 45 24	 mov	 eax, DWORD PTR $T39[ebp]
  0006f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00073	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fog_far$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0007b	8d 45 20	 lea	 eax, DWORD PTR $T38[ebp]
  0007e	89 45 1c	 mov	 DWORD PTR $T37[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00081	8b 45 1c	 mov	 eax, DWORD PTR $T37[ebp]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	89 85 64 ff ff
	ff		 mov	 DWORD PTR _fog_far$[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 31   : 	std::pair<float, long> fog_near(kTPRS.m_fFogNearDistance-3200.0f, 0);

  0008c	83 65 10 00	 and	 DWORD PTR $T34[ebp], 0
  00090	f3 0f 10 85 08
	02 00 00	 movss	 xmm0, DWORD PTR _kTPRS$[ebp+388]
  00098	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@45480000
  000a0	f3 0f 11 45 18	 movss	 DWORD PTR $T36[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000a5	8d 45 18	 lea	 eax, DWORD PTR $T36[ebp]
  000a8	89 45 14	 mov	 DWORD PTR $T35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000ab	8b 45 14	 mov	 eax, DWORD PTR $T35[ebp]
  000ae	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000b2	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fog_near$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000ba	8d 45 10	 lea	 eax, DWORD PTR $T34[ebp]
  000bd	89 45 0c	 mov	 DWORD PTR $T33[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000c0	8b 45 0c	 mov	 eax, DWORD PTR $T33[ebp]
  000c3	8b 00		 mov	 eax, DWORD PTR [eax]
  000c5	89 85 5c ff ff
	ff		 mov	 DWORD PTR _fog_near$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  000cb	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	05 18 01 00 00	 add	 eax, 280		; 00000118H
  000d3	89 45 64	 mov	 DWORD PTR __My_data$45[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000d6	8b 45 64	 mov	 eax, DWORD PTR __My_data$45[ebp]
  000d9	89 45 08	 mov	 DWORD PTR $T32[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  000dc	8b 45 64	 mov	 eax, DWORD PTR __My_data$45[ebp]
  000df	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e2	89 45 04	 mov	 DWORD PTR ___param0$[ebp], eax
  000e5	ff 75 08	 push	 DWORD PTR $T32[ebp]
  000e8	ff 75 04	 push	 DWORD PTR ___param0$[ebp]
  000eb	8d 4d 00	 lea	 ecx, DWORD PTR $T31[ebp]
  000ee	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
  000f3	8d 45 00	 lea	 eax, DWORD PTR $T31[ebp]
  000f6	89 45 f0	 mov	 DWORD PTR $T28[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  000f9	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00101	89 45 60	 mov	 DWORD PTR __My_data$44[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00104	8b 45 60	 mov	 eax, DWORD PTR __My_data$44[ebp]
  00107	89 45 fc	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0010a	8b 45 60	 mov	 eax, DWORD PTR __My_data$44[ebp]
  0010d	8b 00		 mov	 eax, DWORD PTR [eax]
  0010f	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax
  00112	ff 75 fc	 push	 DWORD PTR $T30[ebp]
  00115	ff 75 f8	 push	 DWORD PTR ___param0$[ebp]
  00118	8d 4d f4	 lea	 ecx, DWORD PTR $T29[ebp]
  0011b	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
  00120	8d 45 f4	 lea	 eax, DWORD PTR $T29[ebp]
  00123	89 45 ec	 mov	 DWORD PTR $T27[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 33   : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  00126	8b 45 f0	 mov	 eax, DWORD PTR $T28[ebp]
  00129	8b 00		 mov	 eax, DWORD PTR [eax]
  0012b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0012e	8b 45 ec	 mov	 eax, DWORD PTR $T27[ebp]
  00131	8b 00		 mov	 eax, DWORD PTR [eax]
  00133	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6749 :     return _STD upper_bound(_First, _Last, _Val, less<>{});

  00136	33 c0		 xor	 eax, eax
  00138	88 45 e8	 mov	 BYTE PTR $T26[ebp], al
  0013b	ff 75 e8	 push	 DWORD PTR $T26[ebp]
  0013e	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _fog_far$[ebp]
  00144	50		 push	 eax
  00145	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00148	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  0014b	8d 45 38	 lea	 eax, DWORD PTR _far_it$[ebp]
  0014e	50		 push	 eax
  0014f	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
  00154	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00157	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  0015a	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0015f	89 45 5c	 mov	 DWORD PTR __My_data$43[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00162	8b 45 5c	 mov	 eax, DWORD PTR __My_data$43[ebp]
  00165	89 45 dc	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00168	8b 45 5c	 mov	 eax, DWORD PTR __My_data$43[ebp]
  0016b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016e	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax
  00171	ff 75 dc	 push	 DWORD PTR $T25[ebp]
  00174	ff 75 d8	 push	 DWORD PTR ___param0$[ebp]
  00177	8d 4d d4	 lea	 ecx, DWORD PTR $T24[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
  0017f	8d 45 d4	 lea	 eax, DWORD PTR $T24[ebp]
  00182	89 45 c4	 mov	 DWORD PTR $T21[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00185	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  00188	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0018d	89 45 58	 mov	 DWORD PTR __My_data$42[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00190	8b 45 58	 mov	 eax, DWORD PTR __My_data$42[ebp]
  00193	89 45 d0	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00196	8b 45 58	 mov	 eax, DWORD PTR __My_data$42[ebp]
  00199	8b 00		 mov	 eax, DWORD PTR [eax]
  0019b	89 45 cc	 mov	 DWORD PTR ___param0$[ebp], eax
  0019e	ff 75 d0	 push	 DWORD PTR $T23[ebp]
  001a1	ff 75 cc	 push	 DWORD PTR ___param0$[ebp]
  001a4	8d 4d c8	 lea	 ecx, DWORD PTR $T22[ebp]
  001a7	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
  001ac	8d 45 c8	 lea	 eax, DWORD PTR $T22[ebp]
  001af	89 45 c0	 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 34   : 	std::vector<std::pair<float ,long> >::iterator near_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_near);

  001b2	8b 45 c4	 mov	 eax, DWORD PTR $T21[ebp]
  001b5	8b 00		 mov	 eax, DWORD PTR [eax]
  001b7	89 45 b8	 mov	 DWORD PTR __Last$[ebp], eax
  001ba	8b 45 c0	 mov	 eax, DWORD PTR $T20[ebp]
  001bd	8b 00		 mov	 eax, DWORD PTR [eax]
  001bf	89 45 b4	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6749 :     return _STD upper_bound(_First, _Last, _Val, less<>{});

  001c2	33 c0		 xor	 eax, eax
  001c4	88 45 bc	 mov	 BYTE PTR $T19[ebp], al
  001c7	ff 75 bc	 push	 DWORD PTR $T19[ebp]
  001ca	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _fog_near$[ebp]
  001d0	50		 push	 eax
  001d1	ff 75 b8	 push	 DWORD PTR __Last$[ebp]
  001d4	ff 75 b4	 push	 DWORD PTR __First$[ebp]
  001d7	8d 45 4c	 lea	 eax, DWORD PTR _near_it$[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
  001e0	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 39   : 	BYTE byCUrrentLODLevel = 0;

  001e3	c6 85 83 00 00
	00 00		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 0

; 40   : 
; 41   : 	float fLODLevel1Distance = __GetNoFogDistance();

  001ea	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  001ed	e8 00 00 00 00	 call	 ?__GetNoFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetNoFogDistance
  001f2	d9 5d 40	 fstp	 DWORD PTR _fLODLevel1Distance$[ebp]

; 42   : 	float fLODLevel2Distance = __GetFogDistance();

  001f5	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  001f8	e8 00 00 00 00	 call	 ?__GetFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetFogDistance
  001fd	d9 5d 3c	 fstp	 DWORD PTR _fLODLevel2Distance$[ebp]

; 43   : 
; 44   : 	SelectIndexBuffer(0, &wPrimitiveCount, &ePrimitiveType);

  00200	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00203	50		 push	 eax
  00204	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00207	50		 push	 eax
  00208	6a 00		 push	 0
  0020a	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 45   : 
; 46   : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_SPECULAR|D3DFVF_TEX2);

  00212	68 c4 02 00 00	 push	 708			; 000002c4H
  00217	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0021d	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 47   : 
; 48   : 	std::vector<std::pair<float, long> >::iterator it = m_PatchVector.begin();

  00222	8d 45 78	 lea	 eax, DWORD PTR _it$[ebp]
  00225	50		 push	 eax
  00226	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00229	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  0022f	e8 00 00 00 00	 call	 ?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin

; 50   : 	for( ; it != near_it; ++it)

  00234	eb 09		 jmp	 SHORT $LN106@RenderTerr
$LN2@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00236	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  00239	83 c0 08	 add	 eax, 8
  0023c	89 45 78	 mov	 DWORD PTR _it$[ebp], eax
$LN106@RenderTerr:

; 149  :         return _Ptr == _Right._Ptr;

  0023f	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  00242	3b 45 4c	 cmp	 eax, DWORD PTR _near_it$[ebp]
  00245	75 09		 jne	 SHORT $LN119@RenderTerr
  00247	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv460[ebp], 1
  0024e	eb 04		 jmp	 SHORT $LN120@RenderTerr
$LN119@RenderTerr:
  00250	83 65 54 00	 and	 DWORD PTR tv460[ebp], 0
$LN120@RenderTerr:
  00254	8a 45 54	 mov	 al, BYTE PTR tv460[ebp]
  00257	88 45 6f	 mov	 BYTE PTR $T51[ebp], al

; 153  :         return !(*this == _Right);

  0025a	0f b6 45 6f	 movzx	 eax, BYTE PTR $T51[ebp]
  0025e	85 c0		 test	 eax, eax
  00260	75 09		 jne	 SHORT $LN114@RenderTerr
  00262	c7 45 50 01 00
	00 00		 mov	 DWORD PTR tv453[ebp], 1
  00269	eb 04		 jmp	 SHORT $LN115@RenderTerr
$LN114@RenderTerr:
  0026b	83 65 50 00	 and	 DWORD PTR tv453[ebp], 0
$LN115@RenderTerr:
  0026f	8a 45 50	 mov	 al, BYTE PTR tv453[ebp]
  00272	88 45 6e	 mov	 BYTE PTR $T50[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 50   : 	for( ; it != near_it; ++it)

  00275	0f b6 45 6e	 movzx	 eax, BYTE PTR $T50[ebp]
  00279	85 c0		 test	 eax, eax
  0027b	0f 84 d3 00 00
	00		 je	 $LN3@RenderTerr

; 52   : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00281	0f b6 85 83 00
	00 00		 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00288	85 c0		 test	 eax, eax
  0028a	75 3a		 jne	 SHORT $LN11@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  0028c	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  0028f	89 45 b0	 mov	 DWORD PTR $T18[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00292	ff 75 b0	 push	 DWORD PTR $T18[ebp]
  00295	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0029a	59		 pop	 ecx
  0029b	89 45 ac	 mov	 DWORD PTR $T17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 52   : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  0029e	8b 45 ac	 mov	 eax, DWORD PTR $T17[ebp]
  002a1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002a5	0f 2f 45 40	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  002a9	72 1b		 jb	 SHORT $LN11@RenderTerr

; 53   : 		{
; 54   : 			byCUrrentLODLevel = 1;

  002ab	c6 85 83 00 00
	00 01		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 1

; 55   : 			SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  002b2	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  002b5	50		 push	 eax
  002b6	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  002b9	50		 push	 eax
  002ba	6a 01		 push	 1
  002bc	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  002bf	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 56   : 		}

  002c4	eb 44		 jmp	 SHORT $LN13@RenderTerr
$LN11@RenderTerr:

; 57   : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  002c6	0f b6 85 83 00
	00 00		 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  002cd	83 f8 01	 cmp	 eax, 1
  002d0	75 38		 jne	 SHORT $LN13@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  002d2	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  002d5	89 45 a8	 mov	 DWORD PTR $T16[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  002d8	ff 75 a8	 push	 DWORD PTR $T16[ebp]
  002db	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  002e0	59		 pop	 ecx
  002e1	89 45 80	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 57   : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  002e4	8b 45 80	 mov	 eax, DWORD PTR $T6[ebp]
  002e7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002eb	0f 2f 45 3c	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  002ef	72 19		 jb	 SHORT $LN13@RenderTerr

; 58   : 		{
; 59   : 			byCUrrentLODLevel = 2;

  002f1	c6 85 83 00 00
	00 02		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 60   : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  002f8	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  002fb	50		 push	 eax
  002fc	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  002ff	50		 push	 eax
  00300	6a 02		 push	 2
  00302	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00305	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN13@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  0030a	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  0030d	89 45 a0	 mov	 DWORD PTR $T14[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00310	ff 75 a0	 push	 DWORD PTR $T14[ebp]
  00313	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00318	59		 pop	 ecx
  00319	89 45 9c	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 63   : 		__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, false);

  0031c	6a 00		 push	 0
  0031e	ff 75 74	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00321	ff 75 70	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00324	8b 45 9c	 mov	 eax, DWORD PTR $T13[ebp]
  00327	ff 70 04	 push	 DWORD PTR [eax+4]
  0032a	8d 85 84 00 00
	00		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  00330	50		 push	 eax
  00331	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00334	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat

; 64   : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  00339	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  0033c	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0033f	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00345	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  0034b	7c 02		 jl	 SHORT $LN14@RenderTerr

; 65   : 			break;

  0034d	eb 05		 jmp	 SHORT $LN3@RenderTerr
$LN14@RenderTerr:

; 66   : 		
; 67   : 	}

  0034f	e9 e2 fe ff ff	 jmp	 $LN2@RenderTerr
$LN3@RenderTerr:

; 68   : 
; 69   : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  00354	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  00357	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0035a	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00360	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00366	0f 8d 26 01 00
	00		 jge	 $LN6@RenderTerr

; 71   : 		for(it = near_it; it != far_it; ++it)

  0036c	8b 45 4c	 mov	 eax, DWORD PTR _near_it$[ebp]
  0036f	89 45 78	 mov	 DWORD PTR _it$[ebp], eax
  00372	eb 09		 jmp	 SHORT $LN143@RenderTerr
$LN5@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00374	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  00377	83 c0 08	 add	 eax, 8
  0037a	89 45 78	 mov	 DWORD PTR _it$[ebp], eax
$LN143@RenderTerr:

; 149  :         return _Ptr == _Right._Ptr;

  0037d	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  00380	3b 45 38	 cmp	 eax, DWORD PTR _far_it$[ebp]
  00383	75 09		 jne	 SHORT $LN156@RenderTerr
  00385	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv527[ebp], 1
  0038c	eb 04		 jmp	 SHORT $LN157@RenderTerr
$LN156@RenderTerr:
  0038e	83 65 48 00	 and	 DWORD PTR tv527[ebp], 0
$LN157@RenderTerr:
  00392	8a 45 48	 mov	 al, BYTE PTR tv527[ebp]
  00395	88 45 6d	 mov	 BYTE PTR $T49[ebp], al

; 153  :         return !(*this == _Right);

  00398	0f b6 45 6d	 movzx	 eax, BYTE PTR $T49[ebp]
  0039c	85 c0		 test	 eax, eax
  0039e	75 09		 jne	 SHORT $LN151@RenderTerr
  003a0	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv520[ebp], 1
  003a7	eb 04		 jmp	 SHORT $LN152@RenderTerr
$LN151@RenderTerr:
  003a9	83 65 44 00	 and	 DWORD PTR tv520[ebp], 0
$LN152@RenderTerr:
  003ad	8a 45 44	 mov	 al, BYTE PTR tv520[ebp]
  003b0	88 45 6c	 mov	 BYTE PTR $T48[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 71   : 		for(it = near_it; it != far_it; ++it)

  003b3	0f b6 45 6c	 movzx	 eax, BYTE PTR $T48[ebp]
  003b7	85 c0		 test	 eax, eax
  003b9	0f 84 d3 00 00
	00		 je	 $LN6@RenderTerr

; 73   : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  003bf	0f b6 85 83 00
	00 00		 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  003c6	85 c0		 test	 eax, eax
  003c8	75 3a		 jne	 SHORT $LN16@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  003ca	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  003cd	89 45 98	 mov	 DWORD PTR $T12[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  003d0	ff 75 98	 push	 DWORD PTR $T12[ebp]
  003d3	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  003d8	59		 pop	 ecx
  003d9	89 45 94	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 73   : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  003dc	8b 45 94	 mov	 eax, DWORD PTR $T11[ebp]
  003df	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003e3	0f 2f 45 40	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  003e7	72 1b		 jb	 SHORT $LN16@RenderTerr

; 74   : 			{
; 75   : 				byCUrrentLODLevel = 1;

  003e9	c6 85 83 00 00
	00 01		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 1

; 76   : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  003f0	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  003f3	50		 push	 eax
  003f4	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  003f7	50		 push	 eax
  003f8	6a 01		 push	 1
  003fa	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  003fd	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 77   : 			}

  00402	eb 44		 jmp	 SHORT $LN18@RenderTerr
$LN16@RenderTerr:

; 78   : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00404	0f b6 85 83 00
	00 00		 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  0040b	83 f8 01	 cmp	 eax, 1
  0040e	75 38		 jne	 SHORT $LN18@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00410	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  00413	89 45 90	 mov	 DWORD PTR $T10[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00416	ff 75 90	 push	 DWORD PTR $T10[ebp]
  00419	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0041e	59		 pop	 ecx
  0041f	89 45 8c	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 78   : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00422	8b 45 8c	 mov	 eax, DWORD PTR $T9[ebp]
  00425	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00429	0f 2f 45 3c	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  0042d	72 19		 jb	 SHORT $LN18@RenderTerr

; 79   : 			{
; 80   : 				byCUrrentLODLevel = 2;

  0042f	c6 85 83 00 00
	00 02		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 81   : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00436	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00439	50		 push	 eax
  0043a	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0043d	50		 push	 eax
  0043e	6a 02		 push	 2
  00440	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00443	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN18@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00448	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  0044b	89 45 88	 mov	 DWORD PTR $T8[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  0044e	ff 75 88	 push	 DWORD PTR $T8[ebp]
  00451	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00456	59		 pop	 ecx
  00457	89 45 84	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 84   : 			__SoftwareTransformPatch_RenderPatchSplat(kTPRS, it->second, wPrimitiveCount, ePrimitiveType, true);

  0045a	6a 01		 push	 1
  0045c	ff 75 74	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0045f	ff 75 70	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00462	8b 45 84	 mov	 eax, DWORD PTR $T7[ebp]
  00465	ff 70 04	 push	 DWORD PTR [eax+4]
  00468	8d 85 84 00 00
	00		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  0046e	50		 push	 eax
  0046f	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00472	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@_N@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchSplat

; 85   : 
; 86   : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  00477	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  0047a	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0047d	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00483	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00489	7c 02		 jl	 SHORT $LN19@RenderTerr

; 87   : 				break;

  0048b	eb 05		 jmp	 SHORT $LN6@RenderTerr
$LN19@RenderTerr:

; 88   : 
; 89   : 		}

  0048d	e9 e2 fe ff ff	 jmp	 $LN5@RenderTerr
$LN6@RenderTerr:

; 90   : 	}
; 91   : 
; 92   : 	
; 93   : 	STATEMANAGER.SetTexture(0, NULL);

  00492	6a 00		 push	 0
  00494	6a 00		 push	 0
  00496	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0049c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 94   : 	STATEMANAGER.SetTexture(1, NULL);

  004a1	6a 00		 push	 0
  004a3	6a 01		 push	 1
  004a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ab	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 95   : 	
; 96   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  004b0	6a 03		 push	 3
  004b2	6a 02		 push	 2
  004b4	6a 00		 push	 0
  004b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004bc	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 97   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  004c1	6a 02		 push	 2
  004c3	6a 01		 push	 1
  004c5	6a 00		 push	 0
  004c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004cd	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 98   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  004d2	6a 01		 push	 1
  004d4	6a 04		 push	 4
  004d6	6a 00		 push	 0
  004d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004de	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 99   : 
; 100  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_DISABLE);

  004e3	6a 01		 push	 1
  004e5	6a 01		 push	 1
  004e7	6a 01		 push	 1
  004e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ef	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 101  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);	

  004f4	6a 01		 push	 1
  004f6	6a 04		 push	 4
  004f8	6a 01		 push	 1
  004fa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00500	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 102  : 
; 103  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZRHW);

  00505	6a 04		 push	 4
  00507	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0050d	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 104  : 
; 105  : 	if (IsFastTNL())

  00512	e8 00 00 00 00	 call	 ?IsFastTNL@CGraphicBase@@SA_NXZ ; CGraphicBase::IsFastTNL
  00517	0f b6 c0	 movzx	 eax, al
  0051a	85 c0		 test	 eax, eax
  0051c	0f 84 1d 01 00
	00		 je	 $LN9@RenderTerr

; 106  : 	{
; 107  : 		if (byCUrrentLODLevel != 2)

  00522	0f b6 85 83 00
	00 00		 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00529	83 f8 02	 cmp	 eax, 2
  0052c	74 19		 je	 SHORT $LN21@RenderTerr

; 108  : 		{
; 109  : 			byCUrrentLODLevel = 2;

  0052e	c6 85 83 00 00
	00 02		 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 110  : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00535	8d 45 74	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00538	50		 push	 eax
  00539	8d 45 70	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0053c	50		 push	 eax
  0053d	6a 02		 push	 2
  0053f	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00542	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN21@RenderTerr:

; 111  : 		}
; 112  : 
; 113  : 		if (m_iRenderedSplatNum < m_iSplatLimit)

  00547	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  0054a	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0054d	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00553	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00559	0f 8d e0 00 00
	00		 jge	 $LN9@RenderTerr

; 115  : 			for(it = far_it; it != m_PatchVector.end(); ++it)

  0055f	8b 45 38	 mov	 eax, DWORD PTR _far_it$[ebp]
  00562	89 45 78	 mov	 DWORD PTR _it$[ebp], eax
  00565	eb 09		 jmp	 SHORT $LN196@RenderTerr
$LN8@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00567	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  0056a	83 c0 08	 add	 eax, 8
  0056d	89 45 78	 mov	 DWORD PTR _it$[ebp], eax
$LN196@RenderTerr:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00570	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  00573	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00578	89 45 34	 mov	 DWORD PTR __My_data$41[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0057b	8b 45 34	 mov	 eax, DWORD PTR __My_data$41[ebp]
  0057e	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00584	8b 45 34	 mov	 eax, DWORD PTR __My_data$41[ebp]
  00587	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0058a	89 85 68 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00590	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00596	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0059c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  005a2	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  005a8	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  005ae	8b 4d 78	 mov	 ecx, DWORD PTR _it$[ebp]
  005b1	3b 08		 cmp	 ecx, DWORD PTR [eax]
  005b3	75 09		 jne	 SHORT $LN224@RenderTerr
  005b5	c7 45 30 01 00
	00 00		 mov	 DWORD PTR tv581[ebp], 1
  005bc	eb 04		 jmp	 SHORT $LN225@RenderTerr
$LN224@RenderTerr:
  005be	83 65 30 00	 and	 DWORD PTR tv581[ebp], 0
$LN225@RenderTerr:
  005c2	8a 45 30	 mov	 al, BYTE PTR tv581[ebp]
  005c5	88 45 6b	 mov	 BYTE PTR $T47[ebp], al

; 153  :         return !(*this == _Right);

  005c8	0f b6 45 6b	 movzx	 eax, BYTE PTR $T47[ebp]
  005cc	85 c0		 test	 eax, eax
  005ce	75 09		 jne	 SHORT $LN219@RenderTerr
  005d0	c7 45 2c 01 00
	00 00		 mov	 DWORD PTR tv567[ebp], 1
  005d7	eb 04		 jmp	 SHORT $LN220@RenderTerr
$LN219@RenderTerr:
  005d9	83 65 2c 00	 and	 DWORD PTR tv567[ebp], 0
$LN220@RenderTerr:
  005dd	8a 45 2c	 mov	 al, BYTE PTR tv567[ebp]
  005e0	88 45 6a	 mov	 BYTE PTR $T46[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 115  : 			for(it = far_it; it != m_PatchVector.end(); ++it)

  005e3	0f b6 45 6a	 movzx	 eax, BYTE PTR $T46[ebp]
  005e7	85 c0		 test	 eax, eax
  005e9	74 54		 je	 SHORT $LN9@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  005eb	8b 45 78	 mov	 eax, DWORD PTR _it$[ebp]
  005ee	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  005f4	ff b5 74 ff ff
	ff		 push	 DWORD PTR $T3[ebp]
  005fa	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  005ff	59		 pop	 ecx
  00600	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderSTP.cpp

; 117  : 				__SoftwareTransformPatch_RenderPatchNone(kTPRS, it->second, wPrimitiveCount, ePrimitiveType);

  00606	ff 75 74	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00609	ff 75 70	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  0060c	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00612	ff 70 04	 push	 DWORD PTR [eax+4]
  00615	8d 85 84 00 00
	00		 lea	 eax, DWORD PTR _kTPRS$[ebp]
  0061b	50		 push	 eax
  0061c	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0061f	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXAAUSoftwareTransformPatch_SRenderState@1@JGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__SoftwareTransformPatch_RenderPatchNone

; 118  : 
; 119  : 				if (m_iRenderedSplatNum >= m_iSplatLimit)

  00624	8b 45 7c	 mov	 eax, DWORD PTR _this$[ebp]
  00627	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  0062a	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00630	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00636	7c 02		 jl	 SHORT $LN23@RenderTerr

; 120  : 					break;

  00638	eb 05		 jmp	 SHORT $LN9@RenderTerr
$LN23@RenderTerr:

; 121  : 
; 122  : 			}

  0063a	e9 28 ff ff ff	 jmp	 $LN8@RenderTerr
$LN9@RenderTerr:

; 123  : 		}
; 124  : 	}
; 125  : 
; 126  : 
; 127  : 	//////////////////////////////////////////////////////////////////////////
; 128  : 	// Render State & TextureStageState
; 129  : 	__SoftwareTransformPatch_RestoreRenderState(dwFogEnable);

  0063f	ff b5 6c ff ff
	ff		 push	 DWORD PTR _dwFogEnable$[ebp]
  00645	8b 4d 7c	 mov	 ecx, DWORD PTR _this$[ebp]
  00648	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_RestoreRenderState@CMapOutdoor@@IAEXK@Z ; CMapOutdoor::__SoftwareTransformPatch_RestoreRenderState

; 130  : }

  0064d	8b 8d 1c 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00653	33 cd		 xor	 ecx, ebp
  00655	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0065a	81 c5 20 02 00
	00		 add	 ebp, 544		; 00000220H
  00660	c9		 leave
  00661	c3		 ret	 0
?__RenderTerrain_RenderSoftwareTransformPatch@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__RenderTerrain_RenderSoftwareTransformPatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin, COMDAT
; _this$ = ecx

; 1409 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1412 :     }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?begin@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
