; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
PUBLIC	?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat
PUBLIC	?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
PUBLIC	??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
PUBLIC	??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
PUBLIC	??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z		; std::_Refancy<int *,0>
PUBLIC	??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Make_heap_unchecked<int *,std::less<void> >
PUBLIC	??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
PUBLIC	??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
PUBLIC	??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<int *,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	__real@3acccccd
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@437f0000
PUBLIC	__real@44c80000
PUBLIC	__real@45480000
PUBLIC	__real@459c4000
PUBLIC	__real@461c4000
PUBLIC	__real@bacccccd
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	?GetFogNearDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogNearDistance
EXTRN	?GetFogFarDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogFarDistance
EXTRN	?GetTextureCount@CTextureSet@@QAEKXZ:PROC	; CTextureSet::GetTextureCount
EXTRN	?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z:PROC ; CTextureSet::GetTexture
EXTRN	?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ:PROC ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::DrawWireFrame
EXTRN	?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::SelectIndexBuffer
EXTRN	?__GetNoFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetNoFogDistance
EXTRN	?__GetFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetFogDistance
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SaveTextureStageState
EXTRN	?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z:PROC ; CStateManager::RestoreTextureStageState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetBestFiltering@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetBestFiltering
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA:BYTE	; CSpeedTreeWrapper::ms_bSelfShadowOn
EXTRN	?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A:DWORD ; CTerrainImpl::ms_pTextureSet
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bacccccd
CONST	SEGMENT
__real@bacccccd DD 0bacccccdr			; -0.0015625
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@45480000
CONST	SEGMENT
__real@45480000 DD 045480000r			; 3200
CONST	ENDS
;	COMDAT __real@44c80000
CONST	SEGMENT
__real@44c80000 DD 044c80000r			; 1600
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3acccccd
CONST	SEGMENT
__real@3acccccd DD 03acccccdr			; 0.0015625
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0
__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
__Tmp$2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__Tmp$6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
$T9 = -32						; size = 4
__Tmp$10 = -28						; size = 4
$T11 = -24						; size = 4
$T12 = -20						; size = 4
tv79 = -16						; size = 4
tv71 = -12						; size = 4
tv89 = -8						; size = 4
$T13 = -3						; size = 1
$T14 = -2						; size = 1
$T15 = -1						; size = 1
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Med3_unchecked<int *,std::less<void> >, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00010	7d 09		 jge	 SHORT $LN8@Med3_unche
  00012	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN9@Med3_unche
$LN8@Med3_unche:
  0001b	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN9@Med3_unche:
  0001f	8a 45 f8	 mov	 al, BYTE PTR tv89[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T15[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 2e		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00033	8b 45 ec	 mov	 eax, DWORD PTR $T12[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 e4	 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003e	89 45 e8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00044	8b 4d e8	 mov	 ecx, DWORD PTR $T11[ebp]
  00047	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00049	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0004b	8d 45 e4	 lea	 eax, DWORD PTR __Tmp$10[ebp]
  0004e	89 45 e0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00051	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00054	8b 4d e0	 mov	 ecx, DWORD PTR $T9[ebp]
  00057	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00059	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0005b	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00065	7d 09		 jge	 SHORT $LN27@Med3_unche
  00067	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0006e	eb 04		 jmp	 SHORT $LN28@Med3_unche
$LN27@Med3_unche:
  00070	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN28@Med3_unche:
  00074	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  00077	88 45 fe	 mov	 BYTE PTR $T14[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  0007a	0f b6 45 fe	 movzx	 eax, BYTE PTR $T14[ebp]
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 83 00 00
	00		 je	 $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00086	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00089	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0008c	8b 45 dc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	8b 00		 mov	 eax, DWORD PTR [eax]
  00091	89 45 d4	 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00094	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00097	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0009a	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0009d	8b 4d d8	 mov	 ecx, DWORD PTR $T7[ebp]
  000a0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a4	8d 45 d4	 lea	 eax, DWORD PTR __Tmp$6[ebp]
  000a7	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000aa	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000ad	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  000b0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b2	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000b4	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000b7	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000be	7d 09		 jge	 SHORT $LN46@Med3_unche
  000c0	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  000c7	eb 04		 jmp	 SHORT $LN47@Med3_unche
$LN46@Med3_unche:
  000c9	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN47@Med3_unche:
  000cd	8a 45 f0	 mov	 al, BYTE PTR tv79[ebp]
  000d0	88 45 fd	 mov	 BYTE PTR $T13[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000d3	0f b6 45 fd	 movzx	 eax, BYTE PTR $T13[ebp]
  000d7	85 c0		 test	 eax, eax
  000d9	74 2e		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000db	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000e1	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000e4	8b 00		 mov	 eax, DWORD PTR [eax]
  000e6	89 45 c4	 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000e9	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ec	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000ef	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000f2	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp]
  000f5	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000f7	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000f9	8d 45 c4	 lea	 eax, DWORD PTR __Tmp$2[ebp]
  000fc	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000ff	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00102	8b 4d c0	 mov	 ecx, DWORD PTR $T1[ebp]
  00105	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00107	89 08		 mov	 DWORD PTR [eax], ecx
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  00109	c9		 leave
  0010a	c3		 ret	 0
??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Med3_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Dest_ch$ = -16					; size = 4
__Last_ch$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f0	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  00021	ff 75 f8	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	8b 45 f0	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0002a	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _memmove
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  00036	c9		 leave
  00037	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<int *,std::less<void> >, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00012	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00016	0f 8e a4 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  0001f	40		 inc	 eax
  00020	c1 f8 03	 sar	 eax, 3
  00023	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00026	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00029	d1 e0		 shl	 eax, 1
  0002b	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0002e	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00031	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00037	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0003a	50		 push	 eax
  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00041	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00044	50		 push	 eax
  00045	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  0004d	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00050	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00053	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00059	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0005c	50		 push	 eax
  0005d	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00060	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  00063	c1 e0 02	 shl	 eax, 2
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00069	2b c8		 sub	 ecx, eax
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  00071	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  00074	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00077	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0007d	c1 e0 02	 shl	 eax, 2
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00083	2b c8		 sub	 ecx, eax
  00085	51		 push	 ecx
  00086	8b 45 f4	 mov	 eax, DWORD PTR __Two_step$1[ebp]
  00089	c1 e0 02	 shl	 eax, 2
  0008c	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0008f	2b c8		 sub	 ecx, eax
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  00097	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  0009a	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000a0	c1 e0 02	 shl	 eax, 2
  000a3	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b c8		 sub	 ecx, eax
  000a8	51		 push	 ecx
  000a9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  000af	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b2	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  000bb	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000be	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000c0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c3	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000c6	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000c9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Med3_unchecked<int *,std::less<void> >
  000d1	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000d4	c9		 leave
  000d5	c3		 ret	 0
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Val$4 = -8						; size = 4
$T5 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<int *,std::less<void> >, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 02	 cmp	 eax, 2
  00012	7c 50		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00023	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f8	 mov	 DWORD PTR __Val$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002b	8d 45 f8	 lea	 eax, DWORD PTR __Val$4[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00031	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6219 :     *_Dest      = _STD move(*_First);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR $T3[ebp]
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00041	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00044	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  00047	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0004a	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0004d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00050	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00053	c1 f8 02	 sar	 eax, 2
  00056	50		 push	 eax
  00057	6a 00		 push	 0
  00059	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
  00061	83 c4 14	 add	 esp, 20			; 00000014H
$LN1@Pop_heap_u:

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }
; 6233 : }

  00064	c9		 leave
  00065	c3		 ret	 0
??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
__Top$ = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
tv158 = -32						; size = 4
__Max_sequence_non_leaf$ = -28				; size = 4
tv138 = -24						; size = 4
__Idx$6 = -20						; size = 4
__Hole$ = -16						; size = 4
__Idx$ = -12						; size = 4
__Pred$ = -8						; size = 1
$T7 = -2						; size = 1
$T8 = -1						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	56		 push	 esi

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000a	89 45 d0	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00010	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00013	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00016	48		 dec	 eax
  00017	d1 f8		 sar	 eax, 1
  00019	89 45 e4	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001c	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001f	3b 45 e4	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00022	7d 63		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00024	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00027	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002b	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00034	8b 55 f4	 mov	 edx, DWORD PTR __Idx$[ebp]
  00037	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0003a	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0003d	3b 44 96 fc	 cmp	 eax, DWORD PTR [esi+edx*4-4]
  00041	7d 09		 jge	 SHORT $LN9@Pop_heap_h
  00043	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv138[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN10@Pop_heap_h
$LN9@Pop_heap_h:
  0004c	83 65 e8 00	 and	 DWORD PTR tv138[ebp], 0
$LN10@Pop_heap_h:
  00050	8a 45 e8	 mov	 al, BYTE PTR tv138[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  0005e	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00061	48		 dec	 eax
  00062	89 45 f4	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00068	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0006e	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00071	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00077	8b 55 d8	 mov	 edx, DWORD PTR $T4[ebp]
  0007a	8b 12		 mov	 edx, DWORD PTR [edx]
  0007c	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6203 :         _Hole             = _Idx;

  0007f	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  00082	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  00085	eb 95		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00087	8b 45 f4	 mov	 eax, DWORD PTR __Idx$[ebp]
  0008a	3b 45 e4	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0008d	75 35		 jne	 SHORT $LN5@Pop_heap_h
  0008f	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00092	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00097	79 05		 jns	 SHORT $LN37@Pop_heap_h
  00099	48		 dec	 eax
  0009a	83 c8 fe	 or	 eax, -2			; fffffffeH
  0009d	40		 inc	 eax
$LN37@Pop_heap_h:
  0009e	85 c0		 test	 eax, eax
  000a0	75 22		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000a2	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000a8	8d 44 81 fc	 lea	 eax, DWORD PTR [ecx+eax*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ac	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000af	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000b2	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000b5	8b 55 d4	 mov	 edx, DWORD PTR $T3[ebp]
  000b8	8b 12		 mov	 edx, DWORD PTR [edx]
  000ba	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6208 :         _Hole             = _Bottom - 1;

  000bd	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000c0	48		 dec	 eax
  000c1	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c4	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000c7	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000ca	8a 45 18	 mov	 al, BYTE PTR __Pred$[ebp]
  000cd	88 45 f8	 mov	 BYTE PTR __Pred$[ebp], al
  000d0	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d3	89 45 f0	 mov	 DWORD PTR __Hole$[ebp], eax

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  000d6	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  000d9	48		 dec	 eax
  000da	d1 f8		 sar	 eax, 1
  000dc	89 45 ec	 mov	 DWORD PTR __Idx$6[ebp], eax
  000df	eb 09		 jmp	 SHORT $LN24@Pop_heap_h
$LN22@Pop_heap_h:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  000e4	48		 dec	 eax
  000e5	d1 f8		 sar	 eax, 1
  000e7	89 45 ec	 mov	 DWORD PTR __Idx$6[ebp], eax
$LN24@Pop_heap_h:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  000ea	8b 45 d0	 mov	 eax, DWORD PTR __Top$[ebp]
  000ed	3b 45 f0	 cmp	 eax, DWORD PTR __Hole$[ebp]
  000f0	7d 4d		 jge	 SHORT $LN23@Pop_heap_h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000f2	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  000f5	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000f8	8b 55 dc	 mov	 edx, DWORD PTR $T5[ebp]
  000fb	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000fe	3b 02		 cmp	 eax, DWORD PTR [edx]
  00100	7d 09		 jge	 SHORT $LN28@Pop_heap_h
  00102	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv158[ebp], 1
  00109	eb 04		 jmp	 SHORT $LN29@Pop_heap_h
$LN28@Pop_heap_h:
  0010b	83 65 e0 00	 and	 DWORD PTR tv158[ebp], 0
$LN29@Pop_heap_h:
  0010f	8a 45 e0	 mov	 al, BYTE PTR tv158[ebp]
  00112	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00115	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	74 22		 je	 SHORT $LN23@Pop_heap_h

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0011d	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  00120	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00123	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00126	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00129	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  0012c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0012f	8b 55 cc	 mov	 edx, DWORD PTR $T2[ebp]
  00132	8b 12		 mov	 edx, DWORD PTR [edx]
  00134	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6081 :         _Hole             = _Idx;

  00137	8b 45 ec	 mov	 eax, DWORD PTR __Idx$6[ebp]
  0013a	89 45 f0	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  0013d	eb a2		 jmp	 SHORT $LN22@Pop_heap_h
$LN23@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013f	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00142	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00145	8b 45 f0	 mov	 eax, DWORD PTR __Hole$[ebp]
  00148	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0014b	8b 55 c8	 mov	 edx, DWORD PTR $T1[ebp]
  0014e	8b 12		 mov	 edx, DWORD PTR [edx]
  00150	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 6212 : }

  00153	5e		 pop	 esi
  00154	c9		 leave
  00155	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Refancy<std::pair<float,long> *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Refancy<std::pair<float,long> *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -180						; size = 4
__Tmp$2 = -176						; size = 4
$T3 = -172						; size = 4
$T4 = -168						; size = 4
$T5 = -164						; size = 4
__Tmp$6 = -160						; size = 4
$T7 = -156						; size = 4
$T8 = -152						; size = 4
$T9 = -148						; size = 4
__Tmp$10 = -144						; size = 4
$T11 = -140						; size = 4
$T12 = -136						; size = 4
$T13 = -132						; size = 4
__Tmp$14 = -128						; size = 4
$T15 = -124						; size = 4
$T16 = -120						; size = 4
$T17 = -116						; size = 4
__Tmp$18 = -112						; size = 4
$T19 = -108						; size = 4
$T20 = -104						; size = 4
$T21 = -100						; size = 4
$T22 = -96						; size = 4
$T23 = -92						; size = 4
__Tmp$24 = -88						; size = 4
$T25 = -84						; size = 4
$T26 = -80						; size = 4
__Left$ = -76						; size = 4
__Right$ = -72						; size = 4
$T27 = -68						; size = 4
__Tmp$28 = -64						; size = 4
$T29 = -60						; size = 4
$T30 = -56						; size = 4
__Right$ = -52						; size = 4
__Left$ = -48						; size = 4
__Right$ = -44						; size = 4
__Left$ = -40						; size = 4
__Right$ = -36						; size = 4
__Left$ = -32						; size = 4
__Left$ = -28						; size = 4
__Right$ = -24						; size = 4
__Right$ = -20						; size = 4
__Left$ = -16						; size = 4
__Right$ = -12						; size = 4
__Left$ = -8						; size = 4
__Right$ = -4						; size = 4
__Left$ = 0						; size = 4
__Left$ = 4						; size = 4
tv167 = 8						; size = 4
tv157 = 12						; size = 4
__Left$ = 16						; size = 4
tv146 = 20						; size = 4
tv137 = 24						; size = 4
tv131 = 28						; size = 4
tv91 = 32						; size = 4
tv83 = 36						; size = 4
tv214 = 40						; size = 4
__Mid$ = 44						; size = 4
__First$ = 48						; size = 4
__First$ = 52						; size = 4
__First$ = 56						; size = 4
__First$ = 60						; size = 4
__First$ = 64						; size = 4
__First$ = 68						; size = 4
__First$ = 72						; size = 4
__First$ = 76						; size = 4
$T31 = 80						; size = 1
$T32 = 81						; size = 1
$T33 = 82						; size = 1
$T34 = 83						; size = 1
$T35 = 84						; size = 1
$T36 = 85						; size = 1
$T37 = 86						; size = 1
$T38 = 87						; size = 1
__Glast$ = 88						; size = 4
__Gfirst$ = 92						; size = 4
__Plast$ = 96						; size = 4
__Pfirst$ = 100						; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000b	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  00011	c1 f8 02	 sar	 eax, 2
  00014	d1 f8		 sar	 eax, 1
  00016	8b 4d 74	 mov	 ecx, DWORD PTR __First$[ebp]
  00019	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0001c	89 45 2c	 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0001f	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00022	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00025	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  00028	83 e8 04	 sub	 eax, 4
  0002b	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  0002e	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  00031	ff 75 48	 push	 DWORD PTR __First$[ebp]
  00034	ff 75 2c	 push	 DWORD PTR __Mid$[ebp]
  00037	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0003a	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00042	8b 45 2c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00045	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00048	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0004b	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  0004e	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  00051	83 c0 04	 add	 eax, 4
  00054	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  00057	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  0005a	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0005d	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00060	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00063	0f 83 86 00 00
	00		 jae	 $LN4@Partition_
  00069	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0006c	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0006f	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00072	83 e8 04	 sub	 eax, 4
  00075	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00078	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0007b	89 45 e8	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0007e	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  00081	8b 4d e8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00088	7d 09		 jge	 SHORT $LN42@Partition_
  0008a	c7 45 28 01 00
	00 00		 mov	 DWORD PTR tv214[ebp], 1
  00091	eb 04		 jmp	 SHORT $LN43@Partition_
$LN42@Partition_:
  00093	83 65 28 00	 and	 DWORD PTR tv214[ebp], 0
$LN43@Partition_:
  00097	8a 45 28	 mov	 al, BYTE PTR tv214[ebp]
  0009a	88 45 50	 mov	 BYTE PTR $T31[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0009d	0f b6 45 50	 movzx	 eax, BYTE PTR $T31[ebp]
  000a1	85 c0		 test	 eax, eax
  000a3	75 4a		 jne	 SHORT $LN4@Partition_
  000a5	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000a8	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  000ab	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  000ae	83 e8 04	 sub	 eax, 4
  000b1	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000b4	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000b7	89 45 e4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ba	8b 45 e4	 mov	 eax, DWORD PTR __Left$[ebp]
  000bd	8b 4d 3c	 mov	 ecx, DWORD PTR __First$[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000c4	7d 09		 jge	 SHORT $LN49@Partition_
  000c6	c7 45 24 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  000cd	eb 04		 jmp	 SHORT $LN50@Partition_
$LN49@Partition_:
  000cf	83 65 24 00	 and	 DWORD PTR tv83[ebp], 0
$LN50@Partition_:
  000d3	8a 45 24	 mov	 al, BYTE PTR tv83[ebp]
  000d6	88 45 57	 mov	 BYTE PTR $T38[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000d9	0f b6 45 57	 movzx	 eax, BYTE PTR $T38[ebp]
  000dd	85 c0		 test	 eax, eax
  000df	75 0e		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  000e1	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000e4	83 e8 04	 sub	 eax, 4
  000e7	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  000ea	e9 6e ff ff ff	 jmp	 $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000ef	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000f2	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  000f5	73 71		 jae	 SHORT $LN5@Partition_
  000f7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000fa	89 45 dc	 mov	 DWORD PTR __Right$[ebp], eax
  000fd	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00100	89 45 e0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00103	8b 45 e0	 mov	 eax, DWORD PTR __Left$[ebp]
  00106	8b 4d dc	 mov	 ecx, DWORD PTR __Right$[ebp]
  00109	8b 00		 mov	 eax, DWORD PTR [eax]
  0010b	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0010d	7d 09		 jge	 SHORT $LN54@Partition_
  0010f	c7 45 20 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00116	eb 04		 jmp	 SHORT $LN55@Partition_
$LN54@Partition_:
  00118	83 65 20 00	 and	 DWORD PTR tv91[ebp], 0
$LN55@Partition_:
  0011c	8a 45 20	 mov	 al, BYTE PTR tv91[ebp]
  0011f	88 45 56	 mov	 BYTE PTR $T37[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00122	0f b6 45 56	 movzx	 eax, BYTE PTR $T37[ebp]
  00126	85 c0		 test	 eax, eax
  00128	75 3e		 jne	 SHORT $LN5@Partition_
  0012a	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0012d	89 45 d4	 mov	 DWORD PTR __Right$[ebp], eax
  00130	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00133	89 45 d8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00136	8b 45 d8	 mov	 eax, DWORD PTR __Left$[ebp]
  00139	8b 4d d4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00140	7d 09		 jge	 SHORT $LN59@Partition_
  00142	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00149	eb 04		 jmp	 SHORT $LN60@Partition_
$LN59@Partition_:
  0014b	83 65 1c 00	 and	 DWORD PTR tv131[ebp], 0
$LN60@Partition_:
  0014f	8a 45 1c	 mov	 al, BYTE PTR tv131[ebp]
  00152	88 45 55	 mov	 BYTE PTR $T36[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00155	0f b6 45 55	 movzx	 eax, BYTE PTR $T36[ebp]
  00159	85 c0		 test	 eax, eax
  0015b	75 0b		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  0015d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00160	83 c0 04	 add	 eax, 4
  00163	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  00166	eb 87		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  00168	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0016b	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  0016e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00171	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00174	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  00176	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00179	83 c0 04	 add	 eax, 4
  0017c	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  0017f	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00182	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00185	0f 83 ba 00 00
	00		 jae	 $LN10@Partition_

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0018b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0018e	89 45 d0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00191	8b 45 d0	 mov	 eax, DWORD PTR __Left$[ebp]
  00194	8b 4d 5c	 mov	 ecx, DWORD PTR __Gfirst$[ebp]
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0019b	7d 09		 jge	 SHORT $LN64@Partition_
  0019d	c7 45 18 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  001a4	eb 04		 jmp	 SHORT $LN65@Partition_
$LN64@Partition_:
  001a6	83 65 18 00	 and	 DWORD PTR tv137[ebp], 0
$LN65@Partition_:
  001aa	8a 45 18	 mov	 al, BYTE PTR tv137[ebp]
  001ad	88 45 54	 mov	 BYTE PTR $T35[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  001b0	0f b6 45 54	 movzx	 eax, BYTE PTR $T35[ebp]
  001b4	85 c0		 test	 eax, eax
  001b6	74 07		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  001b8	eb bc		 jmp	 SHORT $LN9@Partition_
  001ba	e9 81 00 00 00	 jmp	 $LN16@Partition_
$LN15@Partition_:

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  001bf	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  001c2	89 45 cc	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001c5	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  001c8	8b 4d cc	 mov	 ecx, DWORD PTR __Right$[ebp]
  001cb	8b 00		 mov	 eax, DWORD PTR [eax]
  001cd	3b 01		 cmp	 eax, DWORD PTR [ecx]
  001cf	7d 09		 jge	 SHORT $LN69@Partition_
  001d1	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv146[ebp], 1
  001d8	eb 04		 jmp	 SHORT $LN70@Partition_
$LN69@Partition_:
  001da	83 65 14 00	 and	 DWORD PTR tv146[ebp], 0
$LN70@Partition_:
  001de	8a 45 14	 mov	 al, BYTE PTR tv146[ebp]
  001e1	88 45 53	 mov	 BYTE PTR $T34[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  001e4	0f b6 45 53	 movzx	 eax, BYTE PTR $T34[ebp]
  001e8	85 c0		 test	 eax, eax
  001ea	74 04		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  001ec	eb 57		 jmp	 SHORT $LN10@Partition_
  001ee	eb 50		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  001f0	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001f3	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  001f6	74 3f		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  001f8	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001fb	89 45 10	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  001fe	8b 45 10	 mov	 eax, DWORD PTR __Left$[ebp]
  00201	89 45 c8	 mov	 DWORD PTR $T30[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00204	8b 45 c8	 mov	 eax, DWORD PTR $T30[ebp]
  00207	8b 00		 mov	 eax, DWORD PTR [eax]
  00209	89 45 c0	 mov	 DWORD PTR __Tmp$28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0020c	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0020f	89 45 c4	 mov	 DWORD PTR $T29[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00212	8b 45 10	 mov	 eax, DWORD PTR __Left$[ebp]
  00215	8b 4d c4	 mov	 ecx, DWORD PTR $T29[ebp]
  00218	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0021a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0021c	8d 45 c0	 lea	 eax, DWORD PTR __Tmp$28[ebp]
  0021f	89 45 bc	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00222	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00225	8b 4d bc	 mov	 ecx, DWORD PTR $T27[ebp]
  00228	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0022a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  0022c	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0022f	83 c0 04	 add	 eax, 4
  00232	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  00235	eb 09		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  00237	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0023a	83 c0 04	 add	 eax, 4
  0023d	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  00240	e9 31 ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  00245	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  00247	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0024a	83 e8 04	 sub	 eax, 4
  0024d	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  00250	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00253	3b 45 58	 cmp	 eax, DWORD PTR __Glast$[ebp]
  00256	0f 83 eb 00 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0025c	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0025f	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00262	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00265	83 e8 04	 sub	 eax, 4
  00268	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  0026b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0026e	89 45 b8	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00271	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00274	8b 4d b8	 mov	 ecx, DWORD PTR __Right$[ebp]
  00277	8b 00		 mov	 eax, DWORD PTR [eax]
  00279	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0027b	7d 09		 jge	 SHORT $LN90@Partition_
  0027d	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv157[ebp], 1
  00284	eb 04		 jmp	 SHORT $LN91@Partition_
$LN90@Partition_:
  00286	83 65 0c 00	 and	 DWORD PTR tv157[ebp], 0
$LN91@Partition_:
  0028a	8a 45 0c	 mov	 al, BYTE PTR tv157[ebp]
  0028d	88 45 52	 mov	 BYTE PTR $T33[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  00290	0f b6 45 52	 movzx	 eax, BYTE PTR $T33[ebp]
  00294	85 c0		 test	 eax, eax
  00296	74 07		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00298	eb ad		 jmp	 SHORT $LN12@Partition_
  0029a	e9 a3 00 00 00	 jmp	 $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0029f	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002a2	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  002a5	8b 45 34	 mov	 eax, DWORD PTR __First$[ebp]
  002a8	83 e8 04	 sub	 eax, 4
  002ab	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  002ae	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002b1	89 45 b4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  002b4	8b 45 b4	 mov	 eax, DWORD PTR __Left$[ebp]
  002b7	8b 4d 34	 mov	 ecx, DWORD PTR __First$[ebp]
  002ba	8b 00		 mov	 eax, DWORD PTR [eax]
  002bc	3b 01		 cmp	 eax, DWORD PTR [ecx]
  002be	7d 09		 jge	 SHORT $LN97@Partition_
  002c0	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  002c7	eb 04		 jmp	 SHORT $LN98@Partition_
$LN97@Partition_:
  002c9	83 65 08 00	 and	 DWORD PTR tv167[ebp], 0
$LN98@Partition_:
  002cd	8a 45 08	 mov	 al, BYTE PTR tv167[ebp]
  002d0	88 45 51	 mov	 BYTE PTR $T32[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  002d3	0f b6 45 51	 movzx	 eax, BYTE PTR $T32[ebp]
  002d7	85 c0		 test	 eax, eax
  002d9	74 04		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  002db	eb 6a		 jmp	 SHORT $LN13@Partition_
  002dd	eb 63		 jmp	 SHORT $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  002df	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002e2	83 e8 04	 sub	 eax, 4
  002e5	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  002e8	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  002eb	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  002ee	8b 45 30	 mov	 eax, DWORD PTR __First$[ebp]
  002f1	83 e8 04	 sub	 eax, 4
  002f4	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  002f7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002fa	3b 45 30	 cmp	 eax, DWORD PTR __First$[ebp]
  002fd	74 43		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  002ff	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00302	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00305	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00308	83 e8 04	 sub	 eax, 4
  0030b	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  0030e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00311	89 45 04	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00314	8b 45 04	 mov	 eax, DWORD PTR __Left$[ebp]
  00317	89 45 b0	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0031a	8b 45 b0	 mov	 eax, DWORD PTR $T26[ebp]
  0031d	8b 00		 mov	 eax, DWORD PTR [eax]
  0031f	89 45 a8	 mov	 DWORD PTR __Tmp$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00322	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  00325	89 45 ac	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00328	8b 45 04	 mov	 eax, DWORD PTR __Left$[ebp]
  0032b	8b 4d ac	 mov	 ecx, DWORD PTR $T25[ebp]
  0032e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00330	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00332	8d 45 a8	 lea	 eax, DWORD PTR __Tmp$24[ebp]
  00335	89 45 a4	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00338	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  0033b	8b 4d a4	 mov	 ecx, DWORD PTR $T23[ebp]
  0033e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00340	89 08		 mov	 DWORD PTR [eax], ecx
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  00342	e9 00 ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  00347	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0034a	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  0034d	75 31		 jne	 SHORT $LN26@Partition_
  0034f	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00352	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00355	75 29		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00357	8d 45 64	 lea	 eax, DWORD PTR __Pfirst$[ebp]
  0035a	89 45 a0	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0035d	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00360	8b 4d a0	 mov	 ecx, DWORD PTR $T22[ebp]
  00363	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00365	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00367	8d 45 60	 lea	 eax, DWORD PTR __Plast$[ebp]
  0036a	89 45 9c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0036d	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00370	8b 4d 9c	 mov	 ecx, DWORD PTR $T21[ebp]
  00373	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00375	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00378	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0037b	e9 d4 01 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  00380	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00383	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  00386	0f 85 9c 00 00
	00		 jne	 $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  0038c	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0038f	3b 45 5c	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00392	74 3a		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  00394	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00397	89 45 fc	 mov	 DWORD PTR __Right$[ebp], eax
  0039a	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0039d	89 45 00	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003a0	8b 45 00	 mov	 eax, DWORD PTR __Left$[ebp]
  003a3	89 45 98	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003a6	8b 45 98	 mov	 eax, DWORD PTR $T20[ebp]
  003a9	8b 00		 mov	 eax, DWORD PTR [eax]
  003ab	89 45 90	 mov	 DWORD PTR __Tmp$18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003ae	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  003b1	89 45 94	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003b4	8b 45 00	 mov	 eax, DWORD PTR __Left$[ebp]
  003b7	8b 4d 94	 mov	 ecx, DWORD PTR $T19[ebp]
  003ba	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003bc	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003be	8d 45 90	 lea	 eax, DWORD PTR __Tmp$18[ebp]
  003c1	89 45 8c	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  003c4	8b 45 fc	 mov	 eax, DWORD PTR __Right$[ebp]
  003c7	8b 4d 8c	 mov	 ecx, DWORD PTR $T17[ebp]
  003ca	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003cc	89 08		 mov	 DWORD PTR [eax], ecx
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  003ce	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  003d1	83 c0 04	 add	 eax, 4
  003d4	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  003d7	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  003da	89 45 f8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003dd	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  003e0	89 45 88	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  003e3	8b 45 88	 mov	 eax, DWORD PTR $T16[ebp]
  003e6	8b 00		 mov	 eax, DWORD PTR [eax]
  003e8	89 45 80	 mov	 DWORD PTR __Tmp$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003eb	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  003ee	89 45 84	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  003f1	8b 45 f8	 mov	 eax, DWORD PTR __Left$[ebp]
  003f4	8b 4d 84	 mov	 ecx, DWORD PTR $T15[ebp]
  003f7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003f9	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  003fb	8d 45 80	 lea	 eax, DWORD PTR __Tmp$14[ebp]
  003fe	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00404	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00407	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  0040d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0040f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  00411	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00414	83 c0 04	 add	 eax, 4
  00417	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  0041a	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0041d	83 c0 04	 add	 eax, 4
  00420	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
  00423	e9 27 01 00 00	 jmp	 $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00428	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0042b	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  0042e	0f 85 c3 00 00
	00		 jne	 $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  00434	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00437	83 e8 04	 sub	 eax, 4
  0043a	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
  0043d	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00440	83 e8 04	 sub	 eax, 4
  00443	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00446	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00449	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  0044c	74 4c		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  0044e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00451	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00454	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00457	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0045d	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00463	8b 00		 mov	 eax, DWORD PTR [eax]
  00465	89 85 70 ff ff
	ff		 mov	 DWORD PTR __Tmp$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0046b	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  0046e	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00474	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  00477	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  0047d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0047f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00481	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$10[ebp]
  00487	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0048d	8b 45 f4	 mov	 eax, DWORD PTR __Right$[ebp]
  00490	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00496	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00498	89 08		 mov	 DWORD PTR [eax], ecx
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  0049a	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0049d	83 e8 04	 sub	 eax, 4
  004a0	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
  004a3	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  004a6	89 45 ec	 mov	 DWORD PTR __Right$[ebp], eax
  004a9	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  004ac	89 45 f0	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004af	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  004b2	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  004b8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  004be	8b 00		 mov	 eax, DWORD PTR [eax]
  004c0	89 85 60 ff ff
	ff		 mov	 DWORD PTR __Tmp$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004c6	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  004c9	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  004cf	8b 45 f0	 mov	 eax, DWORD PTR __Left$[ebp]
  004d2	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  004d8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004da	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  004dc	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$6[ebp]
  004e2	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  004e8	8b 45 ec	 mov	 eax, DWORD PTR __Right$[ebp]
  004eb	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp]
  004f1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  004f3	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  004f5	eb 58		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  004f7	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  004fa	83 e8 04	 sub	 eax, 4
  004fd	89 45 58	 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00500	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00503	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00509	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0050f	8b 00		 mov	 eax, DWORD PTR [eax]
  00511	89 85 50 ff ff
	ff		 mov	 DWORD PTR __Tmp$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00517	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0051a	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00520	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00523	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00529	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0052b	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0052d	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Tmp$2[ebp]
  00533	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00539	8b 45 58	 mov	 eax, DWORD PTR __Glast$[ebp]
  0053c	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  00542	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00544	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  00546	8b 45 5c	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00549	83 c0 04	 add	 eax, 4
  0054c	89 45 5c	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  0054f	e9 20 fc ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  00554	83 c5 68	 add	 ebp, 104		; 00000068H
  00557	c9		 leave
  00558	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Val$2 = -16						; size = 4
$T3 = -12						; size = 4
__Bottom$ = -8						; size = 4
__Hole$4 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<int *,std::less<void> >, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	89 45 f8	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00012	8b 45 f8	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax
$LN4@Make_heap_:
  0001a	83 7d fc 00	 cmp	 DWORD PTR __Hole$4[ebp], 0
  0001e	7e 3a		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  00020	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  00023	48		 dec	 eax
  00024	89 45 fc	 mov	 DWORD PTR __Hole$4[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Hole$4[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00030	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00033	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 f0	 mov	 DWORD PTR __Val$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0003b	8d 45 f0	 lea	 eax, DWORD PTR __Val$2[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  00041	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  00044	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00047	ff 75 f8	 push	 DWORD PTR __Bottom$[ebp]
  0004a	ff 75 fc	 push	 DWORD PTR __Hole$4[ebp]
  0004d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
  00055	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  00058	eb c0		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  0005a	c9		 leave
  0005b	c3		 ret	 0
??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
tv71 = -36						; size = 4
tv92 = -32						; size = 4
__Val$6 = -28						; size = 4
__Dest$ = -24						; size = 4
__Prev$7 = -20						; size = 4
__Last$ = -16						; size = 4
__Mid$8 = -12						; size = 4
__Hole$9 = -8						; size = 4
$T10 = -2						; size = 1
$T11 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<int *,std::less<void> >, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000c	0f 84 1d 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00012	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR __Mid$8[ebp], eax
$LN4@Insertion_:
  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  0001b	83 c0 04	 add	 eax, 4
  0001e	89 45 f4	 mov	 DWORD PTR __Mid$8[ebp], eax
  00021	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00024	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00027	0f 84 02 01 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00030	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00033	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00036	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  00039	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e4	 mov	 DWORD PTR __Val$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00041	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00044	8b 4d e4	 mov	 ecx, DWORD PTR __Val$6[ebp]
  00047	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00049	7d 09		 jge	 SHORT $LN17@Insertion_
  0004b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  00052	eb 04		 jmp	 SHORT $LN18@Insertion_
$LN17@Insertion_:
  00054	83 65 e0 00	 and	 DWORD PTR tv92[ebp], 0
$LN18@Insertion_:
  00058	8a 45 e0	 mov	 al, BYTE PTR tv92[ebp]
  0005b	88 45 ff	 mov	 BYTE PTR $T11[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0005e	0f b6 45 ff	 movzx	 eax, BYTE PTR $T11[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 66		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00066	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00069	83 c0 04	 add	 eax, 4
  0006c	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
  0006f	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00072	89 45 e8	 mov	 DWORD PTR __Dest$[ebp], eax
  00075	8b 45 f4	 mov	 eax, DWORD PTR __Mid$8[ebp]
  00078	89 45 f0	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  0007b	ff 75 e8	 push	 DWORD PTR __Dest$[ebp]
  0007e	ff 75 f0	 push	 DWORD PTR __Last$[ebp]
  00081	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00084	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
  00089	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008c	eb 2c		 jmp	 SHORT $LN20@Insertion_
$LN21@Insertion_:

; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  0008e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00091	3b 45 f0	 cmp	 eax, DWORD PTR __Last$[ebp]
  00094	74 24		 je	 SHORT $LN20@Insertion_

; 4701 :         *--_Dest = _STD move(*--_Last);

  00096	8b 45 f0	 mov	 eax, DWORD PTR __Last$[ebp]
  00099	83 e8 04	 sub	 eax, 4
  0009c	89 45 f0	 mov	 DWORD PTR __Last$[ebp], eax
  0009f	8b 45 e8	 mov	 eax, DWORD PTR __Dest$[ebp]
  000a2	83 e8 04	 sub	 eax, 4
  000a5	89 45 e8	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000a8	8b 45 f0	 mov	 eax, DWORD PTR __Last$[ebp]
  000ab	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4701 :         *--_Dest = _STD move(*--_Last);

  000ae	8b 45 e8	 mov	 eax, DWORD PTR __Dest$[ebp]
  000b1	8b 4d d4	 mov	 ecx, DWORD PTR $T4[ebp]
  000b4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000b6	89 08		 mov	 DWORD PTR [eax], ecx

; 4702 :     }

  000b8	eb d4		 jmp	 SHORT $LN21@Insertion_
$LN20@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000ba	8d 45 e4	 lea	 eax, DWORD PTR __Val$6[ebp]
  000bd	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000c0	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000c3	8b 4d d0	 mov	 ecx, DWORD PTR $T3[ebp]
  000c6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c8	89 08		 mov	 DWORD PTR [eax], ecx

; 7420 :             } else { // look for insertion point after first

  000ca	eb 5e		 jmp	 SHORT $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000cc	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  000cf	89 45 ec	 mov	 DWORD PTR __Prev$7[ebp], eax
  000d2	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000d4	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000d7	89 45 f8	 mov	 DWORD PTR __Hole$9[ebp], eax
$LN7@Insertion_:
  000da	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000dd	83 e8 04	 sub	 eax, 4
  000e0	89 45 ec	 mov	 DWORD PTR __Prev$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e3	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  000e6	8b 4d e4	 mov	 ecx, DWORD PTR __Val$6[ebp]
  000e9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000eb	7d 09		 jge	 SHORT $LN32@Insertion_
  000ed	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  000f4	eb 04		 jmp	 SHORT $LN33@Insertion_
$LN32@Insertion_:
  000f6	83 65 dc 00	 and	 DWORD PTR tv71[ebp], 0
$LN33@Insertion_:
  000fa	8a 45 dc	 mov	 al, BYTE PTR tv71[ebp]
  000fd	88 45 fe	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00100	0f b6 45 fe	 movzx	 eax, BYTE PTR $T10[ebp]
  00104	85 c0		 test	 eax, eax
  00106	74 12		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00108	8b 45 ec	 mov	 eax, DWORD PTR __Prev$7[ebp]
  0010b	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  0010e	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00111	8b 4d cc	 mov	 ecx, DWORD PTR $T2[ebp]
  00114	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00116	89 08		 mov	 DWORD PTR [eax], ecx

; 7423 :                 }

  00118	eb ba		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0011a	8d 45 e4	 lea	 eax, DWORD PTR __Val$6[ebp]
  0011d	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  00120	8b 45 f8	 mov	 eax, DWORD PTR __Hole$9[ebp]
  00123	8b 4d c8	 mov	 ecx, DWORD PTR $T1[ebp]
  00126	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00128	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Insertion_:

; 7426 :             }
; 7427 :         }

  0012a	e9 e9 fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  0012f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  00132	c9		 leave
  00133	c3		 ret	 0
??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z PROC		; std::_Refancy<int *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ENDP		; std::_Refancy<int *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<int *,std::less<void> >, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	c1 f8 02	 sar	 eax, 2
  0000f	83 f8 20	 cmp	 eax, 32			; 00000020H
  00012	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00014	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00017	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001d	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAHU?$less@X@std@@@std@@YAPAHQAH0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<int *,std::less<void> >
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00025	e9 c1 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002a	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  0002e	7f 45		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00030	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00033	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00036	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00039	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Make_heap_unchecked<int *,std::less<void> >
  0003e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00041	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00044	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00047	eb 09		 jmp	 SHORT $LN64@Sort_unche
$LN62@Sort_unche:
  00049	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  0004c	83 e8 04	 sub	 eax, 4
  0004f	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN64@Sort_unche:
  00052	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00055	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00058	c1 f8 02	 sar	 eax, 2
  0005b	83 f8 02	 cmp	 eax, 2
  0005e	7c 13		 jl	 SHORT $LN61@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00060	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00063	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  00066	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<int *,std::less<void> >
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00071	eb d6		 jmp	 SHORT $LN62@Sort_unche
$LN61@Sort_unche:

; 7548 :             return;

  00073	eb 76		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  00075	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00078	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0007b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007e	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00081	50		 push	 eax
  00082	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
  00087	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  0008a	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  0008d	d1 f8		 sar	 eax, 1
  0008f	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00092	c1 f9 02	 sar	 ecx, 2
  00095	03 c1		 add	 eax, ecx
  00097	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  0009a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0009d	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a0	c1 f8 02	 sar	 eax, 2
  000a3	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  000a6	2b 4d f8	 sub	 ecx, DWORD PTR __Mid$1[ebp+4]
  000a9	c1 f9 02	 sar	 ecx, 2
  000ac	3b c1		 cmp	 eax, ecx
  000ae	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000b0	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b3	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000b6	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000b9	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000c7	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000ca	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000cc	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000cf	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000d2	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000d5	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000d8	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  000dd	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000e0	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000e3	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000e6	e9 1b ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000eb	c9		 leave
  000ec	c3		 ret	 0
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z
_TEXT	SEGMENT
__It$ = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -48						; size = 4
__Ptr$3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Ptr$6 = -32						; size = 4
tv144 = -28						; size = 4
__Count2$7 = -24					; size = 4
__First$ = -20						; size = 4
__First$ = -16						; size = 4
__UFirst$ = -12						; size = 4
__UMid$8 = -8						; size = 4
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z PROC ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >, COMDAT

; 6725 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 e0	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6728 :     auto _UFirst                = _Get_unwrapped(_First);

  00018	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 d4	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00030	8b 45 cc	 mov	 eax, DWORD PTR $T1[ebp]
  00033	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00036	c1 f8 03	 sar	 eax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6729 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

  00039	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@upper_boun:

; 6730 : 
; 6731 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0003c	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00040	0f 8e 92 00 00
	00		 jle	 $LN3@upper_boun

; 6732 :         _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00046	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	d1 f8		 sar	 eax, 1
  0004e	89 45 e8	 mov	 DWORD PTR __Count2$7[ebp], eax

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  00051	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00054	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00057	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR __First$[ebp]
  0005d	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00060	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);

  00063	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00066	89 45 f8	 mov	 DWORD PTR __UMid$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00069	8b 45 f8	 mov	 eax, DWORD PTR __UMid$8[ebp]
  0006c	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  0006f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00073	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00076	77 23		 ja	 SHORT $LN36@upper_boun
  00078	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __UMid$8[ebp]
  0007e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00082	0f 2f 01	 comiss	 xmm0, DWORD PTR [ecx]
  00085	77 0e		 ja	 SHORT $LN35@upper_boun
  00087	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0008a	8b 4d f8	 mov	 ecx, DWORD PTR __UMid$8[ebp]
  0008d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00090	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00093	7c 06		 jl	 SHORT $LN36@upper_boun
$LN35@upper_boun:
  00095	83 65 e4 00	 and	 DWORD PTR tv144[ebp], 0
  00099	eb 07		 jmp	 SHORT $LN37@upper_boun
$LN36@upper_boun:
  0009b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv144[ebp], 1
$LN37@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6734 :         if (_Pred(_Val, *_UMid)) {

  000a2	0f b6 45 e4	 movzx	 eax, BYTE PTR tv144[ebp]
  000a6	85 c0		 test	 eax, eax
  000a8	74 08		 je	 SHORT $LN4@upper_boun

; 6735 :             _Count = _Count2;

  000aa	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  000ad	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 6736 :         } else { // try top half

  000b0	eb 21		 jmp	 SHORT $LN5@upper_boun
$LN4@upper_boun:

; 6737 :             _UFirst = _Next_iter(_UMid);

  000b2	8b 45 f8	 mov	 eax, DWORD PTR __UMid$8[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  000b8	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000bb	83 c0 08	 add	 eax, 8
  000be	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6737 :             _UFirst = _Next_iter(_UMid);

  000c1	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  000c4	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 6738 :             _Count -= _Count2 + 1;

  000c7	8b 45 e8	 mov	 eax, DWORD PTR __Count2$7[ebp]
  000ca	40		 inc	 eax
  000cb	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  000ce	2b c8		 sub	 ecx, eax
  000d0	89 4d fc	 mov	 DWORD PTR __Count$[ebp], ecx
$LN5@upper_boun:

; 6739 :         }
; 6740 :     }

  000d3	e9 64 ff ff ff	 jmp	 $LN2@upper_boun
$LN3@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  000d8	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000db	89 45 c8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  000de	ff 75 c8	 push	 DWORD PTR __It$[ebp]
  000e1	e8 00 00 00 00	 call	 ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
  000e6	59		 pop	 ecx
  000e7	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6743 :     return _First;

  000ea	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ed	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  000f0	89 08		 mov	 DWORD PTR [eax], ecx
  000f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 6744 : }

  000f5	c9		 leave
  000f6	c3		 ret	 0
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ENDP ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::vector<int,std::allocator<int> >::emplace_back<int const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABH@?$vector@HV?$allocator@H@std@@@std@@AAEXABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z PROC ; std::_Const_cast<std::pair<float,long> const >, COMDAT

; 292  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 294  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ENDP ; std::_Const_cast<std::pair<float,long> const >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z
_TEXT	SEGMENT
__It$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Ptr$5 = -20						; size = 4
$T6 = -16						; size = 4
__Ptr$7 = -12						; size = 4
__First$ = -8						; size = 4
$T8 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>, COMDAT

; 5478 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  00015	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00018	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR __Ptr$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$5[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00027	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  0002a	33 c0		 xor	 eax, eax
  0002c	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
  0002f	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00032	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 5439 :     for (; _First != _Last; ++_First) {

  00035	eb 09		 jmp	 SHORT $LN26@find
$LN24@find:
  00037	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0003a	83 c0 04	 add	 eax, 4
  0003d	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax
$LN26@find:
  00040	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  00043	3b 45 e0	 cmp	 eax, DWORD PTR $T2[ebp]
  00046	74 10		 je	 SHORT $LN21@find

; 5440 :         if (*_First == _Val) {

  00048	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0004b	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00052	75 02		 jne	 SHORT $LN27@find

; 5441 :             break;

  00054	eb 02		 jmp	 SHORT $LN21@find
$LN27@find:

; 5442 :         }
; 5443 :     }

  00056	eb df		 jmp	 SHORT $LN24@find
$LN21@find:

; 5479 :     _Adl_verify_range(_First, _Last);
; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  00058	8b 45 f8	 mov	 eax, DWORD PTR __First$[ebp]
  0005b	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0005e	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  00061	89 45 d8	 mov	 DWORD PTR __It$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00064	ff 75 d8	 push	 DWORD PTR __It$[ebp]
  00067	e8 00 00 00 00	 call	 ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ; std::_Refancy<int *,0>
  0006c	59		 pop	 ecx
  0006d	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5481 :     return _First;

  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
  00078	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5482 : }

  0007b	c9		 leave
  0007c	c3		 ret	 0
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -52						; size = 1
$T2 = -48						; size = 4
$T3 = -44						; size = 4
__Ptr$4 = -40						; size = 4
__Last$ = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
__Ptr$7 = -24						; size = 4
__First$ = -20						; size = 4
__UFirst$8 = -16					; size = 4
__ULast$9 = -12						; size = 4
__Pred$ = -8						; size = 1
$T10 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 7575 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last) { // order [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 7576 :     _STD sort(_First, _Last, less<>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
  0000b	8a 45 ff	 mov	 al, BYTE PTR $T10[ebp]
  0000e	88 45 f8	 mov	 BYTE PTR __Pred$[ebp], al
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	89 45 dc	 mov	 DWORD PTR __Last$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001d	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  00020	89 45 e8	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00023	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00029	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  0002c	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  0002f	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00032	89 45 f0	 mov	 DWORD PTR __UFirst$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00035	8b 45 dc	 mov	 eax, DWORD PTR __Last$[ebp]
  00038	89 45 d8	 mov	 DWORD PTR __Ptr$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  0003e	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00041	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00044	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  00047	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0004a	89 45 f4	 mov	 DWORD PTR __ULast$9[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  0004d	8a 45 f8	 mov	 al, BYTE PTR __Pred$[ebp]
  00050	88 45 cc	 mov	 BYTE PTR $T1[ebp], al
  00053	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  00056	8b 45 f4	 mov	 eax, DWORD PTR __ULast$9[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR __UFirst$8[ebp]
  0005c	c1 f8 02	 sar	 eax, 2
  0005f	50		 push	 eax
  00060	ff 75 f4	 push	 DWORD PTR __ULast$9[ebp]
  00063	ff 75 f0	 push	 DWORD PTR __UFirst$8[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
  0006b	83 c4 10	 add	 esp, 16			; 00000010H

; 7577 : }

  0006e	c9		 leave
  0006f	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpVertexBuffer.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
_pkVB$ = -16						; size = 4
_pTerrainPatchProxy$ = -12				; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
_patchnum$ = 8						; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone, COMDAT
; _this$ = ecx

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 684  : 	assert(NULL!=m_pTerrainPatchProxyList && "__HardwareTransformPatch_RenderPatchNone");
; 685  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00009	6b 45 08 1c	 imul	 eax, DWORD PTR _patchnum$[ebp], 28
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00013	89 45 f4	 mov	 DWORD PTR _pTerrainPatchProxy$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  00016	8b 45 f4	 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00019	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  0001c	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 687  : 	if (!pTerrainPatchProxy->isUsed())

  0001f	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00023	85 c0		 test	 eax, eax
  00025	75 02		 jne	 SHORT $LN2@HardwareTr

; 688  : 		return;

  00027	eb 55		 jmp	 SHORT $LN1@HardwareTr
$LN2@HardwareTr:

; 689  : 
; 690  : 	CGraphicVertexBuffer* pkVB=pTerrainPatchProxy->HardwareTransformPatch_GetVertexBufferPtr();

  00029	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrainPatchProxy$[ebp]
  0002c	e8 00 00 00 00	 call	 ?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
  00031	89 45 f0	 mov	 DWORD PTR _pkVB$[ebp], eax

; 691  : 	if (!pkVB)

  00034	83 7d f0 00	 cmp	 DWORD PTR _pkVB$[ebp], 0
  00038	75 02		 jne	 SHORT $LN3@HardwareTr

; 692  : 		return;

  0003a	eb 42		 jmp	 SHORT $LN1@HardwareTr
$LN3@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpVertexBuffer.h

; 33   : 		inline	LPDIRECT3DVERTEXBUFFER8 GetD3DVertexBuffer() const	{ return m_lpd3dVB; }

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _pkVB$[ebp]
  0003f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00042	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 694  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	ff b0 a8 09 00
	00		 push	 DWORD PTR [eax+2472]
  0004e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00051	6a 00		 push	 0
  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00059	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 695  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  0005e	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00062	50		 push	 eax
  00063	6a 00		 push	 0
  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  0006e	6a 00		 push	 0
  00070	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00073	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00079	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN1@HardwareTr:

; 696  : }

  0007e	c9		 leave
  0007f	c2 0c 00	 ret	 12			; 0000000cH
?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpVertexBuffer.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
$T1 = -536						; size = 4
$T2 = -532						; size = 4
$T3 = -528						; size = 4
_this$ = -524						; size = 4
$T4 = -520						; size = 4
_dwB$5 = -516						; size = 4
_dwA$6 = -512						; size = 4
_dwR$7 = -508						; size = 4
$T8 = -504						; size = 4
_iPrevRenderedSplatNum$ = -500				; size = 4
$T9 = -496						; size = 4
$T10 = -492						; size = 4
_aIterator$11 = -488					; size = 4
$T12 = -484						; size = 4
_dwG$13 = -480						; size = 4
___param0$ = -476					; size = 4
$T14 = -472						; size = 4
$T15 = -468						; size = 4
$T16 = -464						; size = 4
$T17 = -460						; size = 4
___param0$ = -456					; size = 4
$T18 = -452						; size = 4
___param0$ = -448					; size = 4
tv651 = -444						; size = 4
tv650 = -440						; size = 4
tv640 = -436						; size = 4
tv639 = -432						; size = 4
_ucTerrainNum$ = -428					; size = 1
_iCurRenderedSplatNum$ = -424				; size = 4
_dwFogColor$ = -420					; size = 4
tv800 = -416						; size = 4
__My_data$19 = -412					; size = 4
__My_data$20 = -408					; size = 4
__My_data$21 = -404					; size = 4
_rTerrainSplatPatch$ = -400				; size = 4
_sPatchNum$ = -396					; size = 4
_pkVB$ = -392						; size = 4
tv673 = -388						; size = 4
tv672 = -384						; size = 4
tv662 = -380						; size = 4
tv661 = -376						; size = 4
_rSplat$22 = -372					; size = 4
_rTexture$23 = -368					; size = 4
_wCoordY$ = -364					; size = 2
_wCoordX$ = -360					; size = 2
$T24 = -354						; size = 2
_pTerrainPatchProxy$ = -352				; size = 4
_pTerrain$ = -348					; size = 4
$T25 = -342						; size = 1
$T26 = -341						; size = 1
_j$27 = -340						; size = 4
_isFirst$ = -333					; size = 1
_this$ = -332						; size = 4
_this$ = -328						; size = 4
_matSplatAlphaTexTransform$ = -324			; size = 64
_matShadowTexTransform$28 = -260			; size = 64
_matTexTransform$ = -196				; size = 64
_matSplatColorTexTransform$ = -132			; size = 64
_matTiling$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_patchnum$ = 8						; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 18 02 00
	00		 sub	 esp, 536		; 00000218H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 257  : 	assert(NULL!=m_pTerrainPatchProxyList && "__HardwareTransformPatch_RenderPatchSplat");
; 258  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00019	6b 45 08 1c	 imul	 eax, DWORD PTR _patchnum$[ebp], 28
  0001d	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00023	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00026	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _pTerrainPatchProxy$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 170  : 	bool isUsed()																	{ return m_bUsed; }

  0002c	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00032	8a 40 04	 mov	 al, BYTE PTR [eax+4]
  00035	88 85 ab fe ff
	ff		 mov	 BYTE PTR $T26[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 260  : 	if (!pTerrainPatchProxy->isUsed())

  0003b	0f b6 85 ab fe
	ff ff		 movzx	 eax, BYTE PTR $T26[ebp]
  00042	85 c0		 test	 eax, eax
  00044	75 05		 jne	 SHORT $LN5@HardwareTr

; 261  : 		return;

  00046	e9 3c 0b 00 00	 jmp	 $LN1@HardwareTr
$LN5@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 173  : 	short GetPatchNum()																{ return m_sPatchNum; }

  0004b	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  00051	66 8b 40 06	 mov	 ax, WORD PTR [eax+6]
  00055	66 89 85 9e fe
	ff ff		 mov	 WORD PTR $T24[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 263  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();

  0005c	0f bf 85 9e fe
	ff ff		 movsx	 eax, WORD PTR $T24[ebp]
  00063	89 85 74 fe ff
	ff		 mov	 DWORD PTR _sPatchNum$[ebp], eax

; 264  : 	if (sPatchNum < 0)

  00069	83 bd 74 fe ff
	ff 00		 cmp	 DWORD PTR _sPatchNum$[ebp], 0
  00070	7d 05		 jge	 SHORT $LN6@HardwareTr

; 265  : 		return;

  00072	e9 10 0b 00 00	 jmp	 $LN1@HardwareTr
$LN6@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\TerrainPatch.h

; 176  : 	BYTE GetTerrainNum()															{ return m_byTerrainNum; }

  00077	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrainPatchProxy$[ebp]
  0007d	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  00080	88 85 54 fe ff
	ff		 mov	 BYTE PTR _ucTerrainNum$[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 268  : 	if (0xFF == ucTerrainNum)

  00086	0f b6 85 54 fe
	ff ff		 movzx	 eax, BYTE PTR _ucTerrainNum$[ebp]
  0008d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00092	75 05		 jne	 SHORT $LN7@HardwareTr

; 269  : 		return;

  00094	e9 ee 0a 00 00	 jmp	 $LN1@HardwareTr
$LN7@HardwareTr:

; 270  : 
; 271  : 	CTerrain * pTerrain;
; 272  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  00099	8d 85 a4 fe ff
	ff		 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0009f	50		 push	 eax
  000a0	ff b5 54 fe ff
	ff		 push	 DWORD PTR _ucTerrainNum$[ebp]
  000a6	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000b1	85 c0		 test	 eax, eax
  000b3	75 05		 jne	 SHORT $LN8@HardwareTr

; 273  : 		return;

  000b5	e9 cd 0a 00 00	 jmp	 $LN1@HardwareTr
$LN8@HardwareTr:

; 274  : 
; 275  : 	DWORD dwFogColor;
; 276  : 	if (mc_pEnvironmentData)

  000ba	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000c0	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  000c4	0f 84 16 02 00
	00		 je	 $LN9@HardwareTr

; 277  : 		dwFogColor=mc_pEnvironmentData->FogColor;

  000ca	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000d3	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  000d8	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  000de	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000e8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000ef	72 0c		 jb	 SHORT $LN33@HardwareTr
  000f1	c7 85 4c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv640[ebp], 255 ; 000000ffH
  000fb	eb 48		 jmp	 SHORT $LN34@HardwareTr
$LN33@HardwareTr:
  000fd	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00103	0f 57 c0	 xorps	 xmm0, xmm0
  00106	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00109	72 09		 jb	 SHORT $LN31@HardwareTr
  0010b	83 a5 50 fe ff
	ff 00		 and	 DWORD PTR tv639[ebp], 0
  00112	eb 25		 jmp	 SHORT $LN32@HardwareTr
$LN31@HardwareTr:
  00114	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0011a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0011e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00126	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0012e	e8 00 00 00 00	 call	 __ftoui3
  00133	89 85 50 fe ff
	ff		 mov	 DWORD PTR tv639[ebp], eax
$LN32@HardwareTr:
  00139	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv639[ebp]
  0013f	89 85 4c fe ff
	ff		 mov	 DWORD PTR tv640[ebp], eax
$LN34@HardwareTr:
  00145	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv640[ebp]
  0014b	89 85 04 fe ff
	ff		 mov	 DWORD PTR _dwR$7[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00151	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0015c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00163	72 0c		 jb	 SHORT $LN37@HardwareTr
  00165	c7 85 44 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv651[ebp], 255 ; 000000ffH
  0016f	eb 4a		 jmp	 SHORT $LN38@HardwareTr
$LN37@HardwareTr:
  00171	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00177	0f 57 c0	 xorps	 xmm0, xmm0
  0017a	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  0017e	72 09		 jb	 SHORT $LN35@HardwareTr
  00180	83 a5 48 fe ff
	ff 00		 and	 DWORD PTR tv650[ebp], 0
  00187	eb 26		 jmp	 SHORT $LN36@HardwareTr
$LN35@HardwareTr:
  00189	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0018f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00194	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0019c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001a4	e8 00 00 00 00	 call	 __ftoui3
  001a9	89 85 48 fe ff
	ff		 mov	 DWORD PTR tv650[ebp], eax
$LN36@HardwareTr:
  001af	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv650[ebp]
  001b5	89 85 44 fe ff
	ff		 mov	 DWORD PTR tv651[ebp], eax
$LN38@HardwareTr:
  001bb	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv651[ebp]
  001c1	89 85 20 fe ff
	ff		 mov	 DWORD PTR _dwG$13[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  001c7	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001cd	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001d2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  001d9	72 0c		 jb	 SHORT $LN41@HardwareTr
  001db	c7 85 84 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv662[ebp], 255 ; 000000ffH
  001e5	eb 4a		 jmp	 SHORT $LN42@HardwareTr
$LN41@HardwareTr:
  001e7	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ed	0f 57 c0	 xorps	 xmm0, xmm0
  001f0	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  001f4	72 09		 jb	 SHORT $LN39@HardwareTr
  001f6	83 a5 88 fe ff
	ff 00		 and	 DWORD PTR tv661[ebp], 0
  001fd	eb 26		 jmp	 SHORT $LN40@HardwareTr
$LN39@HardwareTr:
  001ff	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00205	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0020a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00212	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0021a	e8 00 00 00 00	 call	 __ftoui3
  0021f	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv661[ebp], eax
$LN40@HardwareTr:
  00225	8b 85 88 fe ff
	ff		 mov	 eax, DWORD PTR tv661[ebp]
  0022b	89 85 84 fe ff
	ff		 mov	 DWORD PTR tv662[ebp], eax
$LN42@HardwareTr:
  00231	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv662[ebp]
  00237	89 85 fc fd ff
	ff		 mov	 DWORD PTR _dwB$5[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0023d	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00243	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00248	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0024f	72 0c		 jb	 SHORT $LN45@HardwareTr
  00251	c7 85 7c fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv673[ebp], 255 ; 000000ffH
  0025b	eb 4a		 jmp	 SHORT $LN46@HardwareTr
$LN45@HardwareTr:
  0025d	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00263	0f 57 c0	 xorps	 xmm0, xmm0
  00266	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0026a	72 09		 jb	 SHORT $LN43@HardwareTr
  0026c	83 a5 80 fe ff
	ff 00		 and	 DWORD PTR tv672[ebp], 0
  00273	eb 26		 jmp	 SHORT $LN44@HardwareTr
$LN43@HardwareTr:
  00275	8b 85 b4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0027b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00280	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00288	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00290	e8 00 00 00 00	 call	 __ftoui3
  00295	89 85 80 fe ff
	ff		 mov	 DWORD PTR tv672[ebp], eax
$LN44@HardwareTr:
  0029b	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv672[ebp]
  002a1	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv673[ebp], eax
$LN46@HardwareTr:
  002a7	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR tv673[ebp]
  002ad	89 85 00 fe ff
	ff		 mov	 DWORD PTR _dwA$6[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  002b3	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR _dwG$13[ebp]
  002b9	c1 e0 08	 shl	 eax, 8
  002bc	8b 8d 04 fe ff
	ff		 mov	 ecx, DWORD PTR _dwR$7[ebp]
  002c2	c1 e1 10	 shl	 ecx, 16			; 00000010H
  002c5	8b 95 00 fe ff
	ff		 mov	 edx, DWORD PTR _dwA$6[ebp]
  002cb	c1 e2 18	 shl	 edx, 24			; 00000018H
  002ce	0b d1		 or	 edx, ecx
  002d0	0b d0		 or	 edx, eax
  002d2	0b 95 fc fd ff
	ff		 or	 edx, DWORD PTR _dwB$5[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 277  : 		dwFogColor=mc_pEnvironmentData->FogColor;

  002d8	89 95 5c fe ff
	ff		 mov	 DWORD PTR _dwFogColor$[ebp], edx
  002de	eb 07		 jmp	 SHORT $LN10@HardwareTr
$LN9@HardwareTr:

; 278  : 	else
; 279  : 		dwFogColor=0xffffffff;

  002e0	83 8d 5c fe ff
	ff ff		 or	 DWORD PTR _dwFogColor$[ebp], -1
$LN10@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 92   : 			*usCoordX = m_wX;

  002e7	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  002ed	66 8b 80 6c a5
	06 00		 mov	 ax, WORD PTR [eax+435564]
  002f4	66 89 85 98 fe
	ff ff		 mov	 WORD PTR _wCoordX$[ebp], ax

; 93   : 			*usCoordY = m_wY;

  002fb	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00301	66 8b 80 6e a5
	06 00		 mov	 ax, WORD PTR [eax+435566]
  00308	66 89 85 94 fe
	ff ff		 mov	 WORD PTR _wCoordY$[ebp], ax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 86   : 		TTerrainSplatPatch &	GetTerrainSplatPatch() {return m_TerrainSplatPatch;}

  0030f	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00315	05 3c 91 03 00	 add	 eax, 233788		; 0003913cH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 284  : 	TTerrainSplatPatch & rTerrainSplatPatch = pTerrain->GetTerrainSplatPatch();

  0031a	89 85 70 fe ff
	ff		 mov	 DWORD PTR _rTerrainSplatPatch$[ebp], eax

; 285  : 	
; 286  : 	D3DXMATRIX matTexTransform, matSplatAlphaTexTransform, matSplatColorTexTransform;
; 287  : 	m_matWorldForCommonUse._41 = -(float) (wCoordX * CTerrainImpl::TERRAIN_XSIZE);

  00320	0f b7 85 98 fe
	ff ff		 movzx	 eax, WORD PTR _wCoordX$[ebp]
  00327	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0032d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00331	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00338	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0033e	f3 0f 11 80 78
	07 00 00	 movss	 DWORD PTR [eax+1912], xmm0

; 288  : 	m_matWorldForCommonUse._42 = (float) (wCoordY * CTerrainImpl::TERRAIN_YSIZE);

  00346	0f b7 85 94 fe
	ff ff		 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0034d	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00353	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00357	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0035d	f3 0f 11 80 7c
	07 00 00	 movss	 DWORD PTR [eax+1916], xmm0

; 289  : 	D3DXMatrixMultiply(&matTexTransform, &m_matViewInverse, &m_matWorldForCommonUse);

  00365	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0036b	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  00370	50		 push	 eax
  00371	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00377	05 88 07 00 00	 add	 eax, 1928		; 00000788H
  0037c	50		 push	 eax
  0037d	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  00383	50		 push	 eax
  00384	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 290  : 	D3DXMatrixMultiply(&matSplatAlphaTexTransform, &matTexTransform, &m_matSplatAlpha);

  00389	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0038f	05 c8 07 00 00	 add	 eax, 1992		; 000007c8H
  00394	50		 push	 eax
  00395	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  0039b	50		 push	 eax
  0039c	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _matSplatAlphaTexTransform$[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 291  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &matSplatAlphaTexTransform);

  003a8	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _matSplatAlphaTexTransform$[ebp]
  003ae	50		 push	 eax
  003af	6a 11		 push	 17			; 00000011H
  003b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003b7	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 292  : 
; 293  : 	D3DXMATRIX matTiling;
; 294  : 	D3DXMatrixScaling(&matTiling, 1.0f/640.0f, -1.0f/640.0f, 0.0f);

  003bc	51		 push	 ecx
  003bd	0f 57 c0	 xorps	 xmm0, xmm0
  003c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c5	51		 push	 ecx
  003c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bacccccd
  003ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003d3	51		 push	 ecx
  003d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3acccccd
  003dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e1	8d 45 bc	 lea	 eax, DWORD PTR _matTiling$[ebp]
  003e4	50		 push	 eax
  003e5	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 295  : 	matTiling._41=0.0f;

  003ea	0f 57 c0	 xorps	 xmm0, xmm0
  003ed	f3 0f 11 45 ec	 movss	 DWORD PTR _matTiling$[ebp+48], xmm0

; 296  : 	matTiling._42=0.0f;

  003f2	0f 57 c0	 xorps	 xmm0, xmm0
  003f5	f3 0f 11 45 f0	 movss	 DWORD PTR _matTiling$[ebp+52], xmm0

; 297  : 	
; 298  : 	D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &matTiling);

  003fa	8d 45 bc	 lea	 eax, DWORD PTR _matTiling$[ebp]
  003fd	50		 push	 eax
  003fe	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00404	05 88 07 00 00	 add	 eax, 1928		; 00000788H
  00409	50		 push	 eax
  0040a	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  00410	50		 push	 eax
  00411	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 299  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);

  00416	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  0041c	50		 push	 eax
  0041d	6a 10		 push	 16			; 00000010H
  0041f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00425	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 300  : 					
; 301  : 	CGraphicVertexBuffer* pkVB=pTerrainPatchProxy->HardwareTransformPatch_GetVertexBufferPtr();

  0042a	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR _pTerrainPatchProxy$[ebp]
  00430	e8 00 00 00 00	 call	 ?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
  00435	89 85 78 fe ff
	ff		 mov	 DWORD PTR _pkVB$[ebp], eax

; 302  : 	if (!pkVB)

  0043b	83 bd 78 fe ff
	ff 00		 cmp	 DWORD PTR _pkVB$[ebp], 0
  00442	75 05		 jne	 SHORT $LN11@HardwareTr

; 303  : 		return;

  00444	e9 3e 07 00 00	 jmp	 $LN1@HardwareTr
$LN11@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\GrpVertexBuffer.h

; 33   : 		inline	LPDIRECT3DVERTEXBUFFER8 GetD3DVertexBuffer() const	{ return m_lpd3dVB; }

  00449	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR _pkVB$[ebp]
  0044f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00452	89 85 f8 fd ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 305  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  00458	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0045e	ff b0 a8 09 00
	00		 push	 DWORD PTR [eax+2472]
  00464	ff b5 f8 fd ff
	ff		 push	 DWORD PTR $T4[ebp]
  0046a	6a 00		 push	 0
  0046c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00472	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 306  : 	
; 307  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00477	6a 00		 push	 0
  00479	68 89 00 00 00	 push	 137			; 00000089H
  0047e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00484	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 308  : 
; 309  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  00489	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0048f	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00495	89 85 0c fe ff
	ff		 mov	 DWORD PTR _iPrevRenderedSplatNum$[ebp], eax

; 310  : 
; 311  : #ifdef WORLD_EDITOR
; 312  : 
; 313  : 	int nRenderTextureCount = 0;
; 314  : 
; 315  : //	if (!m_bShowEntirePatchTextureCount && !(GetAsyncKeyState(VK_LCONTROL) & 0x8000) )
; 316  : 	if (1)
; 317  : 	{
; 318  : 		for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 319  : 		{
; 320  : 			TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 321  : 			
; 322  : 			if (!rSplat.Active)
; 323  : 				continue;
; 324  : 			
; 325  : 			if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)
; 326  : 				continue;
; 327  : 
; 328  : 			++nRenderTextureCount;
; 329  : 		}
; 330  : 		
; 331  : 		DWORD dwTextureFactor = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 332  : 		
; 333  : 		int TextureCountThreshold = 8;
; 334  : 		DWORD dwTFactor = 0xFFFFFFFF;
; 335  : 		
; 336  : 		if (GetAsyncKeyState(VK_LSHIFT) & 0x8000)
; 337  : 		{
; 338  : 			if (GetAsyncKeyState(VK_1) & 0x8000)
; 339  : 			{
; 340  : 				TextureCountThreshold = 2;
; 341  : 				dwTFactor = 0xFF0000FF;
; 342  : 			}
; 343  : 			else if (GetAsyncKeyState(VK_2) & 0x8000)
; 344  : 			{
; 345  : 				TextureCountThreshold = 3;
; 346  : 				dwTFactor = 0xFF00FF00;
; 347  : 			}
; 348  : 			else if (GetAsyncKeyState(VK_3) & 0x8000)
; 349  : 			{
; 350  : 				TextureCountThreshold = 4;
; 351  : 				dwTFactor = 0xFF00FFFF;
; 352  : 			}
; 353  : 			else if (GetAsyncKeyState(VK_4) & 0x8000)
; 354  : 			{
; 355  : 				TextureCountThreshold = 5;
; 356  : 				dwTFactor = 0xFFFF0000;
; 357  : 			}
; 358  : 			else if (GetAsyncKeyState(VK_5) & 0x8000)
; 359  : 			{
; 360  : 				TextureCountThreshold = 6;
; 361  : 				dwTFactor = 0xFFFFFF00;
; 362  : 			}
; 363  : 			else if (GetAsyncKeyState(VK_6) & 0x8000)
; 364  : 			{
; 365  : 				TextureCountThreshold = 7;
; 366  : 				dwTFactor = 0xFFFF00ff;
; 367  : 			}
; 368  : 			
; 369  : 		}
; 370  : 
; 371  : 		if (nRenderTextureCount>=TextureCountThreshold)
; 372  : 		{
; 373  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTFactor);
; 374  : 			STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 375  : 			STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 376  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 377  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactor);
; 378  : 			STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 379  : 			STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 380  : 		}
; 381  : 		else
; 382  : 		{
; 383  : 			// 0 
; 384  : 			if ( 0 < rTerrainSplatPatch.PatchTileCount[sPatchNum][0] )
; 385  : 			{
; 386  : 				DWORD dwTextureFactorFor0Texture = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 387  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFF88FF88);
; 388  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 389  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 390  : 				STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 391  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactorFor0Texture);
; 392  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 393  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 394  : 			}
; 395  : 
; 396  : 			for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 397  : 			{
; 398  : 				TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 399  : 				
; 400  : 				if (!rSplat.Active)
; 401  : 					continue;
; 402  : 				
; 403  : 				DWORD dwTextureCount = rTerrainSplatPatch.PatchTileCount[sPatchNum][j];
; 404  : 				if (dwTextureCount == 0)
; 405  : 					continue;
; 406  : 				
; 407  : 				DWORD dwTextureFactorForTextureBalance = 0xFFFFFFFF;
; 408  : 
; 409  : 				if (!(GetAsyncKeyState(VK_LSHIFT) & 0x8000))
; 410  : 				{
; 411  : 					const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 412  : 					
; 413  : 					D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 414  : 					STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 415  : 					
; 416  : 					STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 417  : 					STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 418  : 					STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 419  : 				}
; 420  : 				else
; 421  : 				{
; 422  : 					if (dwTextureCount < 71)
; 423  : 					{
; 424  : 						dwTextureFactorForTextureBalance = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 425  : 						if (dwTextureCount < 51)
; 426  : 							STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFFFF0000);
; 427  : 						else
; 428  : 							STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFF0000FF);
; 429  : 						STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 430  : 						STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 431  : 						STATEMANAGER.SetTexture(0, NULL);
; 432  : 					}
; 433  : 					else
; 434  : 					{
; 435  : 						const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 436  : 						
; 437  : 						D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 438  : 						STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 439  : 						
; 440  : 						STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 441  : 					}
; 442  : 					STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 443  : 					STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 444  : 					if (dwTextureCount < 71)
; 445  : 					{
; 446  : 						STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactorForTextureBalance);
; 447  : 						STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 448  : 						STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 449  : 					}
; 450  : 				}
; 451  : 				
; 452  : 				std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);
; 453  : 				if (aIterator == m_RenderedTextureNumVector.end())
; 454  : 					m_RenderedTextureNumVector.push_back(j);
; 455  : 				++m_iRenderedSplatNum;
; 456  : 				if (m_iRenderedSplatNum >= m_iSplatLimit)
; 457  : 					break;
; 458  : 			}	
; 459  : 		}
; 460  : 	}
; 461  : 	else
; 462  : 	{
; 463  : 		int TextureCountThreshold = 6;
; 464  : 		DWORD dwTFactor = 0xFFFF00FF;
; 465  : 		
; 466  : 		if (GetAsyncKeyState(VK_LSHIFT) & 0x8000)
; 467  : 		{
; 468  : 			if (GetAsyncKeyState(VK_1) & 0x8000)
; 469  : 			{
; 470  : 				TextureCountThreshold = 1;
; 471  : 				dwTFactor = 0xFF0000FF;
; 472  : 			}
; 473  : 			else if (GetAsyncKeyState(VK_2) & 0x8000)
; 474  : 			{
; 475  : 				TextureCountThreshold = 2;
; 476  : 				dwTFactor = 0xFF00FF00;
; 477  : 			}
; 478  : 			else if (GetAsyncKeyState(VK_3) & 0x8000)
; 479  : 			{
; 480  : 				TextureCountThreshold = 3;
; 481  : 				dwTFactor = 0xFF00FFFF;
; 482  : 			}
; 483  : 			else if (GetAsyncKeyState(VK_4) & 0x8000)
; 484  : 			{
; 485  : 				TextureCountThreshold = 4;
; 486  : 				dwTFactor = 0xFFFF0000;
; 487  : 			}
; 488  : 			else if (GetAsyncKeyState(VK_5) & 0x8000)
; 489  : 			{
; 490  : 				TextureCountThreshold = 5;
; 491  : 				dwTFactor = 0xFFFFFF00;
; 492  : 			}
; 493  : 		}
; 494  : 		
; 495  : 		for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 496  : 		{
; 497  : 			TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 498  : 			
; 499  : 			if (!rSplat.Active)
; 500  : 				continue;
; 501  : 			
; 502  : 			if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)
; 503  : 				continue;
; 504  : 			
; 505  : 			DWORD dwTextureFactor;
; 506  : 			
; 507  : 			if (nRenderTextureCount>=TextureCountThreshold)
; 508  : 			{
; 509  : 				dwTextureFactor = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 510  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTFactor);
; 511  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 512  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 513  : 				STATEMANAGER.SetTexture(0, NULL);
; 514  : 			}
; 515  : 			else
; 516  : 			{
; 517  : 				const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 518  : 				
; 519  : 				D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 520  : 				STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 521  : 				
; 522  : 				STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 523  : 			}
; 524  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 525  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 526  : 			if (nRenderTextureCount>=TextureCountThreshold)
; 527  : 			{
; 528  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactor);
; 529  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 530  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 531  : 			}
; 532  : 			
; 533  : 			++nRenderTextureCount;
; 534  : 			
; 535  : 			std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);
; 536  : 			if (aIterator == m_RenderedTextureNumVector.end())
; 537  : 				m_RenderedTextureNumVector.push_back(j);
; 538  : 			++m_iRenderedSplatNum;
; 539  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)
; 540  : 				break;
; 541  : 			
; 542  : 		}	
; 543  : 	}
; 544  : 
; 545  : #else
; 546  : 	bool isFirst=true;

  0049b	c6 85 b3 fe ff
	ff 01		 mov	 BYTE PTR _isFirst$[ebp], 1

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  004a2	c7 85 ac fe ff
	ff 01 00 00 00	 mov	 DWORD PTR _j$27[ebp], 1
  004ac	eb 0d		 jmp	 SHORT $LN4@HardwareTr
$LN2@HardwareTr:
  004ae	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _j$27[ebp]
  004b4	40		 inc	 eax
  004b5	89 85 ac fe ff
	ff		 mov	 DWORD PTR _j$27[ebp], eax
$LN4@HardwareTr:
  004bb	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  004c1	89 85 f4 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  004c7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
  004cd	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  004d2	39 85 ac fe ff
	ff		 cmp	 DWORD PTR _j$27[ebp], eax
  004d8	0f 83 07 03 00
	00		 jae	 $LN3@HardwareTr

; 548  : 	{
; 549  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];

  004de	6b 85 ac fe ff
	ff 0c		 imul	 eax, DWORD PTR _j$27[ebp], 12
  004e5	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _rTerrainSplatPatch$[ebp]
  004eb	8d 84 01 00 04
	01 00		 lea	 eax, DWORD PTR [ecx+eax+66560]
  004f2	89 85 8c fe ff
	ff		 mov	 DWORD PTR _rSplat$22[ebp], eax

; 550  : 		
; 551  : 		if (!rSplat.Active)

  004f8	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _rSplat$22[ebp]
  004fe	83 38 00	 cmp	 DWORD PTR [eax], 0
  00501	75 02		 jne	 SHORT $LN12@HardwareTr

; 552  : 			continue;

  00503	eb a9		 jmp	 SHORT $LN2@HardwareTr
$LN12@HardwareTr:

; 553  : 		
; 554  : 		if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)

  00505	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _sPatchNum$[ebp]
  0050b	c1 e0 0a	 shl	 eax, 10			; 0000000aH
  0050e	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _rTerrainSplatPatch$[ebp]
  00514	8d 84 01 00 04
	00 00		 lea	 eax, DWORD PTR [ecx+eax+1024]
  0051b	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR _j$27[ebp]
  00521	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00525	75 02		 jne	 SHORT $LN13@HardwareTr

; 555  : 			continue;

  00527	eb 85		 jmp	 SHORT $LN2@HardwareTr
$LN13@HardwareTr:

; 556  : 		
; 557  : 		const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);

  00529	ff b5 ac fe ff
	ff		 push	 DWORD PTR _j$27[ebp]
  0052f	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00535	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  0053b	e8 00 00 00 00	 call	 ?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ; CTextureSet::GetTexture
  00540	89 85 90 fe ff
	ff		 mov	 DWORD PTR _rTexture$23[ebp], eax

; 558  : 		
; 559  : 		D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);

  00546	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _rTexture$23[ebp]
  0054c	83 c0 54	 add	 eax, 84			; 00000054H
  0054f	50		 push	 eax
  00550	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00556	05 88 07 00 00	 add	 eax, 1928		; 00000788H
  0055b	50		 push	 eax
  0055c	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  00562	50		 push	 eax
  00563	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 560  : 		STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);

  00568	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  0056e	50		 push	 eax
  0056f	6a 10		 push	 16			; 00000010H
  00571	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00577	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 561  : 		if (isFirst)

  0057c	0f b6 85 b3 fe
	ff ff		 movzx	 eax, BYTE PTR _isFirst$[ebp]
  00583	85 c0		 test	 eax, eax
  00585	74 7a		 je	 SHORT $LN14@HardwareTr

; 562  : 		{
; 563  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00587	6a 01		 push	 1
  00589	6a 04		 push	 4
  0058b	6a 01		 push	 1
  0058d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00593	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 564  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  00598	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _rTexture$23[ebp]
  0059e	ff 70 18	 push	 DWORD PTR [eax+24]
  005a1	6a 00		 push	 0
  005a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005a9	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 565  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  005ae	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _rSplat$22[ebp]
  005b4	ff 70 08	 push	 DWORD PTR [eax+8]
  005b7	6a 01		 push	 1
  005b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005bf	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 566  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  005c4	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  005c8	50		 push	 eax
  005c9	6a 00		 push	 0
  005cb	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005d1	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  005d7	6a 00		 push	 0
  005d9	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  005dc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005e2	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 567  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  005e7	6a 02		 push	 2
  005e9	6a 04		 push	 4
  005eb	6a 01		 push	 1
  005ed	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005f3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 568  : 			isFirst=false;

  005f8	c6 85 b3 fe ff
	ff 00		 mov	 BYTE PTR _isFirst$[ebp], 0

; 569  : 		}

  005ff	eb 4f		 jmp	 SHORT $LN15@HardwareTr
$LN14@HardwareTr:

; 570  : 		else
; 571  : 		{
; 572  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  00601	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _rTexture$23[ebp]
  00607	ff 70 18	 push	 DWORD PTR [eax+24]
  0060a	6a 00		 push	 0
  0060c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00612	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 573  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  00617	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _rSplat$22[ebp]
  0061d	ff 70 08	 push	 DWORD PTR [eax+8]
  00620	6a 01		 push	 1
  00622	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00628	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 574  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);			

  0062d	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00631	50		 push	 eax
  00632	6a 00		 push	 0
  00634	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0063a	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  00640	6a 00		 push	 0
  00642	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00645	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0064b	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN15@HardwareTr:

; 577  : 		std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);

  00650	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _j$27[ebp]
  00656	89 85 30 fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0065c	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00662	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00667	89 85 6c fe ff
	ff		 mov	 DWORD PTR __My_data$21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0066d	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$21[ebp]
  00673	89 85 e8 fd ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00679	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$21[ebp]
  0067f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00682	89 85 40 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00688	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0068e	89 85 3c fe ff
	ff		 mov	 DWORD PTR $T18[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00694	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  0069a	89 85 2c fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  006a0	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006a6	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  006ab	89 85 68 fe ff
	ff		 mov	 DWORD PTR __My_data$20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  006b1	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$20[ebp]
  006b7	89 85 f0 fd ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  006bd	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$20[ebp]
  006c3	8b 00		 mov	 eax, DWORD PTR [eax]
  006c5	89 85 38 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  006cb	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  006d1	89 85 34 fe ff
	ff		 mov	 DWORD PTR $T17[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  006d7	8d 85 34 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  006dd	89 85 28 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 577  : 		std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);

  006e3	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  006e9	50		 push	 eax
  006ea	8b 85 2c fe ff
	ff		 mov	 eax, DWORD PTR $T15[ebp]
  006f0	ff 30		 push	 DWORD PTR [eax]
  006f2	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  006f8	ff 30		 push	 DWORD PTR [eax]
  006fa	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR _aIterator$11[ebp]
  00700	50		 push	 eax
  00701	e8 00 00 00 00	 call	 ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@V10@ABH@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  00706	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00709	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0070f	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00714	89 85 64 fe ff
	ff		 mov	 DWORD PTR __My_data$19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0071a	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$19[ebp]
  00720	89 85 ec fd ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00726	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$19[ebp]
  0072c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0072f	89 85 24 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00735	8b 85 24 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0073b	89 85 08 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00741	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00747	89 85 1c fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0074d	8b 85 1c fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00753	8b 8d 18 fe ff
	ff		 mov	 ecx, DWORD PTR _aIterator$11[ebp]
  00759	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0075b	75 0c		 jne	 SHORT $LN169@HardwareTr
  0075d	c7 85 60 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv800[ebp], 1
  00767	eb 07		 jmp	 SHORT $LN170@HardwareTr
$LN169@HardwareTr:
  00769	83 a5 60 fe ff
	ff 00		 and	 DWORD PTR tv800[ebp], 0
$LN170@HardwareTr:
  00770	8a 85 60 fe ff
	ff		 mov	 al, BYTE PTR tv800[ebp]
  00776	88 85 aa fe ff
	ff		 mov	 BYTE PTR $T25[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 578  : 		if (aIterator == m_RenderedTextureNumVector.end())

  0077c	0f b6 85 aa fe
	ff ff		 movzx	 eax, BYTE PTR $T25[ebp]
  00783	85 c0		 test	 eax, eax
  00785	74 24		 je	 SHORT $LN175@HardwareTr

; 579  : 			m_RenderedTextureNumVector.push_back(j);

  00787	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _j$27[ebp]
  0078d	89 85 14 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00793	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00799	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 579  : 			m_RenderedTextureNumVector.push_back(j);

  0079a	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007a0	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  007a6	e8 00 00 00 00	 call	 ??$emplace_back@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEXABH@Z ; std::vector<int,std::allocator<int> >::emplace_back<int const &>
$LN175@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 580  : 		++m_iRenderedSplatNum;

  007ab	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007b1	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  007b7	40		 inc	 eax
  007b8	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007be	89 81 88 09 00
	00		 mov	 DWORD PTR [ecx+2440], eax

; 581  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  007c4	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007ca	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007d0	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  007d6	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  007dc	7c 02		 jl	 SHORT $LN17@HardwareTr

; 582  : 			break;

  007de	eb 05		 jmp	 SHORT $LN3@HardwareTr
$LN17@HardwareTr:

; 583  : 		
; 584  : 	}

  007e0	e9 c9 fc ff ff	 jmp	 $LN2@HardwareTr
$LN3@HardwareTr:

; 585  : 
; 586  : /*
; 587  : 	if (GetAsyncKeyState(VK_CAPITAL) & 0x8000)
; 588  : 	{
; 589  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[200];
; 590  : 		
; 591  : 		if (rSplat.Active)
; 592  : 		{
; 593  : 			const TTerrainTexture & rTexture = m_TextureSet.GetTexture(1);
; 594  : 			
; 595  : 			D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 596  : 			STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 597  : 			
; 598  : 			STATEMANAGER.SetTexture(0, NULL);
; 599  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 600  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 601  : 		}
; 602  : 	}
; 603  : */
; 604  : #endif
; 605  : 
; 606  : 	// 
; 607  : 	if (m_bDrawShadow)

  007e5	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007eb	0f b6 80 31 01
	00 00		 movzx	 eax, BYTE PTR [eax+305]
  007f2	85 c0		 test	 eax, eax
  007f4	0f 84 37 03 00
	00		 je	 $LN18@HardwareTr

; 608  : 	{
; 609  : 		STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  007fa	6a 01		 push	 1
  007fc	68 89 00 00 00	 push	 137			; 00000089H
  00801	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00807	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 610  : 		
; 611  : 		STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, 0xFFFFFFFF);

  0080c	6a ff		 push	 -1
  0080e	6a 22		 push	 34			; 00000022H
  00810	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00816	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 612  : 		STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);

  0081b	6a 01		 push	 1
  0081d	6a 13		 push	 19			; 00000013H
  0081f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00825	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 613  : 		STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

  0082a	6a 03		 push	 3
  0082c	6a 14		 push	 20			; 00000014H
  0082e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00834	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 614  : 				
; 615  : 		D3DXMATRIX matShadowTexTransform;
; 616  : 		D3DXMatrixMultiply(&matShadowTexTransform, &matTexTransform, &m_matStaticShadow);

  00839	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0083f	05 08 08 00 00	 add	 eax, 2056		; 00000808H
  00844	50		 push	 eax
  00845	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  0084b	50		 push	 eax
  0084c	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matShadowTexTransform$28[ebp]
  00852	50		 push	 eax
  00853	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 617  : 
; 618  : 		STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matShadowTexTransform);

  00858	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matShadowTexTransform$28[ebp]
  0085e	50		 push	 eax
  0085f	6a 10		 push	 16			; 00000010H
  00861	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00867	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 94   : 		LPDIRECT3DTEXTURE8		GetShadowTexture()						{ return m_lpShadowTexture; }

  0086c	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  00872	8b 80 44 a5 04
	00		 mov	 eax, DWORD PTR [eax+304452]
  00878	89 85 10 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 619  :  		STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());		

  0087e	ff b5 10 fe ff
	ff		 push	 DWORD PTR $T9[ebp]
  00884	6a 00		 push	 0
  00886	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0088c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 620  : 		
; 621  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00891	6a 02		 push	 2
  00893	6a 02		 push	 2
  00895	6a 00		 push	 0
  00897	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0089d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 622  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  008a2	6a 01		 push	 1
  008a4	6a 03		 push	 3
  008a6	6a 00		 push	 0
  008a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008ae	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 623  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  008b3	6a 04		 push	 4
  008b5	6a 01		 push	 1
  008b7	6a 00		 push	 0
  008b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008bf	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 624  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  008c4	6a 02		 push	 2
  008c6	6a 05		 push	 5
  008c8	6a 00		 push	 0
  008ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008d0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 625  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  008d5	6a 01		 push	 1
  008d7	6a 06		 push	 6
  008d9	6a 00		 push	 0
  008db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008e1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 626  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  008e6	6a 01		 push	 1
  008e8	6a 04		 push	 4
  008ea	6a 00		 push	 0
  008ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008f2	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 627  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  008f7	6a 03		 push	 3
  008f9	6a 0d		 push	 13			; 0000000dH
  008fb	6a 00		 push	 0
  008fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00903	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 628  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);	

  00908	6a 03		 push	 3
  0090a	6a 0e		 push	 14			; 0000000eH
  0090c	6a 00		 push	 0
  0090e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00914	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 629  : 
; 630  : 		if (m_bDrawChrShadow)

  00919	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0091f	0f b6 80 32 01
	00 00		 movzx	 eax, BYTE PTR [eax+306]
  00926	85 c0		 test	 eax, eax
  00928	0f 84 9a 00 00
	00		 je	 $LN19@HardwareTr

; 631  : 		{
; 632  : 			STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &m_matDynamicShadow);

  0092e	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00934	05 48 08 00 00	 add	 eax, 2120		; 00000848H
  00939	50		 push	 eax
  0093a	6a 11		 push	 17			; 00000011H
  0093c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00942	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 633  : 
; 634  :  			STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);

  00947	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0094d	ff b0 d4 01 00
	00		 push	 DWORD PTR [eax+468]
  00953	6a 01		 push	 1
  00955	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0095b	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 635  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00960	6a 02		 push	 2
  00962	6a 02		 push	 2
  00964	6a 01		 push	 1
  00966	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0096c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 636  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00971	6a 01		 push	 1
  00973	6a 03		 push	 3
  00975	6a 01		 push	 1
  00977	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0097d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 637  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00982	6a 04		 push	 4
  00984	6a 01		 push	 1
  00986	6a 01		 push	 1
  00988	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0098e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 638  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  00993	6a 01		 push	 1
  00995	6a 04		 push	 4
  00997	6a 01		 push	 1
  00999	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0099f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 639  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);

  009a4	6a 03		 push	 3
  009a6	6a 0d		 push	 13			; 0000000dH
  009a8	6a 01		 push	 1
  009aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009b0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 640  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

  009b5	6a 03		 push	 3
  009b7	6a 0e		 push	 14			; 0000000eH
  009b9	6a 01		 push	 1
  009bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009c1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 641  : 		}		

  009c6	eb 0f		 jmp	 SHORT $LN20@HardwareTr
$LN19@HardwareTr:

; 642  : 		else
; 643  : 		{
; 644  : 			STATEMANAGER.SetTexture(1, NULL);			

  009c8	6a 00		 push	 0
  009ca	6a 01		 push	 1
  009cc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009d2	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN20@HardwareTr:

; 645  : 		}
; 646  : 		
; 647  : 		ms_faceCount += wPrimitiveCount;

  009d7	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  009db	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?ms_faceCount@CGraphicBase@@1KA ; CGraphicBase::ms_faceCount
  009e1	a3 00 00 00 00	 mov	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 648  : 		STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  009e6	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  009ea	50		 push	 eax
  009eb	6a 00		 push	 0
  009ed	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009f3	ff b0 a0 09 00
	00		 push	 DWORD PTR [eax+2464]
  009f9	6a 00		 push	 0
  009fb	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  009fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a04	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 649  :   		++m_iRenderedSplatNum;

  00a09	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a0f	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00a15	40		 inc	 eax
  00a16	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a1c	89 81 88 09 00
	00		 mov	 DWORD PTR [ecx+2440], eax

; 650  : 
; 651  : 		if (m_bDrawChrShadow)

  00a22	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a28	0f b6 80 32 01
	00 00		 movzx	 eax, BYTE PTR [eax+306]
  00a2f	85 c0		 test	 eax, eax
  00a31	74 44		 je	 SHORT $LN21@HardwareTr

; 652  : 		{
; 653  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00a33	6a 01		 push	 1
  00a35	6a 02		 push	 2
  00a37	6a 01		 push	 1
  00a39	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a3f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 654  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00a44	6a 02		 push	 2
  00a46	6a 01		 push	 1
  00a48	6a 01		 push	 1
  00a4a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a50	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 655  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00a55	6a 02		 push	 2
  00a57	6a 05		 push	 5
  00a59	6a 01		 push	 1
  00a5b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a61	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 656  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00a66	6a 02		 push	 2
  00a68	6a 04		 push	 4
  00a6a	6a 01		 push	 1
  00a6c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a72	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN21@HardwareTr:

; 657  : 		}			
; 658  : 
; 659  :  		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00a77	6a 02		 push	 2
  00a79	6a 02		 push	 2
  00a7b	6a 00		 push	 0
  00a7d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a83	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 660  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00a88	6a 01		 push	 1
  00a8a	6a 03		 push	 3
  00a8c	6a 00		 push	 0
  00a8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00a94	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 661  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00a99	6a 04		 push	 4
  00a9b	6a 01		 push	 1
  00a9d	6a 00		 push	 0
  00a9f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00aa5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 662  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00aaa	6a 02		 push	 2
  00aac	6a 05		 push	 5
  00aae	6a 00		 push	 0
  00ab0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ab6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 663  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00abb	6a 02		 push	 2
  00abd	6a 04		 push	 4
  00abf	6a 00		 push	 0
  00ac1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ac7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 664  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  00acc	6a 01		 push	 1
  00ace	6a 0d		 push	 13			; 0000000dH
  00ad0	6a 00		 push	 0
  00ad2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ad8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 665  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  00add	6a 01		 push	 1
  00adf	6a 0e		 push	 14			; 0000000eH
  00ae1	6a 00		 push	 0
  00ae3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00ae9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 666  : 		
; 667  : 		
; 668  : 		STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00aee	6a 05		 push	 5
  00af0	6a 13		 push	 19			; 00000013H
  00af2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00af8	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 669  : 		STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  00afd	6a 06		 push	 6
  00aff	6a 14		 push	 20			; 00000014H
  00b01	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b07	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 670  : 		STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, dwFogColor);

  00b0c	ff b5 5c fe ff
	ff		 push	 DWORD PTR _dwFogColor$[ebp]
  00b12	6a 22		 push	 34			; 00000022H
  00b14	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b1a	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 671  : 
; 672  : 		STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00b1f	6a 00		 push	 0
  00b21	68 89 00 00 00	 push	 137			; 00000089H
  00b26	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00b2c	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN18@HardwareTr:

; 673  : 	}
; 674  : 	++m_iRenderedPatchNum;

  00b31	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b37	8b 80 8c 09 00
	00		 mov	 eax, DWORD PTR [eax+2444]
  00b3d	40		 inc	 eax
  00b3e	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b44	89 81 8c 09 00
	00		 mov	 DWORD PTR [ecx+2444], eax

; 675  : 
; 676  : 	int iCurRenderedSplatNum=m_iRenderedSplatNum-iPrevRenderedSplatNum;

  00b4a	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b50	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00b56	2b 85 0c fe ff
	ff		 sub	 eax, DWORD PTR _iPrevRenderedSplatNum$[ebp]
  00b5c	89 85 58 fe ff
	ff		 mov	 DWORD PTR _iCurRenderedSplatNum$[ebp], eax

; 677  : 
; 678  : 	m_iRenderedSplatNumSqSum+=iCurRenderedSplatNum*iCurRenderedSplatNum;

  00b62	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR _iCurRenderedSplatNum$[ebp]
  00b68	0f af 85 58 fe
	ff ff		 imul	 eax, DWORD PTR _iCurRenderedSplatNum$[ebp]
  00b6f	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b75	03 81 84 09 00
	00		 add	 eax, DWORD PTR [ecx+2436]
  00b7b	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b81	89 81 84 09 00
	00		 mov	 DWORD PTR [ecx+2436], eax
$LN1@HardwareTr:

; 679  : 
; 680  : }

  00b87	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b8a	33 cd		 xor	 ecx, ebp
  00b8c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b91	c9		 leave
  00b92	c2 0c 00	 ret	 12			; 0000000cH
?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
$T1 = -340						; size = 4
$T2 = -336						; size = 4
$T3 = -332						; size = 4
$T4 = -328						; size = 4
$T5 = -324						; size = 4
$T6 = -320						; size = 4
$T7 = -316						; size = 4
_fog_near$ = -312					; size = 8
_fog_far$ = -304					; size = 8
$T8 = -296						; size = 4
$T9 = -292						; size = 4
$T10 = -288						; size = 4
___param0$ = -284					; size = 4
$T11 = -280						; size = 4
___param0$ = -276					; size = 4
$T12 = -272						; size = 4
$T13 = -268						; size = 4
$T14 = -264						; size = 4
$T15 = -260						; size = 4
$T16 = -256						; size = 4
$T17 = -252						; size = 4
$T18 = -248						; size = 4
$T19 = -244						; size = 4
$T20 = -240						; size = 4
$T21 = -236						; size = 4
___param0$ = -232					; size = 4
$T22 = -228						; size = 4
$T23 = -224						; size = 4
$T24 = -220						; size = 4
$T25 = -216						; size = 4
$T26 = -212						; size = 4
$T27 = -208						; size = 4
$T28 = -204						; size = 4
$T29 = -200						; size = 4
$T30 = -196						; size = 4
$T31 = -192						; size = 4
$T32 = -188						; size = 4
$T33 = -184						; size = 4
$T34 = -180						; size = 4
$T35 = -176						; size = 4
$T36 = -172						; size = 4
$T37 = -168						; size = 4
___param0$ = -164					; size = 4
$T38 = -160						; size = 4
__First$ = -156						; size = 4
__Last$ = -152						; size = 4
$T39 = -148						; size = 1
$T40 = -144						; size = 4
$T41 = -140						; size = 4
$T42 = -136						; size = 4
___param0$ = -132					; size = 4
$T43 = -128						; size = 4
$T44 = -124						; size = 4
___param0$ = -120					; size = 4
__First$ = -116						; size = 4
__Last$ = -112						; size = 4
$T45 = -108						; size = 1
$T46 = -104						; size = 4
$T47 = -100						; size = 4
$T48 = -96						; size = 4
___param0$ = -92					; size = 4
$T49 = -88						; size = 4
___param0$ = -84					; size = 4
$T50 = -80						; size = 4
$T51 = -76						; size = 4
$T52 = -72						; size = 4
$T53 = -68						; size = 4
$T54 = -64						; size = 4
$T55 = -60						; size = 4
$T56 = -56						; size = 4
$T57 = -52						; size = 4
_dwB$58 = -48						; size = 4
_dwA$59 = -44						; size = 4
_dwR$60 = -40						; size = 4
_dwG$61 = -36						; size = 4
__My_data$62 = -32					; size = 4
__My_data$63 = -28					; size = 4
_dwFogEnable$ = -24					; size = 4
tv989 = -20						; size = 4
tv1003 = -16						; size = 4
__My_data$64 = -12					; size = 4
_far_it$ = -8						; size = 4
tv935 = -4						; size = 4
tv942 = 0						; size = 4
_near_it$ = 4						; size = 4
tv861 = 8						; size = 4
tv900 = 12						; size = 4
__My_data$65 = 16					; size = 4
__My_data$66 = 20					; size = 4
__My_data$67 = 24					; size = 4
__My_data$68 = 28					; size = 4
__My_data$69 = 32					; size = 4
_fFogNearDistance$ = 36					; size = 4
_fFogFarDistance$ = 40					; size = 4
_dwFogColor$ = 44					; size = 4
tv703 = 48						; size = 4
tv702 = 52						; size = 4
tv692 = 56						; size = 4
tv691 = 60						; size = 4
tv681 = 64						; size = 4
tv680 = 68						; size = 4
tv670 = 72						; size = 4
tv669 = 76						; size = 4
_fLODLevel2Distance$ = 80				; size = 4
_fLODLevel1Distance$ = 84				; size = 4
$T70 = 90						; size = 1
$T71 = 91						; size = 1
$T72 = 92						; size = 1
$T73 = 93						; size = 1
$T74 = 94						; size = 1
$T75 = 95						; size = 1
_wPrimitiveCount$ = 96					; size = 2
_this$ = 100						; size = 4
_ePrimitiveType$ = 104					; size = 4
_it$ = 108						; size = 4
_this$ = 112						; size = 4
_byCUrrentLODLevel$ = 119				; size = 1
?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch, COMDAT
; _this$ = ecx

; 7    : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec cc 01 00
	00		 sub	 esp, 460		; 000001ccH
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 8    : 	DWORD dwFogColor;
; 9    : 	float fFogFarDistance;
; 10   : 	float fFogNearDistance;
; 11   : 	if (mc_pEnvironmentData)

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00015	0f 84 a5 01 00
	00		 je	 $LN11@RenderTerr

; 13   : 		dwFogColor=mc_pEnvironmentData->FogColor;

  0001b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00021	05 2c 01 00 00	 add	 eax, 300		; 0000012cH
  00026	89 45 64	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00029	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00030	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00037	72 09		 jb	 SHORT $LN35@RenderTerr
  00039	c7 45 48 ff 00
	00 00		 mov	 DWORD PTR tv670[ebp], 255 ; 000000ffH
  00040	eb 36		 jmp	 SHORT $LN36@RenderTerr
$LN35@RenderTerr:
  00042	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00045	0f 57 c0	 xorps	 xmm0, xmm0
  00048	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  0004b	72 06		 jb	 SHORT $LN33@RenderTerr
  0004d	83 65 4c 00	 and	 DWORD PTR tv669[ebp], 0
  00051	eb 1f		 jmp	 SHORT $LN34@RenderTerr
$LN33@RenderTerr:
  00053	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00056	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0005a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00062	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0006a	e8 00 00 00 00	 call	 __ftoui3
  0006f	89 45 4c	 mov	 DWORD PTR tv669[ebp], eax
$LN34@RenderTerr:
  00072	8b 45 4c	 mov	 eax, DWORD PTR tv669[ebp]
  00075	89 45 48	 mov	 DWORD PTR tv670[ebp], eax
$LN36@RenderTerr:
  00078	8b 45 48	 mov	 eax, DWORD PTR tv670[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR _dwR$60[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0007e	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00081	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00086	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0008d	72 09		 jb	 SHORT $LN39@RenderTerr
  0008f	c7 45 40 ff 00
	00 00		 mov	 DWORD PTR tv681[ebp], 255 ; 000000ffH
  00096	eb 38		 jmp	 SHORT $LN40@RenderTerr
$LN39@RenderTerr:
  00098	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	0f 57 c0	 xorps	 xmm0, xmm0
  0009e	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  000a2	72 06		 jb	 SHORT $LN37@RenderTerr
  000a4	83 65 44 00	 and	 DWORD PTR tv680[ebp], 0
  000a8	eb 20		 jmp	 SHORT $LN38@RenderTerr
$LN37@RenderTerr:
  000aa	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000b2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000ba	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000c2	e8 00 00 00 00	 call	 __ftoui3
  000c7	89 45 44	 mov	 DWORD PTR tv680[ebp], eax
$LN38@RenderTerr:
  000ca	8b 45 44	 mov	 eax, DWORD PTR tv680[ebp]
  000cd	89 45 40	 mov	 DWORD PTR tv681[ebp], eax
$LN40@RenderTerr:
  000d0	8b 45 40	 mov	 eax, DWORD PTR tv681[ebp]
  000d3	89 45 dc	 mov	 DWORD PTR _dwG$61[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000d6	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000de	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000e5	72 09		 jb	 SHORT $LN43@RenderTerr
  000e7	c7 45 38 ff 00
	00 00		 mov	 DWORD PTR tv692[ebp], 255 ; 000000ffH
  000ee	eb 38		 jmp	 SHORT $LN44@RenderTerr
$LN43@RenderTerr:
  000f0	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	0f 57 c0	 xorps	 xmm0, xmm0
  000f6	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  000fa	72 06		 jb	 SHORT $LN41@RenderTerr
  000fc	83 65 3c 00	 and	 DWORD PTR tv691[ebp], 0
  00100	eb 20		 jmp	 SHORT $LN42@RenderTerr
$LN41@RenderTerr:
  00102	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00105	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0010a	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00112	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0011a	e8 00 00 00 00	 call	 __ftoui3
  0011f	89 45 3c	 mov	 DWORD PTR tv691[ebp], eax
$LN42@RenderTerr:
  00122	8b 45 3c	 mov	 eax, DWORD PTR tv691[ebp]
  00125	89 45 38	 mov	 DWORD PTR tv692[ebp], eax
$LN44@RenderTerr:
  00128	8b 45 38	 mov	 eax, DWORD PTR tv692[ebp]
  0012b	89 45 d0	 mov	 DWORD PTR _dwB$58[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0012e	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  00131	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00136	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0013d	72 09		 jb	 SHORT $LN47@RenderTerr
  0013f	c7 45 30 ff 00
	00 00		 mov	 DWORD PTR tv703[ebp], 255 ; 000000ffH
  00146	eb 38		 jmp	 SHORT $LN48@RenderTerr
$LN47@RenderTerr:
  00148	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	0f 57 c0	 xorps	 xmm0, xmm0
  0014e	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00152	72 06		 jb	 SHORT $LN45@RenderTerr
  00154	83 65 34 00	 and	 DWORD PTR tv702[ebp], 0
  00158	eb 20		 jmp	 SHORT $LN46@RenderTerr
$LN45@RenderTerr:
  0015a	8b 45 64	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00162	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0016a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00172	e8 00 00 00 00	 call	 __ftoui3
  00177	89 45 34	 mov	 DWORD PTR tv702[ebp], eax
$LN46@RenderTerr:
  0017a	8b 45 34	 mov	 eax, DWORD PTR tv702[ebp]
  0017d	89 45 30	 mov	 DWORD PTR tv703[ebp], eax
$LN48@RenderTerr:
  00180	8b 45 30	 mov	 eax, DWORD PTR tv703[ebp]
  00183	89 45 d4	 mov	 DWORD PTR _dwA$59[ebp], eax

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00186	8b 45 dc	 mov	 eax, DWORD PTR _dwG$61[ebp]
  00189	c1 e0 08	 shl	 eax, 8
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR _dwR$60[ebp]
  0018f	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00192	8b 55 d4	 mov	 edx, DWORD PTR _dwA$59[ebp]
  00195	c1 e2 18	 shl	 edx, 24			; 00000018H
  00198	0b d1		 or	 edx, ecx
  0019a	0b d0		 or	 edx, eax
  0019c	0b 55 d0	 or	 edx, DWORD PTR _dwB$58[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 13   : 		dwFogColor=mc_pEnvironmentData->FogColor;

  0019f	89 55 2c	 mov	 DWORD PTR _dwFogColor$[ebp], edx

; 14   : 		fFogNearDistance=mc_pEnvironmentData->GetFogNearDistance();

  001a2	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001a5	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001a8	e8 00 00 00 00	 call	 ?GetFogNearDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogNearDistance
  001ad	d9 5d 24	 fstp	 DWORD PTR _fFogNearDistance$[ebp]

; 15   : 		fFogFarDistance=mc_pEnvironmentData->GetFogFarDistance();

  001b0	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001b3	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  001b6	e8 00 00 00 00	 call	 ?GetFogFarDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogFarDistance
  001bb	d9 5d 28	 fstp	 DWORD PTR _fFogFarDistance$[ebp]

; 16   : 	}

  001be	eb 1e		 jmp	 SHORT $LN12@RenderTerr
$LN11@RenderTerr:

; 17   : 	else
; 18   : 	{
; 19   : 		dwFogColor=0xffffffff;

  001c0	83 4d 2c ff	 or	 DWORD PTR _dwFogColor$[ebp], -1

; 20   : 		fFogNearDistance=5000.0f;

  001c4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  001cc	f3 0f 11 45 24	 movss	 DWORD PTR _fFogNearDistance$[ebp], xmm0

; 21   : 		fFogFarDistance=10000.0f;

  001d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  001d9	f3 0f 11 45 28	 movss	 DWORD PTR _fFogFarDistance$[ebp], xmm0
$LN12@RenderTerr:

; 22   : 	}
; 23   : 	
; 24   : 	//////////////////////////////////////////////////////////////////////////
; 25   : 	// Render State & TextureStageState	
; 26   : 
; 27   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  001de	68 00 00 02 00	 push	 131072			; 00020000H
  001e3	6a 0b		 push	 11			; 0000000bH
  001e5	6a 00		 push	 0
  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ed	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 28   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  001f2	6a 02		 push	 2
  001f4	6a 18		 push	 24			; 00000018H
  001f6	6a 00		 push	 0
  001f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fe	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 29   : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  00203	68 00 00 02 00	 push	 131072			; 00020000H
  00208	6a 0b		 push	 11			; 0000000bH
  0020a	6a 01		 push	 1
  0020c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00212	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 30   : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  00217	6a 02		 push	 2
  00219	6a 18		 push	 24			; 00000018H
  0021b	6a 01		 push	 1
  0021d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00223	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 31   : 
; 32   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  00228	6a 01		 push	 1
  0022a	6a 1b		 push	 27			; 0000001bH
  0022c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00232	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 33   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  00237	6a 01		 push	 1
  00239	6a 0f		 push	 15			; 0000000fH
  0023b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00241	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 34   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAREF, 0x00000000);

  00246	6a 00		 push	 0
  00248	6a 18		 push	 24			; 00000018H
  0024a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00250	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 35   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  00255	6a 05		 push	 5
  00257	6a 19		 push	 25			; 00000019H
  00259	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0025f	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 36   : 
; 37   : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, dwFogColor);

  00264	ff 75 2c	 push	 DWORD PTR _dwFogColor$[ebp]
  00267	6a 3c		 push	 60			; 0000003cH
  00269	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0026f	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 38   : 
; 39   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00274	6a 02		 push	 2
  00276	6a 02		 push	 2
  00278	6a 00		 push	 0
  0027a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00280	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 40   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00285	6a 01		 push	 1
  00287	6a 03		 push	 3
  00289	6a 00		 push	 0
  0028b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00291	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 41   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00296	6a 04		 push	 4
  00298	6a 01		 push	 1
  0029a	6a 00		 push	 0
  0029c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a2	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 42   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  002a7	6a 02		 push	 2
  002a9	6a 05		 push	 5
  002ab	6a 00		 push	 0
  002ad	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002b3	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 43   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  002b8	6a 02		 push	 2
  002ba	6a 04		 push	 4
  002bc	6a 00		 push	 0
  002be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002c4	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 44   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  002c9	6a 01		 push	 1
  002cb	6a 0d		 push	 13			; 0000000dH
  002cd	6a 00		 push	 0
  002cf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002d5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 45   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  002da	6a 01		 push	 1
  002dc	6a 0e		 push	 14			; 0000000eH
  002de	6a 00		 push	 0
  002e0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002e6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 46   : 
; 47   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  002eb	6a 01		 push	 1
  002ed	6a 02		 push	 2
  002ef	6a 01		 push	 1
  002f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002f7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 48   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  002fc	6a 02		 push	 2
  002fe	6a 01		 push	 1
  00300	6a 01		 push	 1
  00302	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00308	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 49   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  0030d	6a 02		 push	 2
  0030f	6a 05		 push	 5
  00311	6a 01		 push	 1
  00313	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00319	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 50   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0031e	6a 02		 push	 2
  00320	6a 04		 push	 4
  00322	6a 01		 push	 1
  00324	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0032a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 51   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);

  0032f	6a 03		 push	 3
  00331	6a 0d		 push	 13			; 0000000dH
  00333	6a 01		 push	 1
  00335	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0033b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 52   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);

  00340	6a 03		 push	 3
  00342	6a 0e		 push	 14			; 0000000eH
  00344	6a 01		 push	 1
  00346	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0034c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 53   : 
; 54   : #ifdef WORLD_EDITOR
; 55   : 	if (GetAsyncKeyState(VK_CAPITAL))
; 56   : 	{
; 57   : 		CSpeedTreeWrapper::ms_bSelfShadowOn = false;
; 58   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MINFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 59   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MAGFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 60   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MIPFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 61   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MINFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 62   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MAGFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 63   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MIPFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 64   : 	}
; 65   : 	else
; 66   : 	{
; 67   : 		CSpeedTreeWrapper::ms_bSelfShadowOn = true;
; 68   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MINFILTER,	D3DTEXF_LINEAR);
; 69   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MAGFILTER,	D3DTEXF_LINEAR);
; 70   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MIPFILTER,	D3DTEXF_LINEAR);
; 71   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MINFILTER,	D3DTEXF_LINEAR);
; 72   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MAGFILTER,	D3DTEXF_LINEAR);
; 73   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MIPFILTER,	D3DTEXF_LINEAR);
; 74   : 	}
; 75   : #else
; 76   : 	CSpeedTreeWrapper::ms_bSelfShadowOn = true;

  00351	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA, 1 ; CSpeedTreeWrapper::ms_bSelfShadowOn

; 77   : 	STATEMANAGER.SetBestFiltering(0);

  00358	6a 00		 push	 0
  0035a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00360	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 78   : 	STATEMANAGER.SetBestFiltering(1);

  00365	6a 01		 push	 1
  00367	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0036d	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 79   : #endif
; 80   : 
; 81   : 	m_matWorldForCommonUse._41 = 0.0f;

  00372	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00375	0f 57 c0	 xorps	 xmm0, xmm0
  00378	f3 0f 11 80 78
	07 00 00	 movss	 DWORD PTR [eax+1912], xmm0

; 82   : 	m_matWorldForCommonUse._42 = 0.0f;

  00380	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00383	0f 57 c0	 xorps	 xmm0, xmm0
  00386	f3 0f 11 80 7c
	07 00 00	 movss	 DWORD PTR [eax+1916], xmm0

; 83   : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  0038e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00391	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  00396	50		 push	 eax
  00397	68 00 01 00 00	 push	 256			; 00000100H
  0039c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003a2	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 84   : 
; 85   : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE0, &m_matWorldForCommonUse);

  003a7	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  003aa	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  003af	50		 push	 eax
  003b0	6a 10		 push	 16			; 00000010H
  003b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003b8	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 86   : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &m_matWorldForCommonUse);

  003bd	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  003c0	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  003c5	50		 push	 eax
  003c6	6a 11		 push	 17			; 00000011H
  003c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ce	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 87   : 
; 88   : 	// Render State & TextureStageState
; 89   : 	//////////////////////////////////////////////////////////////////////////
; 90   : 
; 91   : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_NORMAL);

  003d3	6a 12		 push	 18			; 00000012H
  003d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003db	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 92   : 
; 93   : 	m_iRenderedSplatNumSqSum = 0;

  003e0	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  003e3	83 a0 84 09 00
	00 00		 and	 DWORD PTR [eax+2436], 0

; 94   : 	m_iRenderedPatchNum = 0;

  003ea	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  003ed	83 a0 8c 09 00
	00 00		 and	 DWORD PTR [eax+2444], 0

; 95   : 	m_iRenderedSplatNum = 0;

  003f4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  003f7	83 a0 88 09 00
	00 00		 and	 DWORD PTR [eax+2440], 0

; 96   : 	m_RenderedTextureNumVector.clear();

  003fe	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00401	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
  00407	e8 00 00 00 00	 call	 ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ; std::vector<int,std::allocator<int> >::clear

; 97   : 
; 98   : 	std::pair<float, long> fog_far(fFogFarDistance+1600.0f, 0);

  0040c	83 65 c4 00	 and	 DWORD PTR $T55[ebp], 0
  00410	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fFogFarDistance$[ebp]
  00415	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@44c80000
  0041d	f3 0f 11 45 cc	 movss	 DWORD PTR $T57[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00422	8d 45 cc	 lea	 eax, DWORD PTR $T57[ebp]
  00425	89 45 c8	 mov	 DWORD PTR $T56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00428	8b 45 c8	 mov	 eax, DWORD PTR $T56[ebp]
  0042b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0042f	f3 0f 11 85 d0
	fe ff ff	 movss	 DWORD PTR _fog_far$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00437	8d 45 c4	 lea	 eax, DWORD PTR $T55[ebp]
  0043a	89 45 c0	 mov	 DWORD PTR $T54[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0043d	8b 45 c0	 mov	 eax, DWORD PTR $T54[ebp]
  00440	8b 00		 mov	 eax, DWORD PTR [eax]
  00442	89 85 d4 fe ff
	ff		 mov	 DWORD PTR _fog_far$[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 99   : 	std::pair<float, long> fog_near(fFogNearDistance-3200.0f, 0);

  00448	83 65 b4 00	 and	 DWORD PTR $T51[ebp], 0
  0044c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fFogNearDistance$[ebp]
  00451	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@45480000
  00459	f3 0f 11 45 bc	 movss	 DWORD PTR $T53[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0045e	8d 45 bc	 lea	 eax, DWORD PTR $T53[ebp]
  00461	89 45 b8	 mov	 DWORD PTR $T52[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00464	8b 45 b8	 mov	 eax, DWORD PTR $T52[ebp]
  00467	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0046b	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _fog_near$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00473	8d 45 b4	 lea	 eax, DWORD PTR $T51[ebp]
  00476	89 45 b0	 mov	 DWORD PTR $T50[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00479	8b 45 b0	 mov	 eax, DWORD PTR $T50[ebp]
  0047c	8b 00		 mov	 eax, DWORD PTR [eax]
  0047e	89 85 cc fe ff
	ff		 mov	 DWORD PTR _fog_near$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00484	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00487	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0048c	89 45 20	 mov	 DWORD PTR __My_data$69[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0048f	8b 45 20	 mov	 eax, DWORD PTR __My_data$69[ebp]
  00492	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00498	8b 45 20	 mov	 eax, DWORD PTR __My_data$69[ebp]
  0049b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0049e	89 45 ac	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  004a1	8b 45 ac	 mov	 eax, DWORD PTR ___param0$[ebp]
  004a4	89 45 a8	 mov	 DWORD PTR $T49[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  004a7	8d 45 a8	 lea	 eax, DWORD PTR $T49[ebp]
  004aa	89 45 9c	 mov	 DWORD PTR $T47[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  004ad	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  004b0	05 18 01 00 00	 add	 eax, 280		; 00000118H
  004b5	89 45 1c	 mov	 DWORD PTR __My_data$68[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  004b8	8b 45 1c	 mov	 eax, DWORD PTR __My_data$68[ebp]
  004bb	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  004c1	8b 45 1c	 mov	 eax, DWORD PTR __My_data$68[ebp]
  004c4	8b 00		 mov	 eax, DWORD PTR [eax]
  004c6	89 45 a4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  004c9	8b 45 a4	 mov	 eax, DWORD PTR ___param0$[ebp]
  004cc	89 45 a0	 mov	 DWORD PTR $T48[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  004cf	8d 45 a0	 lea	 eax, DWORD PTR $T48[ebp]
  004d2	89 45 98	 mov	 DWORD PTR $T46[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 101  : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  004d5	8b 45 9c	 mov	 eax, DWORD PTR $T47[ebp]
  004d8	8b 00		 mov	 eax, DWORD PTR [eax]
  004da	89 45 90	 mov	 DWORD PTR __Last$[ebp], eax
  004dd	8b 45 98	 mov	 eax, DWORD PTR $T46[ebp]
  004e0	8b 00		 mov	 eax, DWORD PTR [eax]
  004e2	89 45 8c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6749 :     return _STD upper_bound(_First, _Last, _Val, less<>{});

  004e5	33 c0		 xor	 eax, eax
  004e7	88 45 94	 mov	 BYTE PTR $T45[ebp], al
  004ea	ff 75 94	 push	 DWORD PTR $T45[ebp]
  004ed	8d 85 d0 fe ff
	ff		 lea	 eax, DWORD PTR _fog_far$[ebp]
  004f3	50		 push	 eax
  004f4	ff 75 90	 push	 DWORD PTR __Last$[ebp]
  004f7	ff 75 8c	 push	 DWORD PTR __First$[ebp]
  004fa	8d 45 f8	 lea	 eax, DWORD PTR _far_it$[ebp]
  004fd	50		 push	 eax
  004fe	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
  00503	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00506	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00509	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0050e	89 45 18	 mov	 DWORD PTR __My_data$67[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00511	8b 45 18	 mov	 eax, DWORD PTR __My_data$67[ebp]
  00514	89 85 bc fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0051a	8b 45 18	 mov	 eax, DWORD PTR __My_data$67[ebp]
  0051d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00520	89 45 88	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00523	8b 45 88	 mov	 eax, DWORD PTR ___param0$[ebp]
  00526	89 45 84	 mov	 DWORD PTR $T44[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00529	8d 45 84	 lea	 eax, DWORD PTR $T44[ebp]
  0052c	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T41[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00532	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00535	05 18 01 00 00	 add	 eax, 280		; 00000118H
  0053a	89 45 14	 mov	 DWORD PTR __My_data$66[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0053d	8b 45 14	 mov	 eax, DWORD PTR __My_data$66[ebp]
  00540	89 45 80	 mov	 DWORD PTR $T43[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00543	8b 45 14	 mov	 eax, DWORD PTR __My_data$66[ebp]
  00546	8b 00		 mov	 eax, DWORD PTR [eax]
  00548	89 85 7c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax
  0054e	ff 75 80	 push	 DWORD PTR $T43[ebp]
  00551	ff b5 7c ff ff
	ff		 push	 DWORD PTR ___param0$[ebp]
  00557	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  0055d	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@QAE@PAU?$pair@MJ@1@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >
  00562	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T42[ebp]
  00568	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T40[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 102  : 	std::vector<std::pair<float ,long> >::iterator near_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_near);

  0056e	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T41[ebp]
  00574	8b 00		 mov	 eax, DWORD PTR [eax]
  00576	89 85 68 ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  0057c	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T40[ebp]
  00582	8b 00		 mov	 eax, DWORD PTR [eax]
  00584	89 85 64 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6749 :     return _STD upper_bound(_First, _Last, _Val, less<>{});

  0058a	33 c0		 xor	 eax, eax
  0058c	88 85 6c ff ff
	ff		 mov	 BYTE PTR $T39[ebp], al
  00592	ff b5 6c ff ff
	ff		 push	 DWORD PTR $T39[ebp]
  00598	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _fog_near$[ebp]
  0059e	50		 push	 eax
  0059f	ff b5 68 ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  005a5	ff b5 64 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  005ab	8d 45 04	 lea	 eax, DWORD PTR _near_it$[ebp]
  005ae	50		 push	 eax
  005af	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@U?$less@X@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@U?$less@X@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long>,std::less<void> >
  005b4	83 c4 14	 add	 esp, 20			; 00000014H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 113  : 	BYTE byCUrrentLODLevel = 0;

  005b7	c6 45 77 00	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 0

; 114  : 
; 115  : 	float fLODLevel1Distance = __GetNoFogDistance();

  005bb	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  005be	e8 00 00 00 00	 call	 ?__GetNoFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetNoFogDistance
  005c3	d9 5d 54	 fstp	 DWORD PTR _fLODLevel1Distance$[ebp]

; 116  : 	float fLODLevel2Distance = __GetFogDistance();

  005c6	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  005c9	e8 00 00 00 00	 call	 ?__GetFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetFogDistance
  005ce	d9 5d 50	 fstp	 DWORD PTR _fLODLevel2Distance$[ebp]

; 117  : 
; 118  : 	SelectIndexBuffer(0, &wPrimitiveCount, &ePrimitiveType);

  005d1	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  005d4	50		 push	 eax
  005d5	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  005d8	50		 push	 eax
  005d9	6a 00		 push	 0
  005db	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  005de	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  005e3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005e8	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T38[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 120  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  005ee	6a 1c		 push	 28			; 0000001cH
  005f0	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR $T38[ebp]
  005f6	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState
  005fb	89 45 e8	 mov	 DWORD PTR _dwFogEnable$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  005fe	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00601	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00606	89 45 10	 mov	 DWORD PTR __My_data$65[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00609	8b 45 10	 mov	 eax, DWORD PTR __My_data$65[ebp]
  0060c	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00612	8b 45 10	 mov	 eax, DWORD PTR __My_data$65[ebp]
  00615	8b 00		 mov	 eax, DWORD PTR [eax]
  00617	89 85 5c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0061d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00623	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 125  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00626	6a 00		 push	 0
  00628	6a 1c		 push	 28			; 0000001cH
  0062a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00630	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 127  : 	for( ; it != near_it; ++it)

  00635	eb 09		 jmp	 SHORT $LN214@RenderTerr
$LN2@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00637	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  0063a	83 c0 08	 add	 eax, 8
  0063d	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
$LN214@RenderTerr:

; 149  :         return _Ptr == _Right._Ptr;

  00640	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00643	3b 45 04	 cmp	 eax, DWORD PTR _near_it$[ebp]
  00646	75 09		 jne	 SHORT $LN227@RenderTerr
  00648	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv900[ebp], 1
  0064f	eb 04		 jmp	 SHORT $LN228@RenderTerr
$LN227@RenderTerr:
  00651	83 65 0c 00	 and	 DWORD PTR tv900[ebp], 0
$LN228@RenderTerr:
  00655	8a 45 0c	 mov	 al, BYTE PTR tv900[ebp]
  00658	88 45 5f	 mov	 BYTE PTR $T75[ebp], al

; 153  :         return !(*this == _Right);

  0065b	0f b6 45 5f	 movzx	 eax, BYTE PTR $T75[ebp]
  0065f	85 c0		 test	 eax, eax
  00661	75 09		 jne	 SHORT $LN222@RenderTerr
  00663	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv861[ebp], 1
  0066a	eb 04		 jmp	 SHORT $LN223@RenderTerr
$LN222@RenderTerr:
  0066c	83 65 08 00	 and	 DWORD PTR tv861[ebp], 0
$LN223@RenderTerr:
  00670	8a 45 08	 mov	 al, BYTE PTR tv861[ebp]
  00673	88 45 5e	 mov	 BYTE PTR $T74[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 127  : 	for( ; it != near_it; ++it)

  00676	0f b6 45 5e	 movzx	 eax, BYTE PTR $T74[ebp]
  0067a	85 c0		 test	 eax, eax
  0067c	0f 84 22 01 00
	00		 je	 $LN3@RenderTerr

; 129  : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00682	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00686	85 c0		 test	 eax, eax
  00688	75 43		 jne	 SHORT $LN13@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  0068a	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  0068d	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T37[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00693	ff b5 58 ff ff
	ff		 push	 DWORD PTR $T37[ebp]
  00699	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0069e	59		 pop	 ecx
  0069f	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T36[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 129  : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  006a5	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T36[ebp]
  006ab	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006af	0f 2f 45 54	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  006b3	72 18		 jb	 SHORT $LN13@RenderTerr

; 130  : 		{
; 131  : 			byCUrrentLODLevel = 1;

  006b5	c6 45 77 01	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 1

; 132  : 			SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  006b9	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  006bc	50		 push	 eax
  006bd	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  006c0	50		 push	 eax
  006c1	6a 01		 push	 1
  006c3	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  006c6	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 133  : 		}

  006cb	eb 4a		 jmp	 SHORT $LN15@RenderTerr
$LN13@RenderTerr:

; 134  : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  006cd	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  006d1	83 f8 01	 cmp	 eax, 1
  006d4	75 41		 jne	 SHORT $LN15@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  006d6	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  006d9	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T35[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  006df	ff b5 50 ff ff
	ff		 push	 DWORD PTR $T35[ebp]
  006e5	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  006ea	59		 pop	 ecx
  006eb	89 85 4c ff ff
	ff		 mov	 DWORD PTR $T34[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 134  : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  006f1	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR $T34[ebp]
  006f7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006fb	0f 2f 45 50	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  006ff	72 16		 jb	 SHORT $LN15@RenderTerr

; 135  : 		{
; 136  : 			byCUrrentLODLevel = 2;

  00701	c6 45 77 02	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 137  : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00705	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00708	50		 push	 eax
  00709	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0070c	50		 push	 eax
  0070d	6a 02		 push	 2
  0070f	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00712	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN15@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00717	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  0071a	89 85 48 ff ff
	ff		 mov	 DWORD PTR $T33[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00720	ff b5 48 ff ff
	ff		 push	 DWORD PTR $T33[ebp]
  00726	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0072b	59		 pop	 ecx
  0072c	89 85 44 ff ff
	ff		 mov	 DWORD PTR $T32[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 140  : 		__HardwareTransformPatch_RenderPatchSplat(it->second, wPrimitiveCount, ePrimitiveType);

  00732	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00735	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00738	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR $T32[ebp]
  0073e	ff 70 04	 push	 DWORD PTR [eax+4]
  00741	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00744	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat

; 141  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  00749	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0074c	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0074f	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00755	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  0075b	7c 02		 jl	 SHORT $LN16@RenderTerr

; 142  : 			break;

  0075d	eb 45		 jmp	 SHORT $LN3@RenderTerr
$LN16@RenderTerr:

; 143  : 		
; 144  :  		if (m_bDrawWireFrame)

  0075f	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00762	0f b6 80 30 01
	00 00		 movzx	 eax, BYTE PTR [eax+304]
  00769	85 c0		 test	 eax, eax
  0076b	74 32		 je	 SHORT $LN17@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  0076d	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00770	89 85 40 ff ff
	ff		 mov	 DWORD PTR $T31[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00776	ff b5 40 ff ff
	ff		 push	 DWORD PTR $T31[ebp]
  0077c	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00781	59		 pop	 ecx
  00782	89 85 3c ff ff
	ff		 mov	 DWORD PTR $T30[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 145  : 			DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  00788	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0078b	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  0078e	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T30[ebp]
  00794	ff 70 04	 push	 DWORD PTR [eax+4]
  00797	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0079a	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN17@RenderTerr:

; 146  : 	}

  0079f	e9 93 fe ff ff	 jmp	 $LN2@RenderTerr
$LN3@RenderTerr:

; 147  : #endif
; 148  : 
; 149  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  007a4	ff 75 e8	 push	 DWORD PTR _dwFogEnable$[ebp]
  007a7	6a 1c		 push	 28			; 0000001cH
  007a9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007af	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 150  : 
; 151  : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  007b4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  007b7	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  007ba	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  007c0	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  007c6	0f 8d 75 01 00
	00		 jge	 $LN6@RenderTerr

; 153  : 		for(it = near_it; it != far_it; ++it)

  007cc	8b 45 04	 mov	 eax, DWORD PTR _near_it$[ebp]
  007cf	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
  007d2	eb 09		 jmp	 SHORT $LN259@RenderTerr
$LN5@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  007d4	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  007d7	83 c0 08	 add	 eax, 8
  007da	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
$LN259@RenderTerr:

; 149  :         return _Ptr == _Right._Ptr;

  007dd	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  007e0	3b 45 f8	 cmp	 eax, DWORD PTR _far_it$[ebp]
  007e3	75 09		 jne	 SHORT $LN272@RenderTerr
  007e5	c7 45 00 01 00
	00 00		 mov	 DWORD PTR tv942[ebp], 1
  007ec	eb 04		 jmp	 SHORT $LN273@RenderTerr
$LN272@RenderTerr:
  007ee	83 65 00 00	 and	 DWORD PTR tv942[ebp], 0
$LN273@RenderTerr:
  007f2	8a 45 00	 mov	 al, BYTE PTR tv942[ebp]
  007f5	88 45 5d	 mov	 BYTE PTR $T73[ebp], al

; 153  :         return !(*this == _Right);

  007f8	0f b6 45 5d	 movzx	 eax, BYTE PTR $T73[ebp]
  007fc	85 c0		 test	 eax, eax
  007fe	75 09		 jne	 SHORT $LN267@RenderTerr
  00800	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv935[ebp], 1
  00807	eb 04		 jmp	 SHORT $LN268@RenderTerr
$LN267@RenderTerr:
  00809	83 65 fc 00	 and	 DWORD PTR tv935[ebp], 0
$LN268@RenderTerr:
  0080d	8a 45 fc	 mov	 al, BYTE PTR tv935[ebp]
  00810	88 45 5c	 mov	 BYTE PTR $T72[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 153  : 		for(it = near_it; it != far_it; ++it)

  00813	0f b6 45 5c	 movzx	 eax, BYTE PTR $T72[ebp]
  00817	85 c0		 test	 eax, eax
  00819	0f 84 22 01 00
	00		 je	 $LN6@RenderTerr

; 155  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  0081f	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00823	85 c0		 test	 eax, eax
  00825	75 43		 jne	 SHORT $LN19@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00827	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  0082a	89 85 38 ff ff
	ff		 mov	 DWORD PTR $T29[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00830	ff b5 38 ff ff
	ff		 push	 DWORD PTR $T29[ebp]
  00836	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0083b	59		 pop	 ecx
  0083c	89 85 34 ff ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 155  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00842	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  00848	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0084c	0f 2f 45 54	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  00850	72 18		 jb	 SHORT $LN19@RenderTerr

; 156  : 			{
; 157  : 				byCUrrentLODLevel = 1;

  00852	c6 45 77 01	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 1

; 158  : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  00856	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00859	50		 push	 eax
  0085a	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0085d	50		 push	 eax
  0085e	6a 01		 push	 1
  00860	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00863	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 159  : 			}

  00868	eb 4a		 jmp	 SHORT $LN21@RenderTerr
$LN19@RenderTerr:

; 160  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0086a	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  0086e	83 f8 01	 cmp	 eax, 1
  00871	75 41		 jne	 SHORT $LN21@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00873	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00876	89 85 30 ff ff
	ff		 mov	 DWORD PTR $T27[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  0087c	ff b5 30 ff ff
	ff		 push	 DWORD PTR $T27[ebp]
  00882	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00887	59		 pop	 ecx
  00888	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T26[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 160  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0088e	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T26[ebp]
  00894	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00898	0f 2f 45 50	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  0089c	72 16		 jb	 SHORT $LN21@RenderTerr

; 161  : 			{
; 162  : 				byCUrrentLODLevel = 2;

  0089e	c6 45 77 02	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 163  : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  008a2	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  008a5	50		 push	 eax
  008a6	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  008a9	50		 push	 eax
  008aa	6a 02		 push	 2
  008ac	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  008af	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN21@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  008b4	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  008b7	89 85 28 ff ff
	ff		 mov	 DWORD PTR $T25[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  008bd	ff b5 28 ff ff
	ff		 push	 DWORD PTR $T25[ebp]
  008c3	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  008c8	59		 pop	 ecx
  008c9	89 85 24 ff ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 166  : 			__HardwareTransformPatch_RenderPatchSplat(it->second, wPrimitiveCount, ePrimitiveType);

  008cf	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  008d2	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  008d5	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  008db	ff 70 04	 push	 DWORD PTR [eax+4]
  008de	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  008e1	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat

; 167  : 
; 168  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  008e6	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  008e9	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  008ec	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  008f2	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  008f8	7c 02		 jl	 SHORT $LN22@RenderTerr

; 169  : 				break;

  008fa	eb 45		 jmp	 SHORT $LN6@RenderTerr
$LN22@RenderTerr:

; 170  : 
; 171  : 			if (m_bDrawWireFrame)

  008fc	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  008ff	0f b6 80 30 01
	00 00		 movzx	 eax, BYTE PTR [eax+304]
  00906	85 c0		 test	 eax, eax
  00908	74 32		 je	 SHORT $LN23@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  0090a	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  0090d	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T23[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00913	ff b5 20 ff ff
	ff		 push	 DWORD PTR $T23[ebp]
  00919	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0091e	59		 pop	 ecx
  0091f	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T22[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 172  : 				DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  00925	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00928	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  0092b	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  00931	ff 70 04	 push	 DWORD PTR [eax+4]
  00934	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00937	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN23@RenderTerr:

; 173  : 		}

  0093c	e9 93 fe ff ff	 jmp	 $LN5@RenderTerr
$LN6@RenderTerr:

; 174  : 	}
; 175  : 
; 176  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00941	6a 00		 push	 0
  00943	6a 1c		 push	 28			; 0000001cH
  00945	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0094b	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 177  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  00950	6a 00		 push	 0
  00952	68 89 00 00 00	 push	 137			; 00000089H
  00957	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0095d	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 178  : 
; 179  : 	STATEMANAGER.SetTexture(0, NULL);

  00962	6a 00		 push	 0
  00964	6a 00		 push	 0
  00966	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0096c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 180  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, FALSE);

  00971	6a 00		 push	 0
  00973	6a 18		 push	 24			; 00000018H
  00975	6a 00		 push	 0
  00977	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0097d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 181  : 
; 182  : 	STATEMANAGER.SetTexture(1, NULL);

  00982	6a 00		 push	 0
  00984	6a 01		 push	 1
  00986	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0098c	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 183  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, FALSE);

  00991	6a 00		 push	 0
  00993	6a 18		 push	 24			; 00000018H
  00995	6a 01		 push	 1
  00997	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0099d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 184  : 
; 185  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  009a2	6a 03		 push	 3
  009a4	6a 02		 push	 2
  009a6	6a 00		 push	 0
  009a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009ae	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 186  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  009b3	6a 02		 push	 2
  009b5	6a 01		 push	 1
  009b7	6a 00		 push	 0
  009b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009bf	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 187  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  009c4	6a 01		 push	 1
  009c6	6a 04		 push	 4
  009c8	6a 00		 push	 0
  009ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009d0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 188  : 
; 189  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_DISABLE);

  009d5	6a 01		 push	 1
  009d7	6a 01		 push	 1
  009d9	6a 01		 push	 1
  009db	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009e1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 190  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);	

  009e6	6a 01		 push	 1
  009e8	6a 04		 push	 4
  009ea	6a 01		 push	 1
  009ec	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  009f2	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 191  : 
; 192  : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  009f7	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  009fa	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  009fd	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00a03	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00a09	0f 8d b2 01 00
	00		 jge	 $LN9@RenderTerr

; 194  : 		for(it = far_it; it != m_PatchVector.end(); ++it)

  00a0f	8b 45 f8	 mov	 eax, DWORD PTR _far_it$[ebp]
  00a12	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
  00a15	eb 09		 jmp	 SHORT $LN324@RenderTerr
$LN8@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00a17	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00a1a	83 c0 08	 add	 eax, 8
  00a1d	89 45 6c	 mov	 DWORD PTR _it$[ebp], eax
$LN324@RenderTerr:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00a20	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00a23	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00a28	89 45 f4	 mov	 DWORD PTR __My_data$64[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00a2b	8b 45 f4	 mov	 eax, DWORD PTR __My_data$64[ebp]
  00a2e	89 85 b4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00a34	8b 45 f4	 mov	 eax, DWORD PTR __My_data$64[ebp]
  00a37	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00a3a	89 85 18 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00a40	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00a46	89 85 14 ff ff
	ff		 mov	 DWORD PTR $T21[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00a4c	8d 85 14 ff ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00a52	89 85 10 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00a58	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR $T20[ebp]
  00a5e	8b 4d 6c	 mov	 ecx, DWORD PTR _it$[ebp]
  00a61	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00a63	75 09		 jne	 SHORT $LN352@RenderTerr
  00a65	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv1003[ebp], 1
  00a6c	eb 04		 jmp	 SHORT $LN353@RenderTerr
$LN352@RenderTerr:
  00a6e	83 65 f0 00	 and	 DWORD PTR tv1003[ebp], 0
$LN353@RenderTerr:
  00a72	8a 45 f0	 mov	 al, BYTE PTR tv1003[ebp]
  00a75	88 45 5a	 mov	 BYTE PTR $T70[ebp], al

; 153  :         return !(*this == _Right);

  00a78	0f b6 45 5a	 movzx	 eax, BYTE PTR $T70[ebp]
  00a7c	85 c0		 test	 eax, eax
  00a7e	75 09		 jne	 SHORT $LN347@RenderTerr
  00a80	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv989[ebp], 1
  00a87	eb 04		 jmp	 SHORT $LN348@RenderTerr
$LN347@RenderTerr:
  00a89	83 65 ec 00	 and	 DWORD PTR tv989[ebp], 0
$LN348@RenderTerr:
  00a8d	8a 45 ec	 mov	 al, BYTE PTR tv989[ebp]
  00a90	88 45 5b	 mov	 BYTE PTR $T71[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 194  : 		for(it = far_it; it != m_PatchVector.end(); ++it)

  00a93	0f b6 45 5b	 movzx	 eax, BYTE PTR $T71[ebp]
  00a97	85 c0		 test	 eax, eax
  00a99	0f 84 22 01 00
	00		 je	 $LN9@RenderTerr

; 196  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00a9f	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00aa3	85 c0		 test	 eax, eax
  00aa5	75 43		 jne	 SHORT $LN25@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00aa7	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00aaa	89 85 0c ff ff
	ff		 mov	 DWORD PTR $T19[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00ab0	ff b5 0c ff ff
	ff		 push	 DWORD PTR $T19[ebp]
  00ab6	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00abb	59		 pop	 ecx
  00abc	89 85 08 ff ff
	ff		 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 196  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00ac2	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR $T18[ebp]
  00ac8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00acc	0f 2f 45 54	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  00ad0	72 18		 jb	 SHORT $LN25@RenderTerr

; 197  : 			{
; 198  : 				byCUrrentLODLevel = 1;

  00ad2	c6 45 77 01	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 1

; 199  : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  00ad6	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00ad9	50		 push	 eax
  00ada	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00add	50		 push	 eax
  00ade	6a 01		 push	 1
  00ae0	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00ae3	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 200  : 			}

  00ae8	eb 4a		 jmp	 SHORT $LN27@RenderTerr
$LN25@RenderTerr:

; 201  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00aea	0f b6 45 77	 movzx	 eax, BYTE PTR _byCUrrentLODLevel$[ebp]
  00aee	83 f8 01	 cmp	 eax, 1
  00af1	75 41		 jne	 SHORT $LN27@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00af3	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00af6	89 85 04 ff ff
	ff		 mov	 DWORD PTR $T17[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00afc	ff b5 04 ff ff
	ff		 push	 DWORD PTR $T17[ebp]
  00b02	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00b07	59		 pop	 ecx
  00b08	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 201  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00b0e	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  00b14	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00b18	0f 2f 45 50	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  00b1c	72 16		 jb	 SHORT $LN27@RenderTerr

; 202  : 			{
; 203  : 				byCUrrentLODLevel = 2;

  00b1e	c6 45 77 02	 mov	 BYTE PTR _byCUrrentLODLevel$[ebp], 2

; 204  : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00b22	8d 45 68	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00b25	50		 push	 eax
  00b26	8d 45 60	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00b29	50		 push	 eax
  00b2a	6a 02		 push	 2
  00b2c	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00b2f	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN27@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00b34	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00b37	89 85 fc fe ff
	ff		 mov	 DWORD PTR $T15[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00b3d	ff b5 fc fe ff
	ff		 push	 DWORD PTR $T15[ebp]
  00b43	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00b48	59		 pop	 ecx
  00b49	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 207  : 			__HardwareTransformPatch_RenderPatchNone(it->second, wPrimitiveCount, ePrimitiveType);

  00b4f	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00b52	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00b55	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  00b5b	ff 70 04	 push	 DWORD PTR [eax+4]
  00b5e	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00b61	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone

; 208  : 
; 209  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  00b66	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00b69	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00b6c	8b 80 88 09 00
	00		 mov	 eax, DWORD PTR [eax+2440]
  00b72	3b 81 9c 09 00
	00		 cmp	 eax, DWORD PTR [ecx+2460]
  00b78	7c 02		 jl	 SHORT $LN28@RenderTerr

; 210  : 				break;

  00b7a	eb 45		 jmp	 SHORT $LN9@RenderTerr
$LN28@RenderTerr:

; 211  : 
; 212  : 			if (m_bDrawWireFrame)

  00b7c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00b7f	0f b6 80 30 01
	00 00		 movzx	 eax, BYTE PTR [eax+304]
  00b86	85 c0		 test	 eax, eax
  00b88	74 32		 je	 SHORT $LN29@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 65   :         return _Ptr;

  00b8a	8b 45 6c	 mov	 eax, DWORD PTR _it$[ebp]
  00b8d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR $T13[ebp], eax

; 256  :         return _Const_cast(_Mybase::operator->());

  00b93	ff b5 f4 fe ff
	ff		 push	 DWORD PTR $T13[ebp]
  00b99	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00b9e	59		 pop	 ecx
  00b9f	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 213  :  				DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  00ba5	ff 75 68	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00ba8	ff 75 60	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00bab	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00bb1	ff 70 04	 push	 DWORD PTR [eax+4]
  00bb4	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb7	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN29@RenderTerr:

; 214  : 		}

  00bbc	e9 56 fe ff ff	 jmp	 $LN8@RenderTerr
$LN9@RenderTerr:

; 215  : 	}
; 216  : 
; 217  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00bc1	6a 02		 push	 2
  00bc3	6a 02		 push	 2
  00bc5	6a 00		 push	 0
  00bc7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bcd	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 218  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00bd2	6a 01		 push	 1
  00bd4	6a 03		 push	 3
  00bd6	6a 00		 push	 0
  00bd8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bde	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 219  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00be3	6a 04		 push	 4
  00be5	6a 01		 push	 1
  00be7	6a 00		 push	 0
  00be9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00bef	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 220  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00bf4	6a 02		 push	 2
  00bf6	6a 05		 push	 5
  00bf8	6a 00		 push	 0
  00bfa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c00	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 221  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00c05	6a 02		 push	 2
  00c07	6a 04		 push	 4
  00c09	6a 00		 push	 0
  00c0b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c11	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 222  : 
; 223  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  00c16	6a 01		 push	 1
  00c18	6a 02		 push	 2
  00c1a	6a 01		 push	 1
  00c1c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c22	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 224  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  00c27	6a 02		 push	 2
  00c29	6a 01		 push	 1
  00c2b	6a 01		 push	 1
  00c2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c33	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 225  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00c38	6a 02		 push	 2
  00c3a	6a 05		 push	 5
  00c3c	6a 01		 push	 1
  00c3e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c44	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 226  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00c49	6a 02		 push	 2
  00c4b	6a 04		 push	 4
  00c4d	6a 01		 push	 1
  00c4f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c55	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 227  : 
; 228  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  00c5a	ff 75 e8	 push	 DWORD PTR _dwFogEnable$[ebp]
  00c5d	6a 1c		 push	 28			; 0000001cH
  00c5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c65	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 229  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  00c6a	6a 01		 push	 1
  00c6c	68 89 00 00 00	 push	 137			; 00000089H
  00c71	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00c77	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00c7c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00c7f	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00c84	89 45 e4	 mov	 DWORD PTR __My_data$63[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00c87	8b 45 e4	 mov	 eax, DWORD PTR __My_data$63[ebp]
  00c8a	89 85 b0 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00c90	8b 45 e4	 mov	 eax, DWORD PTR __My_data$63[ebp]
  00c93	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00c96	89 85 ec fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00c9c	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00ca2	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T11[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00ca8	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00cae	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00cb4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00cb7	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00cbc	89 45 e0	 mov	 DWORD PTR __My_data$62[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00cbf	8b 45 e0	 mov	 eax, DWORD PTR __My_data$62[ebp]
  00cc2	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00cc8	8b 45 e0	 mov	 eax, DWORD PTR __My_data$62[ebp]
  00ccb	8b 00		 mov	 eax, DWORD PTR [eax]
  00ccd	89 85 e4 fe ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00cd3	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  00cd9	89 85 e0 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00cdf	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00ce5	89 85 d8 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 231  : 	std::sort(m_RenderedTextureNumVector.begin(),m_RenderedTextureNumVector.end());

  00ceb	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00cf1	ff 30		 push	 DWORD PTR [eax]
  00cf3	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00cf9	ff 30		 push	 DWORD PTR [eax]
  00cfb	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
  00d00	59		 pop	 ecx
  00d01	59		 pop	 ecx

; 232  : 
; 233  : 	//////////////////////////////////////////////////////////////////////////
; 234  : 	// Render State & TextureStageState
; 235  : 
; 236  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  00d02	6a 3c		 push	 60			; 0000003cH
  00d04	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d0a	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 237  : 
; 238  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE0);

  00d0f	6a 10		 push	 16			; 00000010H
  00d11	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d17	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 239  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);

  00d1c	6a 11		 push	 17			; 00000011H
  00d1e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d24	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 240  : 
; 241  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXCOORDINDEX);

  00d29	6a 0b		 push	 11			; 0000000bH
  00d2b	6a 00		 push	 0
  00d2d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d33	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 242  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS);

  00d38	6a 18		 push	 24			; 00000018H
  00d3a	6a 00		 push	 0
  00d3c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d42	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 243  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  00d47	6a 0b		 push	 11			; 0000000bH
  00d49	6a 01		 push	 1
  00d4b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d51	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 244  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  00d56	6a 18		 push	 24			; 00000018H
  00d58	6a 01		 push	 1
  00d5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d60	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 245  : 
; 246  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00d65	6a 1b		 push	 27			; 0000001bH
  00d67	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d6d	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 247  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  00d72	6a 0f		 push	 15			; 0000000fH
  00d74	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d7a	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 248  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAREF);

  00d7f	6a 18		 push	 24			; 00000018H
  00d81	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d87	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 249  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  00d8c	6a 19		 push	 25			; 00000019H
  00d8e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00d94	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 250  : 
; 251  : 	// Render State & TextureStageState
; 252  : 	//////////////////////////////////////////////////////////////////////////
; 253  : }

  00d99	83 c5 78	 add	 ebp, 120		; 00000078H
  00d9c	c9		 leave
  00d9d	c3		 ret	 0
?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ PROC	; std::vector<int,std::allocator<int> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@HV?$allocator@H@std@@@std@@QAEXXZ ENDP	; std::vector<int,std::allocator<int> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
