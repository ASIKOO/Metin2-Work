; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?MAPOUTDOOR_GET_HEIGHT_USE2D@@3_NA		; MAPOUTDOOR_GET_HEIGHT_USE2D
PUBLIC	?MAPOUTDOOR_GET_HEIGHT_TRACE@@3_NA		; MAPOUTDOOR_GET_HEIGHT_TRACE
_BSS	SEGMENT
?MAPOUTDOOR_GET_HEIGHT_TRACE@@3_NA DB 01H DUP (?)	; MAPOUTDOOR_GET_HEIGHT_TRACE
_BSS	ENDS
_DATA	SEGMENT
?MAPOUTDOOR_GET_HEIGHT_USE2D@@3_NA DB 01H		; MAPOUTDOOR_GET_HEIGHT_USE2D
_DATA	ENDS
CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
CONST	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Throw_tree_length_error@std@@YAXXZ		; std::_Throw_tree_length_error
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
PUBLIC	?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >
PUBLIC	??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
PUBLIC	??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
PUBLIC	??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
PUBLIC	??_ECTerrainPatchProxy@@UAEPAXI@Z		; CTerrainPatchProxy::`vector deleting destructor'
PUBLIC	?deallocate@?$allocator@PAVCMonsterAreaInfo@@@std@@QAEXQAPAVCMonsterAreaInfo@@I@Z ; std::allocator<CMonsterAreaInfo *>::deallocate
PUBLIC	??1?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAE@XZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::~vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >
PUBLIC	?_Copy_assign@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Copy_assign
PUBLIC	?_Clear_and_reserve_geometric@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Clear_and_reserve_geometric
PUBLIC	?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear
PUBLIC	?max_size@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QBEIXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::max_size
PUBLIC	?_Destroy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Buy_raw
PUBLIC	?_Change_array@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXQAPAVCMonsterAreaInfo@@II@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Xlength
PUBLIC	??0CMapOutdoor@@QAE@XZ				; CMapOutdoor::CMapOutdoor
PUBLIC	??1CMapOutdoor@@UAE@XZ				; CMapOutdoor::~CMapOutdoor
PUBLIC	?OnBeginEnvironment@CMapOutdoor@@UAEXXZ		; CMapOutdoor::OnBeginEnvironment
PUBLIC	?Initialize@CMapOutdoor@@MAE_NXZ		; CMapOutdoor::Initialize
PUBLIC	?InitializeFog@CMapOutdoor@@IAEXXZ		; CMapOutdoor::InitializeFog
PUBLIC	?Destroy@CMapOutdoor@@MAE_NXZ			; CMapOutdoor::Destroy
PUBLIC	?OnSetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ	; CMapOutdoor::OnSetEnvironmentDataPtr
PUBLIC	?OnResetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ	; CMapOutdoor::OnResetEnvironmentDataPtr
PUBLIC	?OnPreAssignTerrainPtr@CMapOutdoor@@MAEXXZ	; CMapOutdoor::OnPreAssignTerrainPtr
PUBLIC	?GetHeight@CMapOutdoor@@UAEMMM@Z		; CMapOutdoor::GetHeight
PUBLIC	?GetCacheHeight@CMapOutdoor@@UAEMMM@Z		; CMapOutdoor::GetCacheHeight
PUBLIC	?Clear@CMapOutdoor@@UAEXXZ			; CMapOutdoor::Clear
PUBLIC	?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ	; CMapOutdoor::SetEnvironmentScreenFilter
PUBLIC	?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ	; CMapOutdoor::SetEnvironmentSkyBox
PUBLIC	?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ	; CMapOutdoor::SetEnvironmentLensFlare
PUBLIC	?ClearGuildArea@CMapOutdoor@@QAEXXZ		; CMapOutdoor::ClearGuildArea
PUBLIC	?RegisterGuildArea@CMapOutdoor@@QAEXHHHH@Z	; CMapOutdoor::RegisterGuildArea
PUBLIC	?VisibleMarkedArea@CMapOutdoor@@QAEXXZ		; CMapOutdoor::VisibleMarkedArea
PUBLIC	?DisableMarkedArea@CMapOutdoor@@QAEXXZ		; CMapOutdoor::DisableMarkedArea
PUBLIC	?SetWireframe@CMapOutdoor@@QAEX_N@Z		; CMapOutdoor::SetWireframe
PUBLIC	?IsWireframe@CMapOutdoor@@QAE_NXZ		; CMapOutdoor::IsWireframe
PUBLIC	?GetPickingPointWithRay@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CMapOutdoor::GetPickingPointWithRay
PUBLIC	?GetPickingPointWithRayOnlyTerrain@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CMapOutdoor::GetPickingPointWithRayOnlyTerrain
PUBLIC	?GetPickingPoint@CMapOutdoor@@QAE_NPAUD3DXVECTOR3@@@Z ; CMapOutdoor::GetPickingPoint
PUBLIC	?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z		; CMapOutdoor::SetTerrainCount
PUBLIC	?SetDrawShadow@CMapOutdoor@@QAEX_N@Z		; CMapOutdoor::SetDrawShadow
PUBLIC	?SetDrawCharacterShadow@CMapOutdoor@@QAEX_N@Z	; CMapOutdoor::SetDrawCharacterShadow
PUBLIC	?GetShadowMapColor@CMapOutdoor@@QAEKMM@Z	; CMapOutdoor::GetShadowMapColor
PUBLIC	?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
PUBLIC	?SaveAlphaFogOperation@CMapOutdoor@@IAEXXZ	; CMapOutdoor::SaveAlphaFogOperation
PUBLIC	?RestoreAlphaFogOperation@CMapOutdoor@@IAEXXZ	; CMapOutdoor::RestoreAlphaFogOperation
PUBLIC	?GetHeightMap@CMapOutdoor@@IAEXABEPAPAG@Z	; CMapOutdoor::GetHeightMap
PUBLIC	?GetNormalMap@CMapOutdoor@@IAEXABEPAPAD@Z	; CMapOutdoor::GetNormalMap
PUBLIC	?GetWaterMap@CMapOutdoor@@IAEXABEPAPAE@Z	; CMapOutdoor::GetWaterMap
PUBLIC	?GetWaterHeight@CMapOutdoor@@IAEXEEPAJ@Z	; CMapOutdoor::GetWaterHeight
PUBLIC	??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::clear
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	??1?$map@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@@std@@QAE@XZ ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >
PUBLIC	?DestroyTerrain@CMapOutdoor@@MAEXXZ		; CMapOutdoor::DestroyTerrain
PUBLIC	?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ; CMapOutdoor::CreateTerrainPatchProxyList
PUBLIC	?DestroyTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ; CMapOutdoor::DestroyTerrainPatchProxyList
PUBLIC	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
PUBLIC	?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z		; CMapOutdoor::GetTerrainHeight
PUBLIC	?GetWaterHeight@CMapOutdoor@@QAE_NHHPAJ@Z	; CMapOutdoor::GetWaterHeight
PUBLIC	?GetNormal@CMapOutdoor@@QAE_NHHPAUD3DXVECTOR3@@@Z ; CMapOutdoor::GetNormal
PUBLIC	?DestroyArea@CMapOutdoor@@MAEXXZ		; CMapOutdoor::DestroyArea
PUBLIC	?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z ; CMapOutdoor::ConvertToMapCoords
PUBLIC	?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ; CMapOutdoor::GetAreaPointer
PUBLIC	?GetHeight@CMapOutdoor@@QAEMPAM@Z		; CMapOutdoor::GetHeight
PUBLIC	?GetBrushColor@CMapOutdoor@@QAE_NMMPAM0@Z	; CMapOutdoor::GetBrushColor
PUBLIC	?isAttrOn@CMapOutdoor@@QAE_NMME@Z		; CMapOutdoor::isAttrOn
PUBLIC	?GetAttr@CMapOutdoor@@QAE_NMMPAE@Z		; CMapOutdoor::GetAttr
PUBLIC	?isAttrOn@CMapOutdoor@@QAE_NHHE@Z		; CMapOutdoor::isAttrOn
PUBLIC	?GetAttr@CMapOutdoor@@QAE_NHHPAE@Z		; CMapOutdoor::GetAttr
PUBLIC	?GetTerrainNum@CMapOutdoor@@QAE_NMMPAE@Z	; CMapOutdoor::GetTerrainNum
PUBLIC	?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
PUBLIC	??1?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::~vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >
PUBLIC	?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear
PUBLIC	?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Tidy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<float,long> > >::_Vector_val<std::_Simple_types<std::pair<float,long> > >
PUBLIC	??1?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::~vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Tidy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z ; CMapOutdoor::BuildViewFrustum
PUBLIC	??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
PUBLIC	?_Copy_assign@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Copy_assign
PUBLIC	?_Clear_and_reserve_geometric@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Clear_and_reserve_geometric
PUBLIC	?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
PUBLIC	?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size
PUBLIC	?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy_raw
PUBLIC	?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
PUBLIC	??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
PUBLIC	?_Copy_assign@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Copy_assign
PUBLIC	?_Clear_and_reserve_geometric@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Clear_and_reserve_geometric
PUBLIC	?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear
PUBLIC	?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::max_size
PUBLIC	?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Buy_raw
PUBLIC	?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	??0?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::list<tagRECT,std::allocator<tagRECT> >
PUBLIC	??1?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::~list<tagRECT,std::allocator<tagRECT> >
PUBLIC	?begin@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UtagRECT@@@std@@@std@@@2@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::begin
PUBLIC	?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::clear
PUBLIC	?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::_Alloc_sentinel_and_proxy
PUBLIC	??0?$CDynamicPool@VCMonsterAreaInfo@@@@QAE@XZ	; CDynamicPool<CMonsterAreaInfo>::CDynamicPool<CMonsterAreaInfo>
PUBLIC	??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ	; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>
PUBLIC	?Destroy@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ; CDynamicPool<CMonsterAreaInfo>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ ; CDynamicPool<CMonsterAreaInfo>::Alloc
PUBLIC	?FreeAll@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ; CDynamicPool<CMonsterAreaInfo>::FreeAll
PUBLIC	?Delete@?$CDynamicPool@VCMonsterAreaInfo@@@@KAXPAVCMonsterAreaInfo@@@Z ; CDynamicPool<CMonsterAreaInfo>::Delete
PUBLIC	??_G?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z ; CDynamicPool<CMonsterAreaInfo>::`scalar deleting destructor'
PUBLIC	?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z ; CMapOutdoor::AddMonsterAreaInfo
PUBLIC	?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ	; CMapOutdoor::RemoveAllMonsterAreaInfo
PUBLIC	?GetMonsterAreaInfoFromVectorIndex@CMapOutdoor@@QAE_NKPAPAVCMonsterAreaInfo@@@Z ; CMapOutdoor::GetMonsterAreaInfoFromVectorIndex
PUBLIC	?AddNewMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJW4EMonsterAreaInfoType@2@KKW4EMonsterDir@2@@Z ; CMapOutdoor::AddNewMonsterAreaInfo
PUBLIC	?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z		; CMapOutdoor::GetBaseXY
PUBLIC	?SetBaseXY@CMapOutdoor@@QAEXKK@Z		; CMapOutdoor::SetBaseXY
PUBLIC	?EnablePortal@CMapOutdoor@@QAEX_N@Z		; CMapOutdoor::EnablePortal
PUBLIC	?__XMasTree_Initialize@CMapOutdoor@@AAEXXZ	; CMapOutdoor::__XMasTree_Initialize
PUBLIC	?__XMasTree_Create@CMapOutdoor@@AAEXMMMPBD0@Z	; CMapOutdoor::__XMasTree_Create
PUBLIC	?XMasTree_Destroy@CMapOutdoor@@QAEXXZ		; CMapOutdoor::XMasTree_Destroy
PUBLIC	?XMasTree_Set@CMapOutdoor@@QAEXMMMPBD0@Z	; CMapOutdoor::XMasTree_Set
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Insert_node
PUBLIC	??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
PUBLIC	?SpecialEffect_Create@CMapOutdoor@@QAEXKMMMPBD@Z ; CMapOutdoor::SpecialEffect_Create
PUBLIC	?SpecialEffect_Delete@CMapOutdoor@@QAEXK@Z	; CMapOutdoor::SpecialEffect_Delete
PUBLIC	?SpecialEffect_Destroy@CMapOutdoor@@QAEXXZ	; CMapOutdoor::SpecialEffect_Destroy
PUBLIC	?deallocate@?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@QAEXQAUSItem@SHeightCache@CMapOutdoor@@I@Z ; std::allocator<CMapOutdoor::SHeightCache::SItem>::deallocate
PUBLIC	??0?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
PUBLIC	??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
PUBLIC	?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::clear
PUBLIC	?_Destroy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXPAUSItem@SHeightCache@CMapOutdoor@@0@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@ABEII@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXQAUSItem@SHeightCache@CMapOutdoor@@II@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Change_array
PUBLIC	?_Tidy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Tidy
PUBLIC	?_Xlength@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@CAXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Xlength
PUBLIC	??1SHeightCache@CMapOutdoor@@QAE@XZ		; CMapOutdoor::SHeightCache::~SHeightCache
PUBLIC	?__HeightCache_Init@CMapOutdoor@@AAEXXZ		; CMapOutdoor::__HeightCache_Init
PUBLIC	?__HeightCache_Update@CMapOutdoor@@AAEXXZ	; CMapOutdoor::__HeightCache_Update
PUBLIC	?SetEnvironmentDataName@CMapOutdoor@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CMapOutdoor::SetEnvironmentDataName
PUBLIC	??_GCMapOutdoor@@UAEPAXI@Z			; CMapOutdoor::`scalar deleting destructor'
PUBLIC	??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetObjectHeight::operator()
PUBLIC	??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetPickingPoint::operator()
PUBLIC	?FreeAll@?$CDynamicPool@VCArea@@@@QAEXXZ	; CDynamicPool<CArea>::FreeAll
PUBLIC	?FreeAll@?$CDynamicPool@VCTerrain@@@@QAEXXZ	; CDynamicPool<CTerrain>::FreeAll
PUBLIC	??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z ; CCullingManager::ForInRange2d<FGetPickingPoint>
PUBLIC	??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ	; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>
PUBLIC	?RayTraceCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<FGetObjectHeight>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetObjectHeight>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetObjectHeight>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetObjectHeight>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z ; RangeTester<FGetObjectHeight>::`scalar deleting destructor'
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >
PUBLIC	??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z ; CCullingManager::ForInRay<FGetObjectHeight>
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >,std::_Iterator_base0>::operator++
PUBLIC	??0?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::begin
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::max_size
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::find
PUBLIC	?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Check_grow_by_1
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Rrotate
PUBLIC	?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Insert_node
PUBLIC	??0?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >
PUBLIC	??1?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::~map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >,std::_Iterator_base0>::operator++
PUBLIC	??$stl_wipe_second@V?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@@YAXAAV?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@Z ; stl_wipe_second<std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > > >
PUBLIC	??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::_Try_emplace<int const &>
PUBLIC	??$_Find@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find<int>
PUBLIC	??$emplace_back@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXABUSItem@SHeightCache@CMapOutdoor@@@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::emplace_back<CMapOutdoor::SHeightCache::SItem const &>
PUBLIC	??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Emplace_reallocate<CMapOutdoor::SHeightCache::SItem const &>
PUBLIC	??$_Find@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find<unsigned long>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@std@@P6AXPAVCMonsterAreaInfo@@@Z@std@@YAP6AXPAVCMonsterAreaInfo@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMonsterAreaInfo *> > >,void (__cdecl*)(CMonsterAreaInfo *)>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Free_non_head<std::allocator<std::_List_node<tagRECT,void *> > >
PUBLIC	??$_Emplace@ABUtagRECT@@@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@1@QAU21@ABUtagRECT@@@Z ; std::list<tagRECT,std::allocator<tagRECT> >::_Emplace<tagRECT const &>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
PUBLIC	??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_back_with_unused_capacity<CMonsterAreaInfo * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_reallocate<CMonsterAreaInfo * const &>
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Freenode0<std::allocator<std::_List_node<tagRECT,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
PUBLIC	??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<float,long> > >
PUBLIC	??$?0ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const > const &,std::_Zero_then_variadic_args_t>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Pocca@V?$allocator@PAVCArea@@@std@@@std@@YAXAAV?$allocator@PAVCArea@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CArea *> >
PUBLIC	??$_Pocca@V?$allocator@PAVCTerrain@@@std@@@std@@YAXAAV?$allocator@PAVCTerrain@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CTerrain *> >
PUBLIC	??$_Destroy_range@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@QAU12@AAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::TPatchDrawStruct> >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
PUBLIC	??$_Pocca@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXAAV?$allocator@PAVCMonsterAreaInfo@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CMonsterAreaInfo *> >
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@QAPAV1@AAV?$allocator@PAVCGraphicObjectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicObjectInstance *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??1?$RangeTester@UFGetPickingPoint@@@@UAE@XZ	; RangeTester<FGetPickingPoint>::~RangeTester<FGetPickingPoint>
PUBLIC	?RayTraceCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<FGetPickingPoint>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetPickingPoint>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetPickingPoint>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<FGetPickingPoint>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z ; RangeTester<FGetPickingPoint>::`scalar deleting destructor'
PUBLIC	??$emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KK@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::emplace<std::pair<unsigned long,unsigned long> >
PUBLIC	??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find_lower_bound<int>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
PUBLIC	??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find_lower_bound<unsigned long>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_Transfer_before
PUBLIC	??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > ><tagRECT const &>
PUBLIC	??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<tagRECT,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>
PUBLIC	??$_Assign_range@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0Uforward_iterator_tag@1@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Assign_range<CArea * *>
PUBLIC	??$_Assign_range@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0Uforward_iterator_tag@1@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Assign_range<CTerrain * *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>
PUBLIC	??$_Assign_range@PAPAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0Uforward_iterator_tag@1@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Assign_range<CMonsterAreaInfo * *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
PUBLIC	??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >
PUBLIC	??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >
PUBLIC	??$_Emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@_N@1@$$QAU?$pair@KK@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Emplace<std::pair<unsigned long,unsigned long> >
PUBLIC	??$construct@U?$pair@$$CBHPAE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@QAU?$pair@$$CBHPAE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::construct<std::pair<int const ,unsigned char *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
PUBLIC	??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
PUBLIC	??$_Refancy@PAPAVCArea@@$0A@@std@@YAPAPAVCArea@@PAPAV1@@Z ; std::_Refancy<CArea * *,0>
PUBLIC	??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
PUBLIC	??$_Refancy@PAPAVCTerrain@@$0A@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ; std::_Refancy<CTerrain * *,0>
PUBLIC	??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z ; std::_Copy_memmove<CMonsterAreaInfo * *,CMonsterAreaInfo * *>
PUBLIC	??$_Refancy@PAPAVCMonsterAreaInfo@@$0A@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@@Z ; std::_Refancy<CMonsterAreaInfo * *,0>
PUBLIC	??$_Copy_memmove@PAUSItem@SHeightCache@CMapOutdoor@@PAU123@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@PAU123@00@Z ; std::_Copy_memmove<CMapOutdoor::SHeightCache::SItem *,CMapOutdoor::SHeightCache::SItem *>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
PUBLIC	??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
PUBLIC	??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > ><std::pair<unsigned long,unsigned long> >
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0BB@GCADKGJO@map?1set?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
PUBLIC	??_7?$CDynamicPool@VCMonsterAreaInfo@@@@6B@	; CDynamicPool<CMonsterAreaInfo>::`vftable'
PUBLIC	??_7CMapOutdoor@@6B@				; CMapOutdoor::`vftable'
PUBLIC	??_C@_0BN@FIOHACND@D?3?1ymir?5work?1special?1fog?4tga@ ; `string'
PUBLIC	??_C@_0BP@JMMOMCFP@d?3?1ymir?5work?1special?1white?4dds@ ; `string'
PUBLIC	??_C@_0CI@OKIKMFPM@d?3?1ymir?5Work?1special?1PCBlockerA@ ; `string'
PUBLIC	??_C@_0BJ@GGJMMCMN@d?3?1ymir?5work?1environment@ ; `string'
PUBLIC	??_7?$RangeTester@UFGetObjectHeight@@@@6B@	; RangeTester<FGetObjectHeight>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_7?$RangeTester@UFGetPickingPoint@@@@6B@	; RangeTester<FGetPickingPoint>::`vftable'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CMapOutdoor@@6B@				; CMapOutdoor::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCMapOutdoor@@@8				; CMapOutdoor `RTTI Type Descriptor'
PUBLIC	??_R3CMapOutdoor@@8				; CMapOutdoor::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMapOutdoor@@8				; CMapOutdoor::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CMapOutdoor@@8			; CMapOutdoor::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CMapBase@@8			; CMapBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCMapBase@@@8				; CMapBase `RTTI Type Descriptor'
PUBLIC	??_R3CMapBase@@8				; CMapBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CMapBase@@8				; CMapBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CScreen@@8			; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCScreen@@@8				; CScreen `RTTI Type Descriptor'
PUBLIC	??_R3CScreen@@8					; CScreen::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CScreen@@8					; CScreen::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicCollisionObject@@8	; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicCollisionObject@@@8		; CGraphicCollisionObject `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicCollisionObject@@8			; CGraphicCollisionObject::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicBase@@8			; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicBase@@@8			; CGraphicBase `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicBase@@8				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicBase@@8				; CGraphicBase::`RTTI Base Class Array'
PUBLIC	??_R4?$CDynamicPool@VCMonsterAreaInfo@@@@6B@	; CDynamicPool<CMonsterAreaInfo>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCMonsterAreaInfo@@@@@8	; CDynamicPool<CMonsterAreaInfo> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCMonsterAreaInfo@@@@8	; CDynamicPool<CMonsterAreaInfo>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCMonsterAreaInfo@@@@8	; CDynamicPool<CMonsterAreaInfo>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCMonsterAreaInfo@@@@8 ; CDynamicPool<CMonsterAreaInfo>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$RangeTester@UFGetObjectHeight@@@@6B@	; RangeTester<FGetObjectHeight>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UFGetObjectHeight@@@@@8	; RangeTester<FGetObjectHeight> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UFGetObjectHeight@@@@8	; RangeTester<FGetObjectHeight>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UFGetObjectHeight@@@@8	; RangeTester<FGetObjectHeight>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UFGetObjectHeight@@@@8 ; RangeTester<FGetObjectHeight>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$RangeTester@UFGetPickingPoint@@@@6B@	; RangeTester<FGetPickingPoint>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UFGetPickingPoint@@@@@8	; RangeTester<FGetPickingPoint> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UFGetPickingPoint@@@@8	; RangeTester<FGetPickingPoint>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UFGetPickingPoint@@@@8	; RangeTester<FGetPickingPoint>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UFGetPickingPoint@@@@8 ; RangeTester<FGetPickingPoint>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3c23d70a
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40a00000
PUBLIC	__real@41200000
PUBLIC	__real@42c80000
PUBLIC	__real@43c80000
PUBLIC	__real@459c4000
PUBLIC	__real@461c4000
PUBLIC	__real@46c35000
PUBLIC	__real@46c80000
PUBLIC	__real@47c35000
PUBLIC	__real@ba83126f
PUBLIC	__real@bf800000
PUBLIC	__real@c0e00000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	?GetCaseCRC32@@YAKPBDI@Z:PROC			; GetCaseCRC32
EXTRN	_D3DXPlaneNormalize@8:PROC
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	??0CGraphicIndexBuffer@@QAE@XZ:PROC		; CGraphicIndexBuffer::CGraphicIndexBuffer
EXTRN	??1CGraphicIndexBuffer@@UAE@XZ:PROC		; CGraphicIndexBuffer::~CGraphicIndexBuffer
EXTRN	?Destroy@CGraphicIndexBuffer@@QAEXXZ:PROC	; CGraphicIndexBuffer::Destroy
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?Destroy@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Destroy
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImageInstance::GetTexturePointer
EXTRN	??0CSkyBox@@QAE@XZ:PROC				; CSkyBox::CSkyBox
EXTRN	??1CSkyBox@@UAE@XZ:PROC				; CSkyBox::~CSkyBox
EXTRN	?Unload@CSkyBox@@QAEXXZ:PROC			; CSkyBox::Unload
EXTRN	?SetSkyBoxScale@CSkyBox@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CSkyBox::SetSkyBoxScale
EXTRN	?SetGradientLevel@CSkyBox@@QAEXEE@Z:PROC	; CSkyBox::SetGradientLevel
EXTRN	?SetFaceTexture@CSkyBox@@QAEXPBDH@Z:PROC	; CSkyBox::SetFaceTexture
EXTRN	?SetCloudTexture@CSkyBox@@QAEXPBD@Z:PROC	; CSkyBox::SetCloudTexture
EXTRN	?SetCloudScale@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z:PROC ; CSkyBox::SetCloudScale
EXTRN	?SetCloudHeight@CSkyBox@@QAEXM@Z:PROC		; CSkyBox::SetCloudHeight
EXTRN	?SetCloudTextureScale@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z:PROC ; CSkyBox::SetCloudTextureScale
EXTRN	?SetCloudScrollSpeed@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z:PROC ; CSkyBox::SetCloudScrollSpeed
EXTRN	?SetCloudColor@CSkyBox@@QAEXABUTGradientColor@@0ABK@Z:PROC ; CSkyBox::SetCloudColor
EXTRN	?Refresh@CSkyBox@@QAEXXZ:PROC			; CSkyBox::Refresh
EXTRN	?SetSkyColor@CSkyBox@@QAEXABV?$vector@UTGradientColor@@V?$allocator@UTGradientColor@@@std@@@std@@0J@Z:PROC ; CSkyBox::SetSkyColor
EXTRN	?GetFogNearDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogNearDistance
EXTRN	?GetFogFarDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogFarDistance
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	?RayTrace@SpherePackFactory@@QAEXABVVector3d@@0PAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RayTrace
EXTRN	?PointTest2d@SpherePackFactory@@QAEXABVVector3d@@PAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::PointTest2d
EXTRN	?Clear@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Clear
EXTRN	?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ:PROC ; CGraphicObjectInstance::IsObjectHeight
EXTRN	?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z:PROC ; CGraphicObjectInstance::GetObjectHeight
EXTRN	?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z:PROC ; CEffectManager::RegisterEffect
EXTRN	?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z:PROC ; CEffectManager::CreateEffect
EXTRN	?SelectEffectInstance@CEffectManager@@QAEHK@Z:PROC ; CEffectManager::SelectEffectInstance
EXTRN	?DestroyEffectInstance@CEffectManager@@QAE_NK@Z:PROC ; CEffectManager::DestroyEffectInstance
EXTRN	?SetEffectInstanceGlobalMatrix@CEffectManager@@QAEXABUD3DXMATRIX@@@Z:PROC ; CEffectManager::SetEffectInstanceGlobalMatrix
EXTRN	??0CLensFlare@@QAE@XZ:PROC			; CLensFlare::CLensFlare
EXTRN	??1CLensFlare@@UAE@XZ:PROC			; CLensFlare::~CLensFlare
EXTRN	?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z:PROC ; CLensFlare::SetMainFlare
EXTRN	?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CLensFlare::Initialize
EXTRN	?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z:PROC ; CLensFlare::CharacterizeFlare
EXTRN	??0CScreenFilter@@QAE@XZ:PROC			; CScreenFilter::CScreenFilter
EXTRN	??1CScreenFilter@@UAE@XZ:PROC			; CScreenFilter::~CScreenFilter
EXTRN	?SetEnable@CScreenFilter@@QAEXH@Z:PROC		; CScreenFilter::SetEnable
EXTRN	?SetBlendType@CScreenFilter@@QAEXEE@Z:PROC	; CScreenFilter::SetBlendType
EXTRN	?SetColor@CScreenFilter@@QAEXABUD3DXCOLOR@@@Z:PROC ; CScreenFilter::SetColor
EXTRN	??0CTextureSet@@QAE@XZ:PROC			; CTextureSet::CTextureSet
EXTRN	??1CTextureSet@@UAE@XZ:PROC			; CTextureSet::~CTextureSet
EXTRN	?CreateInstance@CSpeedTreeForest@@QAEPAVCSpeedTreeWrapper@@MMMKPBD@Z:PROC ; CSpeedTreeForest::CreateInstance
EXTRN	?DeleteInstance@CSpeedTreeForest@@QAEXPAVCSpeedTreeWrapper@@@Z:PROC ; CSpeedTreeForest::DeleteInstance
EXTRN	?Clear@CSpeedTreeForest@@QAEXXZ:PROC		; CSpeedTreeForest::Clear
EXTRN	?SetLight@CSpeedTreeForest@@QAEXPBM00@Z:PROC	; CSpeedTreeForest::SetLight
EXTRN	?SetFog@CSpeedTreeForest@@QAEXMM@Z:PROC		; CSpeedTreeForest::SetFog
EXTRN	?SetWindStrength@CSpeedTreeForest@@QAEXM@Z:PROC	; CSpeedTreeForest::SetWindStrength
EXTRN	??0CMapBase@@QAE@XZ:PROC			; CMapBase::CMapBase
EXTRN	??1CMapBase@@UAE@XZ:PROC			; CMapBase::~CMapBase
EXTRN	?Clear@CMapBase@@UAEXXZ:PROC			; CMapBase::Clear
EXTRN	?Picking@CGraphicThingInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z:PROC ; CGraphicThingInstance::Picking
EXTRN	?EnablePortal@CArea@@QAEXH@Z:PROC		; CArea::EnablePortal
EXTRN	?DestroySystem@CArea@@SAXXZ:PROC		; CArea::DestroySystem
EXTRN	?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z:PROC	; CTerrainImpl::GetShadowMapColor
EXTRN	??0CTerrainPatchProxy@@QAE@XZ:PROC		; CTerrainPatchProxy::CTerrainPatchProxy
EXTRN	??1CTerrainPatchProxy@@UAE@XZ:PROC		; CTerrainPatchProxy::~CTerrainPatchProxy
EXTRN	?GetHeight@CTerrain@@QAEMHH@Z:PROC		; CTerrain::GetHeight
EXTRN	?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z:PROC ; CTerrain::GetNormal
EXTRN	?GetAttr@CTerrain@@QAEEGG@Z:PROC		; CTerrain::GetAttr
EXTRN	?isAttrOn@CTerrain@@QAE_NGGE@Z:PROC		; CTerrain::isAttrOn
EXTRN	?GetWaterHeight@CTerrain@@QAEXEPAJ@Z:PROC	; CTerrain::GetWaterHeight
EXTRN	?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z:PROC	; CTerrain::GetWaterHeight
EXTRN	?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z:PROC	; CTerrain::AllocateMarkedSplats
EXTRN	?DeallocateMarkedSplats@CTerrain@@QAEXXZ:PROC	; CTerrain::DeallocateMarkedSplats
EXTRN	?DestroySystem@CTerrain@@SAXXZ:PROC		; CTerrain::DestroySystem
EXTRN	??0CMonsterAreaInfo@@QAE@XZ:PROC		; CMonsterAreaInfo::CMonsterAreaInfo
EXTRN	?Clear@CMonsterAreaInfo@@QAEXXZ:PROC		; CMonsterAreaInfo::Clear
EXTRN	?SetOrigin@CMonsterAreaInfo@@QAEXJJ@Z:PROC	; CMonsterAreaInfo::SetOrigin
EXTRN	?SetSize@CMonsterAreaInfo@@QAEXJJ@Z:PROC	; CMonsterAreaInfo::SetSize
EXTRN	?SetMonsterCount@CMonsterAreaInfo@@QAEXK@Z:PROC	; CMonsterAreaInfo::SetMonsterCount
EXTRN	?SetMonsterDirection@CMonsterAreaInfo@@QAEXW4EMonsterDir@1@@Z:PROC ; CMonsterAreaInfo::SetMonsterDirection
EXTRN	?OnRender@CMapOutdoor@@MAEXXZ:PROC		; CMapOutdoor::OnRender
EXTRN	?Load@CMapOutdoor@@UAE_NMMM@Z:PROC		; CMapOutdoor::Load
EXTRN	?Update@CMapOutdoor@@UAE_NMMM@Z:PROC		; CMapOutdoor::Update
EXTRN	?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z:PROC ; CMapOutdoor::UpdateAroundAmbience
EXTRN	?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z:PROC ; CMapOutdoor::ApplyLight
EXTRN	?ReleaseCharacterShadowTexture@CMapOutdoor@@QAEXXZ:PROC ; CMapOutdoor::ReleaseCharacterShadowTexture
EXTRN	?__ClearGarvage@CMapOutdoor@@MAEXXZ:PROC	; CMapOutdoor::__ClearGarvage
EXTRN	?__UpdateGarvage@CMapOutdoor@@MAEXXZ:PROC	; CMapOutdoor::__UpdateGarvage
EXTRN	?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z:PROC	; CMapOutdoor::LoadTerrain
EXTRN	?LoadArea@CMapOutdoor@@MAE_NGGGG@Z:PROC		; CMapOutdoor::LoadArea
EXTRN	?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z:PROC	; CMapOutdoor::UpdateAreaList
EXTRN	?FreeQuadTree@CMapOutdoor@@IAEXXZ:PROC		; CMapOutdoor::FreeQuadTree
EXTRN	?UnloadWaterTexture@CMapOutdoor@@IAEXXZ:PROC	; CMapOutdoor::UnloadWaterTexture
EXTRN	?SetIndexBuffer@CMapOutdoor@@IAEXXZ:PROC	; CMapOutdoor::SetIndexBuffer
EXTRN	?InitializeVisibleParts@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::InitializeVisibleParts
EXTRN	?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::__SoftwareTransformPatch_Initialize
EXTRN	?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ:PROC ; CMapOutdoor::__SoftwareTransformPatch_Create
EXTRN	?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ:PROC ; CMapOutdoor::__SoftwareTransformPatch_Destroy
EXTRN	??_E?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z:PROC ; CDynamicPool<CMonsterAreaInfo>::`vector deleting destructor'
EXTRN	??_ECMapOutdoor@@UAEPAXI@Z:PROC			; CMapOutdoor::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z:PROC ; RangeTester<FGetObjectHeight>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	??_E?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z:PROC ; RangeTester<FGetPickingPoint>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_Ray@CGraphicBase@@1VCRay@@A:BYTE		; CGraphicBase::ms_Ray
EXTRN	?PR_FCNV@@3MA:DWORD				; PR_FCNV
EXTRN	?PR_ICNV@@3JA:DWORD				; PR_ICNV
EXTRN	?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A:BYTE ; CArea::ms_kPool
EXTRN	?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A:BYTE ; CTerrain::ms_kPool
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A DD 01H DUP (?) ; CSingleton<CEffectManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A DD 01H DUP (?) ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@c0e00000
CONST	SEGMENT
__real@c0e00000 DD 0c0e00000r			; -7
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@ba83126f
CONST	SEGMENT
__real@ba83126f DD 0ba83126fr			; -0.001
CONST	ENDS
;	COMDAT __real@47c35000
CONST	SEGMENT
__real@47c35000 DD 047c35000r			; 100000
CONST	ENDS
;	COMDAT __real@46c80000
CONST	SEGMENT
__real@46c80000 DD 046c80000r			; 25600
CONST	ENDS
;	COMDAT __real@46c35000
CONST	SEGMENT
__real@46c35000 DD 046c35000r			; 25000
CONST	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@43c80000
CONST	SEGMENT
__real@43c80000 DD 043c80000r			; 400
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@41200000
CONST	SEGMENT
__real@41200000 DD 041200000r			; 10
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c23d70a
CONST	SEGMENT
__real@3c23d70a DD 03c23d70ar			; 0.01
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UFGetPickingPoint@@@@8 DD FLAT:??_R0?AU?$RangeTester@UFGetPickingPoint@@@@@8 ; RangeTester<FGetPickingPoint>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UFGetPickingPoint@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UFGetPickingPoint@@@@8 ; RangeTester<FGetPickingPoint>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UFGetPickingPoint@@@@8 DD 00H	; RangeTester<FGetPickingPoint>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UFGetPickingPoint@@@@@8
data$rs	SEGMENT
??_R0?AU?$RangeTester@UFGetPickingPoint@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<FGetPickingPoint> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UFGetPickingPoint@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$RangeTester@UFGetPickingPoint@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UFGetPickingPoint@@@@6B@ DD 00H	; RangeTester<FGetPickingPoint>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UFGetPickingPoint@@@@@8
	DD	FLAT:??_R3?$RangeTester@UFGetPickingPoint@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UFGetObjectHeight@@@@8 DD FLAT:??_R0?AU?$RangeTester@UFGetObjectHeight@@@@@8 ; RangeTester<FGetObjectHeight>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UFGetObjectHeight@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UFGetObjectHeight@@@@8 ; RangeTester<FGetObjectHeight>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UFGetObjectHeight@@@@8 DD 00H	; RangeTester<FGetObjectHeight>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UFGetObjectHeight@@@@@8
data$rs	SEGMENT
??_R0?AU?$RangeTester@UFGetObjectHeight@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<FGetObjectHeight> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UFGetObjectHeight@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$RangeTester@UFGetObjectHeight@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UFGetObjectHeight@@@@6B@ DD 00H	; RangeTester<FGetObjectHeight>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UFGetObjectHeight@@@@@8
	DD	FLAT:??_R3?$RangeTester@UFGetObjectHeight@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCMonsterAreaInfo@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCMonsterAreaInfo@@@@@8 ; CDynamicPool<CMonsterAreaInfo>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCMonsterAreaInfo@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCMonsterAreaInfo@@@@8 ; CDynamicPool<CMonsterAreaInfo>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCMonsterAreaInfo@@@@8 DD 00H	; CDynamicPool<CMonsterAreaInfo>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCMonsterAreaInfo@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCMonsterAreaInfo@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CMonsterAreaInfo> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCMonsterAreaInfo@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCMonsterAreaInfo@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCMonsterAreaInfo@@@@6B@ DD 00H	; CDynamicPool<CMonsterAreaInfo>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCMonsterAreaInfo@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCMonsterAreaInfo@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicBase@@8
rdata$r	SEGMENT
??_R2CGraphicBase@@8 DD FLAT:??_R1A@?0A@EA@CGraphicBase@@8 ; CGraphicBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicBase@@8
rdata$r	SEGMENT
??_R3CGraphicBase@@8 DD 00H				; CGraphicBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicBase@@@8
data$rs	SEGMENT
??_R0?AVCGraphicBase@@@8 DD FLAT:??_7type_info@@6B@	; CGraphicBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicBase@@8 DD FLAT:??_R0?AVCGraphicBase@@@8 ; CGraphicBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R2CGraphicCollisionObject@@8 DD FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8 ; CGraphicCollisionObject::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R3CGraphicCollisionObject@@8 DD 00H			; CGraphicCollisionObject::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicCollisionObject@@@8
data$rs	SEGMENT
??_R0?AVCGraphicCollisionObject@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicCollisionObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicCollisionObject@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicCollisionObject@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicCollisionObject@@8 DD FLAT:??_R0?AVCGraphicCollisionObject@@@8 ; CGraphicCollisionObject::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicCollisionObject@@8
rdata$r	ENDS
;	COMDAT ??_R2CScreen@@8
rdata$r	SEGMENT
??_R2CScreen@@8 DD FLAT:??_R1A@?0A@EA@CScreen@@8	; CScreen::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CScreen@@8
rdata$r	SEGMENT
??_R3CScreen@@8 DD 00H					; CScreen::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCScreen@@@8
data$rs	SEGMENT
??_R0?AVCScreen@@@8 DD FLAT:??_7type_info@@6B@		; CScreen `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCScreen@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CScreen@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CScreen@@8 DD FLAT:??_R0?AVCScreen@@@8	; CScreen::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CScreen@@8
rdata$r	ENDS
;	COMDAT ??_R2CMapBase@@8
rdata$r	SEGMENT
??_R2CMapBase@@8 DD FLAT:??_R1A@?0A@EA@CMapBase@@8	; CMapBase::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CMapBase@@8
rdata$r	SEGMENT
??_R3CMapBase@@8 DD 00H					; CMapBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CMapBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMapBase@@@8
data$rs	SEGMENT
??_R0?AVCMapBase@@@8 DD FLAT:??_7type_info@@6B@		; CMapBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMapBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CMapBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMapBase@@8 DD FLAT:??_R0?AVCMapBase@@@8	; CMapBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMapBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CMapOutdoor@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CMapOutdoor@@8 DD FLAT:??_R0?AVCMapOutdoor@@@8 ; CMapOutdoor::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CMapOutdoor@@8
rdata$r	ENDS
;	COMDAT ??_R2CMapOutdoor@@8
rdata$r	SEGMENT
??_R2CMapOutdoor@@8 DD FLAT:??_R1A@?0A@EA@CMapOutdoor@@8 ; CMapOutdoor::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CMapBase@@8
	DD	FLAT:??_R1A@?0A@EA@CScreen@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicCollisionObject@@8
	DD	FLAT:??_R1A@?0A@EA@CGraphicBase@@8
rdata$r	ENDS
;	COMDAT ??_R3CMapOutdoor@@8
rdata$r	SEGMENT
??_R3CMapOutdoor@@8 DD 00H				; CMapOutdoor::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2CMapOutdoor@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCMapOutdoor@@@8
data$rs	SEGMENT
??_R0?AVCMapOutdoor@@@8 DD FLAT:??_7type_info@@6B@	; CMapOutdoor `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCMapOutdoor@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CMapOutdoor@@6B@
rdata$r	SEGMENT
??_R4CMapOutdoor@@6B@ DD 00H				; CMapOutdoor::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCMapOutdoor@@@8
	DD	FLAT:??_R3CMapOutdoor@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$rs	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$RangeTester@UFGetPickingPoint@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UFGetPickingPoint@@@@6B@ DD FLAT:??_R4?$RangeTester@UFGetPickingPoint@@@@6B@ ; RangeTester<FGetPickingPoint>::`vftable'
	DD	FLAT:??_E?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UFGetObjectHeight@@@@6B@ DD FLAT:??_R4?$RangeTester@UFGetObjectHeight@@@@6B@ ; RangeTester<FGetObjectHeight>::`vftable'
	DD	FLAT:??_E?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_C@_0BJ@GGJMMCMN@d?3?1ymir?5work?1environment@
CONST	SEGMENT
??_C@_0BJ@GGJMMCMN@d?3?1ymir?5work?1environment@ DB 'd:/ymir work/environ'
	DB	'ment', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OKIKMFPM@d?3?1ymir?5Work?1special?1PCBlockerA@
CONST	SEGMENT
??_C@_0CI@OKIKMFPM@d?3?1ymir?5Work?1special?1PCBlockerA@ DB 'd:/ymir Work'
	DB	'/special/PCBlockerAlpha.dds', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JMMOMCFP@d?3?1ymir?5work?1special?1white?4dds@
CONST	SEGMENT
??_C@_0BP@JMMOMCFP@d?3?1ymir?5work?1special?1white?4dds@ DB 'd:/ymir work'
	DB	'/special/white.dds', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FIOHACND@D?3?1ymir?5work?1special?1fog?4tga@
CONST	SEGMENT
??_C@_0BN@FIOHACND@D?3?1ymir?5work?1special?1fog?4tga@ DB 'D:/ymir work/s'
	DB	'pecial/fog.tga', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CMapOutdoor@@6B@
CONST	SEGMENT
??_7CMapOutdoor@@6B@ DD FLAT:??_R4CMapOutdoor@@6B@	; CMapOutdoor::`vftable'
	DD	FLAT:??_ECMapOutdoor@@UAEPAXI@Z
	DD	FLAT:?Clear@CMapOutdoor@@UAEXXZ
	DD	FLAT:?Initialize@CMapOutdoor@@MAE_NXZ
	DD	FLAT:?Destroy@CMapOutdoor@@MAE_NXZ
	DD	FLAT:?Load@CMapOutdoor@@UAE_NMMM@Z
	DD	FLAT:?Update@CMapOutdoor@@UAE_NMMM@Z
	DD	FLAT:?UpdateAroundAmbience@CMapOutdoor@@UAEXMMM@Z
	DD	FLAT:?GetHeight@CMapOutdoor@@UAEMMM@Z
	DD	FLAT:?OnBeginEnvironment@CMapOutdoor@@UAEXXZ
	DD	FLAT:?ApplyLight@CMapOutdoor@@UAEXKABU_D3DLIGHT8@@@Z
	DD	FLAT:?OnRender@CMapOutdoor@@MAEXXZ
	DD	FLAT:?OnSetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ
	DD	FLAT:?OnResetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ
	DD	FLAT:?OnPreAssignTerrainPtr@CMapOutdoor@@MAEXXZ
	DD	FLAT:?GetCacheHeight@CMapOutdoor@@UAEMMM@Z
	DD	FLAT:?__ClearGarvage@CMapOutdoor@@MAEXXZ
	DD	FLAT:?__UpdateGarvage@CMapOutdoor@@MAEXXZ
	DD	FLAT:?LoadTerrain@CMapOutdoor@@MAE_NGGGG@Z
	DD	FLAT:?LoadArea@CMapOutdoor@@MAE_NGGGG@Z
	DD	FLAT:?UpdateAreaList@CMapOutdoor@@MAEXJJ@Z
	DD	FLAT:?DestroyTerrain@CMapOutdoor@@MAEXXZ
	DD	FLAT:?DestroyArea@CMapOutdoor@@MAEXXZ
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCMonsterAreaInfo@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCMonsterAreaInfo@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCMonsterAreaInfo@@@@6B@ ; CDynamicPool<CMonsterAreaInfo>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
CONST	SEGMENT
??_C@_0BB@GCADKGJO@map?1set?5too?5long@ DB 'map/set too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z$1
__ehfuncinfo$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z$0
__ehfuncinfo$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$0
__ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z$0
__ehfuncinfo$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z$0
__ehfuncinfo$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1SHeightCache@CMapOutdoor@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ$0
__ehfuncinfo$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ$1
__ehfuncinfo$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z$0
__ehfuncinfo$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetHeight@CMapOutdoor@@UAEMMM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetHeight@CMapOutdoor@@UAEMMM@Z$0
__ehfuncinfo$?GetHeight@CMapOutdoor@@UAEMMM@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetHeight@CMapOutdoor@@UAEMMM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1CMapOutdoor@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1CMapOutdoor@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1CMapOutdoor@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CMapOutdoor@@QAE@XZ DD 019930522H
	DD	020H
	DD	FLAT:__unwindtable$??0CMapOutdoor@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CMapOutdoor@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$12
	DD	0cH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$13
	DD	0dH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$14
	DD	0eH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$15
	DD	0fH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$16
	DD	010H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$17
	DD	011H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$18
	DD	012H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$19
	DD	013H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$20
	DD	014H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$21
	DD	015H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$22
	DD	016H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$23
	DD	017H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$24
	DD	018H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$25
	DD	019H
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$26
	DD	01aH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$27
	DD	01bH
	DD	FLAT:___std_terminate
	DD	01bH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$28
	DD	01dH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$29
	DD	01eH
	DD	FLAT:__unwindfunclet$??0CMapOutdoor@@QAE@XZ$30
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_ECTerrainPatchProxy@@UAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z
_TEXT	SEGMENT
___formal$ = -48					; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
__Val$ = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > ><std::pair<unsigned long,unsigned long> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Allocate

; 786  :     }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	83 c0 10	 add	 eax, 16			; 00000010H
  00056	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00059	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  0005c	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 d0	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00067	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0006a	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006d	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00070	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 246  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00073	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00076	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 246  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  00079	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0007c	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
  0007f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00081	89 08		 mov	 DWORD PTR [eax], ecx
  00083	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  00086	83 c0 04	 add	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00089	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 246  :         : first(_STD forward<_Other1>(_Right.first)), second(_STD forward<_Other2>(_Right.second)) {}

  0008c	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0008f	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
  00092	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00094	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00097	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0009a	50		 push	 eax
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	ff 70 04	 push	 DWORD PTR [eax+4]
  000a1	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>
  000a6	59		 pop	 ecx
  000a7	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  000a8	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000ab	50		 push	 eax
  000ac	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b2	83 c0 04	 add	 eax, 4
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>
  000bb	59		 pop	 ecx
  000bc	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000bd	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000c0	50		 push	 eax
  000c1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c7	83 c0 08	 add	 eax, 8
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * &>
  000d0	59		 pop	 ecx
  000d1	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000d2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000e6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	c9		 leave
  000f5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > ><std::pair<unsigned long,unsigned long> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 18	 imul	 eax, eax, 24
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 18	 imul	 eax, eax, 24
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAUSItem@SHeightCache@CMapOutdoor@@PAU123@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@PAU123@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUSItem@SHeightCache@CMapOutdoor@@PAU123@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@PAU123@00@Z PROC ; std::_Copy_memmove<CMapOutdoor::SHeightCache::SItem *,CMapOutdoor::SHeightCache::SItem *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAUSItem@SHeightCache@CMapOutdoor@@PAU123@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@PAU123@00@Z ENDP ; std::_Copy_memmove<CMapOutdoor::SHeightCache::SItem *,CMapOutdoor::SHeightCache::SItem *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAPAVCMonsterAreaInfo@@$0A@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAPAVCMonsterAreaInfo@@$0A@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@@Z PROC ; std::_Refancy<CMonsterAreaInfo * *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAPAVCMonsterAreaInfo@@$0A@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@@Z ENDP ; std::_Refancy<CMonsterAreaInfo * *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CMonsterAreaInfo * *,CMonsterAreaInfo * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CMonsterAreaInfo * *,CMonsterAreaInfo * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAPAVCTerrain@@$0A@@std@@YAPAPAVCTerrain@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAPAVCTerrain@@$0A@@std@@YAPAPAVCTerrain@@PAPAV1@@Z PROC ; std::_Refancy<CTerrain * *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAPAVCTerrain@@$0A@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ENDP ; std::_Refancy<CTerrain * *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CTerrain * *,CTerrain * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAPAVCArea@@$0A@@std@@YAPAPAVCArea@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAPAVCArea@@$0A@@std@@YAPAPAVCArea@@PAPAV1@@Z PROC ; std::_Refancy<CArea * *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAPAVCArea@@$0A@@std@@YAPAPAVCArea@@PAPAV1@@Z ENDP ; std::_Refancy<CArea * *,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CArea * *,CArea * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CArea * *,CArea * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBHPAE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@QAU?$pair@$$CBHPAE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
_this$ = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
___formal$ = -16					; size = 1
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T8 = -3						; size = 1
$T9 = -2						; size = 1
$T10 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBHPAE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@QAU?$pair@$$CBHPAE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::construct<std::pair<int const ,unsigned char *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT

; 700  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000c	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0000f	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00012	8d 45 fd	 lea	 eax, DWORD PTR $T8[ebp]
  00015	89 45 cc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0001b	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00021	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00031	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00034	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00037	8a 00		 mov	 al, BYTE PTR [eax]
  00039	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  0003c	33 c0		 xor	 eax, eax
  0003e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
  00041	33 c0		 xor	 eax, eax
  00043	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
  00046	8a 45 ff	 mov	 al, BYTE PTR $T10[ebp]
  00049	88 45 f4	 mov	 BYTE PTR ___formal$[ebp], al
  0004c	8a 45 fe	 mov	 al, BYTE PTR $T9[ebp]
  0004f	88 45 f0	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00052	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00055	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 790  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

  00058	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 980  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

  00060	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  00063	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  0006d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 702  :     }

  00071	c9		 leave
  00072	c3		 ret	 0
??$construct@U?$pair@$$CBHPAE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@QAU?$pair@$$CBHPAE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::construct<std::pair<int const ,unsigned char *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@_N@1@$$QAU?$pair@KK@1@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 12
$T2 = -116						; size = 8
$T3 = -108						; size = 4
__Loc$ = -104						; size = 12
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
__Inserted$ = -80					; size = 4
$T7 = -76						; size = 4
__Old_val$8 = -72					; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
__Scary$ = -32						; size = 4
__Val$ = -28						; size = 4
tv147 = -24						; size = 4
tv167 = -20						; size = 4
__Bound$ = -16						; size = 4
__Keyval$18 = -12					; size = 4
_this$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$_Emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@_N@1@$$QAU?$pair@KK@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Emplace<std::pair<unsigned long,unsigned long> >, COMDAT
; _this$ = ecx

; 1002 :     pair<_Nodeptr, bool> _Emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00011	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00014	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00017	89 45 e0	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 2000 :         return _Val.first;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1008 :             const auto& _Keyval = _In_place_key_extractor::_Extract(_Vals...);

  0001d	89 45 f4	 mov	 DWORD PTR __Keyval$18[ebp], eax

; 1009 :             _Loc                = _Find_lower_bound(_Keyval);

  00020	ff 75 f4	 push	 DWORD PTR __Keyval$18[ebp]
  00023	8d 45 80	 lea	 eax, DWORD PTR $T1[ebp]
  00026	50		 push	 eax
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find_lower_bound<unsigned long>
  0002f	8b f0		 mov	 esi, eax
  00031	8d 7d 98	 lea	 edi, DWORD PTR __Loc$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00037	8b 45 a0	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0003a	89 45 f0	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __Bound$[ebp]
  00040	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00044	85 c0		 test	 eax, eax
  00046	75 37		 jne	 SHORT $LN39@Emplace

; 2035 :         return _Mypair._Get_first();

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0004b	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  00051	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00054	8b 45 f4	 mov	 eax, DWORD PTR __Keyval$18[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0005f	73 09		 jae	 SHORT $LN51@Emplace
  00061	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN49@Emplace
$LN51@Emplace:
  0006a	83 65 ec 00	 and	 DWORD PTR tv167[ebp], 0
$LN49@Emplace:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0006e	0f b6 45 ec	 movzx	 eax, BYTE PTR tv167[ebp]
  00072	85 c0		 test	 eax, eax
  00074	75 09		 jne	 SHORT $LN39@Emplace
  00076	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv147[ebp], 1
  0007d	eb 04		 jmp	 SHORT $LN37@Emplace
$LN39@Emplace:
  0007f	83 65 e8 00	 and	 DWORD PTR tv147[ebp], 0
$LN37@Emplace:

; 1010 :             if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00083	0f b6 45 e8	 movzx	 eax, BYTE PTR tv147[ebp]
  00087	85 c0		 test	 eax, eax
  00089	74 2d		 je	 SHORT $LN2@Emplace

; 1011 :                 return {_Loc._Bound, false};

  0008b	c6 45 ff 00	 mov	 BYTE PTR $T20[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008f	8d 45 a0	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00092	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00098	8b 4d d4	 mov	 ecx, DWORD PTR $T15[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0009f	8d 45 ff	 lea	 eax, DWORD PTR $T20[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000a5	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a8	8b 4d d0	 mov	 ecx, DWORD PTR $T14[ebp]
  000ab	8a 09		 mov	 cl, BYTE PTR [ecx]
  000ad	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1011 :                 return {_Loc._Bound, false};

  000b0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b3	e9 9d 00 00 00	 jmp	 $LN1@Emplace
$LN2@Emplace:

; 1012 :             }
; 1013 : 
; 1014 :             _Check_grow_by_1();

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c0	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c9	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000cc	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  000d2	ff 75 c8	 push	 DWORD PTR $T12[ebp]
  000d5	8b 45 e0	 mov	 eax, DWORD PTR __Scary$[ebp]
  000d8	ff 30		 push	 DWORD PTR [eax]
  000da	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000dd	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  000e0	e8 00 00 00 00	 call	 ??$?0U?$pair@KK@std@@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@$$QAU?$pair@KK@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > ><std::pair<unsigned long,unsigned long> >
  000e5	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  000e8	83 65 bc 00	 and	 DWORD PTR $T9[ebp], 0
  000ec	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  000ef	83 c0 04	 add	 eax, 4
  000f2	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000f5	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000f8	8b 00		 mov	 eax, DWORD PTR [eax]
  000fa	89 45 b8	 mov	 DWORD PTR __Old_val$8[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000fd	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  00100	8b 4d bc	 mov	 ecx, DWORD PTR $T9[ebp]
  00103	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00105	8b 45 b8	 mov	 eax, DWORD PTR __Old_val$8[ebp]
  00108	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010b	8b 45 b4	 mov	 eax, DWORD PTR $T7[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1015 :             _Inserted = _Tree_temp_node<_Alnode>(_Getal(), _Scary->_Myhead, _STD forward<_Valtys>(_Vals)...)._Release();

  00111	8d 4d 8c	 lea	 ecx, DWORD PTR $T2[ebp]
  00114	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00119	ff 75 b0	 push	 DWORD PTR __Inserted$[ebp]
  0011c	ff 75 9c	 push	 DWORD PTR __Loc$[ebp+4]
  0011f	ff 75 98	 push	 DWORD PTR __Loc$[ebp]
  00122	8b 4d e0	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00125	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Insert_node
  0012a	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
  0012d	c6 45 fe 01	 mov	 BYTE PTR $T19[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00131	8d 45 ac	 lea	 eax, DWORD PTR $T6[ebp]
  00134	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00137	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0013a	8b 4d a8	 mov	 ecx, DWORD PTR $T5[ebp]
  0013d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0013f	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8d 45 fe	 lea	 eax, DWORD PTR $T19[ebp]
  00144	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00147	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0014a	8b 4d a4	 mov	 ecx, DWORD PTR $T4[ebp]
  0014d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0014f	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1034 :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00152	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Emplace:

; 1035 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	c9		 leave
  00158	c2 08 00	 ret	 8
??$_Emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@_N@1@$$QAU?$pair@KK@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Emplace<std::pair<unsigned long,unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z PROC ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z ; std::_Copy_memmove<CMonsterAreaInfo * *,CMonsterAreaInfo * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ENDP ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z PROC ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUSItem@SHeightCache@CMapOutdoor@@PAU123@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@PAU123@00@Z ; std::_Copy_memmove<CMapOutdoor::SHeightCache::SItem *,CMapOutdoor::SHeightCache::SItem *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 03	 sar	 eax, 3
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ENDP ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Assign_range@PAPAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Mylast$ = -36						; size = 4
$T1 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Oldcapacity$2 = -24					; size = 4
__Myend$ = -20						; size = 4
__Myfirst$ = -16					; size = 4
_this$ = -12						; size = 4
__Newsize$ = -8						; size = 4
__My_data$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAPAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Assign_range<CMonsterAreaInfo * *>, COMDAT
; _this$ = ecx

; 1094 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00012	89 45 f8	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1096 :         auto& _My_data      = _Mypair._Myval2;

  00015	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1097 :         pointer& _Myfirst   = _My_data._Myfirst;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1098 :         pointer& _Mylast    = _My_data._Mylast;

  00021	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1099 :         pointer& _Myend     = _My_data._Myend;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	83 c0 08	 add	 eax, 8
  00030	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1100 : 
; 1101 :         _My_data._Orphan_all();
; 1102 : 
; 1103 : #if _HAS_IF_CONSTEXPR
; 1104 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1105 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1106 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1107 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

  00033	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00036	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 02	 sar	 eax, 2
  00040	89 45 e8	 mov	 DWORD PTR __Oldcapacity$2[ebp], eax

; 1108 :             if (_Newsize > _Oldcapacity) {

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	3b 45 e8	 cmp	 eax, DWORD PTR __Oldcapacity$2[ebp]
  00049	76 0b		 jbe	 SHORT $LN2@Assign_ran

; 1109 :                 _Clear_and_reserve_geometric(_Newsize);

  0004b	ff 75 f8	 push	 DWORD PTR __Newsize$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Clear_and_reserve_geometric@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Clear_and_reserve_geometric
$LN2@Assign_ran:

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00056	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0005e	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00064	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  00067	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0006a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCMonsterAreaInfo@@PAPAV1@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@00@Z ; std::_Copy_memmove<CMonsterAreaInfo * *,CMonsterAreaInfo * *>
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$_Refancy@PAPAVCMonsterAreaInfo@@$0A@@std@@YAPAPAVCMonsterAreaInfo@@PAPAV1@@Z ; std::_Refancy<CMonsterAreaInfo * *,0>
  0007b	59		 pop	 ecx
  0007c	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax

; 1113 :         } else
; 1114 : #endif // _HAS_IF_CONSTEXPR
; 1115 :         {
; 1116 :             auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1117 : 
; 1118 :             if (_Newsize > _Oldsize) {
; 1119 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1120 :                 if (_Newsize > _Oldcapacity) { // reallocate
; 1121 :                     _Clear_and_reserve_geometric(_Newsize);
; 1122 :                     _Oldsize = 0;
; 1123 :                 }
; 1124 : 
; 1125 :                 // performance note: traversing [_First, _Mid) twice
; 1126 :                 const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1127 :                 _Copy_unchecked(_First, _Mid, _Myfirst);
; 1128 :                 _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1129 :             } else {
; 1130 :                 const pointer _Newlast = _Myfirst + _Newsize;
; 1131 :                 _Copy_unchecked(_First, _Last, _Myfirst);
; 1132 :                 _Destroy(_Newlast, _Mylast);
; 1133 :                 _Mylast = _Newlast;
; 1134 :             }
; 1135 :         }
; 1136 :     }

  00081	c9		 leave
  00082	c2 0c 00	 ret	 12			; 0000000cH
??$_Assign_range@PAPAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Assign_range<CMonsterAreaInfo * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Assign_range@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Mylast$ = -36						; size = 4
$T1 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Oldcapacity$2 = -24					; size = 4
__Myend$ = -20						; size = 4
__Myfirst$ = -16					; size = 4
_this$ = -12						; size = 4
__Newsize$ = -8						; size = 4
__My_data$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Assign_range<CTerrain * *>, COMDAT
; _this$ = ecx

; 1094 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00012	89 45 f8	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1096 :         auto& _My_data      = _Mypair._Myval2;

  00015	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1097 :         pointer& _Myfirst   = _My_data._Myfirst;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1098 :         pointer& _Mylast    = _My_data._Mylast;

  00021	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1099 :         pointer& _Myend     = _My_data._Myend;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	83 c0 08	 add	 eax, 8
  00030	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1100 : 
; 1101 :         _My_data._Orphan_all();
; 1102 : 
; 1103 : #if _HAS_IF_CONSTEXPR
; 1104 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1105 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1106 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1107 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

  00033	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00036	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 02	 sar	 eax, 2
  00040	89 45 e8	 mov	 DWORD PTR __Oldcapacity$2[ebp], eax

; 1108 :             if (_Newsize > _Oldcapacity) {

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	3b 45 e8	 cmp	 eax, DWORD PTR __Oldcapacity$2[ebp]
  00049	76 0b		 jbe	 SHORT $LN2@Assign_ran

; 1109 :                 _Clear_and_reserve_geometric(_Newsize);

  0004b	ff 75 f8	 push	 DWORD PTR __Newsize$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Clear_and_reserve_geometric@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Clear_and_reserve_geometric
$LN2@Assign_ran:

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00056	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0005e	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00064	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  00067	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0006a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCTerrain@@PAPAV1@@std@@YAPAPAVCTerrain@@PAPAV1@00@Z ; std::_Copy_memmove<CTerrain * *,CTerrain * *>
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$_Refancy@PAPAVCTerrain@@$0A@@std@@YAPAPAVCTerrain@@PAPAV1@@Z ; std::_Refancy<CTerrain * *,0>
  0007b	59		 pop	 ecx
  0007c	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax

; 1113 :         } else
; 1114 : #endif // _HAS_IF_CONSTEXPR
; 1115 :         {
; 1116 :             auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1117 : 
; 1118 :             if (_Newsize > _Oldsize) {
; 1119 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1120 :                 if (_Newsize > _Oldcapacity) { // reallocate
; 1121 :                     _Clear_and_reserve_geometric(_Newsize);
; 1122 :                     _Oldsize = 0;
; 1123 :                 }
; 1124 : 
; 1125 :                 // performance note: traversing [_First, _Mid) twice
; 1126 :                 const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1127 :                 _Copy_unchecked(_First, _Mid, _Myfirst);
; 1128 :                 _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1129 :             } else {
; 1130 :                 const pointer _Newlast = _Myfirst + _Newsize;
; 1131 :                 _Copy_unchecked(_First, _Last, _Myfirst);
; 1132 :                 _Destroy(_Newlast, _Mylast);
; 1133 :                 _Mylast = _Newlast;
; 1134 :             }
; 1135 :         }
; 1136 :     }

  00081	c9		 leave
  00082	c2 0c 00	 ret	 12			; 0000000cH
??$_Assign_range@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Assign_range<CTerrain * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Assign_range@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__Mylast$ = -36						; size = 4
$T1 = -32						; size = 4
__Ptr$ = -28						; size = 4
__Oldcapacity$2 = -24					; size = 4
__Myend$ = -20						; size = 4
__Myfirst$ = -16					; size = 4
_this$ = -12						; size = 4
__Newsize$ = -8						; size = 4
__My_data$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Assign_range@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0Uforward_iterator_tag@1@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Assign_range<CArea * *>, COMDAT
; _this$ = ecx

; 1094 :     void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) { // assign forward range [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000f	c1 f8 02	 sar	 eax, 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00012	89 45 f8	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1096 :         auto& _My_data      = _Mypair._Myval2;

  00015	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1097 :         pointer& _Myfirst   = _My_data._Myfirst;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1098 :         pointer& _Mylast    = _My_data._Mylast;

  00021	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	89 45 dc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1099 :         pointer& _Myend     = _My_data._Myend;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	83 c0 08	 add	 eax, 8
  00030	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1100 : 
; 1101 :         _My_data._Orphan_all();
; 1102 : 
; 1103 : #if _HAS_IF_CONSTEXPR
; 1104 :         if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
; 1105 :                           _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>,
; 1106 :                           _Uses_default_destroy<_Alty, _Ty*>>) {
; 1107 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

  00033	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00036	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0003d	c1 f8 02	 sar	 eax, 2
  00040	89 45 e8	 mov	 DWORD PTR __Oldcapacity$2[ebp], eax

; 1108 :             if (_Newsize > _Oldcapacity) {

  00043	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00046	3b 45 e8	 cmp	 eax, DWORD PTR __Oldcapacity$2[ebp]
  00049	76 0b		 jbe	 SHORT $LN2@Assign_ran

; 1109 :                 _Clear_and_reserve_geometric(_Newsize);

  0004b	ff 75 f8	 push	 DWORD PTR __Newsize$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Clear_and_reserve_geometric@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Clear_and_reserve_geometric
$LN2@Assign_ran:

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00056	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0005e	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00064	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  00067	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0006a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCArea@@PAPAV1@@std@@YAPAPAVCArea@@PAPAV1@00@Z ; std::_Copy_memmove<CArea * *,CArea * *>
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$_Refancy@PAPAVCArea@@$0A@@std@@YAPAPAVCArea@@PAPAV1@@Z ; std::_Refancy<CArea * *,0>
  0007b	59		 pop	 ecx
  0007c	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax

; 1113 :         } else
; 1114 : #endif // _HAS_IF_CONSTEXPR
; 1115 :         {
; 1116 :             auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
; 1117 : 
; 1118 :             if (_Newsize > _Oldsize) {
; 1119 :                 const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
; 1120 :                 if (_Newsize > _Oldcapacity) { // reallocate
; 1121 :                     _Clear_and_reserve_geometric(_Newsize);
; 1122 :                     _Oldsize = 0;
; 1123 :                 }
; 1124 : 
; 1125 :                 // performance note: traversing [_First, _Mid) twice
; 1126 :                 const _Iter _Mid = _STD next(_First, static_cast<difference_type>(_Oldsize));
; 1127 :                 _Copy_unchecked(_First, _Mid, _Myfirst);
; 1128 :                 _Mylast = _Ucopy(_Mid, _Last, _Mylast);
; 1129 :             } else {
; 1130 :                 const pointer _Newlast = _Myfirst + _Newsize;
; 1131 :                 _Copy_unchecked(_First, _Last, _Myfirst);
; 1132 :                 _Destroy(_Newlast, _Mylast);
; 1133 :                 _Mylast = _Newlast;
; 1134 :             }
; 1135 :         }
; 1136 :     }

  00081	c9		 leave
  00082	c2 0c 00	 ret	 12			; 0000000cH
??$_Assign_range@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Assign_range<CArea * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<tagRECT,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<tagRECT,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@HPAX@std@@@std@@YAXAAPAU?$_Tree_node@HPAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<int,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 14	 imul	 eax, eax, 20
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 2c	 imul	 eax, eax, 44
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >, COMDAT

; 377  :     static void _Freenode(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 378  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode call");
; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00007	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00010	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00015	33 c0		 xor	 eax, eax
  00017	83 e0 01	 and	 eax, 1
  0001a	74 0c		 je	 SHORT $LN6@Freenode
  0001c	6a 1c		 push	 28			; 0000001cH
  0001e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	59		 pop	 ecx
  00027	59		 pop	 ecx
$LN6@Freenode:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00028	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0002e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
  00033	59		 pop	 ecx
  00034	59		 pop	 ecx

; 381  :     }

  00035	c9		 leave
  00036	c3		 ret	 0
??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > ><tagRECT const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005a	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00068	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00071	8b 75 e0	 mov	 esi, DWORD PTR $T3[ebp]
  00074	8b 7d dc	 mov	 edi, DWORD PTR $T2[ebp]
  00077	a5		 movsd
  00078	a5		 movsd
  00079	a5		 movsd
  0007a	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	c9		 leave
  00090	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > ><tagRECT const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 18	 imul	 eax, eax, 24
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 18	 imul	 eax, eax, 24
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<tagRECT,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 18	 imul	 eax, eax, 24
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find_lower_bound<unsigned long>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	73 09		 jae	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find_lower_bound<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 18	 imul	 eax, eax, 24
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
__Myhead$ = 12						; size = 4
_<_Vals_0>$ = 16					; size = 4
_<_Vals_1>$ = 20					; size = 4
_<_Vals_2>$ = 24					; size = 4
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >, COMDAT
; _this$ = ecx

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 784  :     explicit _Tree_temp_node_alloc(_Alnode& _Al_) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 785  :         _Alloc_construct_ptr<_Alnode>::_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Allocate

; 805  :         : _Tree_temp_node_alloc<_Alnode>(_Al_) {

  00043	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0004a	8b 45 18	 mov	 eax, DWORD PTR _<_Vals_2>$[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  00050	8b 45 14	 mov	 eax, DWORD PTR _<_Vals_1>$[ebp]
  00053	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00056	8b 45 10	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00059	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	83 c0 10	 add	 eax, 16			; 00000010H
  00065	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 806  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0006e	ff 75 e8	 push	 DWORD PTR $T5[ebp]
  00071	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  00074	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00077	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	ff 30		 push	 DWORD PTR [eax]
  0007f	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBHPAE@std@@ABUpiecewise_construct_t@2@V?$tuple@ABH@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@QAU?$pair@$$CBHPAE@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::construct<std::pair<int const ,unsigned char *>,std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
  00084	83 c4 14	 add	 esp, 20			; 00000014H

; 807  :         _Construct_in_place(this->_Ptr->_Left, _Myhead);

  00087	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0008a	50		 push	 eax
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	ff 70 04	 push	 DWORD PTR [eax+4]
  00091	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>
  00096	59		 pop	 ecx
  00097	59		 pop	 ecx

; 808  :         _Construct_in_place(this->_Ptr->_Parent, _Myhead);

  00098	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  0009b	50		 push	 eax
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a2	83 c0 04	 add	 eax, 4
  000a5	50		 push	 eax
  000a6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx

; 809  :         _Construct_in_place(this->_Ptr->_Right, _Myhead);

  000ad	8d 45 0c	 lea	 eax, DWORD PTR __Myhead$[ebp]
  000b0	50		 push	 eax
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b7	83 c0 08	 add	 eax, 8
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@0@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * &>
  000c0	59		 pop	 ecx
  000c1	59		 pop	 ecx

; 810  :         this->_Ptr->_Color = _Red;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c8	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 811  :         this->_Ptr->_Isnil = false;

  000cc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cf	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d2	c6 40 0d 00	 mov	 BYTE PTR [eax+13], 0

; 812  :     }

  000d6	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000da	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e7	59		 pop	 ecx
  000e8	c9		 leave
  000e9	c2 14 00	 ret	 20			; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
__unwindfunclet$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT
; _this$ = ecx

; 817  :     ~_Tree_temp_node() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 818  :         if (this->_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3e		 je	 SHORT $LN9@Tree_temp_

; 819  :             _Destroy_in_place(this->_Ptr->_Left);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	ff 70 04	 push	 DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  0001d	59		 pop	 ecx

; 820  :             _Destroy_in_place(this->_Ptr->_Parent);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  0002d	59		 pop	 ecx

; 821  :             _Destroy_in_place(this->_Ptr->_Right);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00034	83 c0 08	 add	 eax, 8
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *>
  0003d	59		 pop	 ecx

; 822  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 10	 add	 eax, 16			; 00000010H
  00047	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN9@Tree_temp_:
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 824  :     }

  00058	c9		 leave
  00059	c3		 ret	 0
??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$_Tree_temp_node_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node_alloc<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 18	 imul	 eax, eax, 24
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 18	 imul	 eax, eax, 24
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 12
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
tv64 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Trynode$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find_lower_bound<int>, COMDAT
; _this$ = ecx

; 1699 :     _Tree_find_result<_Nodeptr> _Find_lower_bound(const _Keyty& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00011	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1700 :         const auto _Scary = _Get_scary();
; 1701 :         _Tree_find_result<_Nodeptr> _Result{{_Scary->_Myhead->_Parent, _Tree_child::_Right}, _Scary->_Myhead};

  00017	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax
  00022	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0
  00026	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1702 :         _Nodeptr _Trynode = _Result._Location._Parent;

  0002e	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN2@Find_lower:

; 1703 :         while (!_Trynode->_Isnil) {

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00037	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0003b	85 c0		 test	 eax, eax
  0003d	75 5a		 jne	 SHORT $LN3@Find_lower

; 1704 :             _Result._Location._Parent = _Trynode;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00042	89 45 d8	 mov	 DWORD PTR __Result$[ebp], eax

; 2035 :         return _Mypair._Get_first();

  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00048	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0004b	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00051	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00054	8b 4d 0c	 mov	 ecx, DWORD PTR __Keyval$[ebp]
  00057	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005a	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0005c	7d 09		 jge	 SHORT $LN23@Find_lower
  0005e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN21@Find_lower
$LN23@Find_lower:
  00067	83 65 f0 00	 and	 DWORD PTR tv64[ebp], 0
$LN21@Find_lower:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1705 :             if (_DEBUG_LT_PRED(_Getcomp(), _Traits::_Kfn(_Trynode->_Myval), _Keyval)) {

  0006b	0f b6 45 f0	 movzx	 eax, BYTE PTR tv64[ebp]
  0006f	85 c0		 test	 eax, eax
  00071	74 0f		 je	 SHORT $LN4@Find_lower

; 1706 :                 _Result._Location._Child = _Tree_child::_Right;

  00073	83 65 dc 00	 and	 DWORD PTR __Result$[ebp+4], 0

; 1707 :                 _Trynode                 = _Trynode->_Right;

  00077	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0007a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007d	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax

; 1708 :             } else {

  00080	eb 15		 jmp	 SHORT $LN5@Find_lower
$LN4@Find_lower:

; 1709 :                 _Result._Location._Child = _Tree_child::_Left;

  00082	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR __Result$[ebp+4], 1

; 1710 :                 _Result._Bound           = _Trynode;

  00089	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 1711 :                 _Trynode                 = _Trynode->_Left;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Trynode$[ebp]
  00092	8b 00		 mov	 eax, DWORD PTR [eax]
  00094	89 45 fc	 mov	 DWORD PTR __Trynode$[ebp], eax
$LN5@Find_lower:

; 1712 :             }
; 1713 :         }

  00097	eb 9b		 jmp	 SHORT $LN2@Find_lower
$LN3@Find_lower:

; 1714 : 
; 1715 :         return _Result;

  00099	8d 75 d8	 lea	 esi, DWORD PTR __Result$[ebp]
  0009c	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  0009f	a5		 movsd
  000a0	a5		 movsd
  000a1	a5		 movsd
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1716 :     }

  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi
  000a7	c9		 leave
  000a8	c2 08 00	 ret	 8
??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find_lower_bound<int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KK@1@@Z
_TEXT	SEGMENT
__Result$ = -40						; size = 8
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
___param0$ = -16					; size = 4
$T5 = -12						; size = 4
$T6 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Vals_0>$ = 12					; size = 4
??$emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KK@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::emplace<std::pair<unsigned long,unsigned long> >, COMDAT
; _this$ = ecx

; 1094 :     pair<iterator, bool> emplace(_Valtys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1095 :         const auto _Result = _Emplace(_STD forward<_Valtys>(_Vals)...);

  0000f	ff 75 f8	 push	 DWORD PTR $T6[ebp]
  00012	8d 45 d8	 lea	 eax, DWORD PTR __Result$[ebp]
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$_Emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@_N@1@$$QAU?$pair@KK@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Emplace<std::pair<unsigned long,unsigned long> >

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00021	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00024	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 1096 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  0002a	8b 45 d8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002d	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00036	8d 45 ec	 lea	 eax, DWORD PTR $T4[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00046	8d 45 dc	 lea	 eax, DWORD PTR __Result$[ebp+4]
  00049	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004f	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00052	8a 09		 mov	 cl, BYTE PTR [ecx]
  00054	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1096 :         return {iterator(_Result.first, _Get_scary()), _Result.second};

  00057	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1097 :     }

  0005a	c9		 leave
  0005b	c2 08 00	 ret	 8
??$emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KK@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::emplace<std::pair<unsigned long,unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ??_G?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z PROC	; RangeTester<FGetPickingPoint>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UFGetPickingPoint@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
  00019	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	74 0c		 je	 SHORT $LN2@scalar
  00021	6a 0c		 push	 12			; 0000000cH
  00023	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_G?$RangeTester@UFGetPickingPoint@@@@UAEPAXI@Z ENDP	; RangeTester<FGetPickingPoint>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetPickingPoint>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@PointTest2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetPickingPoint::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00025	c9		 leave
  00026	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetPickingPoint>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetPickingPoint>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@RangeTestC
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetPickingPoint::operator()
$LN1@RangeTestC:

; 47   : 	}

  00025	c9		 leave
  00026	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetPickingPoint>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetPickingPoint>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetPickingPoint>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<FGetPickingPoint>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00012	73 0e		 jae	 SHORT $LN3@RayTraceCa
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001c	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _distance$[ebp]
  00020	72 17		 jb	 SHORT $LN2@RayTraceCa
$LN3@RayTraceCa:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00022	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00025	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00028	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0002b	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	e8 00 00 00 00	 call	 ??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetPickingPoint::operator()
$LN2@RayTraceCa:

; 34   : 	};

  00039	c9		 leave
  0003a	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UFGetPickingPoint@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<FGetPickingPoint>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??1?$RangeTester@UFGetPickingPoint@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$RangeTester@UFGetPickingPoint@@@@UAE@XZ PROC	; RangeTester<FGetPickingPoint>::~RangeTester<FGetPickingPoint>, COMDAT
; _this$ = ecx

; 19   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UFGetPickingPoint@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00019	c9		 leave
  0001a	c3		 ret	 0
??1?$RangeTester@UFGetPickingPoint@@@@UAE@XZ ENDP	; RangeTester<FGetPickingPoint>::~RangeTester<FGetPickingPoint>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@QAPAV1@AAV?$allocator@PAVCGraphicObjectInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@QAPAV1@AAV?$allocator@PAVCGraphicObjectInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicObjectInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@QAPAV1@AAV?$allocator@PAVCGraphicObjectInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z PROC ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 14	 imul	 eax, eax, 20
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@HPAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@HPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<int,void *> *,std::_Tree_node<int,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ENDP ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXAAV?$allocator@PAVCMonsterAreaInfo@@@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXAAV?$allocator@PAVCMonsterAreaInfo@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<CMonsterAreaInfo *> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXAAV?$allocator@PAVCMonsterAreaInfo@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<CMonsterAreaInfo *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec 5d 74
	d1 05		 mov	 DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d 5d 74 d1 05	 cmp	 eax, 97612893		; 05d1745dH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 2c	 imul	 eax, eax, 44
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@QAU12@AAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@QAU12@AAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CMapOutdoor::TPatchDrawStruct> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@QAU12@AAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@PAVCTerrain@@@std@@@std@@YAXAAV?$allocator@PAVCTerrain@@@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@PAVCTerrain@@@std@@@std@@YAXAAV?$allocator@PAVCTerrain@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<CTerrain *> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@PAVCTerrain@@@std@@@std@@YAXAAV?$allocator@PAVCTerrain@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@PAVCArea@@@std@@@std@@YAXAAV?$allocator@PAVCArea@@@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@PAVCArea@@@std@@@std@@YAXAAV?$allocator@PAVCArea@@@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<CArea *> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@PAVCArea@@@std@@@std@@YAXAAV?$allocator@PAVCArea@@@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 18	 imul	 eax, eax, 24
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,int>,void *> *,std::_Tree_node<std::pair<unsigned long const ,int>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 18	 imul	 eax, eax, 24
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> *,std::_Tree_node<std::pair<int const ,unsigned char *>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 885  : void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 886  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 887  :         _Left = _Right;
; 888  :     }
; 889  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$?0ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
___formal$ = -4						; size = 1
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 10	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	8a 00		 mov	 al, BYTE PTR [eax]
  00014	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al
  00017	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0001d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 20 00	 and	 DWORD PTR [eax], 0
  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00030	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c9		 leave
  00034	c2 0c 00	 ret	 12			; 0000000cH
??$?0ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::pair<float,long> > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::pair<float,long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CTerrain *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CArea *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<tagRECT,void *>::_Freenode0<std::allocator<std::_List_node<tagRECT,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<tagRECT,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<tagRECT,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 18	 imul	 eax, eax, 24
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<tagRECT,void *>::_Freenode0<std::allocator<std::_List_node<tagRECT,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_reallocate<CMonsterAreaInfo * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAPAPAVCMonsterAreaInfo@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Uninitialized_move<CMonsterAreaInfo * *,std::allocator<CMonsterAreaInfo *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCMonsterAreaInfo@@@std@@QAEXQAPAVCMonsterAreaInfo@@I@Z ; std::allocator<CMonsterAreaInfo *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXQAPAVCMonsterAreaInfo@@II@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_reallocate<CMonsterAreaInfo * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABQAVCMonsterAreaInfo@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABQAVCMonsterAreaInfo@@@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_back_with_unused_capacity<CMonsterAreaInfo * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABQAVCMonsterAreaInfo@@@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_back_with_unused_capacity<CMonsterAreaInfo * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_back_with_unused_capacity<CMonsterAreaInfo * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEPAPAVCMonsterAreaInfo@@QAPAV2@ABQAV2@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Emplace_reallocate<CMonsterAreaInfo * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Old_val$2 = -12					; size = 4
__New_val$ = -8						; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 3a		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f8	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f4	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  0003f	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00042	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00045	e8 00 00 00 00	 call	 ??$_Freenode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
  0004a	59		 pop	 ecx
  0004b	59		 pop	 ecx

; 746  :         }

  0004c	eb bb		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  0004e	c9		 leave
  0004f	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABUtagRECT@@@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@1@QAU21@ABUtagRECT@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUtagRECT@@@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@1@QAU21@ABUtagRECT@@@Z PROC ; std::list<tagRECT,std::allocator<tagRECT> >::_Emplace<tagRECT const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 aa aa
	aa 0a		 mov	 DWORD PTR $T12[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABUtagRECT@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@ABUtagRECT@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > ><tagRECT const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<tagRECT,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABUtagRECT@@@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@1@QAU21@ABUtagRECT@@@Z ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::_Emplace<tagRECT const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<tagRECT,void *>::_Free_non_head<std::allocator<std::_List_node<tagRECT,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Freenode0<std::allocator<std::_List_node<tagRECT,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<tagRECT,void *>::_Free_non_head<std::allocator<std::_List_node<tagRECT,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@std@@P6AXPAVCMonsterAreaInfo@@@Z@std@@YAP6AXPAVCMonsterAreaInfo@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@std@@P6AXPAVCMonsterAreaInfo@@@Z@std@@YAP6AXPAVCMonsterAreaInfo@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMonsterAreaInfo *> > >,void (__cdecl*)(CMonsterAreaInfo *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@std@@P6AXPAVCMonsterAreaInfo@@@Z@std@@YAP6AXPAVCMonsterAreaInfo@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMonsterAreaInfo *> > >,void (__cdecl*)(CMonsterAreaInfo *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@ABK@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find<unsigned long>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find_lower_bound<unsigned long>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	73 09		 jae	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Emplace_reallocate<CMapOutdoor::SHeightCache::SItem const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 03	 sar	 ecx, 3
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 03	 sar	 eax, 3
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 1f		 mov	 DWORD PTR $T22[ebp], 536870911 ; 1fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@CAXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@ABEII@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$2[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 1f		 cmp	 DWORD PTR __Newcapacity$[ebp], 536870911 ; 1fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 03	 shl	 eax, 3
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014a	8b 55 00	 mov	 edx, DWORD PTR $T10[ebp]
  0014d	89 0a		 mov	 DWORD PTR [edx], ecx
  0014f	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00155	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00158	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  0015b	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015e	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00161	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00164	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00166	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00168	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0016b	8b 00		 mov	 eax, DWORD PTR [eax]
  0016d	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00170	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00173	8b 00		 mov	 eax, DWORD PTR [eax]
  00175	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00178	33 c0		 xor	 eax, eax
  0017a	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017d	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  00180	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00186	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00189	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018c	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018f	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00192	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00195	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00198	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  0019b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  001a0	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a3	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a5	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a8	8b 00		 mov	 eax, DWORD PTR [eax]
  001aa	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001b0	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b3	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b6	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b9	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001bc	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bf	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c2	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  001ca	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cd	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001d0	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d3	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d6	8b 00		 mov	 eax, DWORD PTR [eax]
  001d8	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001de	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001e1	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e4	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e7	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001ea	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001ed	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001f0	8d 44 c1 08	 lea	 eax, DWORD PTR [ecx+eax*8+8]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f4	50		 push	 eax
  001f5	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f8	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fb	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUSItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAPAUSItem@SHeightCache@CMapOutdoor@@QAU123@0PAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Uninitialized_move<CMapOutdoor::SHeightCache::SItem *,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00200	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00203	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00205	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00208	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020b	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	e8 00 00 00 00	 call	 ?_Destroy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXPAUSItem@SHeightCache@CMapOutdoor@@0@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00213	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00216	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00219	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@QAEXQAUSItem@SHeightCache@CMapOutdoor@@I@Z ; std::allocator<CMapOutdoor::SHeightCache::SItem>::deallocate

; 762  :         _RERAISE;

  00221	6a 00		 push	 0
  00223	6a 00		 push	 0
  00225	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0022a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022f	c3		 ret	 0
$LN7@Emplace_re:
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00234	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00236	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0023a	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023d	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  00240	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00243	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	e8 00 00 00 00	 call	 ?_Change_array@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXQAUSItem@SHeightCache@CMapOutdoor@@II@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024b	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0024e	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00251	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
$LN70@Emplace_re:

; 767  :     }

  00254	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00257	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025e	59		 pop	 ecx
  0025f	5f		 pop	 edi
  00260	5e		 pop	 esi
  00261	5b		 pop	 ebx
  00262	83 c5 70	 add	 ebp, 112		; 00000070H
  00265	c9		 leave
  00266	c2 08 00	 ret	 8
  00269	cc		 int	 3
  0026a	cc		 int	 3
  0026b	cc		 int	 3
  0026c	cc		 int	 3
  0026d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Emplace_reallocate<CMapOutdoor::SHeightCache::SItem const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXABUSItem@SHeightCache@CMapOutdoor@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXABUSItem@SHeightCache@CMapOutdoor@@@Z PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::emplace_back<CMapOutdoor::SHeightCache::SItem const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 68		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00031	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00040	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00048	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004b	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00051	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00057	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00060	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00063	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00066	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006e	8b 55 d0	 mov	 edx, DWORD PTR $T4[ebp]
  00071	89 0a		 mov	 DWORD PTR [edx], ecx
  00073	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00076	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	83 c0 08	 add	 eax, 8
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00089	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0008b	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0008d	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00090	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00093	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00096	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00099	ff 30		 push	 DWORD PTR [eax]
  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEPAUSItem@SHeightCache@CMapOutdoor@@QAU234@ABU234@@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Emplace_reallocate<CMapOutdoor::SHeightCache::SItem const &>
  000a3	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a6	c9		 leave
  000a7	c2 04 00	 ret	 4
??$emplace_back@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXABUSItem@SHeightCache@CMapOutdoor@@@Z ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::emplace_back<CMapOutdoor::SHeightCache::SItem const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Find@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABH@Z
_TEXT	SEGMENT
__Loc$ = -44						; size = 12
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
tv79 = -16						; size = 4
tv131 = -12						; size = 4
__Bound$ = -8						; size = 4
_this$ = -4						; size = 4
__Keyval$ = 8						; size = 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find<int>, COMDAT
; _this$ = ecx

; 1457 :     _NODISCARD _Nodeptr _Find(const _Other& _Keyval) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1458 :         const _Tree_find_result<_Nodeptr> _Loc = _Find_lower_bound(_Keyval);

  00009	ff 75 08	 push	 DWORD PTR __Keyval$[ebp]
  0000c	8d 45 d4	 lea	 eax, DWORD PTR __Loc$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find_lower_bound<int>

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00018	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0001b	89 45 f8	 mov	 DWORD PTR __Bound$[ebp], eax

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Bound$[ebp]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 37		 jne	 SHORT $LN30@Find

; 2035 :         return _Mypair._Get_first();

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00032	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  00035	8b 45 08	 mov	 eax, DWORD PTR __Keyval$[ebp]
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __Bound$[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00040	7d 09		 jge	 SHORT $LN42@Find
  00042	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN40@Find
$LN42@Find:
  0004b	83 65 f4 00	 and	 DWORD PTR tv131[ebp], 0
$LN40@Find:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  0004f	0f b6 45 f4	 movzx	 eax, BYTE PTR tv131[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 09		 jne	 SHORT $LN30@Find
  00057	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  0005e	eb 04		 jmp	 SHORT $LN28@Find
$LN30@Find:
  00060	83 65 f0 00	 and	 DWORD PTR tv79[ebp], 0
$LN28@Find:

; 1459 :         if (_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00064	0f b6 45 f0	 movzx	 eax, BYTE PTR tv79[ebp]
  00068	85 c0		 test	 eax, eax
  0006a	74 05		 je	 SHORT $LN2@Find

; 1460 :             return _Loc._Bound;

  0006c	8b 45 dc	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  0006f	eb 11		 jmp	 SHORT $LN1@Find
$LN2@Find:

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00071	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00074	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2051 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0007a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 1461 :         }
; 1462 : 
; 1463 :         return _Get_scary()->_Myhead;

  0007d	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Find:

; 1464 :     }

  00082	c9		 leave
  00083	c2 04 00	 ret	 4
??$_Find@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find<int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z
_TEXT	SEGMENT
$T1 = -32						; size = 8
$T2 = -24						; size = 4
__Loc$ = -20						; size = 12
$T3 = -8						; size = 4
$T4 = -4						; size = 4
$T5 = 0							; size = 4
__Inserted$ = 4						; size = 4
$T6 = 8							; size = 4
__Old_val$7 = 12					; size = 4
$T8 = 16						; size = 4
$T9 = 20						; size = 4
$T10 = 24						; size = 4
$T11 = 28						; size = 4
$T12 = 32						; size = 4
$T13 = 36						; size = 4
$T14 = 40						; size = 4
$T15 = 44						; size = 4
_this$16 = 48						; size = 4
$T17 = 52						; size = 4
$T18 = 56						; size = 4
$T19 = 60						; size = 4
$T20 = 64						; size = 4
$T21 = 68						; size = 4
$T22 = 72						; size = 4
$T23 = 76						; size = 4
__Scary$ = 80						; size = 4
__Val$ = 84						; size = 4
tv168 = 88						; size = 4
tv188 = 92						; size = 4
__Bound$ = 96						; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
$T25 = 110						; size = 1
$T26 = 111						; size = 1
___$ReturnUdt$ = 120					; size = 4
__Keyval$ = 124						; size = 4
??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z PROC ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::_Try_emplace<int const &>, COMDAT
; _this$ = ecx

; 175  :     pair<_Nodeptr, bool> _Try_emplace(_Keyty&& _Keyval, _Mappedty&&... _Mapval) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H
  0000b	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 176  :         const auto _Loc = _Mybase::_Find_lower_bound(_Keyval);

  0000e	ff 75 7c	 push	 DWORD PTR __Keyval$[ebp]
  00011	8d 45 ec	 lea	 eax, DWORD PTR __Loc$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??$_Find_lower_bound@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IBE?AU?$_Tree_find_result@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find_lower_bound<int>

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Loc$[ebp+8]
  00020	89 45 60	 mov	 DWORD PTR __Bound$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00023	8b 45 60	 mov	 eax, DWORD PTR __Bound$[ebp]
  00026	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002a	85 c0		 test	 eax, eax
  0002c	75 37		 jne	 SHORT $LN31@Try_emplac

; 2035 :         return _Mypair._Get_first();

  0002e	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00031	89 45 4c	 mov	 DWORD PTR $T23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2035 :         return _Mypair._Get_first();

  00034	8b 45 4c	 mov	 eax, DWORD PTR $T23[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 127  :         return _Left < _Right;

  0003a	8b 45 7c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  0003d	8b 4d 60	 mov	 ecx, DWORD PTR __Bound$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  00045	7d 09		 jge	 SHORT $LN43@Try_emplac
  00047	c7 45 5c 01 00
	00 00		 mov	 DWORD PTR tv188[ebp], 1
  0004e	eb 04		 jmp	 SHORT $LN41@Try_emplac
$LN43@Try_emplac:
  00050	83 65 5c 00	 and	 DWORD PTR tv188[ebp], 0
$LN41@Try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1695 :         return !_Bound->_Isnil && !_DEBUG_LT_PRED(_Getcomp(), _Keyval, _Traits::_Kfn(_Bound->_Myval));

  00054	0f b6 45 5c	 movzx	 eax, BYTE PTR tv188[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	75 09		 jne	 SHORT $LN31@Try_emplac
  0005c	c7 45 58 01 00
	00 00		 mov	 DWORD PTR tv168[ebp], 1
  00063	eb 04		 jmp	 SHORT $LN29@Try_emplac
$LN31@Try_emplac:
  00065	83 65 58 00	 and	 DWORD PTR tv168[ebp], 0
$LN29@Try_emplac:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 177  :         if (_Mybase::_Lower_bound_duplicate(_Loc._Bound, _Keyval)) {

  00069	0f b6 45 58	 movzx	 eax, BYTE PTR tv168[ebp]
  0006d	85 c0		 test	 eax, eax
  0006f	74 2d		 je	 SHORT $LN2@Try_emplac

; 178  :             return {_Loc._Bound, false};

  00071	c6 45 6f 00	 mov	 BYTE PTR $T26[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00075	8d 45 f4	 lea	 eax, DWORD PTR __Loc$[ebp+8]
  00078	89 45 48	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0007b	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	8b 4d 48	 mov	 ecx, DWORD PTR $T22[ebp]
  00081	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00083	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00085	8d 45 6f	 lea	 eax, DWORD PTR $T26[ebp]
  00088	89 45 44	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0008b	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0008e	8b 4d 44	 mov	 ecx, DWORD PTR $T21[ebp]
  00091	8a 09		 mov	 cl, BYTE PTR [ecx]
  00093	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 178  :             return {_Loc._Bound, false};

  00096	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00099	e9 dd 00 00 00	 jmp	 $LN1@Try_emplac
$LN2@Try_emplac:

; 179  :         }
; 180  : 
; 181  :         _Mybase::_Check_grow_by_1();

  0009e	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Check_grow_by_1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000a6	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a9	89 45 40	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  000ac	8b 45 40	 mov	 eax, DWORD PTR $T20[ebp]
  000af	89 45 50	 mov	 DWORD PTR __Scary$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000b2	8d 45 67	 lea	 eax, DWORD PTR $T24[ebp]
  000b5	89 45 20	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000b8	8b 45 7c	 mov	 eax, DWORD PTR __Keyval$[ebp]
  000bb	89 45 3c	 mov	 DWORD PTR $T19[ebp], eax
  000be	8b 45 3c	 mov	 eax, DWORD PTR $T19[ebp]
  000c1	89 45 38	 mov	 DWORD PTR $T18[ebp], eax
  000c4	8b 45 38	 mov	 eax, DWORD PTR $T18[ebp]
  000c7	89 45 34	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 245  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  000ca	8d 45 28	 lea	 eax, DWORD PTR $T14[ebp]
  000cd	89 45 30	 mov	 DWORD PTR _this$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000d0	8b 45 34	 mov	 eax, DWORD PTR $T17[ebp]
  000d3	89 45 2c	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  000d6	8b 45 30	 mov	 eax, DWORD PTR _this$16[ebp]
  000d9	8b 4d 2c	 mov	 ecx, DWORD PTR $T15[ebp]
  000dc	89 08		 mov	 DWORD PTR [eax], ecx

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  000de	8d 45 28	 lea	 eax, DWORD PTR $T14[ebp]
  000e1	89 45 1c	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000e4	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000e7	89 45 24	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  000ea	8b 45 24	 mov	 eax, DWORD PTR $T13[ebp]
  000ed	89 45 18	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  000f0	ff 75 20	 push	 DWORD PTR $T12[ebp]
  000f3	ff 75 1c	 push	 DWORD PTR $T11[ebp]
  000f6	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B
  000fb	8b 45 50	 mov	 eax, DWORD PTR __Scary$[ebp]
  000fe	ff 30		 push	 DWORD PTR [eax]
  00100	ff 75 18	 push	 DWORD PTR $T10[ebp]
  00103	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  00106	e8 00 00 00 00	 call	 ??$?0ABUpiecewise_construct_t@std@@V?$tuple@ABH@1@V?$tuple@$$V@1@@?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABH@1@$$QAV?$tuple@$$V@1@@Z ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > ><std::piecewise_construct_t const &,std::tuple<int const &>,std::tuple<> >
  0010b	89 45 14	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  0010e	83 65 10 00	 and	 DWORD PTR $T8[ebp], 0
  00112	8b 45 14	 mov	 eax, DWORD PTR $T9[ebp]
  00115	83 c0 04	 add	 eax, 4
  00118	89 45 54	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0011b	8b 45 54	 mov	 eax, DWORD PTR __Val$[ebp]
  0011e	8b 00		 mov	 eax, DWORD PTR [eax]
  00120	89 45 0c	 mov	 DWORD PTR __Old_val$7[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00123	8b 45 54	 mov	 eax, DWORD PTR __Val$[ebp]
  00126	8b 4d 10	 mov	 ecx, DWORD PTR $T8[ebp]
  00129	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  0012b	8b 45 0c	 mov	 eax, DWORD PTR __Old_val$7[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1048 :         return _STD exchange(_Ptr, nullptr);

  00131	8b 45 08	 mov	 eax, DWORD PTR $T6[ebp]
  00134	89 45 04	 mov	 DWORD PTR __Inserted$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 184  :         const auto _Inserted = _Tree_temp_node<_Alnode>(_Mybase::_Getal(), _Scary->_Myhead, piecewise_construct,

  00137	8d 4d e0	 lea	 ecx, DWORD PTR $T1[ebp]
  0013a	e8 00 00 00 00	 call	 ??1?$_Tree_temp_node@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >::~_Tree_temp_node<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  0013f	ff 75 04	 push	 DWORD PTR __Inserted$[ebp]
  00142	ff 75 f0	 push	 DWORD PTR __Loc$[ebp+4]
  00145	ff 75 ec	 push	 DWORD PTR __Loc$[ebp]
  00148	8b 4d 50	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0014b	e8 00 00 00 00	 call	 ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@2@QAU32@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Insert_node
  00150	89 45 00	 mov	 DWORD PTR $T5[ebp], eax
  00153	c6 45 6e 01	 mov	 BYTE PTR $T25[ebp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00157	8d 45 00	 lea	 eax, DWORD PTR $T5[ebp]
  0015a	89 45 fc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0015d	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00160	8b 4d fc	 mov	 ecx, DWORD PTR $T4[ebp]
  00163	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00165	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00167	8d 45 6e	 lea	 eax, DWORD PTR $T25[ebp]
  0016a	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0016d	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00170	8b 4d f8	 mov	 ecx, DWORD PTR $T3[ebp]
  00173	8a 09		 mov	 cl, BYTE PTR [ecx]
  00175	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 190  :         return {_Scary->_Insert_node(_Loc._Location, _Inserted), true};

  00178	8b 45 78	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Try_emplac:

; 191  :     }

  0017b	83 c5 70	 add	 ebp, 112		; 00000070H
  0017e	c9		 leave
  0017f	c2 08 00	 ret	 8
??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z ENDP ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::_Try_emplace<int const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
;	COMDAT ??$stl_wipe_second@V?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@@YAXAAV?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
___param0$ = -28					; size = 4
__Scary$9 = -24						; size = 4
$T10 = -20						; size = 4
tv170 = -16						; size = 4
tv197 = -12						; size = 4
_i$11 = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
_container$ = 8						; size = 4
??$stl_wipe_second@V?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@@YAXAAV?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@Z PROC ; stl_wipe_second<std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > > >, COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 127  : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  00006	8d 45 f8	 lea	 eax, DWORD PTR _i$11[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _container$[ebp]
  0000d	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::begin
  00012	eb 08		 jmp	 SHORT $LN4@stl_wipe_s
$LN2@stl_wipe_s:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  00014	8d 4d f8	 lea	 ecx, DWORD PTR _i$11[ebp]
  00017	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >,std::_Iterator_base0>::operator++
$LN4@stl_wipe_s:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _container$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001f	89 45 ec	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00022	8b 45 ec	 mov	 eax, DWORD PTR $T10[ebp]
  00025	89 45 e8	 mov	 DWORD PTR __Scary$9[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00028	8b 45 e8	 mov	 eax, DWORD PTR __Scary$9[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00030	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00033	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00036	8d 45 e0	 lea	 eax, DWORD PTR $T8[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _i$11[ebp]
  00042	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00044	75 09		 jne	 SHORT $LN73@stl_wipe_s
  00046	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv197[ebp], 1
  0004d	eb 04		 jmp	 SHORT $LN74@stl_wipe_s
$LN73@stl_wipe_s:
  0004f	83 65 f4 00	 and	 DWORD PTR tv197[ebp], 0
$LN74@stl_wipe_s:
  00053	8a 45 f4	 mov	 al, BYTE PTR tv197[ebp]
  00056	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 236  :         return !(*this == _Right);

  00059	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  0005d	85 c0		 test	 eax, eax
  0005f	75 09		 jne	 SHORT $LN68@stl_wipe_s
  00061	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv170[ebp], 1
  00068	eb 04		 jmp	 SHORT $LN69@stl_wipe_s
$LN68@stl_wipe_s:
  0006a	83 65 f0 00	 and	 DWORD PTR tv170[ebp], 0
$LN69@stl_wipe_s:
  0006e	8a 45 f0	 mov	 al, BYTE PTR tv170[ebp]
  00071	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 127  : 	for (TContainer::iterator i = container.begin(); i != container.end(); ++i)

  00074	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  00078	85 c0		 test	 eax, eax
  0007a	74 3b		 je	 SHORT $LN3@stl_wipe_s
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _i$11[ebp]
  0007f	83 c0 10	 add	 eax, 16			; 00000010H
  00082	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  00085	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00088	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0008b	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  0008e	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00091	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  00094	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  00097	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0009a	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 129  : 		delete i->second;

  0009d	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
  000a6	6a 01		 push	 1
  000a8	ff 75 c4	 push	 DWORD PTR $T1[ebp]
  000ab	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000b0	59		 pop	 ecx
  000b1	59		 pop	 ecx

; 130  : 	}

  000b2	e9 5d ff ff ff	 jmp	 $LN2@stl_wipe_s
$LN3@stl_wipe_s:

; 131  : 	
; 132  : 	container.clear();

  000b7	8b 4d 08	 mov	 ecx, DWORD PTR _container$[ebp]
  000ba	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::clear

; 133  : }

  000bf	c9		 leave
  000c0	c3		 ret	 0
??$stl_wipe_second@V?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@@YAXAAV?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@Z ENDP ; stl_wipe_second<std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Pnode$ = -12						; size = 4
__Pnode$2 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00015	85 c0		 test	 eax, eax
  00017	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 f8	 mov	 DWORD PTR __Pnode$2[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$2[ebp]
  00027	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002b	85 c0		 test	 eax, eax
  0002d	75 17		 jne	 SHORT $LN3@operator
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003a	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00044	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  0004e	eb 30		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN9@operator

; 452  :             _Pnode = _Pnode->_Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  00070	eb e9		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 454  : 
; 455  :         return _Pnode;

  00072	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  00083	c9		 leave
  00084	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ PROC ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::~map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::~map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
;	COMDAT ??0?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ PROC ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >, COMDAT
; _this$ = ecx

; 107  :     map() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
??0?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ ENDP ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S13$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S13$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@ABH@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@ABH@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@H@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Find<int>
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@ABH@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::begin, COMDAT
; _this$ = ecx

; 1238 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 :     }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<int const ,unsigned char *>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<int const ,unsigned char *>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Pnode$ = -12						; size = 4
__Pnode$2 = -8						; size = 4
_this$ = -4						; size = 4
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 51   :     _Tree_unchecked_const_iterator& operator++() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 52   :         if (_Ptr->_Right->_Isnil) { // climb looking for right subtree

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00011	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00015	85 c0		 test	 eax, eax
  00017	74 37		 je	 SHORT $LN4@operator
$LN2@operator:

; 53   :             _Nodeptr _Pnode;
; 54   :             while (!(_Pnode = _Ptr->_Parent)->_Isnil && _Ptr == _Pnode->_Right) {

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	89 45 f8	 mov	 DWORD PTR __Pnode$2[ebp], eax
  00024	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$2[ebp]
  00027	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  0002b	85 c0		 test	 eax, eax
  0002d	75 17		 jne	 SHORT $LN3@operator
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003a	75 0a		 jne	 SHORT $LN3@operator

; 55   :                 _Ptr = _Pnode; // ==> parent while right subtree

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  00042	89 08		 mov	 DWORD PTR [eax], ecx

; 56   :             }

  00044	eb d3		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 57   : 
; 58   :             _Ptr = _Pnode; // ==> parent (head if end())

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnode$2[ebp]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx

; 59   :         } else {

  0004e	eb 30		 jmp	 SHORT $LN5@operator
$LN4@operator:

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 00		 mov	 eax, DWORD PTR [eax]
  00055	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00058	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN8@operator:

; 451  :         while (!_Pnode->_Left->_Isnil) {

  0005b	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00064	85 c0		 test	 eax, eax
  00066	75 0a		 jne	 SHORT $LN9@operator

; 452  :             _Pnode = _Pnode->_Left;

  00068	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f4	 mov	 DWORD PTR __Pnode$[ebp], eax

; 453  :         }

  00070	eb e9		 jmp	 SHORT $LN8@operator
$LN9@operator:

; 454  : 
; 455  :         return _Pnode;

  00072	8b 45 f4	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00075	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 60   :             _Ptr = _Mytree::_Min(_Ptr->_Right); // ==> smallest of right subtree

  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@operator:

; 61   :         }
; 62   : 
; 63   :         return *this;

  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 64   :     }

  00083	c9		 leave
  00084	c3		 ret	 0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z
_TEXT	SEGMENT
_r$ = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_pFunc$ = 16						; size = 4
??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z PROC ; CCullingManager::ForInRay<FGetObjectHeight>, COMDAT
; _this$ = ecx

; 119  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  00028	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  0002f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@

; 15   : 		: f(fn), dist(distance)

  00036	8b 45 10	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR _r$[ebp+4], eax
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00044	f3 0f 11 45 ec	 movss	 DWORD PTR _r$[ebp+8], xmm0

; 120  : 		RangeTester<T> r(pFunc);

  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 121  : 		/*Vector3d p2;
; 122  : 		//p2.Set(p.x+(dir.x*50000.0f),p.y+(dir.y*50000.0f),p.z+(dir.z*50000.0f));
; 123  : 		p2.x = p.x+50000.0f*dir.x;
; 124  : 		p2.y = p.y+50000.0f*dir.y;
; 125  : 		p2.z = p.z+50000.0f*dir.z;
; 126  : 			// p + (50000.0f*dir);//(p.x+(dir.x*50000.0f),p.y+(dir.y*50000.0f),p.z+(dir.z*50000.0f));*/
; 127  : 		m_Factory->RayTrace(p1, dir, &r/*this*/);		

  0004d	8d 45 e4	 lea	 eax, DWORD PTR _r$[ebp]
  00050	50		 push	 eax
  00051	ff 75 0c	 push	 DWORD PTR _dir$[ebp]
  00054	ff 75 08	 push	 DWORD PTR _p1$[ebp]
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005d	e8 00 00 00 00	 call	 ?RayTrace@SpherePackFactory@@QAEXABVVector3d@@0PAVSpherePackCallback@@@Z ; SpherePackFactory::RayTrace

; 128  : 	}

  00062	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 19   : 	{}

  00066	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  0006d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 128  : 	}

  00074	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00077	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007e	59		 pop	 ecx
  0007f	c9		 leave
  00080	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ ; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z ENDP ; CCullingManager::ForInRay<FGetObjectHeight>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >, COMDAT
; _this$ = ecx

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);
; 44   :     }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ??_G?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z PROC	; RangeTester<FGetObjectHeight>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
  00019	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	74 0c		 je	 SHORT $LN2@scalar
  00021	6a 0c		 push	 12			; 0000000cH
  00023	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_G?$RangeTester@UFGetObjectHeight@@@@UAEPAXI@Z ENDP	; RangeTester<FGetObjectHeight>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetObjectHeight>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@PointTest2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetObjectHeight::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00025	c9		 leave
  00026	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetObjectHeight>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetObjectHeight>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@RangeTestC
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetObjectHeight::operator()
$LN1@RangeTestC:

; 47   : 	}

  00025	c9		 leave
  00026	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetObjectHeight>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<FGetObjectHeight>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<FGetObjectHeight>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<FGetObjectHeight>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00012	73 0e		 jae	 SHORT $LN3@RayTraceCa
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001c	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _distance$[ebp]
  00020	72 17		 jb	 SHORT $LN2@RayTraceCa
$LN3@RayTraceCa:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00022	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00025	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00028	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0002b	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	e8 00 00 00 00	 call	 ??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z ; FGetObjectHeight::operator()
$LN2@RayTraceCa:

; 34   : 	};

  00039	c9		 leave
  0003a	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UFGetObjectHeight@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<FGetObjectHeight>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ PROC	; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>, COMDAT
; _this$ = ecx

; 19   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00019	c9		 leave
  0001a	c3		 ret	 0
??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ ENDP	; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z
_TEXT	SEGMENT
_r$ = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_pFunc$ = 12						; size = 4
??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z PROC ; CCullingManager::ForInRange2d<FGetPickingPoint>, COMDAT
; _this$ = ecx

; 105  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  00028	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  0002f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetPickingPoint@@@@6B@

; 15   : 		: f(fn), dist(distance)

  00036	8b 45 0c	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR _r$[ebp+4], eax
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00044	f3 0f 11 45 ec	 movss	 DWORD PTR _r$[ebp+8], xmm0

; 106  : 		RangeTester<T> r(pFunc);

  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 107  : 		m_Factory->PointTest2d(p, &r);

  0004d	8d 45 e4	 lea	 eax, DWORD PTR _r$[ebp]
  00050	50		 push	 eax
  00051	ff 75 08	 push	 DWORD PTR _p$[ebp]
  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0005a	e8 00 00 00 00	 call	 ?PointTest2d@SpherePackFactory@@QAEXABVVector3d@@PAVSpherePackCallback@@@Z ; SpherePackFactory::PointTest2d

; 108  : 	}

  0005f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 19   : 	{}

  00063	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UFGetPickingPoint@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  0006a	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 108  : 	}

  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	c9		 leave
  0007d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetPickingPoint@@@@UAE@XZ ; RangeTester<FGetPickingPoint>::~RangeTester<FGetPickingPoint>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z ENDP ; CCullingManager::ForInRange2d<FGetPickingPoint>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?FreeAll@?$CDynamicPool@VCTerrain@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 1
$T2 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
_this$ = -4						; size = 4
?FreeAll@?$CDynamicPool@VCTerrain@@@@QAEXXZ PROC	; CDynamicPool<CTerrain>::FreeAll, COMDAT
; _this$ = ecx

; 84   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 			m_kVct_pkFree=m_kVct_pkData;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Right$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1168 :         if (this != _STD addressof(_Right)) {

  00021	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  00027	74 13		 je	 SHORT $LN1@FreeAll

; 1169 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00029	33 c0		 xor	 eax, eax
  0002b	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0002e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00031	ff 75 f8	 push	 DWORD PTR __Right$[ebp]
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Copy_assign@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Copy_assign
$LN1@FreeAll:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 86   : 		}

  0003c	c9		 leave
  0003d	c3		 ret	 0
?FreeAll@?$CDynamicPool@VCTerrain@@@@QAEXXZ ENDP	; CDynamicPool<CTerrain>::FreeAll
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?FreeAll@?$CDynamicPool@VCArea@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 1
$T2 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
_this$ = -4						; size = 4
?FreeAll@?$CDynamicPool@VCArea@@@@QAEXXZ PROC		; CDynamicPool<CArea>::FreeAll, COMDAT
; _this$ = ecx

; 84   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 			m_kVct_pkFree=m_kVct_pkData;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Right$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1168 :         if (this != _STD addressof(_Right)) {

  00021	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  00027	74 13		 je	 SHORT $LN1@FreeAll

; 1169 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00029	33 c0		 xor	 eax, eax
  0002b	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0002e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00031	ff 75 f8	 push	 DWORD PTR __Right$[ebp]
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Copy_assign@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Copy_assign
$LN1@FreeAll:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 86   : 		}

  0003c	c9		 leave
  0003d	c3		 ret	 0
?FreeAll@?$CDynamicPool@VCArea@@@@QAEXXZ ENDP		; CDynamicPool<CArea>::FreeAll
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_fZ$1 = -20						; size = 4
_fY$2 = -16						; size = 4
_fX$3 = -12						; size = 4
_pThing$4 = -8						; size = 4
_this$ = -4						; size = 4
_pInstance$ = 8						; size = 4
??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FGetPickingPoint::operator(), COMDAT
; _this$ = ecx

; 47   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 48   : 		if( pInstance && pInstance->GetType() == CGraphicThingInstance::ID )

  00009	83 7d 08 00	 cmp	 DWORD PTR _pInstance$[ebp], 0
  0000d	0f 84 ac 00 00
	00		 je	 $LN5@operator
  00013	8b 45 08	 mov	 eax, DWORD PTR _pInstance$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR _pInstance$[ebp]
  0001b	ff 50 04	 call	 DWORD PTR [eax+4]
  0001e	3d 13 1f f2 ad	 cmp	 eax, -1376641261	; adf21f13H
  00023	0f 85 96 00 00
	00		 jne	 $LN5@operator

; 49   : 		{			
; 50   : 			CGraphicThingInstance * pThing = (CGraphicThingInstance *)pInstance;

  00029	8b 45 08	 mov	 eax, DWORD PTR _pInstance$[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR _pThing$4[ebp], eax

; 51   : 			if (!pThing->IsObjectHeight())

  0002f	8b 4d f8	 mov	 ecx, DWORD PTR _pThing$4[ebp]
  00032	e8 00 00 00 00	 call	 ?IsObjectHeight@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::IsObjectHeight
  00037	0f b6 c0	 movzx	 eax, al
  0003a	85 c0		 test	 eax, eax
  0003c	75 02		 jne	 SHORT $LN3@operator

; 52   : 				return;

  0003e	eb 7f		 jmp	 SHORT $LN1@operator
$LN3@operator:

; 53   : 
; 54   : 			float fX, fY, fZ;
; 55   : 			if (pThing->Picking(m_v3Start, m_v3Dir, fX, fY))

  00040	8d 45 f0	 lea	 eax, DWORD PTR _fY$2[ebp]
  00043	50		 push	 eax
  00044	8d 45 f4	 lea	 eax, DWORD PTR _fX$3[ebp]
  00047	50		 push	 eax
  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004e	50		 push	 eax
  0004f	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _pThing$4[ebp]
  00055	e8 00 00 00 00	 call	 ?Picking@CGraphicThingInstance@@QAE_NABUD3DXVECTOR3@@0AAM1@Z ; CGraphicThingInstance::Picking
  0005a	0f b6 c0	 movzx	 eax, al
  0005d	85 c0		 test	 eax, eax
  0005f	74 5e		 je	 SHORT $LN5@operator

; 56   : 			{
; 57   : 				if (pThing->GetObjectHeight(fX, -fY, &fZ))

  00061	8d 45 ec	 lea	 eax, DWORD PTR _fZ$1[ebp]
  00064	50		 push	 eax
  00065	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fY$2[ebp]
  0006a	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00071	51		 push	 ecx
  00072	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00077	51		 push	 ecx
  00078	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fX$3[ebp]
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _pThing$4[ebp]
  00085	e8 00 00 00 00	 call	 ?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ; CGraphicObjectInstance::GetObjectHeight
  0008a	0f b6 c0	 movzx	 eax, al
  0008d	85 c0		 test	 eax, eax
  0008f	74 2e		 je	 SHORT $LN5@operator

; 58   : 				{
; 59   : 					m_v3PickingPoint.x = fX;

  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fX$3[ebp]
  00099	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 60   : 					m_v3PickingPoint.y = fY;

  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fY$2[ebp]
  000a6	f3 0f 11 40 1c	 movss	 DWORD PTR [eax+28], xmm0

; 61   : 					m_v3PickingPoint.z = fZ;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fZ$1[ebp]
  000b3	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 62   : 					m_bPicked = true;

  000b8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	c6 40 24 01	 mov	 BYTE PTR [eax+36], 1
$LN5@operator:
$LN1@operator:

; 63   : 				}				
; 64   : 			}			
; 65   : 		}
; 66   : 	}

  000bf	c9		 leave
  000c0	c2 04 00	 ret	 4
??RFGetPickingPoint@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FGetPickingPoint::operator()
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pObject$ = 8						; size = 4
??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; FGetObjectHeight::operator(), COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 		if (pObject->GetObjectHeight(m_fRequestX, m_fRequestY, &m_fReturnHeight))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	50		 push	 eax
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	51		 push	 ecx
  00012	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00017	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00025	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR _pObject$[ebp]
  0002d	e8 00 00 00 00	 call	 ?GetObjectHeight@CGraphicObjectInstance@@QAE_NMMPAM@Z ; CGraphicObjectInstance::GetObjectHeight
  00032	0f b6 c0	 movzx	 eax, al
  00035	85 c0		 test	 eax, eax
  00037	74 06		 je	 SHORT $LN2@operator

; 29   : 		{
; 30   : #ifdef SPHERELIB_STRICT
; 31   : 			printf("FIND %f\n", m_fReturnHeight);
; 32   : #endif
; 33   : 			m_bHeightFound = true;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN2@operator:

; 34   : 		}
; 35   : 	}

  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
??RFGetObjectHeight@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; FGetObjectHeight::operator()
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCMapOutdoor@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCMapOutdoor@@UAEPAXI@Z PROC				; CMapOutdoor::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CMapOutdoor@@UAE@XZ	; CMapOutdoor::~CMapOutdoor
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b0 13 00 00	 push	 5040			; 000013b0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCMapOutdoor@@UAEPAXI@Z ENDP				; CMapOutdoor::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetEnvironmentDataName@CMapOutdoor@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_strEnvironmentDataName$ = 8				; size = 4
?SetEnvironmentDataName@CMapOutdoor@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CMapOutdoor::SetEnvironmentDataName, COMDAT
; _this$ = ecx

; 1339 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1340 : 	m_envDataName = strEnvironmentDataName;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 94 13 00 00	 add	 eax, 5012		; 00001394H
  00011	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 08	 mov	 eax, DWORD PTR _strEnvironmentDataName$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2863 :         if (this != _STD addressof(_Right)) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	3b 45 f4	 cmp	 eax, DWORD PTR $T2[ebp]
  00020	74 13		 je	 SHORT $LN1@SetEnviron

; 2864 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00022	33 c0		 xor	 eax, eax
  00024	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00027	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0002a	ff 75 08	 push	 DWORD PTR _strEnvironmentDataName$[ebp]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
$LN1@SetEnviron:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1341 : }

  00035	c9		 leave
  00036	c2 04 00	 ret	 4
?SetEnvironmentDataName@CMapOutdoor@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CMapOutdoor::SetEnvironmentDataName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__HeightCache_Update@CMapOutdoor@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__HeightCache_Update@CMapOutdoor@@AAEXXZ PROC		; CMapOutdoor::__HeightCache_Update, COMDAT
; _this$ = ecx

; 734  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 735  : 	m_kHeightCache.m_isUpdated=true;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 78 13 00
	00 01		 mov	 BYTE PTR [eax+4984], 1

; 736  : }

  00011	c9		 leave
  00012	c3		 ret	 0
?__HeightCache_Update@CMapOutdoor@@AAEXXZ ENDP		; CMapOutdoor::__HeightCache_Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__HeightCache_Init@CMapOutdoor@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_uIndex$1 = -4						; size = 4
?__HeightCache_Init@CMapOutdoor@@AAEXXZ PROC		; CMapOutdoor::__HeightCache_Init, COMDAT
; _this$ = ecx

; 739  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 740  : 	m_kHeightCache.m_isUpdated=false;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	c6 80 78 13 00
	00 00		 mov	 BYTE PTR [eax+4984], 0

; 741  : 
; 742  : 	for (UINT uIndex=0; uIndex!=SHeightCache::HASH_SIZE; ++uIndex)

  00012	83 65 fc 00	 and	 DWORD PTR _uIndex$1[ebp], 0
  00016	eb 07		 jmp	 SHORT $LN4@HeightCach
$LN2@HeightCach:
  00018	8b 45 fc	 mov	 eax, DWORD PTR _uIndex$1[ebp]
  0001b	40		 inc	 eax
  0001c	89 45 fc	 mov	 DWORD PTR _uIndex$1[ebp], eax
$LN4@HeightCach:
  0001f	83 7d fc 64	 cmp	 DWORD PTR _uIndex$1[ebp], 100 ; 00000064H
  00023	74 15		 je	 SHORT $LN1@HeightCach

; 743  : 		m_kHeightCache.m_akVct_kItem[uIndex].clear();

  00025	6b 45 fc 0c	 imul	 eax, DWORD PTR _uIndex$1[ebp], 12
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8d 8c 01 c8 0e
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+3784]
  00033	e8 00 00 00 00	 call	 ?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::clear
  00038	eb de		 jmp	 SHORT $LN2@HeightCach
$LN1@HeightCach:

; 744  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
?__HeightCache_Init@CMapOutdoor@@AAEXXZ ENDP		; CMapOutdoor::__HeightCache_Init
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1SHeightCache@CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1SHeightCache@CMapOutdoor@@QAE@XZ PROC		; CMapOutdoor::SHeightCache::~SHeightCache, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1SHeightCache@CMapOutdoor@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	68 00 00 00 00	 push	 OFFSET ??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  0002b	6a 64		 push	 100			; 00000064H
  0002d	6a 0c		 push	 12			; 0000000cH
  0002f	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00037	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0003a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00041	59		 pop	 ecx
  00042	c9		 leave
  00043	c3		 ret	 0
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1SHeightCache@CMapOutdoor@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1SHeightCache@CMapOutdoor@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1SHeightCache@CMapOutdoor@@QAE@XZ ENDP		; CMapOutdoor::SHeightCache::~SHeightCache
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@CAXXZ PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@CAXXZ ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXXZ PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 03	 sar	 eax, 3
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 03	 shl	 eax, 3
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXXZ ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXQAUSItem@SHeightCache@CMapOutdoor@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXQAUSItem@SHeightCache@CMapOutdoor@@II@Z PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 03	 sar	 eax, 3
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 03	 shl	 eax, 3
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXQAUSItem@SHeightCache@CMapOutdoor@@II@Z ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@ABEII@Z PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 03	 sar	 eax, 3
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 1f		 mov	 DWORD PTR $T7[ebp], 536870911 ; 1fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@ABEII@Z ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXPAUSItem@SHeightCache@CMapOutdoor@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXPAUSItem@SHeightCache@CMapOutdoor@@0@Z PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXPAUSItem@SHeightCache@CMapOutdoor@@0@Z ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@YAXPAUSItem@SHeightCache@CMapOutdoor@@QAU123@AAV?$allocator@USItem@SHeightCache@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@AAEXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ PROC ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ENDP ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@QAEXQAUSItem@SHeightCache@CMapOutdoor@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@QAEXQAUSItem@SHeightCache@CMapOutdoor@@I@Z PROC ; std::allocator<CMapOutdoor::SHeightCache::SItem>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 03	 shl	 eax, 3
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@QAEXQAUSItem@SHeightCache@CMapOutdoor@@I@Z ENDP ; std::allocator<CMapOutdoor::SHeightCache::SItem>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SpecialEffect_Destroy@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_rkEffMgr$ = -68					; size = 4
_iEffectID$1 = -64					; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
$T7 = -40						; size = 4
$T8 = -36						; size = 4
___param0$ = -32					; size = 4
__Scary$9 = -28						; size = 4
$T10 = -24						; size = 4
tv168 = -20						; size = 4
tv195 = -16						; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
?SpecialEffect_Destroy@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::SpecialEffect_Destroy, COMDAT
; _this$ = ecx

; 1428 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1429 : 	CEffectManager& rkEffMgr = CEffectManager::Instance();

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0000e	89 45 bc	 mov	 DWORD PTR _rkEffMgr$[ebp], eax

; 1430 : 
; 1431 : 	TSpecialEffectMap::iterator itor = m_kMap_dwID_iEffectID.begin();

  00011	8d 45 f8	 lea	 eax, DWORD PTR _itor$[ebp]
  00014	50		 push	 eax
  00015	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
  0001e	e8 00 00 00 00	 call	 ?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin

; 1432 : 	for (; itor != m_kMap_dwID_iEffectID.end(); ++itor)

  00023	eb 08		 jmp	 SHORT $LN4@SpecialEff
$LN2@SpecialEff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  00025	8d 4d f8	 lea	 ecx, DWORD PTR _itor$[ebp]
  00028	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >,std::_Iterator_base0>::operator++
$LN4@SpecialEff:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00030	05 c0 0e 00 00	 add	 eax, 3776		; 00000ec0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00035	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR __Scary$9[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR __Scary$9[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00046	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00049	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0004c	8d 45 dc	 lea	 eax, DWORD PTR $T8[ebp]
  0004f	89 45 d8	 mov	 DWORD PTR $T7[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00052	8b 45 d8	 mov	 eax, DWORD PTR $T7[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  00058	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005a	75 09		 jne	 SHORT $LN75@SpecialEff
  0005c	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv195[ebp], 1
  00063	eb 04		 jmp	 SHORT $LN76@SpecialEff
$LN75@SpecialEff:
  00065	83 65 f0 00	 and	 DWORD PTR tv195[ebp], 0
$LN76@SpecialEff:
  00069	8a 45 f0	 mov	 al, BYTE PTR tv195[ebp]
  0006c	88 45 ff	 mov	 BYTE PTR $T12[ebp], al

; 236  :         return !(*this == _Right);

  0006f	0f b6 45 ff	 movzx	 eax, BYTE PTR $T12[ebp]
  00073	85 c0		 test	 eax, eax
  00075	75 09		 jne	 SHORT $LN70@SpecialEff
  00077	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv168[ebp], 1
  0007e	eb 04		 jmp	 SHORT $LN71@SpecialEff
$LN70@SpecialEff:
  00080	83 65 ec 00	 and	 DWORD PTR tv168[ebp], 0
$LN71@SpecialEff:
  00084	8a 45 ec	 mov	 al, BYTE PTR tv168[ebp]
  00087	88 45 fe	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1432 : 	for (; itor != m_kMap_dwID_iEffectID.end(); ++itor)

  0008a	0f b6 45 fe	 movzx	 eax, BYTE PTR $T11[ebp]
  0008e	85 c0		 test	 eax, eax
  00090	74 3a		 je	 SHORT $LN1@SpecialEff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  00092	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00095	83 c0 10	 add	 eax, 16			; 00000010H
  00098	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0009b	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  0009e	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a1	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  000a4	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000a7	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000aa	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  000ad	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  000b0	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1434 : 		int iEffectID = itor->second;

  000b3	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000b6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b9	89 45 c0	 mov	 DWORD PTR _iEffectID$1[ebp], eax

; 1435 : 		rkEffMgr.DestroyEffectInstance(iEffectID);

  000bc	ff 75 c0	 push	 DWORD PTR _iEffectID$1[ebp]
  000bf	8b 4d bc	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  000c2	e8 00 00 00 00	 call	 ?DestroyEffectInstance@CEffectManager@@QAE_NK@Z ; CEffectManager::DestroyEffectInstance

; 1436 : 	}

  000c7	e9 59 ff ff ff	 jmp	 $LN2@SpecialEff
$LN1@SpecialEff:

; 1437 : }

  000cc	c9		 leave
  000cd	c3		 ret	 0
?SpecialEffect_Destroy@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::SpecialEffect_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SpecialEffect_Delete@CMapOutdoor@@QAEXK@Z
_TEXT	SEGMENT
_rkEffMgr$ = -64					; size = 4
_iEffectID$ = -60					; size = 4
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
___param0$ = -28					; size = 4
__Scary$8 = -24						; size = 4
$T9 = -20						; size = 4
_itor$ = -16						; size = 4
tv192 = -12						; size = 4
_this$ = -8						; size = 4
$T10 = -1						; size = 1
_dwID$ = 8						; size = 4
?SpecialEffect_Delete@CMapOutdoor@@QAEXK@Z PROC		; CMapOutdoor::SpecialEffect_Delete, COMDAT
; _this$ = ecx

; 1416 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1417 : 	TSpecialEffectMap::iterator itor = m_kMap_dwID_iEffectID.find(dwID);

  00009	8d 45 08	 lea	 eax, DWORD PTR _dwID$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 f0	 lea	 eax, DWORD PTR _itor$[ebp]
  00010	50		 push	 eax
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
  0001a	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	05 c0 0e 00 00	 add	 eax, 3776		; 00000ec0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00027	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0002a	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0002d	89 45 e8	 mov	 DWORD PTR __Scary$8[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00030	8b 45 e8	 mov	 eax, DWORD PTR __Scary$8[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00038	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  0003e	8d 45 e0	 lea	 eax, DWORD PTR $T7[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00044	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	3b 45 f0	 cmp	 eax, DWORD PTR _itor$[ebp]
  0004c	75 09		 jne	 SHORT $LN72@SpecialEff
  0004e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv192[ebp], 1
  00055	eb 04		 jmp	 SHORT $LN73@SpecialEff
$LN72@SpecialEff:
  00057	83 65 f4 00	 and	 DWORD PTR tv192[ebp], 0
$LN73@SpecialEff:
  0005b	8a 45 f4	 mov	 al, BYTE PTR tv192[ebp]
  0005e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1419 : 	if (m_kMap_dwID_iEffectID.end() == itor)

  00061	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00065	85 c0		 test	 eax, eax
  00067	74 02		 je	 SHORT $LN75@SpecialEff

; 1420 : 		return;

  00069	eb 3d		 jmp	 SHORT $LN1@SpecialEff
$LN75@SpecialEff:

; 1421 : 
; 1422 : 	CEffectManager& rkEffMgr = CEffectManager::Instance();

  0006b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00070	89 45 c0	 mov	 DWORD PTR _rkEffMgr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  00073	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  00076	83 c0 10	 add	 eax, 16			; 00000010H
  00079	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0007c	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00082	8b 45 d4	 mov	 eax, DWORD PTR $T4[ebp]
  00085	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00088	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  0008b	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  0008e	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  00091	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1423 : 	int iEffectID = itor->second;

  00094	8b 45 c8	 mov	 eax, DWORD PTR $T1[ebp]
  00097	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009a	89 45 c4	 mov	 DWORD PTR _iEffectID$[ebp], eax

; 1424 : 	rkEffMgr.DestroyEffectInstance(iEffectID);

  0009d	ff 75 c4	 push	 DWORD PTR _iEffectID$[ebp]
  000a0	8b 4d c0	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  000a3	e8 00 00 00 00	 call	 ?DestroyEffectInstance@CEffectManager@@QAE_NK@Z ; CEffectManager::DestroyEffectInstance
$LN1@SpecialEff:

; 1425 : }

  000a8	c9		 leave
  000a9	c2 04 00	 ret	 4
?SpecialEffect_Delete@CMapOutdoor@@QAEXK@Z ENDP		; CMapOutdoor::SpecialEffect_Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SpecialEffect_Create@CMapOutdoor@@QAEXKMMMPBD@Z
_TEXT	SEGMENT
$T1 = -104						; size = 8
$T2 = -96						; size = 8
$T3 = -88						; size = 4
$T4 = -84						; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 4
$T7 = -72						; size = 4
$T8 = -68						; size = 4
_dwEffectID$ = -64					; size = 4
_dwEffectID$9 = -60					; size = 4
$T10 = -56						; size = 4
$T11 = -52						; size = 4
$T12 = -48						; size = 4
$T13 = -44						; size = 4
$T14 = -40						; size = 4
$T15 = -36						; size = 4
$T16 = -32						; size = 4
___param0$ = -28					; size = 4
__Scary$17 = -24					; size = 4
$T18 = -20						; size = 4
_itor$ = -16						; size = 4
tv210 = -12						; size = 4
tv278 = -8						; size = 4
_this$ = -4						; size = 4
_rkEffMgr$ = 0						; size = 4
$T19 = 6						; size = 1
$T20 = 7						; size = 1
_mat$21 = 8						; size = 64
$T22 = 72						; size = 12
$T23 = 84						; size = 12
__$ArrayPad$ = 96					; size = 4
_dwID$ = 108						; size = 4
_x$ = 112						; size = 4
_y$ = 116						; size = 4
_z$ = 120						; size = 4
_c_szEffName$ = 124					; size = 4
?SpecialEffect_Create@CMapOutdoor@@QAEXKMMMPBD@Z PROC	; CMapOutdoor::SpecialEffect_Create, COMDAT
; _this$ = ecx

; 1389 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1390 : 	CEffectManager& rkEffMgr = CEffectManager::Instance();

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0001d	89 45 00	 mov	 DWORD PTR _rkEffMgr$[ebp], eax

; 1391 : 
; 1392 : 	TSpecialEffectMap::iterator itor = m_kMap_dwID_iEffectID.find(dwID);

  00020	8d 45 6c	 lea	 eax, DWORD PTR _dwID$[ebp]
  00023	50		 push	 eax
  00024	8d 45 f0	 lea	 eax, DWORD PTR _itor$[ebp]
  00027	50		 push	 eax
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
  00031	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	05 c0 0e 00 00	 add	 eax, 3776		; 00000ec0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0003e	89 45 ec	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00041	8b 45 ec	 mov	 eax, DWORD PTR $T18[ebp]
  00044	89 45 e8	 mov	 DWORD PTR __Scary$17[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00047	8b 45 e8	 mov	 eax, DWORD PTR __Scary$17[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0004f	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00052	89 45 e0	 mov	 DWORD PTR $T16[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00055	8d 45 e0	 lea	 eax, DWORD PTR $T16[ebp]
  00058	89 45 dc	 mov	 DWORD PTR $T15[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  0005b	8b 45 dc	 mov	 eax, DWORD PTR $T15[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	3b 45 f0	 cmp	 eax, DWORD PTR _itor$[ebp]
  00063	75 09		 jne	 SHORT $LN80@SpecialEff
  00065	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv278[ebp], 1
  0006c	eb 04		 jmp	 SHORT $LN81@SpecialEff
$LN80@SpecialEff:
  0006e	83 65 f8 00	 and	 DWORD PTR tv278[ebp], 0
$LN81@SpecialEff:
  00072	8a 45 f8	 mov	 al, BYTE PTR tv278[ebp]
  00075	88 45 07	 mov	 BYTE PTR $T20[ebp], al

; 236  :         return !(*this == _Right);

  00078	0f b6 45 07	 movzx	 eax, BYTE PTR $T20[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	75 09		 jne	 SHORT $LN75@SpecialEff
  00080	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv210[ebp], 1
  00087	eb 04		 jmp	 SHORT $LN76@SpecialEff
$LN75@SpecialEff:
  00089	83 65 f4 00	 and	 DWORD PTR tv210[ebp], 0
$LN76@SpecialEff:
  0008d	8a 45 f4	 mov	 al, BYTE PTR tv210[ebp]
  00090	88 45 06	 mov	 BYTE PTR $T19[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1393 : 	if (m_kMap_dwID_iEffectID.end() != itor)

  00093	0f b6 45 06	 movzx	 eax, BYTE PTR $T19[ebp]
  00097	85 c0		 test	 eax, eax
  00099	0f 84 f8 01 00
	00		 je	 $LN3@SpecialEff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  0009f	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  000a2	83 c0 10	 add	 eax, 16			; 00000010H
  000a5	89 45 d8	 mov	 DWORD PTR $T14[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  000a8	8b 45 d8	 mov	 eax, DWORD PTR $T14[ebp]
  000ab	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000ae	8b 45 d4	 mov	 eax, DWORD PTR $T13[ebp]
  000b1	89 45 d0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000b4	8b 45 d0	 mov	 eax, DWORD PTR $T12[ebp]
  000b7	89 45 cc	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  000ba	8b 45 cc	 mov	 eax, DWORD PTR $T11[ebp]
  000bd	89 45 c8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1395 : 		DWORD dwEffectID = itor->second;

  000c0	8b 45 c8	 mov	 eax, DWORD PTR $T10[ebp]
  000c3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000c6	89 45 c4	 mov	 DWORD PTR _dwEffectID$9[ebp], eax

; 1396 : 		if (rkEffMgr.SelectEffectInstance(dwEffectID))

  000c9	ff 75 c4	 push	 DWORD PTR _dwEffectID$9[ebp]
  000cc	8b 4d 00	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  000cf	e8 00 00 00 00	 call	 ?SelectEffectInstance@CEffectManager@@QAEHK@Z ; CEffectManager::SelectEffectInstance
  000d4	85 c0		 test	 eax, eax
  000d6	0f 84 bb 01 00
	00		 je	 $LN3@SpecialEff
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  000dc	6a 10		 push	 16			; 00000010H
  000de	58		 pop	 eax
  000df	6b c0 03	 imul	 eax, eax, 3
  000e2	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  000e6	6a 04		 push	 4
  000e8	59		 pop	 ecx
  000e9	d1 e1		 shl	 ecx, 1
  000eb	0f 57 c0	 xorps	 xmm0, xmm0
  000ee	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000f3	6a 10		 push	 16			; 00000010H
  000f5	58		 pop	 eax
  000f6	6b c0 03	 imul	 eax, eax, 3
  000f9	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  000fd	6a 04		 push	 4
  000ff	59		 pop	 ecx
  00100	c1 e1 00	 shl	 ecx, 0
  00103	0f 57 c0	 xorps	 xmm0, xmm0
  00106	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0010b	6a 10		 push	 16			; 00000010H
  0010d	58		 pop	 eax
  0010e	6b c0 03	 imul	 eax, eax, 3
  00111	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00115	6a 04		 push	 4
  00117	59		 pop	 ecx
  00118	6b c9 00	 imul	 ecx, ecx, 0
  0011b	0f 57 c0	 xorps	 xmm0, xmm0
  0011e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00123	6a 10		 push	 16			; 00000010H
  00125	58		 pop	 eax
  00126	d1 e0		 shl	 eax, 1
  00128	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  0012c	6a 04		 push	 4
  0012e	59		 pop	 ecx
  0012f	6b c9 03	 imul	 ecx, ecx, 3
  00132	0f 57 c0	 xorps	 xmm0, xmm0
  00135	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0013a	6a 10		 push	 16			; 00000010H
  0013c	58		 pop	 eax
  0013d	d1 e0		 shl	 eax, 1
  0013f	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00143	6a 04		 push	 4
  00145	59		 pop	 ecx
  00146	c1 e1 00	 shl	 ecx, 0
  00149	0f 57 c0	 xorps	 xmm0, xmm0
  0014c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00151	6a 10		 push	 16			; 00000010H
  00153	58		 pop	 eax
  00154	d1 e0		 shl	 eax, 1
  00156	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  0015a	6a 04		 push	 4
  0015c	59		 pop	 ecx
  0015d	6b c9 00	 imul	 ecx, ecx, 0
  00160	0f 57 c0	 xorps	 xmm0, xmm0
  00163	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00168	6a 10		 push	 16			; 00000010H
  0016a	58		 pop	 eax
  0016b	c1 e0 00	 shl	 eax, 0
  0016e	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00172	6a 04		 push	 4
  00174	59		 pop	 ecx
  00175	6b c9 03	 imul	 ecx, ecx, 3
  00178	0f 57 c0	 xorps	 xmm0, xmm0
  0017b	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00180	6a 10		 push	 16			; 00000010H
  00182	58		 pop	 eax
  00183	c1 e0 00	 shl	 eax, 0
  00186	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  0018a	6a 04		 push	 4
  0018c	59		 pop	 ecx
  0018d	d1 e1		 shl	 ecx, 1
  0018f	0f 57 c0	 xorps	 xmm0, xmm0
  00192	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00197	6a 10		 push	 16			; 00000010H
  00199	58		 pop	 eax
  0019a	c1 e0 00	 shl	 eax, 0
  0019d	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  001a1	6a 04		 push	 4
  001a3	59		 pop	 ecx
  001a4	6b c9 00	 imul	 ecx, ecx, 0
  001a7	0f 57 c0	 xorps	 xmm0, xmm0
  001aa	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001af	6a 10		 push	 16			; 00000010H
  001b1	58		 pop	 eax
  001b2	6b c0 00	 imul	 eax, eax, 0
  001b5	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  001b9	6a 04		 push	 4
  001bb	59		 pop	 ecx
  001bc	6b c9 03	 imul	 ecx, ecx, 3
  001bf	0f 57 c0	 xorps	 xmm0, xmm0
  001c2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001c7	6a 10		 push	 16			; 00000010H
  001c9	58		 pop	 eax
  001ca	6b c0 00	 imul	 eax, eax, 0
  001cd	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  001d1	6a 04		 push	 4
  001d3	59		 pop	 ecx
  001d4	d1 e1		 shl	 ecx, 1
  001d6	0f 57 c0	 xorps	 xmm0, xmm0
  001d9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  001de	6a 10		 push	 16			; 00000010H
  001e0	58		 pop	 eax
  001e1	6b c0 00	 imul	 eax, eax, 0
  001e4	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  001e8	6a 04		 push	 4
  001ea	59		 pop	 ecx
  001eb	c1 e1 00	 shl	 ecx, 0
  001ee	0f 57 c0	 xorps	 xmm0, xmm0
  001f1	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  001f6	6a 10		 push	 16			; 00000010H
  001f8	58		 pop	 eax
  001f9	6b c0 03	 imul	 eax, eax, 3
  001fc	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00200	6a 04		 push	 4
  00202	59		 pop	 ecx
  00203	6b c9 03	 imul	 ecx, ecx, 3
  00206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020e	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00213	6a 10		 push	 16			; 00000010H
  00215	58		 pop	 eax
  00216	d1 e0		 shl	 eax, 1
  00218	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  0021c	6a 04		 push	 4
  0021e	59		 pop	 ecx
  0021f	d1 e1		 shl	 ecx, 1
  00221	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00229	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0022e	6a 10		 push	 16			; 00000010H
  00230	58		 pop	 eax
  00231	c1 e0 00	 shl	 eax, 0
  00234	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00238	6a 04		 push	 4
  0023a	59		 pop	 ecx
  0023b	c1 e1 00	 shl	 ecx, 0
  0023e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00246	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0024b	6a 10		 push	 16			; 00000010H
  0024d	58		 pop	 eax
  0024e	6b c0 00	 imul	 eax, eax, 0
  00251	8d 44 05 08	 lea	 eax, DWORD PTR _mat$21[ebp+eax]
  00255	6a 04		 push	 4
  00257	59		 pop	 ecx
  00258	6b c9 00	 imul	 ecx, ecx, 0
  0025b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00263	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1400 : 			mat._41 = x;

  00268	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _x$[ebp]
  0026d	f3 0f 11 45 38	 movss	 DWORD PTR _mat$21[ebp+48], xmm0

; 1401 : 			mat._42 = y;

  00272	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _y$[ebp]
  00277	f3 0f 11 45 3c	 movss	 DWORD PTR _mat$21[ebp+52], xmm0

; 1402 : 			mat._43 = z;

  0027c	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _z$[ebp]
  00281	f3 0f 11 45 40	 movss	 DWORD PTR _mat$21[ebp+56], xmm0

; 1403 : 			rkEffMgr.SetEffectInstanceGlobalMatrix(mat);

  00286	8d 45 08	 lea	 eax, DWORD PTR _mat$21[ebp]
  00289	50		 push	 eax
  0028a	8b 4d 00	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  0028d	e8 00 00 00 00	 call	 ?SetEffectInstanceGlobalMatrix@CEffectManager@@QAEXABUD3DXMATRIX@@@Z ; CEffectManager::SetEffectInstanceGlobalMatrix

; 1404 : 			return;

  00292	e9 a4 00 00 00	 jmp	 $LN1@SpecialEff
$LN3@SpecialEff:

; 1405 : 		}
; 1406 : 	}
; 1407 : 
; 1408 : 	rkEffMgr.RegisterEffect(c_szEffName);

  00297	6a 00		 push	 0
  00299	6a 00		 push	 0
  0029b	ff 75 7c	 push	 DWORD PTR _c_szEffName$[ebp]
  0029e	8b 4d 00	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  002a1	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  002a6	0f 57 c0	 xorps	 xmm0, xmm0
  002a9	f3 0f 11 45 54	 movss	 DWORD PTR $T23[ebp], xmm0

; 181  :     y = fy;

  002ae	0f 57 c0	 xorps	 xmm0, xmm0
  002b1	f3 0f 11 45 58	 movss	 DWORD PTR $T23[ebp+4], xmm0

; 182  :     z = fz;

  002b6	0f 57 c0	 xorps	 xmm0, xmm0
  002b9	f3 0f 11 45 5c	 movss	 DWORD PTR $T23[ebp+8], xmm0

; 180  :     x = fx;

  002be	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _x$[ebp]
  002c3	f3 0f 11 45 48	 movss	 DWORD PTR $T22[ebp], xmm0

; 181  :     y = fy;

  002c8	f3 0f 10 45 74	 movss	 xmm0, DWORD PTR _y$[ebp]
  002cd	f3 0f 11 45 4c	 movss	 DWORD PTR $T22[ebp+4], xmm0

; 182  :     z = fz;

  002d2	f3 0f 10 45 78	 movss	 xmm0, DWORD PTR _z$[ebp]
  002d7	f3 0f 11 45 50	 movss	 DWORD PTR $T22[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1409 : 	DWORD dwEffectID = rkEffMgr.CreateEffect(c_szEffName,

  002dc	8d 45 54	 lea	 eax, DWORD PTR $T23[ebp]
  002df	50		 push	 eax
  002e0	8d 45 48	 lea	 eax, DWORD PTR $T22[ebp]
  002e3	50		 push	 eax
  002e4	ff 75 7c	 push	 DWORD PTR _c_szEffName$[ebp]
  002e7	8b 4d 00	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  002ea	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect
  002ef	89 45 c0	 mov	 DWORD PTR _dwEffectID$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  002f2	8d 45 c0	 lea	 eax, DWORD PTR _dwEffectID$[ebp]
  002f5	89 45 b4	 mov	 DWORD PTR $T6[ebp], eax
  002f8	8d 45 6c	 lea	 eax, DWORD PTR _dwID$[ebp]
  002fb	89 45 bc	 mov	 DWORD PTR $T8[ebp], eax
  002fe	8b 45 bc	 mov	 eax, DWORD PTR $T8[ebp]
  00301	89 45 b8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00304	8b 45 b8	 mov	 eax, DWORD PTR $T7[ebp]
  00307	8b 00		 mov	 eax, DWORD PTR [eax]
  00309	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0030c	8b 45 b4	 mov	 eax, DWORD PTR $T6[ebp]
  0030f	89 45 b0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00312	8b 45 b0	 mov	 eax, DWORD PTR $T5[ebp]
  00315	8b 00		 mov	 eax, DWORD PTR [eax]
  00317	89 45 a4	 mov	 DWORD PTR $T2[ebp+4], eax

; 392  :     return _Mypair(_STD forward<_Ty1>(_Val1), _STD forward<_Ty2>(_Val2));

  0031a	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  0031d	89 45 ac	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00320	8b 45 ac	 mov	 eax, DWORD PTR $T4[ebp]
  00323	89 45 a8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 165  :         return this->emplace(_STD forward<_Valty>(_Val));

  00326	ff 75 a8	 push	 DWORD PTR $T3[ebp]
  00329	8d 45 98	 lea	 eax, DWORD PTR $T1[ebp]
  0032c	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1412 : 	m_kMap_dwID_iEffectID.insert(make_pair(dwID, dwEffectID));

  0032d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00330	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 165  :         return this->emplace(_STD forward<_Valty>(_Val));

  00336	e8 00 00 00 00	 call	 ??$emplace@U?$pair@KK@std@@@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@KK@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::emplace<std::pair<unsigned long,unsigned long> >
$LN1@SpecialEff:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1413 : }

  0033b	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0033e	33 cd		 xor	 ecx, ebp
  00340	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00345	83 c5 64	 add	 ebp, 100		; 00000064H
  00348	c9		 leave
  00349	c2 14 00	 ret	 20			; 00000014H
?SpecialEffect_Create@CMapOutdoor@@QAEXKMMMPBD@Z ENDP	; CMapOutdoor::SpecialEffect_Create
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ PROC ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ ENDP ; std::map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >::~map<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@2@QAU32@@Z
_TEXT	SEGMENT
__Parent_sibling$1 = -20				; size = 4
__Parent_sibling$2 = -16				; size = 4
_this$ = -12						; size = 4
__Head$ = -8						; size = 4
__Pnode$3 = -4						; size = 4
__Loc$ = 8						; size = 8
__Newnode$ = 16						; size = 4
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@2@QAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Insert_node, COMDAT
; _this$ = ecx

; 644  :     _Nodeptr _Insert_node(const _Tree_id<_Nodeptr> _Loc, const _Nodeptr _Newnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 645  :         ++_Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	40		 inc	 eax
  00010	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 646  :         const auto _Head  = _Myhead;

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	89 45 f8	 mov	 DWORD PTR __Head$[ebp], eax

; 647  :         _Newnode->_Parent = _Loc._Parent;

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00024	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 648  :         if (_Loc._Parent == _Head) { // first node in tree, just set head values

  00027	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR __Head$[ebp]
  0002d	75 29		 jne	 SHORT $LN5@Insert_nod

; 649  :             _Head->_Left     = _Newnode;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 650  :             _Head->_Parent   = _Newnode;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 651  :             _Head->_Right    = _Newnode;

  00040	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00043	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00046	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 652  :             _Newnode->_Color = _Black; // the root is black

  00049	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0004c	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 653  :             return _Newnode;

  00050	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  00053	e9 a3 01 00 00	 jmp	 $LN18@Insert_nod
$LN5@Insert_nod:

; 654  :         }
; 655  : 
; 656  :         _STL_INTERNAL_CHECK(_Loc._Child != _Tree_child::_Unused);
; 657  :         if (_Loc._Child == _Tree_child::_Right) { // add to right of _Loc._Parent

  00058	83 7d 0c 00	 cmp	 DWORD PTR __Loc$[ebp+4], 0
  0005c	75 1f		 jne	 SHORT $LN6@Insert_nod

; 658  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Right->_Isnil);
; 659  :             _Loc._Parent->_Right = _Newnode;

  0005e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00064	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 660  :             if (_Loc._Parent == _Head->_Right) { // remember rightmost node

  00067	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0006d	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00070	75 09		 jne	 SHORT $LN8@Insert_nod

; 661  :                 _Head->_Right = _Newnode;

  00072	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00075	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00078	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN8@Insert_nod:

; 662  :             }
; 663  :         } else { // add to left of _Loc._Parent

  0007b	eb 1a		 jmp	 SHORT $LN7@Insert_nod
$LN6@Insert_nod:

; 664  :             _STL_INTERNAL_CHECK(_Loc._Parent->_Left->_Isnil);
; 665  :             _Loc._Parent->_Left = _Newnode;

  0007d	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00080	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx

; 666  :             if (_Loc._Parent == _Head->_Left) { // remember leftmost node

  00085	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00088	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0008b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008d	75 08		 jne	 SHORT $LN7@Insert_nod

; 667  :                 _Head->_Left = _Newnode;

  0008f	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  00092	8b 4d 10	 mov	 ecx, DWORD PTR __Newnode$[ebp]
  00095	89 08		 mov	 DWORD PTR [eax], ecx
$LN7@Insert_nod:

; 668  :             }
; 669  :         }
; 670  : 
; 671  :         for (_Nodeptr _Pnode = _Newnode; _Pnode->_Parent->_Color == _Red;) {

  00097	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
  0009a	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax
$LN4@Insert_nod:
  0009d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000a0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a3	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000a7	85 c0		 test	 eax, eax
  000a9	0f 85 3f 01 00
	00		 jne	 $LN3@Insert_nod

; 672  :             if (_Pnode->_Parent == _Pnode->_Parent->_Parent->_Left) { // fixup red-red in left subtree

  000af	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  000bb	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000be	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000c0	0f 85 95 00 00
	00		 jne	 $LN10@Insert_nod

; 673  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Right;

  000c6	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000cf	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000d2	89 45 f0	 mov	 DWORD PTR __Parent_sibling$2[ebp], eax

; 674  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  000d5	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000d8	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  000dc	85 c0		 test	 eax, eax
  000de	75 2c		 jne	 SHORT $LN12@Insert_nod

; 675  :                     _Pnode->_Parent->_Color          = _Black;

  000e0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e6	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 676  :                     _Parent_sibling->_Color          = _Black;

  000ea	8b 45 f0	 mov	 eax, DWORD PTR __Parent_sibling$2[ebp]
  000ed	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 677  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  000f1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  000f4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fa	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 678  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  000fe	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00107	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 679  :                 } else { // parent's sibling has red and black children

  0010a	eb 4a		 jmp	 SHORT $LN13@Insert_nod
$LN12@Insert_nod:

; 680  :                     if (_Pnode == _Pnode->_Parent->_Right) { // rotate right child to left

  0010c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0010f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00112	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  00115	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00118	75 14		 jne	 SHORT $LN14@Insert_nod

; 681  :                         _Pnode = _Pnode->_Parent;

  0011a	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0011d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00120	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 682  :                         _Lrotate(_Pnode);

  00123	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  00126	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Lrotate
$LN14@Insert_nod:

; 683  :                     }
; 684  : 
; 685  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  0012e	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00131	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00134	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 686  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00138	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0013b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0013e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00141	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 687  :                     _Rrotate(_Pnode->_Parent->_Parent);

  00145	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00148	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0014b	ff 70 04	 push	 DWORD PTR [eax+4]
  0014e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00151	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Rrotate
$LN13@Insert_nod:

; 688  :                 }
; 689  :             } else { // fixup red-red in right subtree

  00156	e9 8e 00 00 00	 jmp	 $LN11@Insert_nod
$LN10@Insert_nod:

; 690  :                 const auto _Parent_sibling = _Pnode->_Parent->_Parent->_Left;

  0015b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  0015e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00161	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00164	8b 00		 mov	 eax, DWORD PTR [eax]
  00166	89 45 ec	 mov	 DWORD PTR __Parent_sibling$1[ebp], eax

; 691  :                 if (_Parent_sibling->_Color == _Red) { // parent's sibling has two red children, blacken both

  00169	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  0016c	0f be 40 0c	 movsx	 eax, BYTE PTR [eax+12]
  00170	85 c0		 test	 eax, eax
  00172	75 2c		 jne	 SHORT $LN15@Insert_nod

; 692  :                     _Pnode->_Parent->_Color          = _Black;

  00174	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00177	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0017a	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 693  :                     _Parent_sibling->_Color          = _Black;

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __Parent_sibling$1[ebp]
  00181	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 694  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  00185	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00188	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0018e	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 695  :                     _Pnode                           = _Pnode->_Parent->_Parent;

  00192	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  00195	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00198	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0019b	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 696  :                 } else { // parent's sibling has red and black children

  0019e	eb 49		 jmp	 SHORT $LN11@Insert_nod
$LN15@Insert_nod:

; 697  :                     if (_Pnode == _Pnode->_Parent->_Left) { // rotate left child to right

  001a0	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$3[ebp]
  001a9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  001ab	75 14		 jne	 SHORT $LN17@Insert_nod

; 698  :                         _Pnode = _Pnode->_Parent;

  001ad	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001b0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001b3	89 45 fc	 mov	 DWORD PTR __Pnode$3[ebp], eax

; 699  :                         _Rrotate(_Pnode);

  001b6	ff 75 fc	 push	 DWORD PTR __Pnode$3[ebp]
  001b9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	e8 00 00 00 00	 call	 ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Rrotate
$LN17@Insert_nod:

; 700  :                     }
; 701  : 
; 702  :                     _Pnode->_Parent->_Color          = _Black; // propagate red up

  001c1	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001c4	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001c7	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 703  :                     _Pnode->_Parent->_Parent->_Color = _Red;

  001cb	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001ce	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001d4	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0

; 704  :                     _Lrotate(_Pnode->_Parent->_Parent);

  001d8	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$3[ebp]
  001db	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001de	ff 70 04	 push	 DWORD PTR [eax+4]
  001e1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e4	e8 00 00 00 00	 call	 ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Lrotate
$LN11@Insert_nod:

; 705  :                 }
; 706  :             }
; 707  :         }

  001e9	e9 af fe ff ff	 jmp	 $LN4@Insert_nod
$LN3@Insert_nod:

; 708  : 
; 709  :         _Head->_Parent->_Color = _Black; // root is always black

  001ee	8b 45 f8	 mov	 eax, DWORD PTR __Head$[ebp]
  001f1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f4	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 710  :         return _Newnode;

  001f8	8b 45 10	 mov	 eax, DWORD PTR __Newnode$[ebp]
$LN18@Insert_nod:

; 711  :     }

  001fb	c9		 leave
  001fc	c2 0c 00	 ret	 12			; 0000000cH
?_Insert_node@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@U?$_Tree_id@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@2@QAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Insert_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Rrotate, COMDAT
; _this$ = ecx

; 480  :     void _Rrotate(_Nodeptr _Wherenode) noexcept { // promote left node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 481  :         _Nodeptr _Pnode   = _Wherenode->_Left;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 482  :         _Wherenode->_Left = _Pnode->_Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00016	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 483  : 
; 484  :         if (!_Pnode->_Right->_Isnil) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001e	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0c		 jne	 SHORT $LN2@Rrotate

; 485  :             _Pnode->_Right->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Rrotate:

; 486  :         }
; 487  : 
; 488  :         _Pnode->_Parent = _Wherenode->_Parent;

  00035	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003b	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 489  : 
; 490  :         if (_Wherenode == _Myhead->_Parent) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00049	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004c	75 0d		 jne	 SHORT $LN3@Rrotate

; 491  :             _Myhead->_Parent = _Pnode;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00056	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00059	eb 27		 jmp	 SHORT $LN4@Rrotate
$LN3@Rrotate:

; 492  :         } else if (_Wherenode == _Wherenode->_Parent->_Right) {

  0005b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00064	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00067	75 0e		 jne	 SHORT $LN5@Rrotate

; 493  :             _Wherenode->_Parent->_Right = _Pnode;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00072	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 494  :         } else {

  00075	eb 0b		 jmp	 SHORT $LN4@Rrotate
$LN5@Rrotate:

; 495  :             _Wherenode->_Parent->_Left = _Pnode;

  00077	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@Rrotate:

; 496  :         }
; 497  : 
; 498  :         _Pnode->_Right      = _Wherenode;

  00082	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00085	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00088	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 499  :         _Wherenode->_Parent = _Pnode;

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00091	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 500  :     }

  00094	c9		 leave
  00095	c2 04 00	 ret	 4
?_Rrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Pnode$ = -4						; size = 4
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Lrotate, COMDAT
; _this$ = ecx

; 458  :     void _Lrotate(_Nodeptr _Wherenode) noexcept { // promote right node to root of subtree

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 459  :         _Nodeptr _Pnode    = _Wherenode->_Right;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0000b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000e	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 460  :         _Wherenode->_Right = _Pnode->_Left;

  00011	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00017	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00019	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 461  : 
; 462  :         if (!_Pnode->_Left->_Isnil) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00025	85 c0		 test	 eax, eax
  00027	75 0b		 jne	 SHORT $LN2@Lrotate

; 463  :             _Pnode->_Left->_Parent = _Wherenode;

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN2@Lrotate:

; 464  :         }
; 465  : 
; 466  :         _Pnode->_Parent = _Wherenode->_Parent;

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  0003a	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 467  : 
; 468  :         if (_Wherenode == _Myhead->_Parent) {

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00048	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0004b	75 0d		 jne	 SHORT $LN3@Lrotate

; 469  :             _Myhead->_Parent = _Pnode;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00055	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00058	eb 26		 jmp	 SHORT $LN4@Lrotate
$LN3@Lrotate:

; 470  :         } else if (_Wherenode == _Wherenode->_Parent->_Left) {

  0005a	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0005d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00063	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00065	75 0d		 jne	 SHORT $LN5@Lrotate

; 471  :             _Wherenode->_Parent->_Left = _Pnode;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0006a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  00070	89 08		 mov	 DWORD PTR [eax], ecx

; 472  :         } else {

  00072	eb 0c		 jmp	 SHORT $LN4@Lrotate
$LN5@Lrotate:

; 473  :             _Wherenode->_Parent->_Right = _Pnode;

  00074	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0007d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN4@Lrotate:

; 474  :         }
; 475  : 
; 476  :         _Pnode->_Left       = _Wherenode;

  00080	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Wherenode$[ebp]
  00086	89 08		 mov	 DWORD PTR [eax], ecx

; 477  :         _Wherenode->_Parent = _Pnode;

  00088	8b 45 08	 mov	 eax, DWORD PTR __Wherenode$[ebp]
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0008e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 478  :     }

  00091	c9		 leave
  00092	c2 04 00	 ret	 4
?_Lrotate@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S14$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S14$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Check_grow_by_1, COMDAT
; _this$ = ecx

; 1718 :     void _Check_grow_by_1() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1719 :         if (max_size() == _Get_scary()->_Mysize) {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00023	75 05		 jne	 SHORT $LN3@Check_grow

; 1720 :             _Throw_tree_length_error();

  00025	e8 00 00 00 00	 call	 ?_Throw_tree_length_error@std@@YAXXZ ; std::_Throw_tree_length_error
$LN3@Check_grow:

; 1721 :         }
; 1722 :     }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?_Check_grow_by_1@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Check_grow_by_1
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
___param0$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find, COMDAT
; _this$ = ecx

; 1467 :     _NODISCARD iterator find(const key_type& _Keyval) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  00015	ff 75 0c	 push	 DWORD PTR __Keyval$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$_Find@K@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@ABEPAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@ABK@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Find<unsigned long>
  00020	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00023	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00026	8b 4d f4	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx

; 1468 :         return iterator(_Find(_Keyval), _Get_scary());

  0002b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1469 :     }

  0002e	c9		 leave
  0002f	c2 08 00	 ret	 8
?find@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@ABK@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1310 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2043 :         return _Mypair._Myval2._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2043 :         return _Mypair._Myval2._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 1311 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1312 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alnode_traits::max_size(_Getal()));
; 1313 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___param0$ = -16					; size = 4
__Scary$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin, COMDAT
; _this$ = ecx

; 1238 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Scary$[ebp], eax

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00015	8b 45 f4	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	8b 4d f0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00025	89 08		 mov	 DWORD PTR [eax], ecx

; 1239 :         const auto _Scary = _Get_scary();
; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  00027	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1241 :     }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?begin@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKH@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKH@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,int> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKH@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,int>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,int>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?XMasTree_Set@CMapOutdoor@@QAEXMMMPBD0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_c_szTreeName$ = 20					; size = 4
_c_szEffName$ = 24					; size = 4
?XMasTree_Set@CMapOutdoor@@QAEXMMMPBD0@Z PROC		; CMapOutdoor::XMasTree_Set, COMDAT
; _this$ = ecx

; 1383 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 : 	XMasTree_Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?XMasTree_Destroy@CMapOutdoor@@QAEXXZ ; CMapOutdoor::XMasTree_Destroy

; 1385 : 	__XMasTree_Create(x, y, z, c_szTreeName, c_szEffName);

  0000f	ff 75 18	 push	 DWORD PTR _c_szEffName$[ebp]
  00012	ff 75 14	 push	 DWORD PTR _c_szTreeName$[ebp]
  00015	51		 push	 ecx
  00016	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0001b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00020	51		 push	 ecx
  00021	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00026	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002b	51		 push	 ecx
  0002c	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__XMasTree_Create@CMapOutdoor@@AAEXMMMPBD0@Z ; CMapOutdoor::__XMasTree_Create

; 1386 : }

  0003e	c9		 leave
  0003f	c2 14 00	 ret	 20			; 00000014H
?XMasTree_Set@CMapOutdoor@@QAEXMMMPBD0@Z ENDP		; CMapOutdoor::XMasTree_Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?XMasTree_Destroy@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_rkEffMgr$1 = -12					; size = 4
_rkForest$2 = -8					; size = 4
_this$ = -4						; size = 4
?XMasTree_Destroy@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::XMasTree_Destroy, COMDAT
; _this$ = ecx

; 1350 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1351 : 	if (m_kXMas.m_pkTree)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 b8 0e 00
	00 00		 cmp	 DWORD PTR [eax+3768], 0
  00013	74 31		 je	 SHORT $LN2@XMasTree_D

; 1352 : 	{
; 1353 : 		CSpeedTreeForestDirectX8& rkForest=CSpeedTreeForestDirectX8::Instance();

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  0001a	89 45 f8	 mov	 DWORD PTR _rkForest$2[ebp], eax

; 1354 : 		m_kXMas.m_pkTree->Clear();

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 88 b8 0e 00
	00		 mov	 ecx, DWORD PTR [eax+3768]
  00026	e8 00 00 00 00	 call	 ?Clear@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Clear

; 1355 : 		rkForest.DeleteInstance(m_kXMas.m_pkTree);

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	ff b0 b8 0e 00
	00		 push	 DWORD PTR [eax+3768]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _rkForest$2[ebp]
  00037	e8 00 00 00 00	 call	 ?DeleteInstance@CSpeedTreeForest@@QAEXPAVCSpeedTreeWrapper@@@Z ; CSpeedTreeForest::DeleteInstance

; 1356 : 		m_kXMas.m_pkTree=NULL;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 a0 b8 0e 00
	00 00		 and	 DWORD PTR [eax+3768], 0
$LN2@XMasTree_D:

; 1357 : 	}
; 1358 : 	if (-1 != m_kXMas.m_iEffectID)

  00046	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 b8 bc 0e 00
	00 ff		 cmp	 DWORD PTR [eax+3772], -1
  00050	74 23		 je	 SHORT $LN1@XMasTree_D

; 1359 : 	{
; 1360 : 		CEffectManager& rkEffMgr = CEffectManager::Instance();

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  00057	89 45 f4	 mov	 DWORD PTR _rkEffMgr$1[ebp], eax

; 1361 : 		rkEffMgr.DestroyEffectInstance(m_kXMas.m_iEffectID);

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	ff b0 bc 0e 00
	00		 push	 DWORD PTR [eax+3772]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR _rkEffMgr$1[ebp]
  00066	e8 00 00 00 00	 call	 ?DestroyEffectInstance@CEffectManager@@QAE_NK@Z ; CEffectManager::DestroyEffectInstance

; 1362 : 		m_kXMas.m_iEffectID=-1;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 88 bc 0e 00
	00 ff		 or	 DWORD PTR [eax+3772], -1
$LN1@XMasTree_D:

; 1363 : 	}
; 1364 : }

  00075	c9		 leave
  00076	c3		 ret	 0
?XMasTree_Destroy@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::XMasTree_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__XMasTree_Create@CMapOutdoor@@AAEXMMMPBD0@Z
_TEXT	SEGMENT
_rkForest$ = -44					; size = 4
_dwCRC32$ = -40						; size = 4
_this$ = -36						; size = 4
_rkEffMgr$ = -32					; size = 4
$T1 = -28						; size = 12
$T2 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_z$ = 16						; size = 4
_c_szTreeName$ = 20					; size = 4
_c_szEffName$ = 24					; size = 4
?__XMasTree_Create@CMapOutdoor@@AAEXMMMPBD0@Z PROC	; CMapOutdoor::__XMasTree_Create, COMDAT
; _this$ = ecx

; 1367 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 1368 : 	assert(NULL==m_kXMas.m_pkTree);
; 1369 : 	assert(-1==m_kXMas.m_iEffectID);
; 1370 : 
; 1371 : 	CSpeedTreeForestDirectX8& rkForest=CSpeedTreeForestDirectX8::Instance();

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00018	89 45 d4	 mov	 DWORD PTR _rkForest$[ebp], eax

; 1372 : 	DWORD dwCRC32 = GetCaseCRC32(c_szTreeName, strlen(c_szTreeName));

  0001b	ff 75 14	 push	 DWORD PTR _c_szTreeName$[ebp]
  0001e	e8 00 00 00 00	 call	 _strlen
  00023	59		 pop	 ecx
  00024	50		 push	 eax
  00025	ff 75 14	 push	 DWORD PTR _c_szTreeName$[ebp]
  00028	e8 00 00 00 00	 call	 ?GetCaseCRC32@@YAKPBDI@Z ; GetCaseCRC32
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx
  0002f	89 45 d8	 mov	 DWORD PTR _dwCRC32$[ebp], eax

; 1373 : 	m_kXMas.m_pkTree=rkForest.CreateInstance(x, y, z, dwCRC32, c_szTreeName);

  00032	ff 75 14	 push	 DWORD PTR _c_szTreeName$[ebp]
  00035	ff 75 d8	 push	 DWORD PTR _dwCRC32$[ebp]
  00038	51		 push	 ecx
  00039	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  0003e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00043	51		 push	 ecx
  00044	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00049	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004e	51		 push	 ecx
  0004f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  00054	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00059	8b 4d d4	 mov	 ecx, DWORD PTR _rkForest$[ebp]
  0005c	e8 00 00 00 00	 call	 ?CreateInstance@CSpeedTreeForest@@QAEPAVCSpeedTreeWrapper@@MMMKPBD@Z ; CSpeedTreeForest::CreateInstance
  00061	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	89 81 b8 0e 00
	00		 mov	 DWORD PTR [ecx+3768], eax

; 1374 : 
; 1375 : 	CEffectManager& rkEffMgr = CEffectManager::Instance();

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCEffectManager@@@@0PAVCEffectManager@@A ; CSingleton<CEffectManager>::ms_singleton
  0006f	89 45 e0	 mov	 DWORD PTR _rkEffMgr$[ebp], eax

; 1376 : 	rkEffMgr.RegisterEffect(c_szEffName);

  00072	6a 00		 push	 0
  00074	6a 00		 push	 0
  00076	ff 75 18	 push	 DWORD PTR _c_szEffName$[ebp]
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  0007c	e8 00 00 00 00	 call	 ?RegisterEffect@CEffectManager@@QAEHPBD_N1@Z ; CEffectManager::RegisterEffect
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00081	0f 57 c0	 xorps	 xmm0, xmm0
  00084	f3 0f 11 45 f0	 movss	 DWORD PTR $T2[ebp], xmm0

; 181  :     y = fy;

  00089	0f 57 c0	 xorps	 xmm0, xmm0
  0008c	f3 0f 11 45 f4	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 182  :     z = fz;

  00091	0f 57 c0	 xorps	 xmm0, xmm0
  00094	f3 0f 11 45 f8	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 180  :     x = fx;

  00099	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0009e	f3 0f 11 45 e4	 movss	 DWORD PTR $T1[ebp], xmm0

; 181  :     y = fy;

  000a3	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  000a8	f3 0f 11 45 e8	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 182  :     z = fz;

  000ad	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _z$[ebp]
  000b2	f3 0f 11 45 ec	 movss	 DWORD PTR $T1[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1377 : 	m_kXMas.m_iEffectID = rkEffMgr.CreateEffect(c_szEffName,

  000b7	8d 45 f0	 lea	 eax, DWORD PTR $T2[ebp]
  000ba	50		 push	 eax
  000bb	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  000be	50		 push	 eax
  000bf	ff 75 18	 push	 DWORD PTR _c_szEffName$[ebp]
  000c2	8b 4d e0	 mov	 ecx, DWORD PTR _rkEffMgr$[ebp]
  000c5	e8 00 00 00 00	 call	 ?CreateEffect@CEffectManager@@QAEHPBDABUD3DXVECTOR3@@1@Z ; CEffectManager::CreateEffect
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	89 81 bc 0e 00
	00		 mov	 DWORD PTR [ecx+3772], eax

; 1378 : 												D3DXVECTOR3(x, y, z),
; 1379 : 												D3DXVECTOR3(0.0f, 0.0f, 0.0f));
; 1380 : }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	c9		 leave
  000de	c2 14 00	 ret	 20			; 00000014H
?__XMasTree_Create@CMapOutdoor@@AAEXMMMPBD0@Z ENDP	; CMapOutdoor::__XMasTree_Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__XMasTree_Initialize@CMapOutdoor@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__XMasTree_Initialize@CMapOutdoor@@AAEXXZ PROC		; CMapOutdoor::__XMasTree_Initialize, COMDAT
; _this$ = ecx

; 1344 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1345 : 	m_kXMas.m_pkTree=NULL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 b8 0e 00
	00 00		 and	 DWORD PTR [eax+3768], 0

; 1346 : 	m_kXMas.m_iEffectID=-1;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 88 bc 0e 00
	00 ff		 or	 DWORD PTR [eax+3772], -1

; 1347 : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?__XMasTree_Initialize@CMapOutdoor@@AAEXXZ ENDP		; CMapOutdoor::__XMasTree_Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?EnablePortal@CMapOutdoor@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
_bFlag$ = 8						; size = 1
?EnablePortal@CMapOutdoor@@QAEX_N@Z PROC		; CMapOutdoor::EnablePortal, COMDAT
; _this$ = ecx

; 390  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 391  : 	m_bEnablePortal = bFlag;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8a 4d 08	 mov	 cl, BYTE PTR _bFlag$[ebp]
  0000e	88 88 b7 0e 00
	00		 mov	 BYTE PTR [eax+3767], cl

; 392  : 
; 393  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00014	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  00018	eb 07		 jmp	 SHORT $LN4@EnablePort
$LN2@EnablePort:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001d	40		 inc	 eax
  0001e	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@EnablePort:
  00021	83 7d fc 09	 cmp	 DWORD PTR _i$1[ebp], 9
  00025	7d 29		 jge	 SHORT $LN1@EnablePort

; 394  : 		if (m_pArea[i])

  00027	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 bc 81 e0 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+224], 0
  00035	74 17		 je	 SHORT $LN5@EnablePort

; 395  : 			m_pArea[i]->EnablePortal(bFlag);

  00037	0f b6 45 08	 movzx	 eax, BYTE PTR _bFlag$[ebp]
  0003b	50		 push	 eax
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	8b 8c 81 e0 00
	00 00		 mov	 ecx, DWORD PTR [ecx+eax*4+224]
  00049	e8 00 00 00 00	 call	 ?EnablePortal@CArea@@QAEXH@Z ; CArea::EnablePortal
$LN5@EnablePort:
  0004e	eb ca		 jmp	 SHORT $LN2@EnablePort
$LN1@EnablePort:

; 396  : }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?EnablePortal@CMapOutdoor@@QAEX_N@Z ENDP		; CMapOutdoor::EnablePortal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetBaseXY@CMapOutdoor@@QAEXKK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwBaseX$ = 8						; size = 4
_dwBaseY$ = 12						; size = 4
?SetBaseXY@CMapOutdoor@@QAEXKK@Z PROC			; CMapOutdoor::SetBaseXY, COMDAT
; _this$ = ecx

; 1333 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1334 : 	m_dwBaseX = dwBaseX;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwBaseX$[ebp]
  0000d	89 88 a0 0e 00
	00		 mov	 DWORD PTR [eax+3744], ecx

; 1335 : 	m_dwBaseY = dwBaseY;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR _dwBaseY$[ebp]
  00019	89 88 a4 0e 00
	00		 mov	 DWORD PTR [eax+3748], ecx

; 1336 : }

  0001f	c9		 leave
  00020	c2 08 00	 ret	 8
?SetBaseXY@CMapOutdoor@@QAEXKK@Z ENDP			; CMapOutdoor::SetBaseXY
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pdwBaseX$ = 8						; size = 4
_pdwBaseY$ = 12						; size = 4
?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z PROC			; CMapOutdoor::GetBaseXY, COMDAT
; _this$ = ecx

; 1327 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1328 : 	*pdwBaseX = m_dwBaseX;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pdwBaseX$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 89 a0 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3744]
  00013	89 08		 mov	 DWORD PTR [eax], ecx

; 1329 : 	*pdwBaseY = m_dwBaseY;

  00015	8b 45 0c	 mov	 eax, DWORD PTR _pdwBaseY$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 89 a4 0e 00
	00		 mov	 ecx, DWORD PTR [ecx+3748]
  00021	89 08		 mov	 DWORD PTR [eax], ecx

; 1330 : }

  00023	c9		 leave
  00024	c2 08 00	 ret	 8
?GetBaseXY@CMapOutdoor@@QAEXPAK0@Z ENDP			; CMapOutdoor::GetBaseXY
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?AddNewMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJW4EMonsterAreaInfoType@2@KKW4EMonsterDir@2@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_pMonsterAreaInfo$ = -4					; size = 4
_lOriginX$ = 8						; size = 4
_lOriginY$ = 12						; size = 4
_lSizeX$ = 16						; size = 4
_lSizeY$ = 20						; size = 4
_eMonsterAreaInfoType$ = 24				; size = 4
_dwVID$ = 28						; size = 4
_dwCount$ = 32						; size = 4
_eMonsterDir$ = 36					; size = 4
?AddNewMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJW4EMonsterAreaInfoType@2@KKW4EMonsterDir@2@@Z PROC ; CMapOutdoor::AddNewMonsterAreaInfo, COMDAT
; _this$ = ecx

; 1306 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1307 : 	CMonsterAreaInfo * pMonsterAreaInfo = m_kPool_kMonsterAreaInfo.Alloc();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  00012	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ ; CDynamicPool<CMonsterAreaInfo>::Alloc
  00017	89 45 fc	 mov	 DWORD PTR _pMonsterAreaInfo$[ebp], eax

; 1308 : 	pMonsterAreaInfo->Clear();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0001d	e8 00 00 00 00	 call	 ?Clear@CMonsterAreaInfo@@QAEXXZ ; CMonsterAreaInfo::Clear

; 1309 : 	pMonsterAreaInfo->SetOrigin(lOriginX, lOriginY);

  00022	ff 75 0c	 push	 DWORD PTR _lOriginY$[ebp]
  00025	ff 75 08	 push	 DWORD PTR _lOriginX$[ebp]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0002b	e8 00 00 00 00	 call	 ?SetOrigin@CMonsterAreaInfo@@QAEXJJ@Z ; CMonsterAreaInfo::SetOrigin

; 1310 : 	pMonsterAreaInfo->SetSize(lSizeX, lSizeY);

  00030	ff 75 14	 push	 DWORD PTR _lSizeY$[ebp]
  00033	ff 75 10	 push	 DWORD PTR _lSizeX$[ebp]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  00039	e8 00 00 00 00	 call	 ?SetSize@CMonsterAreaInfo@@QAEXJJ@Z ; CMonsterAreaInfo::SetSize

; 1311 : 
; 1312 : 	pMonsterAreaInfo->SetMonsterAreaInfoType(eMonsterAreaInfoType);

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]
  00041	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h

; 55   : 	void			SetMonsterAreaInfoType(EMonsterAreaInfoType eMonsterAreaInfoType) { m_eMonsterAreaInfoType = eMonsterAreaInfoType; }

  00044	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d 18	 mov	 ecx, DWORD PTR _eMonsterAreaInfoType$[ebp]
  0004a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1314 : 	if (CMonsterAreaInfo::MONSTERAREAINFOTYPE_MONSTER == eMonsterAreaInfoType)

  0004d	83 7d 18 01	 cmp	 DWORD PTR _eMonsterAreaInfoType$[ebp], 1
  00051	75 11		 jne	 SHORT $LN2@AddNewMons

; 1315 : 		pMonsterAreaInfo->SetMonsterVID(dwVID);

  00053	8b 45 fc	 mov	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]
  00056	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h

; 71   : 	void			SetMonsterVID(DWORD dwVID) { m_dwVID = dwVID; }

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d 1c	 mov	 ecx, DWORD PTR _dwVID$[ebp]
  0005f	89 48 40	 mov	 DWORD PTR [eax+64], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1315 : 		pMonsterAreaInfo->SetMonsterVID(dwVID);

  00062	eb 15		 jmp	 SHORT $LN3@AddNewMons
$LN2@AddNewMons:

; 1316 : 	else if (CMonsterAreaInfo::MONSTERAREAINFOTYPE_GROUP == eMonsterAreaInfoType)

  00064	83 7d 18 02	 cmp	 DWORD PTR _eMonsterAreaInfoType$[ebp], 2
  00068	75 0f		 jne	 SHORT $LN3@AddNewMons

; 1317 : 		pMonsterAreaInfo->SetMonsterGroupID(dwVID);

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]
  0006d	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MonsterAreaInfo.h

; 59   : 	void			SetMonsterGroupID(DWORD dwGroupID) { m_dwGroupID = dwGroupID;}

  00070	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d 1c	 mov	 ecx, DWORD PTR _dwVID$[ebp]
  00076	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN3@AddNewMons:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1318 : 	pMonsterAreaInfo->SetMonsterCount(dwCount);

  00079	ff 75 20	 push	 DWORD PTR _dwCount$[ebp]
  0007c	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0007f	e8 00 00 00 00	 call	 ?SetMonsterCount@CMonsterAreaInfo@@QAEXK@Z ; CMonsterAreaInfo::SetMonsterCount

; 1319 : 	pMonsterAreaInfo->SetMonsterDirection(eMonsterDir);

  00084	ff 75 24	 push	 DWORD PTR _eMonsterDir$[ebp]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0008a	e8 00 00 00 00	 call	 ?SetMonsterDirection@CMonsterAreaInfo@@QAEXW4EMonsterDir@1@@Z ; CMonsterAreaInfo::SetMonsterDirection
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 fc	 lea	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1320 : 	m_MonsterAreaInfoPtrVector.push_back(pMonsterAreaInfo);

  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1322 : 	return pMonsterAreaInfo;

  000a1	8b 45 fc	 mov	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]

; 1323 : }

  000a4	c9		 leave
  000a5	c2 20 00	 ret	 32			; 00000020H
?AddNewMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJW4EMonsterAreaInfoType@2@KKW4EMonsterDir@2@@Z ENDP ; CMapOutdoor::AddNewMonsterAreaInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetMonsterAreaInfoFromVectorIndex@CMapOutdoor@@QAE_NKPAPAVCMonsterAreaInfo@@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__My_data$2 = -16					; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$4 = -4					; size = 4
_dwMonsterAreaInfoVectorIndex$ = 8			; size = 4
_ppMonsterAreaInfo$ = 12				; size = 4
?GetMonsterAreaInfoFromVectorIndex@CMapOutdoor@@QAE_NKPAPAVCMonsterAreaInfo@@@Z PROC ; CMapOutdoor::GetMonsterAreaInfoFromVectorIndex, COMDAT
; _this$ = ecx

; 1294 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00011	89 45 fc	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00014	8b 45 fc	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001f	c1 f8 02	 sar	 eax, 2
  00022	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1295 : 	if (dwMonsterAreaInfoVectorIndex >= m_MonsterAreaInfoPtrVector.size())

  00025	8b 45 08	 mov	 eax, DWORD PTR _dwMonsterAreaInfoVectorIndex$[ebp]
  00028	3b 45 f4	 cmp	 eax, DWORD PTR $T3[ebp]
  0002b	72 04		 jb	 SHORT $LN2@GetMonster

; 1296 : 		return false;

  0002d	32 c0		 xor	 al, al
  0002f	eb 25		 jmp	 SHORT $LN1@GetMonster
$LN2@GetMonster:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00039	89 45 f0	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0003c	8b 45 f0	 mov	 eax, DWORD PTR __My_data$2[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _dwMonsterAreaInfoVectorIndex$[ebp]
  00044	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00047	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1298 : 	*ppMonsterAreaInfo = m_MonsterAreaInfoPtrVector[dwMonsterAreaInfoVectorIndex];

  0004a	8b 45 0c	 mov	 eax, DWORD PTR _ppMonsterAreaInfo$[ebp]
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  00050	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00052	89 08		 mov	 DWORD PTR [eax], ecx

; 1299 : 	return true;

  00054	b0 01		 mov	 al, 1
$LN1@GetMonster:

; 1300 : }

  00056	c9		 leave
  00057	c2 08 00	 ret	 8
?GetMonsterAreaInfoFromVectorIndex@CMapOutdoor@@QAE_NKPAPAVCMonsterAreaInfo@@@Z ENDP ; CMapOutdoor::GetMonsterAreaInfoFromVectorIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T1 = -72						; size = 4
$T2 = -68						; size = 4
_pMonsterAreaInfo$3 = -64				; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
___param0$ = -44					; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
___param0$ = -32					; size = 4
_this$ = -28						; size = 4
tv166 = -24						; size = 4
tv180 = -20						; size = 4
__My_data$10 = -16					; size = 4
__My_data$11 = -12					; size = 4
_this$ = -8						; size = 4
$T12 = -2						; size = 1
$T13 = -1						; size = 1
?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ PROC	; CMapOutdoor::RemoveAllMonsterAreaInfo, COMDAT
; _this$ = ecx

; 1281 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00011	89 45 f4	 mov	 DWORD PTR __My_data$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00014	8b 45 f4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00017	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0001a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00022	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00025	89 45 dc	 mov	 DWORD PTR $T9[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00028	8d 45 dc	 lea	 eax, DWORD PTR $T9[ebp]
  0002b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1282 : 	m_MonsterAreaInfoPtrVectorIterator = m_MonsterAreaInfoPtrVector.begin();

  0002e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	89 81 9c 0e 00
	00		 mov	 DWORD PTR [ecx+3740], eax
$LN2@RemoveAllM:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00044	89 45 f0	 mov	 DWORD PTR __My_data$10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00047	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  0004a	89 45 b8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0004d	8b 45 f0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00050	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00053	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00056	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0005c	8d 45 d0	 lea	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d cc	 mov	 ecx, DWORD PTR $T6[ebp]
  00068	8b 80 9c 0e 00
	00		 mov	 eax, DWORD PTR [eax+3740]
  0006e	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00070	75 09		 jne	 SHORT $LN42@RemoveAllM
  00072	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv180[ebp], 1
  00079	eb 04		 jmp	 SHORT $LN43@RemoveAllM
$LN42@RemoveAllM:
  0007b	83 65 ec 00	 and	 DWORD PTR tv180[ebp], 0
$LN43@RemoveAllM:
  0007f	8a 45 ec	 mov	 al, BYTE PTR tv180[ebp]
  00082	88 45 ff	 mov	 BYTE PTR $T13[ebp], al

; 153  :         return !(*this == _Right);

  00085	0f b6 45 ff	 movzx	 eax, BYTE PTR $T13[ebp]
  00089	85 c0		 test	 eax, eax
  0008b	75 09		 jne	 SHORT $LN37@RemoveAllM
  0008d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  00094	eb 04		 jmp	 SHORT $LN38@RemoveAllM
$LN37@RemoveAllM:
  00096	83 65 e8 00	 and	 DWORD PTR tv166[ebp], 0
$LN38@RemoveAllM:
  0009a	8a 45 e8	 mov	 al, BYTE PTR tv166[ebp]
  0009d	88 45 fe	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1283 : 	while (m_MonsterAreaInfoPtrVectorIterator != m_MonsterAreaInfoPtrVector.end())

  000a0	0f b6 45 fe	 movzx	 eax, BYTE PTR $T12[ebp]
  000a4	85 c0		 test	 eax, eax
  000a6	74 3f		 je	 SHORT $LN3@RemoveAllM
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 80 9c 0e 00
	00		 mov	 eax, DWORD PTR [eax+3740]
  000b1	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  000b4	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b7	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1285 : 		CMonsterAreaInfo * pMonsterAreaInfo = *m_MonsterAreaInfoPtrVectorIterator;

  000ba	8b 45 c4	 mov	 eax, DWORD PTR $T4[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	89 45 c0	 mov	 DWORD PTR _pMonsterAreaInfo$3[ebp], eax

; 1286 : 		pMonsterAreaInfo->Clear();

  000c2	8b 4d c0	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$3[ebp]
  000c5	e8 00 00 00 00	 call	 ?Clear@CMonsterAreaInfo@@QAEXXZ ; CMonsterAreaInfo::Clear

; 1287 : 		++m_MonsterAreaInfoPtrVectorIterator;

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	05 9c 0e 00 00	 add	 eax, 3740		; 00000e9cH
  000d2	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000d5	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 00		 mov	 eax, DWORD PTR [eax]
  000da	83 c0 04	 add	 eax, 4
  000dd	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1288 : 	}

  000e2	e9 55 ff ff ff	 jmp	 $LN2@RemoveAllM
$LN3@RemoveAllM:

; 1289 : 	m_kPool_kMonsterAreaInfo.FreeAll();

  000e7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  000f0	e8 00 00 00 00	 call	 ?FreeAll@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ; CDynamicPool<CMonsterAreaInfo>::FreeAll

; 1290 : 	m_MonsterAreaInfoPtrVector.clear();

  000f5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
  000fe	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear

; 1291 : }

  00103	c9		 leave
  00104	c3		 ret	 0
?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ ENDP	; CMapOutdoor::RemoveAllMonsterAreaInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pMonsterAreaInfo$ = -4					; size = 4
_lOriginX$ = 8						; size = 4
_lOriginY$ = 12						; size = 4
_lSizeX$ = 16						; size = 4
_lSizeY$ = 20						; size = 4
?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z PROC ; CMapOutdoor::AddMonsterAreaInfo, COMDAT
; _this$ = ecx

; 1270 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1271 : 	CMonsterAreaInfo * pMonsterAreaInfo = m_kPool_kMonsterAreaInfo.Alloc();

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  00011	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ ; CDynamicPool<CMonsterAreaInfo>::Alloc
  00016	89 45 fc	 mov	 DWORD PTR _pMonsterAreaInfo$[ebp], eax

; 1272 : 	pMonsterAreaInfo->Clear();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Clear@CMonsterAreaInfo@@QAEXXZ ; CMonsterAreaInfo::Clear

; 1273 : 	pMonsterAreaInfo->SetOrigin(lOriginX, lOriginY);

  00021	ff 75 0c	 push	 DWORD PTR _lOriginY$[ebp]
  00024	ff 75 08	 push	 DWORD PTR _lOriginX$[ebp]
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  0002a	e8 00 00 00 00	 call	 ?SetOrigin@CMonsterAreaInfo@@QAEXJJ@Z ; CMonsterAreaInfo::SetOrigin

; 1274 : 	pMonsterAreaInfo->SetSize(lSizeX, lSizeY);

  0002f	ff 75 14	 push	 DWORD PTR _lSizeY$[ebp]
  00032	ff 75 10	 push	 DWORD PTR _lSizeX$[ebp]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _pMonsterAreaInfo$[ebp]
  00038	e8 00 00 00 00	 call	 ?SetSize@CMonsterAreaInfo@@QAEXJJ@Z ; CMonsterAreaInfo::SetSize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0003d	8d 45 fc	 lea	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]
  00040	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1275 : 	m_MonsterAreaInfoPtrVector.push_back(pMonsterAreaInfo);

  00041	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0004a	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1277 : 	return pMonsterAreaInfo;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pMonsterAreaInfo$[ebp]

; 1278 : }

  00052	c9		 leave
  00053	c2 10 00	 ret	 16			; 00000010H
?AddMonsterAreaInfo@CMapOutdoor@@QAEPAVCMonsterAreaInfo@@JJJJ@Z ENDP ; CMapOutdoor::AddMonsterAreaInfo
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z PROC	; CDynamicPool<CMonsterAreaInfo>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ ; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCMonsterAreaInfo@@@@UAEPAXI@Z ENDP	; CDynamicPool<CMonsterAreaInfo>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCMonsterAreaInfo@@@@KAXPAVCMonsterAreaInfo@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCMonsterAreaInfo@@@@KAXPAVCMonsterAreaInfo@@@Z PROC ; CDynamicPool<CMonsterAreaInfo>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCMonsterAreaInfo@@@@KAXPAVCMonsterAreaInfo@@@Z ENDP ; CDynamicPool<CMonsterAreaInfo>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?FreeAll@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -20						; size = 1
$T2 = -16						; size = 4
_this$ = -12						; size = 4
__Right$ = -8						; size = 4
_this$ = -4						; size = 4
?FreeAll@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ PROC ; CDynamicPool<CMonsterAreaInfo>::FreeAll, COMDAT
; _this$ = ecx

; 84   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 85   : 			m_kVct_pkFree=m_kVct_pkData;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Right$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 10	 add	 eax, 16			; 00000010H
  00018	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Right$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1168 :         if (this != _STD addressof(_Right)) {

  00021	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	3b 45 f0	 cmp	 eax, DWORD PTR $T2[ebp]
  00027	74 13		 je	 SHORT $LN1@FreeAll

; 1169 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00029	33 c0		 xor	 eax, eax
  0002b	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0002e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00031	ff 75 f8	 push	 DWORD PTR __Right$[ebp]
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Copy_assign@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Copy_assign
$LN1@FreeAll:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 86   : 		}

  0003c	c9		 leave
  0003d	c3		 ret	 0
?FreeAll@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ENDP ; CDynamicPool<CMonsterAreaInfo>::FreeAll
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ PROC ; CDynamicPool<CMonsterAreaInfo>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 5a		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	68 9c 00 00 00	 push	 156			; 0000009cH
  0005e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00063	59		 pop	 ecx
  00064	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006f	74 0d		 je	 SHORT $LN4@Alloc
  00071	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00074	e8 00 00 00 00	 call	 ??0CMonsterAreaInfo@@QAE@XZ ; CMonsterAreaInfo::CMonsterAreaInfo
  00079	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007e	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00082	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00085	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00092	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00095	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXABQAVCMonsterAreaInfo@@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::emplace_back<CMonsterAreaInfo * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a7	40		 inc	 eax
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ae	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000b1	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000bc	6a 04		 push	 4
  000be	58		 pop	 eax
  000bf	6b c0 ff	 imul	 eax, eax, -1
  000c2	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c5	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000cb	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000dc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000e2	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000eb	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f6	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ff	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00102	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	83 e8 04	 sub	 eax, 4
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00115	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ$0:
  00000	68 9c 00 00 00	 push	 156			; 0000009cH
  00005	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEPAVCMonsterAreaInfo@@XZ ENDP ; CDynamicPool<CMonsterAreaInfo>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ PROC ; CDynamicPool<CMonsterAreaInfo>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCMonsterAreaInfo@@@@KAXPAVCMonsterAreaInfo@@@Z ; CDynamicPool<CMonsterAreaInfo>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@std@@P6AXPAVCMonsterAreaInfo@@@Z@std@@YAP6AXPAVCMonsterAreaInfo@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCMonsterAreaInfo@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CMonsterAreaInfo *> > >,void (__cdecl*)(CMonsterAreaInfo *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ENDP ; CDynamicPool<CMonsterAreaInfo>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ PROC	; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCMonsterAreaInfo@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ ENDP	; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCMonsterAreaInfo@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCMonsterAreaInfo@@@@QAE@XZ PROC	; CDynamicPool<CMonsterAreaInfo>::CDynamicPool<CMonsterAreaInfo>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCMonsterAreaInfo@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCMonsterAreaInfo@@@@QAE@XZ ENDP	; CDynamicPool<CMonsterAreaInfo>::CDynamicPool<CMonsterAreaInfo>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 18	 imul	 eax, eax, 24
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@UtagRECT@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@UtagRECT@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<tagRECT,void *> *,std::_List_node<tagRECT,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Free_non_head<std::allocator<std::_List_node<tagRECT,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Freenode0<std::allocator<std::_List_node<tagRECT,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@std@@@?$_List_node@UtagRECT@@PAX@std@@SAXAAV?$allocator@U?$_List_node@UtagRECT@@PAX@std@@@1@PAU01@@Z ; std::_List_node<tagRECT,void *>::_Free_non_head<std::allocator<std::_List_node<tagRECT,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UtagRECT@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UtagRECT@@@std@@@std@@@2@XZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UtagRECT@@@std@@@std@@@2@XZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::~list<tagRECT,std::allocator<tagRECT> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::~list<tagRECT,std::allocator<tagRECT> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ PROC ; std::list<tagRECT,std::allocator<tagRECT> >::list<tagRECT,std::allocator<tagRECT> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ENDP ; std::list<tagRECT,std::allocator<tagRECT> >::list<tagRECT,std::allocator<tagRECT> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$1 = -44					; size = 4
$T2 = -40						; size = 4
__Myend$ = -36						; size = 4
__Mylast$ = -32						; size = 4
__Myfirst$ = -28					; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__Newvec$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1633 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1634 :         // allocate array with _Newcapacity elements
; 1635 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1636 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1637 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1638 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 dc	 mov	 DWORD PTR __Myend$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002a	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002d	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00030	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00033	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00037	c7 45 d4 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0003e	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00045	76 05		 jbe	 SHORT $LN12@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00047	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Buy_raw:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0004f	c1 e0 02	 shl	 eax, 2
  00052	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00055	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005d	59		 pop	 ecx
  0005e	89 45 f4	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1644 :         _Myfirst           = _Newvec;

  00061	8b 45 e4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 1645 :         _Mylast            = _Newvec;

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx

; 1646 :         _Myend             = _Newvec + _Newcapacity;

  00071	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00077	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Buy_raw:

; 1647 :     }

  0007f	c9		 leave
  00080	c2 04 00	 ret	 4
?_Buy_raw@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Myfirst$ = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1271 :     void _Clear_and_reserve_geometric(const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1272 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1273 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1274 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1275 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1276 : 
; 1277 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1278 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1279 :         {
; 1280 :             _Lockit _Lock(_LOCK_DEBUG);
; 1281 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter); // asserts that all iterators are orphaned
; 1282 :         } // unlock
; 1283 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1284 : 
; 1285 :         if (_Newsize > max_size()) {

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QBEIXZ ; std::vector<CArea *,std::allocator<CArea *> >::max_size
  0002f	39 45 08	 cmp	 DWORD PTR __Newsize$[ebp], eax
  00032	76 05		 jbe	 SHORT $LN2@Clear_and_

; 1286 :             _Xlength();

  00034	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@CAXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Xlength
$LN2@Clear_and_:

; 1287 :         }
; 1288 : 
; 1289 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00039	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@ABEII@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Calculate_growth
  00044	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1290 : 
; 1291 :         if (_Myfirst) { // destroy and deallocate old array

  00047	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	74 74		 je	 SHORT $LN3@Clear_and_

; 1292 :             _Destroy(_Myfirst, _Mylast);

  0004f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00062	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00068	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0006b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0006e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00071	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCArea@@@std@@@std@@YAXPAPAVCArea@@QAPAV1@AAV?$allocator@PAVCArea@@@0@@Z ; std::_Destroy_range<std::allocator<CArea *> >
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0007f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00082	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00085	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax

; 1293 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	2b 01		 sub	 eax, DWORD PTR [ecx]
  00092	c1 f8 02	 sar	 eax, 2
  00095	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00098	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000a3	c1 e0 02	 shl	 eax, 2
  000a6	50		 push	 eax
  000a7	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000aa	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000af	59		 pop	 ecx
  000b0	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1295 :             _Myfirst = pointer();

  000b1	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b4	83 20 00	 and	 DWORD PTR [eax], 0

; 1296 :             _Mylast  = pointer();

  000b7	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ba	83 20 00	 and	 DWORD PTR [eax], 0

; 1297 :             _Myend   = pointer();

  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Clear_and_:

; 1298 :         }
; 1299 : 
; 1300 :         _Buy_raw(_Newcapacity);

  000c3	ff 75 cc	 push	 DWORD PTR __Newcapacity$[ebp]
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Buy_raw
$LN4@Clear_and_:

; 1301 :     }

  000ce	c9		 leave
  000cf	c2 04 00	 ret	 4
?_Clear_and_reserve_geometric@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Copy_assign@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 1
__First$ = -36						; size = 4
$T2 = -32						; size = 4
__Last$ = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Right_data$ = -4					; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<CArea *,std::allocator<CArea *> >::_Copy_assign, COMDAT
; _this$ = ecx

; 1150 :     void _Copy_assign(const vector& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1151 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  00024	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@PAVCArea@@@std@@@std@@YAXAAV?$allocator@PAVCArea@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CArea *> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 1152 :         auto& _Right_data = _Right._Mypair._Myval2;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Right_data$[ebp], eax

; 1153 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  00045	8b 45 e4	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0004b	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Assign_range@PAPAVCArea@@@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXPAPAVCArea@@0Uforward_iterator_tag@1@@Z ; std::vector<CArea *,std::allocator<CArea *> >::_Assign_range<CArea * *>

; 1154 :     }

  0005c	c9		 leave
  0005d	c2 08 00	 ret	 8
?_Copy_assign@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<CArea *,std::allocator<CArea *> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ PROC ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ENDP ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$1 = -44					; size = 4
$T2 = -40						; size = 4
__Myend$ = -36						; size = 4
__Mylast$ = -32						; size = 4
__Myfirst$ = -28					; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__Newvec$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1633 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1634 :         // allocate array with _Newcapacity elements
; 1635 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1636 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1637 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1638 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 dc	 mov	 DWORD PTR __Myend$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002a	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002d	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00030	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00033	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00037	c7 45 d4 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0003e	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00045	76 05		 jbe	 SHORT $LN12@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00047	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Buy_raw:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0004f	c1 e0 02	 shl	 eax, 2
  00052	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00055	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005d	59		 pop	 ecx
  0005e	89 45 f4	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1644 :         _Myfirst           = _Newvec;

  00061	8b 45 e4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 1645 :         _Mylast            = _Newvec;

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx

; 1646 :         _Myend             = _Newvec + _Newcapacity;

  00071	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00077	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Buy_raw:

; 1647 :     }

  0007f	c9		 leave
  00080	c2 04 00	 ret	 4
?_Buy_raw@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Myfirst$ = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1271 :     void _Clear_and_reserve_geometric(const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1272 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1273 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1274 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1275 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1276 : 
; 1277 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1278 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1279 :         {
; 1280 :             _Lockit _Lock(_LOCK_DEBUG);
; 1281 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter); // asserts that all iterators are orphaned
; 1282 :         } // unlock
; 1283 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1284 : 
; 1285 :         if (_Newsize > max_size()) {

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QBEIXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::max_size
  0002f	39 45 08	 cmp	 DWORD PTR __Newsize$[ebp], eax
  00032	76 05		 jbe	 SHORT $LN2@Clear_and_

; 1286 :             _Xlength();

  00034	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@CAXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Xlength
$LN2@Clear_and_:

; 1287 :         }
; 1288 : 
; 1289 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00039	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@ABEII@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Calculate_growth
  00044	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1290 : 
; 1291 :         if (_Myfirst) { // destroy and deallocate old array

  00047	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	74 74		 je	 SHORT $LN3@Clear_and_

; 1292 :             _Destroy(_Myfirst, _Mylast);

  0004f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00062	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00068	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0006b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0006e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00071	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTerrain@@@std@@@std@@YAXPAPAVCTerrain@@QAPAV1@AAV?$allocator@PAVCTerrain@@@0@@Z ; std::_Destroy_range<std::allocator<CTerrain *> >
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0007f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00082	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00085	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax

; 1293 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	2b 01		 sub	 eax, DWORD PTR [ecx]
  00092	c1 f8 02	 sar	 eax, 2
  00095	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00098	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000a3	c1 e0 02	 shl	 eax, 2
  000a6	50		 push	 eax
  000a7	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000aa	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000af	59		 pop	 ecx
  000b0	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1295 :             _Myfirst = pointer();

  000b1	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b4	83 20 00	 and	 DWORD PTR [eax], 0

; 1296 :             _Mylast  = pointer();

  000b7	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ba	83 20 00	 and	 DWORD PTR [eax], 0

; 1297 :             _Myend   = pointer();

  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Clear_and_:

; 1298 :         }
; 1299 : 
; 1300 :         _Buy_raw(_Newcapacity);

  000c3	ff 75 cc	 push	 DWORD PTR __Newcapacity$[ebp]
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Buy_raw
$LN4@Clear_and_:

; 1301 :     }

  000ce	c9		 leave
  000cf	c2 04 00	 ret	 4
?_Clear_and_reserve_geometric@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Copy_assign@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 1
__First$ = -36						; size = 4
$T2 = -32						; size = 4
__Last$ = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Right_data$ = -4					; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Copy_assign, COMDAT
; _this$ = ecx

; 1150 :     void _Copy_assign(const vector& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1151 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  00024	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@PAVCTerrain@@@std@@@std@@YAXAAV?$allocator@PAVCTerrain@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CTerrain *> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 1152 :         auto& _Right_data = _Right._Mypair._Myval2;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Right_data$[ebp], eax

; 1153 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  00045	8b 45 e4	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0004b	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Assign_range@PAPAVCTerrain@@@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXPAPAVCTerrain@@0Uforward_iterator_tag@1@@Z ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Assign_range<CTerrain * *>

; 1154 :     }

  0005c	c9		 leave
  0005d	c2 08 00	 ret	 8
?_Copy_assign@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ PROC ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ENDP ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z
_TEXT	SEGMENT
$T1 = -84						; size = 16
$T2 = -68						; size = 16
$T3 = -52						; size = 16
$T4 = -36						; size = 16
$T5 = -20						; size = 16
$T6 = -4						; size = 16
_fd$ = 12						; size = 4
_fc$ = 16						; size = 4
_fb$ = 20						; size = 4
_fa$ = 24						; size = 4
_fd$ = 28						; size = 4
_fc$ = 32						; size = 4
_fb$ = 36						; size = 4
_fa$ = 40						; size = 4
_fd$ = 44						; size = 4
_fc$ = 48						; size = 4
_fb$ = 52						; size = 4
_fa$ = 56						; size = 4
_fd$ = 60						; size = 4
_fc$ = 64						; size = 4
_fb$ = 68						; size = 4
_fa$ = 72						; size = 4
_fd$ = 76						; size = 4
_fc$ = 80						; size = 4
_fb$ = 84						; size = 4
_fa$ = 88						; size = 4
_fd$ = 92						; size = 4
_fc$ = 96						; size = 4
_fb$ = 100						; size = 4
_fa$ = 104						; size = 4
_i$7 = 108						; size = 4
_this$ = 112						; size = 4
_mat$ = 124						; size = 4
?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z PROC ; CMapOutdoor::BuildViewFrustum, COMDAT
; _this$ = ecx

; 717  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 719  : 	m_plane[0] = D3DXPLANE(          mat._13,           mat._23,           mat._33,           mat._43);		// Near

  00010	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00013	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00018	f3 0f 11 45 68	 movss	 DWORD PTR _fa$[ebp], xmm0
  0001d	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00020	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00025	f3 0f 11 45 64	 movss	 DWORD PTR _fb$[ebp], xmm0
  0002a	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0002d	f3 0f 10 40 28	 movss	 xmm0, DWORD PTR [eax+40]
  00032	f3 0f 11 45 60	 movss	 DWORD PTR _fc$[ebp], xmm0
  00037	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0003a	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  0003f	f3 0f 11 45 5c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00044	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00049	f3 0f 11 45 fc	 movss	 DWORD PTR $T6[ebp], xmm0

; 830  :     b = fb;

  0004e	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00053	f3 0f 11 45 00	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 831  :     c = fc;

  00058	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _fc$[ebp]
  0005d	f3 0f 11 45 04	 movss	 DWORD PTR $T6[ebp+8], xmm0

; 832  :     d = fd;

  00062	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  00067	f3 0f 11 45 08	 movss	 DWORD PTR $T6[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 719  : 	m_plane[0] = D3DXPLANE(          mat._13,           mat._23,           mat._33,           mat._43);		// Near

  0006c	6a 10		 push	 16			; 00000010H
  0006e	58		 pop	 eax
  0006f	6b c0 00	 imul	 eax, eax, 0
  00072	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  0007c	8d 75 fc	 lea	 esi, DWORD PTR $T6[ebp]
  0007f	a5		 movsd
  00080	a5		 movsd
  00081	a5		 movsd
  00082	a5		 movsd

; 720  : 	m_plane[1] = D3DXPLANE(mat._14 - mat._13, mat._24 - mat._23, mat._34 - mat._33, mat._44 - mat._43);		// Far

  00083	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00086	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00089	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0008e	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00093	f3 0f 11 45 58	 movss	 DWORD PTR _fa$[ebp], xmm0
  00098	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0009b	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  0009e	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  000a3	f3 0f 5c 41 18	 subss	 xmm0, DWORD PTR [ecx+24]
  000a8	f3 0f 11 45 54	 movss	 DWORD PTR _fb$[ebp], xmm0
  000ad	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  000b0	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  000b3	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  000b8	f3 0f 5c 41 28	 subss	 xmm0, DWORD PTR [ecx+40]
  000bd	f3 0f 11 45 50	 movss	 DWORD PTR _fc$[ebp], xmm0
  000c2	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  000c5	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  000c8	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  000cd	f3 0f 5c 41 38	 subss	 xmm0, DWORD PTR [ecx+56]
  000d2	f3 0f 11 45 4c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  000d7	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _fa$[ebp]
  000dc	f3 0f 11 45 ec	 movss	 DWORD PTR $T5[ebp], xmm0

; 830  :     b = fb;

  000e1	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _fb$[ebp]
  000e6	f3 0f 11 45 f0	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 831  :     c = fc;

  000eb	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _fc$[ebp]
  000f0	f3 0f 11 45 f4	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 832  :     d = fd;

  000f5	f3 0f 10 45 4c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  000fa	f3 0f 11 45 f8	 movss	 DWORD PTR $T5[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 720  : 	m_plane[1] = D3DXPLANE(mat._14 - mat._13, mat._24 - mat._23, mat._34 - mat._33, mat._44 - mat._43);		// Far

  000ff	6a 10		 push	 16			; 00000010H
  00101	58		 pop	 eax
  00102	c1 e0 00	 shl	 eax, 0
  00105	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00108	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  0010f	8d 75 ec	 lea	 esi, DWORD PTR $T5[ebp]
  00112	a5		 movsd
  00113	a5		 movsd
  00114	a5		 movsd
  00115	a5		 movsd

; 721  : 	m_plane[2] = D3DXPLANE(mat._14 + mat._11, mat._24 + mat._21, mat._34 + mat._31, mat._44 + mat._41);		// Left

  00116	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00119	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  0011c	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00121	f3 0f 58 01	 addss	 xmm0, DWORD PTR [ecx]
  00125	f3 0f 11 45 48	 movss	 DWORD PTR _fa$[ebp], xmm0
  0012a	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0012d	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00130	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00135	f3 0f 58 41 10	 addss	 xmm0, DWORD PTR [ecx+16]
  0013a	f3 0f 11 45 44	 movss	 DWORD PTR _fb$[ebp], xmm0
  0013f	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00142	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00145	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  0014a	f3 0f 58 41 20	 addss	 xmm0, DWORD PTR [ecx+32]
  0014f	f3 0f 11 45 40	 movss	 DWORD PTR _fc$[ebp], xmm0
  00154	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00157	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  0015a	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  0015f	f3 0f 58 41 30	 addss	 xmm0, DWORD PTR [ecx+48]
  00164	f3 0f 11 45 3c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00169	f3 0f 10 45 48	 movss	 xmm0, DWORD PTR _fa$[ebp]
  0016e	f3 0f 11 45 dc	 movss	 DWORD PTR $T4[ebp], xmm0

; 830  :     b = fb;

  00173	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00178	f3 0f 11 45 e0	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 831  :     c = fc;

  0017d	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _fc$[ebp]
  00182	f3 0f 11 45 e4	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 832  :     d = fd;

  00187	f3 0f 10 45 3c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  0018c	f3 0f 11 45 e8	 movss	 DWORD PTR $T4[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 721  : 	m_plane[2] = D3DXPLANE(mat._14 + mat._11, mat._24 + mat._21, mat._34 + mat._31, mat._44 + mat._41);		// Left

  00191	6a 10		 push	 16			; 00000010H
  00193	58		 pop	 eax
  00194	d1 e0		 shl	 eax, 1
  00196	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  001a0	8d 75 dc	 lea	 esi, DWORD PTR $T4[ebp]
  001a3	a5		 movsd
  001a4	a5		 movsd
  001a5	a5		 movsd
  001a6	a5		 movsd

; 722  : 	m_plane[3] = D3DXPLANE(mat._14 - mat._11, mat._24 - mat._21, mat._34 - mat._31, mat._44 - mat._41);		// Right

  001a7	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  001aa	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  001ad	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  001b2	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001b6	f3 0f 11 45 38	 movss	 DWORD PTR _fa$[ebp], xmm0
  001bb	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  001be	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  001c1	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  001c6	f3 0f 5c 41 10	 subss	 xmm0, DWORD PTR [ecx+16]
  001cb	f3 0f 11 45 34	 movss	 DWORD PTR _fb$[ebp], xmm0
  001d0	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  001d3	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  001d6	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  001db	f3 0f 5c 41 20	 subss	 xmm0, DWORD PTR [ecx+32]
  001e0	f3 0f 11 45 30	 movss	 DWORD PTR _fc$[ebp], xmm0
  001e5	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  001e8	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  001eb	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  001f0	f3 0f 5c 41 30	 subss	 xmm0, DWORD PTR [ecx+48]
  001f5	f3 0f 11 45 2c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  001fa	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR _fa$[ebp]
  001ff	f3 0f 11 45 cc	 movss	 DWORD PTR $T3[ebp], xmm0

; 830  :     b = fb;

  00204	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00209	f3 0f 11 45 d0	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 831  :     c = fc;

  0020e	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _fc$[ebp]
  00213	f3 0f 11 45 d4	 movss	 DWORD PTR $T3[ebp+8], xmm0

; 832  :     d = fd;

  00218	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  0021d	f3 0f 11 45 d8	 movss	 DWORD PTR $T3[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 722  : 	m_plane[3] = D3DXPLANE(mat._14 - mat._11, mat._24 - mat._21, mat._34 - mat._31, mat._44 - mat._41);		// Right

  00222	6a 10		 push	 16			; 00000010H
  00224	58		 pop	 eax
  00225	6b c0 03	 imul	 eax, eax, 3
  00228	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0022b	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  00232	8d 75 cc	 lea	 esi, DWORD PTR $T3[ebp]
  00235	a5		 movsd
  00236	a5		 movsd
  00237	a5		 movsd
  00238	a5		 movsd

; 723  : 	m_plane[4] = D3DXPLANE(mat._14 + mat._12, mat._24 + mat._22, mat._34 + mat._32, mat._44 + mat._42);		// Bottom

  00239	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0023c	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  0023f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00244	f3 0f 58 41 04	 addss	 xmm0, DWORD PTR [ecx+4]
  00249	f3 0f 11 45 28	 movss	 DWORD PTR _fa$[ebp], xmm0
  0024e	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00251	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00254	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  00259	f3 0f 58 41 14	 addss	 xmm0, DWORD PTR [ecx+20]
  0025e	f3 0f 11 45 24	 movss	 DWORD PTR _fb$[ebp], xmm0
  00263	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  00266	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00269	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  0026e	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  00273	f3 0f 11 45 20	 movss	 DWORD PTR _fc$[ebp], xmm0
  00278	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0027b	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  0027e	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00283	f3 0f 58 41 34	 addss	 xmm0, DWORD PTR [ecx+52]
  00288	f3 0f 11 45 1c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  0028d	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00292	f3 0f 11 45 bc	 movss	 DWORD PTR $T2[ebp], xmm0

; 830  :     b = fb;

  00297	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fb$[ebp]
  0029c	f3 0f 11 45 c0	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 831  :     c = fc;

  002a1	f3 0f 10 45 20	 movss	 xmm0, DWORD PTR _fc$[ebp]
  002a6	f3 0f 11 45 c4	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 832  :     d = fd;

  002ab	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  002b0	f3 0f 11 45 c8	 movss	 DWORD PTR $T2[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 723  : 	m_plane[4] = D3DXPLANE(mat._14 + mat._12, mat._24 + mat._22, mat._34 + mat._32, mat._44 + mat._42);		// Bottom

  002b5	6a 10		 push	 16			; 00000010H
  002b7	58		 pop	 eax
  002b8	c1 e0 02	 shl	 eax, 2
  002bb	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  002be	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  002c5	8d 75 bc	 lea	 esi, DWORD PTR $T2[ebp]
  002c8	a5		 movsd
  002c9	a5		 movsd
  002ca	a5		 movsd
  002cb	a5		 movsd

; 724  : 	m_plane[5] = D3DXPLANE(mat._14 - mat._12, mat._24 - mat._22, mat._34 - mat._32, mat._44 - mat._42);		// Top

  002cc	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  002cf	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  002d2	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  002d7	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  002dc	f3 0f 11 45 18	 movss	 DWORD PTR _fa$[ebp], xmm0
  002e1	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  002e4	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  002e7	f3 0f 10 40 1c	 movss	 xmm0, DWORD PTR [eax+28]
  002ec	f3 0f 5c 41 14	 subss	 xmm0, DWORD PTR [ecx+20]
  002f1	f3 0f 11 45 14	 movss	 DWORD PTR _fb$[ebp], xmm0
  002f6	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  002f9	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  002fc	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00301	f3 0f 5c 41 24	 subss	 xmm0, DWORD PTR [ecx+36]
  00306	f3 0f 11 45 10	 movss	 DWORD PTR _fc$[ebp], xmm0
  0030b	8b 45 7c	 mov	 eax, DWORD PTR _mat$[ebp]
  0030e	8b 4d 7c	 mov	 ecx, DWORD PTR _mat$[ebp]
  00311	f3 0f 10 40 3c	 movss	 xmm0, DWORD PTR [eax+60]
  00316	f3 0f 5c 41 34	 subss	 xmm0, DWORD PTR [ecx+52]
  0031b	f3 0f 11 45 0c	 movss	 DWORD PTR _fd$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00320	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fa$[ebp]
  00325	f3 0f 11 45 ac	 movss	 DWORD PTR $T1[ebp], xmm0

; 830  :     b = fb;

  0032a	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fb$[ebp]
  0032f	f3 0f 11 45 b0	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 831  :     c = fc;

  00334	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fc$[ebp]
  00339	f3 0f 11 45 b4	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 832  :     d = fd;

  0033e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fd$[ebp]
  00343	f3 0f 11 45 b8	 movss	 DWORD PTR $T1[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 724  : 	m_plane[5] = D3DXPLANE(mat._14 - mat._12, mat._24 - mat._22, mat._34 - mat._32, mat._44 - mat._42);		// Top

  00348	6a 10		 push	 16			; 00000010H
  0034a	58		 pop	 eax
  0034b	6b c0 05	 imul	 eax, eax, 5
  0034e	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00351	8d bc 01 1c 02
	00 00		 lea	 edi, DWORD PTR [ecx+eax+540]
  00358	8d 75 ac	 lea	 esi, DWORD PTR $T1[ebp]
  0035b	a5		 movsd
  0035c	a5		 movsd
  0035d	a5		 movsd
  0035e	a5		 movsd

; 725  : 
; 726  : 	for (int i = 0; i < 6; ++i)

  0035f	83 65 6c 00	 and	 DWORD PTR _i$7[ebp], 0
  00363	eb 07		 jmp	 SHORT $LN4@BuildViewF
$LN2@BuildViewF:
  00365	8b 45 6c	 mov	 eax, DWORD PTR _i$7[ebp]
  00368	40		 inc	 eax
  00369	89 45 6c	 mov	 DWORD PTR _i$7[ebp], eax
$LN4@BuildViewF:
  0036c	83 7d 6c 06	 cmp	 DWORD PTR _i$7[ebp], 6
  00370	7d 29		 jge	 SHORT $LN3@BuildViewF

; 727  : 		D3DXPlaneNormalize(&m_plane[i],&m_plane[i]);

  00372	8b 45 6c	 mov	 eax, DWORD PTR _i$7[ebp]
  00375	c1 e0 04	 shl	 eax, 4
  00378	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0037b	8d 84 01 1c 02
	00 00		 lea	 eax, DWORD PTR [ecx+eax+540]
  00382	50		 push	 eax
  00383	8b 45 6c	 mov	 eax, DWORD PTR _i$7[ebp]
  00386	c1 e0 04	 shl	 eax, 4
  00389	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0038c	8d 84 01 1c 02
	00 00		 lea	 eax, DWORD PTR [ecx+eax+540]
  00393	50		 push	 eax
  00394	e8 00 00 00 00	 call	 _D3DXPlaneNormalize@8
  00399	eb ca		 jmp	 SHORT $LN2@BuildViewF
$LN3@BuildViewF:

; 728  : }

  0039b	5f		 pop	 edi
  0039c	5e		 pop	 esi
  0039d	83 c5 74	 add	 ebp, 116		; 00000074H
  003a0	c9		 leave
  003a1	c2 04 00	 ret	 4
?BuildViewFrustum@CMapOutdoor@@IAEXAAUD3DXMATRIX@@@Z ENDP ; CMapOutdoor::BuildViewFrustum
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@YAXPAUTPatchDrawStruct@CMapOutdoor@@QAU12@AAV?$allocator@UTPatchDrawStruct@CMapOutdoor@@@0@@Z ; std::_Destroy_range<std::allocator<CMapOutdoor::TPatchDrawStruct> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 04	 sar	 eax, 4
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 04	 shl	 eax, 4
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ PROC ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::~vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ENDP ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::~vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::pair<float,long> > >::_Vector_val<std::_Simple_types<std::pair<float,long> > >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::pair<float,long> > >::_Vector_val<std::_Simple_types<std::pair<float,long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<float,long> > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 03	 sar	 eax, 3
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 03	 shl	 eax, 3
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@U?$pair@MJ@std@@@std@@@std@@YAXPAU?$pair@MJ@0@QAU10@AAV?$allocator@U?$pair@MJ@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::pair<float,long> > >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::~vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::~vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_wCoordX$ = 8						; size = 2
_wCoordY$ = 12						; size = 2
_pbyTerrainNum$ = 16					; size = 4
?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z PROC	; CMapOutdoor::GetTerrainNumFromCoord, COMDAT
; _this$ = ecx

; 707  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 708  : 	*pbyTerrainNum = (wCoordY - m_CurCoordinate.m_sTerrainCoordY + LOAD_SIZE_WIDTH) * 3 + 

  00007	0f b7 45 0c	 movzx	 eax, WORD PTR _wCoordY$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	0f bf 49 76	 movsx	 ecx, WORD PTR [ecx+118]
  00012	2b c1		 sub	 eax, ecx
  00014	40		 inc	 eax
  00015	6b c0 03	 imul	 eax, eax, 3
  00018	0f b7 4d 08	 movzx	 ecx, WORD PTR _wCoordX$[ebp]
  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	0f bf 52 74	 movsx	 edx, WORD PTR [edx+116]
  00023	2b ca		 sub	 ecx, edx
  00025	8d 44 08 01	 lea	 eax, DWORD PTR [eax+ecx+1]
  00029	8b 4d 10	 mov	 ecx, DWORD PTR _pbyTerrainNum$[ebp]
  0002c	88 01		 mov	 BYTE PTR [ecx], al

; 709  : 		(wCoordX - m_CurCoordinate.m_sTerrainCoordX + LOAD_SIZE_WIDTH);
; 710  : 	
; 711  : 	if (*pbyTerrainNum < 0 || *pbyTerrainNum > AROUND_AREA_NUM)

  0002e	8b 45 10	 mov	 eax, DWORD PTR _pbyTerrainNum$[ebp]
  00031	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00034	85 c0		 test	 eax, eax
  00036	7c 0b		 jl	 SHORT $LN3@GetTerrain
  00038	8b 45 10	 mov	 eax, DWORD PTR _pbyTerrainNum$[ebp]
  0003b	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0003e	83 f8 09	 cmp	 eax, 9
  00041	7e 04		 jle	 SHORT $LN2@GetTerrain
$LN3@GetTerrain:

; 712  : 		return false;

  00043	32 c0		 xor	 al, al
  00045	eb 02		 jmp	 SHORT $LN1@GetTerrain
$LN2@GetTerrain:

; 713  : 	return true;

  00047	b0 01		 mov	 al, 1
$LN1@GetTerrain:

; 714  : }

  00049	c9		 leave
  0004a	c2 0c 00	 ret	 12			; 0000000cH
?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ENDP	; CMapOutdoor::GetTerrainNumFromCoord
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetTerrainNum@CMapOutdoor@@QAE_NMMPAE@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_wTerrainNumX$ = -24					; size = 2
_wTerrainNumY$ = -20					; size = 2
_iy$ = -16						; size = 4
_ix$ = -12						; size = 4
tv73 = -8						; size = 4
tv69 = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_pbyTerrainNum$ = 16					; size = 4
?GetTerrainNum@CMapOutdoor@@QAE_NMMPAE@Z PROC		; CMapOutdoor::GetTerrainNum, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 	if (fy < 0)

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  00010	76 11		 jbe	 SHORT $LN2@GetTerrain

; 430  : 		fy = -fy;

  00012	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00017	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001e	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
$LN2@GetTerrain:

; 431  : 
; 432  : 	int ix, iy;
; 433  : 	
; 434  : 	PR_FLOAT_TO_INT(fx, ix);

  00023	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00028	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00030	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00036	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0003c	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00044	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0004b	76 0b		 jbe	 SHORT $LN4@GetTerrain
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00052	48		 dec	 eax
  00053	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00056	eb 08		 jmp	 SHORT $LN5@GetTerrain
$LN4@GetTerrain:
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0005d	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN5@GetTerrain:
  00060	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]
  00063	89 45 f4	 mov	 DWORD PTR _ix$[ebp], eax

; 435  : 	PR_FLOAT_TO_INT(fy, iy);

  00066	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0006b	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00073	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00079	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0007f	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00087	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0008e	76 0b		 jbe	 SHORT $LN6@GetTerrain
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00095	48		 dec	 eax
  00096	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  00099	eb 08		 jmp	 SHORT $LN7@GetTerrain
$LN6@GetTerrain:
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000a0	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
$LN7@GetTerrain:
  000a3	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  000a6	89 45 f0	 mov	 DWORD PTR _iy$[ebp], eax

; 436  : 
; 437  : 	WORD wTerrainNumX = ix / (CTerrainImpl::TERRAIN_XSIZE);

  000a9	8b 45 f4	 mov	 eax, DWORD PTR _ix$[ebp]
  000ac	99		 cdq
  000ad	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000b2	f7 f9		 idiv	 ecx
  000b4	66 89 45 e8	 mov	 WORD PTR _wTerrainNumX$[ebp], ax

; 438  : 	WORD wTerrainNumY = iy / (CTerrainImpl::TERRAIN_YSIZE);

  000b8	8b 45 f0	 mov	 eax, DWORD PTR _iy$[ebp]
  000bb	99		 cdq
  000bc	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000c1	f7 f9		 idiv	 ecx
  000c3	66 89 45 ec	 mov	 WORD PTR _wTerrainNumY$[ebp], ax

; 439  : 
; 440  : 	return GetTerrainNumFromCoord(wTerrainNumX, wTerrainNumY, pbyTerrainNum);

  000c7	ff 75 10	 push	 DWORD PTR _pbyTerrainNum$[ebp]
  000ca	ff 75 ec	 push	 DWORD PTR _wTerrainNumY$[ebp]
  000cd	ff 75 e8	 push	 DWORD PTR _wTerrainNumX$[ebp]
  000d0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord

; 441  : }

  000d8	c9		 leave
  000d9	c2 0c 00	 ret	 12			; 0000000cH
?GetTerrainNum@CMapOutdoor@@QAE_NMMPAE@Z ENDP		; CMapOutdoor::GetTerrainNum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetAttr@CMapOutdoor@@QAE_NHHPAE@Z
_TEXT	SEGMENT
_pTerrain$ = -32					; size = 4
_wLocalX$ = -28						; size = 2
_wLocalY$ = -24						; size = 2
_byTerrainNum$ = -20					; size = 1
_wTerrainCoordY$ = -16					; size = 2
_wTerrainCoordX$ = -12					; size = 2
_this$ = -8						; size = 4
_byAttr$ = -1						; size = 1
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_pbyAttr$ = 16						; size = 4
?GetAttr@CMapOutdoor@@QAE_NHHPAE@Z PROC			; CMapOutdoor::GetAttr, COMDAT
; _this$ = ecx

; 1242 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1243 : 	if (iX < 0 || iY < 0 || iX > m_sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE || iY > m_sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE)

  00009	83 7d 08 00	 cmp	 DWORD PTR _iX$[ebp], 0
  0000d	7c 2a		 jl	 SHORT $LN3@GetAttr
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _iY$[ebp], 0
  00013	7c 24		 jl	 SHORT $LN3@GetAttr
  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0001c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00022	39 45 08	 cmp	 DWORD PTR _iX$[ebp], eax
  00025	7f 12		 jg	 SHORT $LN3@GetAttr
  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  0002e	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00034	39 45 0c	 cmp	 DWORD PTR _iY$[ebp], eax
  00037	7e 07		 jle	 SHORT $LN2@GetAttr
$LN3@GetAttr:

; 1244 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	e9 a5 00 00 00	 jmp	 $LN1@GetAttr
$LN2@GetAttr:

; 1245 : 	
; 1246 : 	WORD wTerrainCoordX, wTerrainCoordY;
; 1247 : 	wTerrainCoordX = iX / CTerrainImpl::TERRAIN_XSIZE;

  00040	8b 45 08	 mov	 eax, DWORD PTR _iX$[ebp]
  00043	99		 cdq
  00044	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00049	f7 f9		 idiv	 ecx
  0004b	66 89 45 f4	 mov	 WORD PTR _wTerrainCoordX$[ebp], ax

; 1248 : 	wTerrainCoordY = iY / CTerrainImpl::TERRAIN_YSIZE;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _iY$[ebp]
  00052	99		 cdq
  00053	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00058	f7 f9		 idiv	 ecx
  0005a	66 89 45 f0	 mov	 WORD PTR _wTerrainCoordY$[ebp], ax

; 1249 : 	
; 1250 : 	BYTE byTerrainNum;
; 1251 : 	if (!GetTerrainNumFromCoord(wTerrainCoordX, wTerrainCoordY, &byTerrainNum))

  0005e	8d 45 ec	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  00061	50		 push	 eax
  00062	ff 75 f0	 push	 DWORD PTR _wTerrainCoordY$[ebp]
  00065	ff 75 f4	 push	 DWORD PTR _wTerrainCoordX$[ebp]
  00068	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  00070	0f b6 c0	 movzx	 eax, al
  00073	85 c0		 test	 eax, eax
  00075	75 04		 jne	 SHORT $LN4@GetAttr

; 1252 : 		return false;

  00077	32 c0		 xor	 al, al
  00079	eb 6a		 jmp	 SHORT $LN1@GetAttr
$LN4@GetAttr:

; 1253 : 	CTerrain * pTerrain;
; 1254 : 	if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  0007b	8d 45 e0	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0007e	50		 push	 eax
  0007f	ff 75 ec	 push	 DWORD PTR _byTerrainNum$[ebp]
  00082	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN5@GetAttr

; 1255 : 		return false;

  0008e	32 c0		 xor	 al, al
  00090	eb 53		 jmp	 SHORT $LN1@GetAttr
$LN5@GetAttr:

; 1256 : 
; 1257 : 	WORD wLocalX, wLocalY;
; 1258 : 	wLocalX = (WORD) (iX - wTerrainCoordX * CTerrainImpl::TERRAIN_XSIZE) / (CTerrainImpl::HALF_CELLSCALE);

  00092	0f b7 45 f4	 movzx	 eax, WORD PTR _wTerrainCoordX$[ebp]
  00096	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _iX$[ebp]
  0009f	2b c8		 sub	 ecx, eax
  000a1	0f b7 c1	 movzx	 eax, cx
  000a4	99		 cdq
  000a5	6a 64		 push	 100			; 00000064H
  000a7	59		 pop	 ecx
  000a8	f7 f9		 idiv	 ecx
  000aa	66 89 45 e4	 mov	 WORD PTR _wLocalX$[ebp], ax

; 1259 : 	wLocalY = (WORD) (iY - wTerrainCoordY * CTerrainImpl::TERRAIN_YSIZE) / (CTerrainImpl::HALF_CELLSCALE);

  000ae	0f b7 45 f0	 movzx	 eax, WORD PTR _wTerrainCoordY$[ebp]
  000b2	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  000b8	8b 4d 0c	 mov	 ecx, DWORD PTR _iY$[ebp]
  000bb	2b c8		 sub	 ecx, eax
  000bd	0f b7 c1	 movzx	 eax, cx
  000c0	99		 cdq
  000c1	6a 64		 push	 100			; 00000064H
  000c3	59		 pop	 ecx
  000c4	f7 f9		 idiv	 ecx
  000c6	66 89 45 e8	 mov	 WORD PTR _wLocalY$[ebp], ax

; 1260 : 
; 1261 : 	BYTE byAttr = pTerrain->GetAttr(wLocalX, wLocalY);

  000ca	ff 75 e8	 push	 DWORD PTR _wLocalY$[ebp]
  000cd	ff 75 e4	 push	 DWORD PTR _wLocalX$[ebp]
  000d0	8b 4d e0	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  000d3	e8 00 00 00 00	 call	 ?GetAttr@CTerrain@@QAEEGG@Z ; CTerrain::GetAttr
  000d8	88 45 ff	 mov	 BYTE PTR _byAttr$[ebp], al

; 1262 : 
; 1263 : 	*pbyAttr = byAttr;

  000db	8b 45 10	 mov	 eax, DWORD PTR _pbyAttr$[ebp]
  000de	8a 4d ff	 mov	 cl, BYTE PTR _byAttr$[ebp]
  000e1	88 08		 mov	 BYTE PTR [eax], cl

; 1264 : 
; 1265 : 	return true;

  000e3	b0 01		 mov	 al, 1
$LN1@GetAttr:

; 1266 : }

  000e5	c9		 leave
  000e6	c2 0c 00	 ret	 12			; 0000000cH
?GetAttr@CMapOutdoor@@QAE_NHHPAE@Z ENDP			; CMapOutdoor::GetAttr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?isAttrOn@CMapOutdoor@@QAE_NHHE@Z
_TEXT	SEGMENT
_pTerrain$ = -28					; size = 4
_wLocalX$ = -24						; size = 2
_wLocalY$ = -20						; size = 2
_byTerrainNum$ = -16					; size = 1
_wTerrainCoordY$ = -12					; size = 2
_wTerrainCoordX$ = -8					; size = 2
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_byAttr$ = 16						; size = 1
?isAttrOn@CMapOutdoor@@QAE_NHHE@Z PROC			; CMapOutdoor::isAttrOn, COMDAT
; _this$ = ecx

; 1219 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1220 : 	if (iX < 0 || iY < 0 || iX > m_sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE || iY > m_sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE)

  00009	83 7d 08 00	 cmp	 DWORD PTR _iX$[ebp], 0
  0000d	7c 2a		 jl	 SHORT $LN3@isAttrOn
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _iY$[ebp], 0
  00013	7c 24		 jl	 SHORT $LN3@isAttrOn
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0001c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00022	39 45 08	 cmp	 DWORD PTR _iX$[ebp], eax
  00025	7f 12		 jg	 SHORT $LN3@isAttrOn
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  0002e	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00034	39 45 0c	 cmp	 DWORD PTR _iY$[ebp], eax
  00037	7e 07		 jle	 SHORT $LN2@isAttrOn
$LN3@isAttrOn:

; 1221 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	e9 99 00 00 00	 jmp	 $LN1@isAttrOn
$LN2@isAttrOn:

; 1222 : 
; 1223 : 	WORD wTerrainCoordX, wTerrainCoordY;
; 1224 : 	wTerrainCoordX = iX / CTerrainImpl::TERRAIN_XSIZE;

  00040	8b 45 08	 mov	 eax, DWORD PTR _iX$[ebp]
  00043	99		 cdq
  00044	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00049	f7 f9		 idiv	 ecx
  0004b	66 89 45 f8	 mov	 WORD PTR _wTerrainCoordX$[ebp], ax

; 1225 : 	wTerrainCoordY = iY / CTerrainImpl::TERRAIN_YSIZE;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _iY$[ebp]
  00052	99		 cdq
  00053	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00058	f7 f9		 idiv	 ecx
  0005a	66 89 45 f4	 mov	 WORD PTR _wTerrainCoordY$[ebp], ax

; 1226 : 
; 1227 : 	BYTE byTerrainNum;
; 1228 : 	if (!GetTerrainNumFromCoord(wTerrainCoordX, wTerrainCoordY, &byTerrainNum))

  0005e	8d 45 f0	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  00061	50		 push	 eax
  00062	ff 75 f4	 push	 DWORD PTR _wTerrainCoordY$[ebp]
  00065	ff 75 f8	 push	 DWORD PTR _wTerrainCoordX$[ebp]
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  00070	0f b6 c0	 movzx	 eax, al
  00073	85 c0		 test	 eax, eax
  00075	75 04		 jne	 SHORT $LN4@isAttrOn

; 1229 : 		return false;

  00077	32 c0		 xor	 al, al
  00079	eb 5e		 jmp	 SHORT $LN1@isAttrOn
$LN4@isAttrOn:

; 1230 : 	CTerrain * pTerrain;
; 1231 : 	if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  0007b	8d 45 e4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0007e	50		 push	 eax
  0007f	ff 75 f0	 push	 DWORD PTR _byTerrainNum$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN5@isAttrOn

; 1232 : 		return false;

  0008e	32 c0		 xor	 al, al
  00090	eb 47		 jmp	 SHORT $LN1@isAttrOn
$LN5@isAttrOn:

; 1233 : 
; 1234 : 	WORD wLocalX, wLocalY;
; 1235 : 	wLocalX = (iX - wTerrainCoordX * CTerrainImpl::TERRAIN_XSIZE) / (CTerrainImpl::HALF_CELLSCALE);

  00092	0f b7 45 f8	 movzx	 eax, WORD PTR _wTerrainCoordX$[ebp]
  00096	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _iX$[ebp]
  0009f	2b c8		 sub	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	99		 cdq
  000a4	6a 64		 push	 100			; 00000064H
  000a6	59		 pop	 ecx
  000a7	f7 f9		 idiv	 ecx
  000a9	66 89 45 e8	 mov	 WORD PTR _wLocalX$[ebp], ax

; 1236 : 	wLocalY = (iY - wTerrainCoordY * CTerrainImpl::TERRAIN_YSIZE) / (CTerrainImpl::HALF_CELLSCALE);

  000ad	0f b7 45 f4	 movzx	 eax, WORD PTR _wTerrainCoordY$[ebp]
  000b1	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  000b7	8b 4d 0c	 mov	 ecx, DWORD PTR _iY$[ebp]
  000ba	2b c8		 sub	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	99		 cdq
  000bf	6a 64		 push	 100			; 00000064H
  000c1	59		 pop	 ecx
  000c2	f7 f9		 idiv	 ecx
  000c4	66 89 45 ec	 mov	 WORD PTR _wLocalY$[ebp], ax

; 1237 : 	
; 1238 : 	return pTerrain->isAttrOn(wLocalX, wLocalY, byAttr);

  000c8	ff 75 10	 push	 DWORD PTR _byAttr$[ebp]
  000cb	ff 75 ec	 push	 DWORD PTR _wLocalY$[ebp]
  000ce	ff 75 e8	 push	 DWORD PTR _wLocalX$[ebp]
  000d1	8b 4d e4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  000d4	e8 00 00 00 00	 call	 ?isAttrOn@CTerrain@@QAE_NGGE@Z ; CTerrain::isAttrOn
$LN1@isAttrOn:

; 1239 : }

  000d9	c9		 leave
  000da	c2 0c 00	 ret	 12			; 0000000cH
?isAttrOn@CMapOutdoor@@QAE_NHHE@Z ENDP			; CMapOutdoor::isAttrOn
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetAttr@CMapOutdoor@@QAE_NMMPAE@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iX$ = -16						; size = 4
_iY$ = -12						; size = 4
tv71 = -8						; size = 4
tv67 = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_pbyAttr$ = 16						; size = 4
?GetAttr@CMapOutdoor@@QAE_NMMPAE@Z PROC			; CMapOutdoor::GetAttr, COMDAT
; _this$ = ecx

; 1210 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1211 : 	int iX, iY;
; 1212 : 	PR_FLOAT_TO_INT(fX, iX);

  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0000e	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00016	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0001c	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00022	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0002a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00031	76 0b		 jbe	 SHORT $LN3@GetAttr
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00038	48		 dec	 eax
  00039	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  0003c	eb 08		 jmp	 SHORT $LN4@GetAttr
$LN3@GetAttr:
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00043	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
$LN4@GetAttr:
  00046	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00049	89 45 f0	 mov	 DWORD PTR _iX$[ebp], eax

; 1213 : 	PR_FLOAT_TO_INT(fY, iY);

  0004c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00051	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00059	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0005f	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00065	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0006d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00074	76 0b		 jbe	 SHORT $LN5@GetAttr
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0007b	48		 dec	 eax
  0007c	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  0007f	eb 08		 jmp	 SHORT $LN6@GetAttr
$LN5@GetAttr:
  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00086	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
$LN6@GetAttr:
  00089	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  0008c	89 45 f4	 mov	 DWORD PTR _iY$[ebp], eax

; 1214 : 
; 1215 : 	return GetAttr(iX, iY, pbyAttr);

  0008f	ff 75 10	 push	 DWORD PTR _pbyAttr$[ebp]
  00092	ff 75 f4	 push	 DWORD PTR _iY$[ebp]
  00095	ff 75 f0	 push	 DWORD PTR _iX$[ebp]
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?GetAttr@CMapOutdoor@@QAE_NHHPAE@Z ; CMapOutdoor::GetAttr

; 1216 : }

  000a0	c9		 leave
  000a1	c2 0c 00	 ret	 12			; 0000000cH
?GetAttr@CMapOutdoor@@QAE_NMMPAE@Z ENDP			; CMapOutdoor::GetAttr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?isAttrOn@CMapOutdoor@@QAE_NMME@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_iX$ = -16						; size = 4
_iY$ = -12						; size = 4
tv71 = -8						; size = 4
tv67 = -4						; size = 4
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_byAttr$ = 16						; size = 1
?isAttrOn@CMapOutdoor@@QAE_NMME@Z PROC			; CMapOutdoor::isAttrOn, COMDAT
; _this$ = ecx

; 1201 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1202 : 	int iX, iY;
; 1203 : 	PR_FLOAT_TO_INT(fX, iX);

  00009	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fX$[ebp]
  0000e	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00016	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0001c	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00022	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0002a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00031	76 0b		 jbe	 SHORT $LN3@isAttrOn
  00033	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00038	48		 dec	 eax
  00039	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
  0003c	eb 08		 jmp	 SHORT $LN4@isAttrOn
$LN3@isAttrOn:
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00043	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
$LN4@isAttrOn:
  00046	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00049	89 45 f0	 mov	 DWORD PTR _iX$[ebp], eax

; 1204 : 	PR_FLOAT_TO_INT(fY, iY);

  0004c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fY$[ebp]
  00051	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00059	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0005f	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00065	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0006d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00074	76 0b		 jbe	 SHORT $LN5@isAttrOn
  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0007b	48		 dec	 eax
  0007c	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  0007f	eb 08		 jmp	 SHORT $LN6@isAttrOn
$LN5@isAttrOn:
  00081	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00086	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
$LN6@isAttrOn:
  00089	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  0008c	89 45 f4	 mov	 DWORD PTR _iY$[ebp], eax

; 1205 : 
; 1206 : 	return isAttrOn(iX, iY, byAttr);

  0008f	ff 75 10	 push	 DWORD PTR _byAttr$[ebp]
  00092	ff 75 f4	 push	 DWORD PTR _iY$[ebp]
  00095	ff 75 f0	 push	 DWORD PTR _iX$[ebp]
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?isAttrOn@CMapOutdoor@@QAE_NHHE@Z ; CMapOutdoor::isAttrOn

; 1207 : }

  000a0	c9		 leave
  000a1	c2 0c 00	 ret	 12			; 0000000cH
?isAttrOn@CMapOutdoor@@QAE_NMME@Z ENDP			; CMapOutdoor::isAttrOn
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetBrushColor@CMapOutdoor@@QAE_NMMPAM0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bSuccess$ = -1						; size = 1
_fX$ = 8						; size = 4
_fY$ = 12						; size = 4
_pLowColor$ = 16					; size = 4
_pHighColor$ = 20					; size = 4
?GetBrushColor@CMapOutdoor@@QAE_NMMPAM0@Z PROC		; CMapOutdoor::GetBrushColor, COMDAT
; _this$ = ecx

; 976  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 	bool bSuccess = false;

  00008	c6 45 ff 00	 mov	 BYTE PTR _bSuccess$[ebp], 0

; 978  : 	
; 979  : //	float fU, fV;
; 980  : //	
; 981  : //	GetOneToOneMappingCoordinates(fX, fY, fU, fV);
; 982  : //	
; 983  : //	if (fU >= 0.0f && fU <= 1.0f && fV >= 0.0f && fV <= 1.0f)
; 984  : //	{
; 985  : //		int nImageCol = (m_cBrushMap.GetWidth() - 1) * fU;
; 986  : //		int nImageRow = (m_cBrushMap.GetHeight() - 1) * fV;
; 987  : //		
; 988  : //		// low
; 989  : //		BYTE* pPixel = m_cBrushMap.GetPixel(nImageCol, nImageRow);
; 990  : //		pLowColor[0] = (pPixel[0] / 255.0f);
; 991  : //		pLowColor[1] = (pPixel[1] / 255.0f);
; 992  : //		pLowColor[2] = (pPixel[2] / 255.0f);
; 993  : //		pLowColor[3] = (pPixel[3] / 255.0f);
; 994  : //		
; 995  : //		// high
; 996  : //		pPixel = m_cBrushMap2.GetPixel(nImageCol, nImageRow);
; 997  : //		pHighColor[0] = (pPixel[0] / 255.0f);
; 998  : //		pHighColor[1] = (pPixel[1] / 255.0f);
; 999  : //		pHighColor[2] = (pPixel[2] / 255.0f);
; 1000 : //		pHighColor[3] = (pPixel[3] / 255.0f);
; 1001 : //		
; 1002 : //		bSuccess = true;
; 1003 : //	}
; 1004 : 	pLowColor[0] = (1.0f);

  0000c	6a 04		 push	 4
  0000e	58		 pop	 eax
  0000f	6b c0 00	 imul	 eax, eax, 0
  00012	8b 4d 10	 mov	 ecx, DWORD PTR _pLowColor$[ebp]
  00015	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001d	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1005 : 	pLowColor[1] = (1.0f);

  00022	6a 04		 push	 4
  00024	58		 pop	 eax
  00025	c1 e0 00	 shl	 eax, 0
  00028	8b 4d 10	 mov	 ecx, DWORD PTR _pLowColor$[ebp]
  0002b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00033	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1006 : 	pLowColor[2] = (1.0f);

  00038	6a 04		 push	 4
  0003a	58		 pop	 eax
  0003b	d1 e0		 shl	 eax, 1
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR _pLowColor$[ebp]
  00040	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00048	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1007 : 	pLowColor[3] = (1.0f);

  0004d	6a 04		 push	 4
  0004f	58		 pop	 eax
  00050	6b c0 03	 imul	 eax, eax, 3
  00053	8b 4d 10	 mov	 ecx, DWORD PTR _pLowColor$[ebp]
  00056	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0005e	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1008 : 	pHighColor[0] = (1.0f);

  00063	6a 04		 push	 4
  00065	58		 pop	 eax
  00066	6b c0 00	 imul	 eax, eax, 0
  00069	8b 4d 14	 mov	 ecx, DWORD PTR _pHighColor$[ebp]
  0006c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00074	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1009 : 	pHighColor[1] = (1.0f);

  00079	6a 04		 push	 4
  0007b	58		 pop	 eax
  0007c	c1 e0 00	 shl	 eax, 0
  0007f	8b 4d 14	 mov	 ecx, DWORD PTR _pHighColor$[ebp]
  00082	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0008a	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1010 : 	pHighColor[2] = (1.0f);

  0008f	6a 04		 push	 4
  00091	58		 pop	 eax
  00092	d1 e0		 shl	 eax, 1
  00094	8b 4d 14	 mov	 ecx, DWORD PTR _pHighColor$[ebp]
  00097	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0009f	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1011 : 	pHighColor[3] = (1.0f);

  000a4	6a 04		 push	 4
  000a6	58		 pop	 eax
  000a7	6b c0 03	 imul	 eax, eax, 3
  000aa	8b 4d 14	 mov	 ecx, DWORD PTR _pHighColor$[ebp]
  000ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000b5	f3 0f 11 04 01	 movss	 DWORD PTR [ecx+eax], xmm0

; 1012 : 	
; 1013 : 	return bSuccess;

  000ba	8a 45 ff	 mov	 al, BYTE PTR _bSuccess$[ebp]

; 1014 : }

  000bd	c9		 leave
  000be	c2 10 00	 ret	 16			; 00000010H
?GetBrushColor@CMapOutdoor@@QAE_NMMPAM0@Z ENDP		; CMapOutdoor::GetBrushColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetHeight@CMapOutdoor@@QAEMPAM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pPos$ = 8						; size = 4
?GetHeight@CMapOutdoor@@QAEMPAM@Z PROC			; CMapOutdoor::GetHeight, COMDAT
; _this$ = ecx

; 970  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 971  : 	pPos[2] = GetHeight(pPos[0], pPos[1]);

  00007	6a 04		 push	 4
  00009	58		 pop	 eax
  0000a	c1 e0 00	 shl	 eax, 0
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00010	51		 push	 ecx
  00011	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  00016	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 00	 imul	 eax, eax, 0
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00024	51		 push	 ecx
  00025	f3 0f 10 04 01	 movss	 xmm0, DWORD PTR [ecx+eax]
  0002a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	ff 50 1c	 call	 DWORD PTR [eax+28]
  0003a	6a 04		 push	 4
  0003c	58		 pop	 eax
  0003d	d1 e0		 shl	 eax, 1
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00042	d9 1c 01	 fstp	 DWORD PTR [ecx+eax]

; 972  : 	return pPos[2];

  00045	6a 04		 push	 4
  00047	58		 pop	 eax
  00048	d1 e0		 shl	 eax, 1
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0004d	d9 04 01	 fld	 DWORD PTR [ecx+eax]

; 973  : }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?GetHeight@CMapOutdoor@@QAEMPAM@Z ENDP			; CMapOutdoor::GetHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_byAreaNum$ = 8					; size = 1
_ppArea$ = 12						; size = 4
?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z PROC	; CMapOutdoor::GetAreaPointer, COMDAT
; _this$ = ecx

; 1019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1020 : 	if (c_byAreaNum >= AROUND_AREA_NUM)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byAreaNum$[ebp]
  0000b	83 f8 09	 cmp	 eax, 9
  0000e	7c 0a		 jl	 SHORT $LN2@GetAreaPoi

; 1021 : 	{
; 1022 : 		*ppArea = NULL;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _ppArea$[ebp]
  00013	83 20 00	 and	 DWORD PTR [eax], 0

; 1023 : 		return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	eb 31		 jmp	 SHORT $LN1@GetAreaPoi
$LN2@GetAreaPoi:

; 1024 : 	}
; 1025 : 
; 1026 : 	if (NULL == m_pArea[c_byAreaNum])

  0001a	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byAreaNum$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 bc 81 e0 00
	00 00 00	 cmp	 DWORD PTR [ecx+eax*4+224], 0
  00029	75 0a		 jne	 SHORT $LN3@GetAreaPoi

; 1027 : 	{
; 1028 : 		*ppArea = NULL;

  0002b	8b 45 0c	 mov	 eax, DWORD PTR _ppArea$[ebp]
  0002e	83 20 00	 and	 DWORD PTR [eax], 0

; 1029 : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	eb 16		 jmp	 SHORT $LN1@GetAreaPoi
$LN3@GetAreaPoi:

; 1030 : 	}
; 1031 : 
; 1032 : 	*ppArea = m_pArea[c_byAreaNum];

  00035	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byAreaNum$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _ppArea$[ebp]
  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 84 82 e0 00
	00 00		 mov	 eax, DWORD PTR [edx+eax*4+224]
  00046	89 01		 mov	 DWORD PTR [ecx], eax

; 1033 : 	return TRUE;

  00048	33 c0		 xor	 eax, eax
  0004a	40		 inc	 eax
$LN1@GetAreaPoi:

; 1034 : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?GetAreaPointer@CMapOutdoor@@QAEHEPAPAVCArea@@@Z ENDP	; CMapOutdoor::GetAreaPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
_fSubcellY$ = -64					; size = 4
_fSubcellX$ = -60					; size = 4
_fCellY$ = -56						; size = 4
_fCellX$ = -52						; size = 4
_iy$ = -48						; size = 4
_ix$ = -44						; size = 4
tv139 = -40						; size = 4
tv134 = -36						; size = 4
_fRatioooscale$ = -32					; size = 4
tv95 = -28						; size = 4
tv91 = -24						; size = 4
tv73 = -20						; size = 4
tv69 = -16						; size = 4
_fooscale$ = -12					; size = 4
_maxy$ = -8						; size = 4
_maxx$ = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
_iCellX$ = 16						; size = 4
_iCellY$ = 20						; size = 4
_pucSubCellX$ = 24					; size = 4
_pucSubCellY$ = 28					; size = 4
_pwTerrainNumX$ = 32					; size = 4
_pwTerrainNumY$ = 36					; size = 4
?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z PROC ; CMapOutdoor::ConvertToMapCoords, COMDAT
; _this$ = ecx

; 1547 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 1548 : 	if ( fy < 0 )

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  00010	76 11		 jbe	 SHORT $LN10@ConvertToM

; 1549 : 		fy = -fy;

  00012	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00017	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001e	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
$LN10@ConvertToM:

; 1550 : 	
; 1551 : 	int ix, iy;
; 1552 : 	PR_FLOAT_TO_INT(fx, ix);

  00023	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00028	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00030	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00036	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0003c	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00044	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0004b	76 0b		 jbe	 SHORT $LN12@ConvertToM
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00052	48		 dec	 eax
  00053	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00056	eb 08		 jmp	 SHORT $LN13@ConvertToM
$LN12@ConvertToM:
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0005d	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
$LN13@ConvertToM:
  00060	8b 45 f0	 mov	 eax, DWORD PTR tv69[ebp]
  00063	89 45 d4	 mov	 DWORD PTR _ix$[ebp], eax

; 1553 : 	PR_FLOAT_TO_INT(fy, iy);

  00066	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0006b	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00073	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00079	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0007f	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00087	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0008e	76 0b		 jbe	 SHORT $LN14@ConvertToM
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00095	48		 dec	 eax
  00096	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  00099	eb 08		 jmp	 SHORT $LN15@ConvertToM
$LN14@ConvertToM:
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000a0	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
$LN15@ConvertToM:
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]
  000a6	89 45 d0	 mov	 DWORD PTR _iy$[ebp], eax

; 1554 : 	
; 1555 : 	*pwTerrainNumX = ix / (CTerrainImpl::TERRAIN_XSIZE);

  000a9	8b 45 d4	 mov	 eax, DWORD PTR _ix$[ebp]
  000ac	99		 cdq
  000ad	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000b2	f7 f9		 idiv	 ecx
  000b4	8b 4d 20	 mov	 ecx, DWORD PTR _pwTerrainNumX$[ebp]
  000b7	66 89 01	 mov	 WORD PTR [ecx], ax

; 1556 : 	*pwTerrainNumY = iy / (CTerrainImpl::TERRAIN_YSIZE);

  000ba	8b 45 d0	 mov	 eax, DWORD PTR _iy$[ebp]
  000bd	99		 cdq
  000be	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000c3	f7 f9		 idiv	 ecx
  000c5	8b 4d 24	 mov	 ecx, DWORD PTR _pwTerrainNumY$[ebp]
  000c8	66 89 01	 mov	 WORD PTR [ecx], ax

; 1557 : 	
; 1558 : 	float maxx = (float) CTerrainImpl::TERRAIN_XSIZE;

  000cb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c80000
  000d3	f3 0f 11 45 fc	 movss	 DWORD PTR _maxx$[ebp], xmm0

; 1559 : 	float maxy = (float) CTerrainImpl::TERRAIN_YSIZE;

  000d8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c80000
  000e0	f3 0f 11 45 f8	 movss	 DWORD PTR _maxy$[ebp], xmm0
$LN2@ConvertToM:

; 1560 : 	
; 1561 : 	while (fx < 0)

  000e5	0f 57 c0	 xorps	 xmm0, xmm0
  000e8	0f 2f 45 08	 comiss	 xmm0, DWORD PTR _fx$[ebp]
  000ec	76 11		 jbe	 SHORT $LN3@ConvertToM

; 1562 : 		fx += maxx;

  000ee	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000f3	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _maxx$[ebp]
  000f8	f3 0f 11 45 08	 movss	 DWORD PTR _fx$[ebp], xmm0
  000fd	eb e6		 jmp	 SHORT $LN2@ConvertToM
$LN3@ConvertToM:

; 1563 : 	
; 1564 : 	while (fy < 0)

  000ff	0f 57 c0	 xorps	 xmm0, xmm0
  00102	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  00106	76 11		 jbe	 SHORT $LN5@ConvertToM

; 1565 : 		fy += maxy;

  00108	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0010d	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR _maxy$[ebp]
  00112	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
  00117	eb e6		 jmp	 SHORT $LN3@ConvertToM
$LN5@ConvertToM:

; 1566 : 	
; 1567 : 	while (fx >= maxx)

  00119	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0011e	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _maxx$[ebp]
  00122	72 11		 jb	 SHORT $LN7@ConvertToM

; 1568 : 		fx -= maxx;

  00124	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00129	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _maxx$[ebp]
  0012e	f3 0f 11 45 08	 movss	 DWORD PTR _fx$[ebp], xmm0
  00133	eb e4		 jmp	 SHORT $LN5@ConvertToM
$LN7@ConvertToM:

; 1569 : 	
; 1570 : 	while (fy >= maxy)

  00135	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0013a	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _maxy$[ebp]
  0013e	72 11		 jb	 SHORT $LN9@ConvertToM

; 1571 : 		fy -= maxy;

  00140	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00145	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _maxy$[ebp]
  0014a	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
  0014f	eb e4		 jmp	 SHORT $LN7@ConvertToM
$LN9@ConvertToM:

; 1572 : 	
; 1573 : 	float fooscale = 1.0f / (float)(CTerrainImpl::HALF_CELLSCALE);

  00151	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3c23d70a
  00159	f3 0f 11 45 f4	 movss	 DWORD PTR _fooscale$[ebp], xmm0

; 1574 : 	
; 1575 : 	float fCellX, fCellY;
; 1576 : 	
; 1577 : 	fCellX = fx * fooscale;

  0015e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00163	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _fooscale$[ebp]
  00168	f3 0f 11 45 cc	 movss	 DWORD PTR _fCellX$[ebp], xmm0

; 1578 : 	fCellY = fy * fooscale;

  0016d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00172	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _fooscale$[ebp]
  00177	f3 0f 11 45 c8	 movss	 DWORD PTR _fCellY$[ebp], xmm0

; 1579 : 	
; 1580 : 	PR_FLOAT_TO_INT(fCellX, *iCellX);

  0017c	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fCellX$[ebp]
  00181	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00189	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0018f	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00195	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0019d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  001a4	76 0b		 jbe	 SHORT $LN16@ConvertToM
  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001ab	48		 dec	 eax
  001ac	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  001af	eb 08		 jmp	 SHORT $LN17@ConvertToM
$LN16@ConvertToM:
  001b1	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001b6	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
$LN17@ConvertToM:
  001b9	8b 45 10	 mov	 eax, DWORD PTR _iCellX$[ebp]
  001bc	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  001bf	89 08		 mov	 DWORD PTR [eax], ecx

; 1581 : 	PR_FLOAT_TO_INT(fCellY, *iCellY);

  001c1	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fCellY$[ebp]
  001c6	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  001ce	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  001d4	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  001da	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001e2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  001e9	76 0b		 jbe	 SHORT $LN18@ConvertToM
  001eb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001f0	48		 dec	 eax
  001f1	89 45 e4	 mov	 DWORD PTR tv95[ebp], eax
  001f4	eb 08		 jmp	 SHORT $LN19@ConvertToM
$LN18@ConvertToM:
  001f6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001fb	89 45 e4	 mov	 DWORD PTR tv95[ebp], eax
$LN19@ConvertToM:
  001fe	8b 45 14	 mov	 eax, DWORD PTR _iCellY$[ebp]
  00201	8b 4d e4	 mov	 ecx, DWORD PTR tv95[ebp]
  00204	89 08		 mov	 DWORD PTR [eax], ecx

; 1582 : 	
; 1583 : 	float fRatioooscale = ((float)CTerrainImpl::HEIGHT_TILE_XRATIO) * fooscale;

  00206	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0020e	f3 0f 59 45 f4	 mulss	 xmm0, DWORD PTR _fooscale$[ebp]
  00213	f3 0f 11 45 e0	 movss	 DWORD PTR _fRatioooscale$[ebp], xmm0

; 1584 : 	
; 1585 : 	float fSubcellX, fSubcellY;
; 1586 : 	fSubcellX = fx * fRatioooscale;

  00218	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0021d	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _fRatioooscale$[ebp]
  00222	f3 0f 11 45 c4	 movss	 DWORD PTR _fSubcellX$[ebp], xmm0

; 1587 : 	fSubcellY = fy * fRatioooscale;

  00227	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0022c	f3 0f 59 45 e0	 mulss	 xmm0, DWORD PTR _fRatioooscale$[ebp]
  00231	f3 0f 11 45 c0	 movss	 DWORD PTR _fSubcellY$[ebp], xmm0

; 1588 : 	
; 1589 : 	PR_FLOAT_TO_INT(fSubcellX, *pucSubCellX);

  00236	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fSubcellX$[ebp]
  0023b	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00243	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00249	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0024f	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00257	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0025e	76 0b		 jbe	 SHORT $LN20@ConvertToM
  00260	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00265	48		 dec	 eax
  00266	89 45 dc	 mov	 DWORD PTR tv134[ebp], eax
  00269	eb 08		 jmp	 SHORT $LN21@ConvertToM
$LN20@ConvertToM:
  0026b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00270	89 45 dc	 mov	 DWORD PTR tv134[ebp], eax
$LN21@ConvertToM:
  00273	8b 45 18	 mov	 eax, DWORD PTR _pucSubCellX$[ebp]
  00276	8a 4d dc	 mov	 cl, BYTE PTR tv134[ebp]
  00279	88 08		 mov	 BYTE PTR [eax], cl

; 1590 : 	PR_FLOAT_TO_INT(fSubcellY, *pucSubCellY);

  0027b	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fSubcellY$[ebp]
  00280	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00288	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  0028e	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00294	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0029c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  002a3	76 0b		 jbe	 SHORT $LN22@ConvertToM
  002a5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  002aa	48		 dec	 eax
  002ab	89 45 d8	 mov	 DWORD PTR tv139[ebp], eax
  002ae	eb 08		 jmp	 SHORT $LN23@ConvertToM
$LN22@ConvertToM:
  002b0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  002b5	89 45 d8	 mov	 DWORD PTR tv139[ebp], eax
$LN23@ConvertToM:
  002b8	8b 45 1c	 mov	 eax, DWORD PTR _pucSubCellY$[ebp]
  002bb	8a 4d d8	 mov	 cl, BYTE PTR tv139[ebp]
  002be	88 08		 mov	 BYTE PTR [eax], cl

; 1591 : 	*pucSubCellX = (*pucSubCellX) % CTerrainImpl::HEIGHT_TILE_XRATIO;

  002c0	8b 45 18	 mov	 eax, DWORD PTR _pucSubCellX$[ebp]
  002c3	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  002c6	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002cb	79 05		 jns	 SHORT $LN24@ConvertToM
  002cd	48		 dec	 eax
  002ce	83 c8 fe	 or	 eax, -2			; fffffffeH
  002d1	40		 inc	 eax
$LN24@ConvertToM:
  002d2	8b 4d 18	 mov	 ecx, DWORD PTR _pucSubCellX$[ebp]
  002d5	88 01		 mov	 BYTE PTR [ecx], al

; 1592 : 	*pucSubCellY = (*pucSubCellY) % CTerrainImpl::HEIGHT_TILE_YRATIO;

  002d7	8b 45 1c	 mov	 eax, DWORD PTR _pucSubCellY$[ebp]
  002da	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  002dd	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  002e2	79 05		 jns	 SHORT $LN25@ConvertToM
  002e4	48		 dec	 eax
  002e5	83 c8 fe	 or	 eax, -2			; fffffffeH
  002e8	40		 inc	 eax
$LN25@ConvertToM:
  002e9	8b 4d 1c	 mov	 ecx, DWORD PTR _pucSubCellY$[ebp]
  002ec	88 01		 mov	 BYTE PTR [ecx], al

; 1593 : }

  002ee	c9		 leave
  002ef	c2 20 00	 ret	 32			; 00000020H
?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z ENDP ; CMapOutdoor::ConvertToMapCoords
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?DestroyArea@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?DestroyArea@CMapOutdoor@@MAEXXZ PROC			; CMapOutdoor::DestroyArea, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 400  : 	m_AreaVector.clear();

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 4c 09 00
	00		 add	 ecx, 2380		; 0000094cH
  00011	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 401  : 	m_AreaDeleteVector.clear();

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 58 09 00
	00		 add	 ecx, 2392		; 00000958H
  0001f	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 402  : 
; 403  : 	CArea::ms_kPool.FreeAll();

  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CArea@@2V?$CDynamicPool@VCArea@@@@A ; CArea::ms_kPool
  00029	e8 00 00 00 00	 call	 ?FreeAll@?$CDynamicPool@VCArea@@@@QAEXXZ ; CDynamicPool<CArea>::FreeAll

; 404  : 	
; 405  : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  0002e	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN4@DestroyAre
$LN2@DestroyAre:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	40		 inc	 eax
  00038	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DestroyAre:
  0003b	83 7d fc 09	 cmp	 DWORD PTR _i$1[ebp], 9
  0003f	7d 10		 jge	 SHORT $LN1@DestroyAre

; 406  : 		m_pArea[i] = NULL;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 a4 81 e0 00
	00 00 00	 and	 DWORD PTR [ecx+eax*4+224], 0
  0004f	eb e3		 jmp	 SHORT $LN2@DestroyAre
$LN1@DestroyAre:

; 407  : }

  00051	c9		 leave
  00052	c3		 ret	 0
?DestroyArea@CMapOutdoor@@MAEXXZ ENDP			; CMapOutdoor::DestroyArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetNormal@CMapOutdoor@@QAE_NHHPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_pTerrain$ = -20					; size = 4
_byTerrainNum$ = -16					; size = 1
_usCoordX$ = -12					; size = 2
_usCoordY$ = -8						; size = 2
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_pv3Normal$ = 16					; size = 4
?GetNormal@CMapOutdoor@@QAE_NHHPAUD3DXVECTOR3@@@Z PROC	; CMapOutdoor::GetNormal, COMDAT
; _this$ = ecx

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 903  : 	if (ix <= 0)

  00009	83 7d 08 00	 cmp	 DWORD PTR _ix$[ebp], 0
  0000d	7f 06		 jg	 SHORT $LN6@GetNormal

; 904  : 		ix = 0;

  0000f	83 65 08 00	 and	 DWORD PTR _ix$[ebp], 0
  00013	eb 22		 jmp	 SHORT $LN7@GetNormal
$LN6@GetNormal:

; 905  : 	else if (ix >= m_sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE)

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0001c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00022	39 45 08	 cmp	 DWORD PTR _ix$[ebp], eax
  00025	7c 10		 jl	 SHORT $LN7@GetNormal

; 906  : 		ix = m_sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0002e	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00034	89 45 08	 mov	 DWORD PTR _ix$[ebp], eax
$LN7@GetNormal:

; 907  : 	
; 908  : 	if (iy <= 0)

  00037	83 7d 0c 00	 cmp	 DWORD PTR _iy$[ebp], 0
  0003b	7f 06		 jg	 SHORT $LN9@GetNormal

; 909  : 		iy = 0;

  0003d	83 65 0c 00	 and	 DWORD PTR _iy$[ebp], 0
  00041	eb 22		 jmp	 SHORT $LN10@GetNormal
$LN9@GetNormal:

; 910  : 	else if (iy >= m_sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE)

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  0004a	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00050	39 45 0c	 cmp	 DWORD PTR _iy$[ebp], eax
  00053	7c 10		 jl	 SHORT $LN10@GetNormal

; 911  : 		iy = m_sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  0005c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00062	89 45 0c	 mov	 DWORD PTR _iy$[ebp], eax
$LN10@GetNormal:

; 912  : 	
; 913  : 	WORD usCoordX, usCoordY;
; 914  : 	
; 915  : 	usCoordX = (WORD) (ix / (CTerrainImpl::TERRAIN_XSIZE));

  00065	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  00068	99		 cdq
  00069	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  0006e	f7 f9		 idiv	 ecx
  00070	66 89 45 f4	 mov	 WORD PTR _usCoordX$[ebp], ax

; 916  : 	usCoordY = (WORD) (iy / (CTerrainImpl::TERRAIN_YSIZE));

  00074	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  00077	99		 cdq
  00078	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  0007d	f7 f9		 idiv	 ecx
  0007f	66 89 45 f8	 mov	 WORD PTR _usCoordY$[ebp], ax

; 917  : 	
; 918  : 	if (usCoordX >= m_sTerrainCountX - 1)

  00083	0f b7 45 f4	 movzx	 eax, WORD PTR _usCoordX$[ebp]
  00087	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	0f bf 49 70	 movsx	 ecx, WORD PTR [ecx+112]
  0008e	49		 dec	 ecx
  0008f	3b c1		 cmp	 eax, ecx
  00091	7c 0c		 jl	 SHORT $LN12@GetNormal

; 919  : 		usCoordX = m_sTerrainCountX - 1;

  00093	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00096	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0009a	48		 dec	 eax
  0009b	66 89 45 f4	 mov	 WORD PTR _usCoordX$[ebp], ax
$LN12@GetNormal:

; 920  : 	
; 921  : 	if (usCoordY >= m_sTerrainCountY - 1)

  0009f	0f b7 45 f8	 movzx	 eax, WORD PTR _usCoordY$[ebp]
  000a3	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	0f bf 49 72	 movsx	 ecx, WORD PTR [ecx+114]
  000aa	49		 dec	 ecx
  000ab	3b c1		 cmp	 eax, ecx
  000ad	7c 0c		 jl	 SHORT $LN13@GetNormal

; 922  : 		usCoordY = m_sTerrainCountY - 1;

  000af	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  000b6	48		 dec	 eax
  000b7	66 89 45 f8	 mov	 WORD PTR _usCoordY$[ebp], ax
$LN13@GetNormal:

; 923  : 	
; 924  : 	BYTE byTerrainNum;
; 925  : 	if (!GetTerrainNumFromCoord(usCoordX, usCoordY, &byTerrainNum))

  000bb	8d 45 f0	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  000be	50		 push	 eax
  000bf	ff 75 f8	 push	 DWORD PTR _usCoordY$[ebp]
  000c2	ff 75 f4	 push	 DWORD PTR _usCoordX$[ebp]
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  000cd	0f b6 c0	 movzx	 eax, al
  000d0	85 c0		 test	 eax, eax
  000d2	75 04		 jne	 SHORT $LN14@GetNormal

; 926  : 		return false;

  000d4	32 c0		 xor	 al, al
  000d6	eb 54		 jmp	 SHORT $LN1@GetNormal
$LN14@GetNormal:

; 927  : 	
; 928  : 	CTerrain * pTerrain;
; 929  : 	
; 930  : 	if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  000d8	8d 45 ec	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000db	50		 push	 eax
  000dc	ff 75 f0	 push	 DWORD PTR _byTerrainNum$[ebp]
  000df	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000e7	85 c0		 test	 eax, eax
  000e9	75 04		 jne	 SHORT $LN2@GetNormal

; 931  : 		return false;

  000eb	32 c0		 xor	 al, al
  000ed	eb 3d		 jmp	 SHORT $LN1@GetNormal
$LN2@GetNormal:

; 932  : 	
; 933  : 	while (ix >= CTerrainImpl::TERRAIN_XSIZE)

  000ef	81 7d 08 00 64
	00 00		 cmp	 DWORD PTR _ix$[ebp], 25600 ; 00006400H
  000f6	7c 0d		 jl	 SHORT $LN4@GetNormal

; 934  : 		ix -= CTerrainImpl::TERRAIN_XSIZE;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _ix$[ebp]
  000fb	2d 00 64 00 00	 sub	 eax, 25600		; 00006400H
  00100	89 45 08	 mov	 DWORD PTR _ix$[ebp], eax
  00103	eb ea		 jmp	 SHORT $LN2@GetNormal
$LN4@GetNormal:

; 935  : 
; 936  : 	while (iy >= CTerrainImpl::TERRAIN_YSIZE)

  00105	81 7d 0c 00 64
	00 00		 cmp	 DWORD PTR _iy$[ebp], 25600 ; 00006400H
  0010c	7c 0d		 jl	 SHORT $LN5@GetNormal

; 937  : 		iy -= CTerrainImpl::TERRAIN_YSIZE;

  0010e	8b 45 0c	 mov	 eax, DWORD PTR _iy$[ebp]
  00111	2d 00 64 00 00	 sub	 eax, 25600		; 00006400H
  00116	89 45 0c	 mov	 DWORD PTR _iy$[ebp], eax
  00119	eb ea		 jmp	 SHORT $LN4@GetNormal
$LN5@GetNormal:

; 938  : 
; 939  : 	return pTerrain->GetNormal(ix, iy, pv3Normal);

  0011b	ff 75 10	 push	 DWORD PTR _pv3Normal$[ebp]
  0011e	ff 75 0c	 push	 DWORD PTR _iy$[ebp]
  00121	ff 75 08	 push	 DWORD PTR _ix$[ebp]
  00124	8b 4d ec	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00127	e8 00 00 00 00	 call	 ?GetNormal@CTerrain@@QAE_NHHPAUD3DXVECTOR3@@@Z ; CTerrain::GetNormal
$LN1@GetNormal:

; 940  : }

  0012c	c9		 leave
  0012d	c2 0c 00	 ret	 12			; 0000000cH
?GetNormal@CMapOutdoor@@QAE_NHHPAUD3DXVECTOR3@@@Z ENDP	; CMapOutdoor::GetNormal
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetWaterHeight@CMapOutdoor@@QAE_NHHPAJ@Z
_TEXT	SEGMENT
_pTerrain$ = -28					; size = 4
_wLocalX$ = -24						; size = 2
_wLocalY$ = -20						; size = 2
_byTerrainNum$ = -16					; size = 1
_wTerrainCoordY$ = -12					; size = 2
_wTerrainCoordX$ = -8					; size = 2
_this$ = -4						; size = 4
_iX$ = 8						; size = 4
_iY$ = 12						; size = 4
_plWaterHeight$ = 16					; size = 4
?GetWaterHeight@CMapOutdoor@@QAE_NHHPAJ@Z PROC		; CMapOutdoor::GetWaterHeight, COMDAT
; _this$ = ecx

; 680  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 681  : 	if (iX < 0 || iY < 0 || iX > m_sTerrainCountX * CTerrainImpl::TERRAIN_XSIZE || iY > m_sTerrainCountY * CTerrainImpl::TERRAIN_YSIZE)

  00009	83 7d 08 00	 cmp	 DWORD PTR _iX$[ebp], 0
  0000d	7c 2a		 jl	 SHORT $LN3@GetWaterHe
  0000f	83 7d 0c 00	 cmp	 DWORD PTR _iY$[ebp], 0
  00013	7c 24		 jl	 SHORT $LN3@GetWaterHe
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	0f bf 40 70	 movsx	 eax, WORD PTR [eax+112]
  0001c	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00022	39 45 08	 cmp	 DWORD PTR _iX$[ebp], eax
  00025	7f 12		 jg	 SHORT $LN3@GetWaterHe
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	0f bf 40 72	 movsx	 eax, WORD PTR [eax+114]
  0002e	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00034	39 45 0c	 cmp	 DWORD PTR _iY$[ebp], eax
  00037	7e 07		 jle	 SHORT $LN2@GetWaterHe
$LN3@GetWaterHe:

; 682  : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	e9 9f 00 00 00	 jmp	 $LN1@GetWaterHe
$LN2@GetWaterHe:

; 683  : 
; 684  : 	WORD wTerrainCoordX, wTerrainCoordY;
; 685  : 	wTerrainCoordX = iX / CTerrainImpl::TERRAIN_XSIZE;

  00040	8b 45 08	 mov	 eax, DWORD PTR _iX$[ebp]
  00043	99		 cdq
  00044	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00049	f7 f9		 idiv	 ecx
  0004b	66 89 45 f8	 mov	 WORD PTR _wTerrainCoordX$[ebp], ax

; 686  : 	wTerrainCoordY = iY / CTerrainImpl::TERRAIN_YSIZE;

  0004f	8b 45 0c	 mov	 eax, DWORD PTR _iY$[ebp]
  00052	99		 cdq
  00053	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  00058	f7 f9		 idiv	 ecx
  0005a	66 89 45 f4	 mov	 WORD PTR _wTerrainCoordY$[ebp], ax

; 687  : 
; 688  : 	BYTE byTerrainNum;
; 689  : 	if (!GetTerrainNumFromCoord(wTerrainCoordX, wTerrainCoordY, &byTerrainNum))

  0005e	8d 45 f0	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  00061	50		 push	 eax
  00062	ff 75 f4	 push	 DWORD PTR _wTerrainCoordY$[ebp]
  00065	ff 75 f8	 push	 DWORD PTR _wTerrainCoordX$[ebp]
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  00070	0f b6 c0	 movzx	 eax, al
  00073	85 c0		 test	 eax, eax
  00075	75 04		 jne	 SHORT $LN4@GetWaterHe

; 690  : 		return false;

  00077	32 c0		 xor	 al, al
  00079	eb 64		 jmp	 SHORT $LN1@GetWaterHe
$LN4@GetWaterHe:

; 691  : 	CTerrain * pTerrain;
; 692  : 	if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  0007b	8d 45 e4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0007e	50		 push	 eax
  0007f	ff 75 f0	 push	 DWORD PTR _byTerrainNum$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0008a	85 c0		 test	 eax, eax
  0008c	75 04		 jne	 SHORT $LN5@GetWaterHe

; 693  : 		return false;

  0008e	32 c0		 xor	 al, al
  00090	eb 4d		 jmp	 SHORT $LN1@GetWaterHe
$LN5@GetWaterHe:

; 694  : 
; 695  : 	WORD wLocalX, wLocalY;
; 696  : 	wLocalX = (iX - wTerrainCoordX * CTerrainImpl::TERRAIN_XSIZE) / (CTerrainImpl::WATERMAP_XSIZE);

  00092	0f b7 45 f8	 movzx	 eax, WORD PTR _wTerrainCoordX$[ebp]
  00096	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _iX$[ebp]
  0009f	2b c8		 sub	 ecx, eax
  000a1	8b c1		 mov	 eax, ecx
  000a3	99		 cdq
  000a4	83 e2 7f	 and	 edx, 127		; 0000007fH
  000a7	03 c2		 add	 eax, edx
  000a9	c1 f8 07	 sar	 eax, 7
  000ac	66 89 45 e8	 mov	 WORD PTR _wLocalX$[ebp], ax

; 697  : 	wLocalY = (iY - wTerrainCoordY * CTerrainImpl::TERRAIN_YSIZE) / (CTerrainImpl::WATERMAP_YSIZE);

  000b0	0f b7 45 f4	 movzx	 eax, WORD PTR _wTerrainCoordY$[ebp]
  000b4	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _iY$[ebp]
  000bd	2b c8		 sub	 ecx, eax
  000bf	8b c1		 mov	 eax, ecx
  000c1	99		 cdq
  000c2	83 e2 7f	 and	 edx, 127		; 0000007fH
  000c5	03 c2		 add	 eax, edx
  000c7	c1 f8 07	 sar	 eax, 7
  000ca	66 89 45 ec	 mov	 WORD PTR _wLocalY$[ebp], ax

; 698  : 	
; 699  : 	return pTerrain->GetWaterHeight(wLocalX, wLocalY, plWaterHeight);

  000ce	ff 75 10	 push	 DWORD PTR _plWaterHeight$[ebp]
  000d1	ff 75 ec	 push	 DWORD PTR _wLocalY$[ebp]
  000d4	ff 75 e8	 push	 DWORD PTR _wLocalX$[ebp]
  000d7	8b 4d e4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  000da	e8 00 00 00 00	 call	 ?GetWaterHeight@CTerrain@@QAE_NGGPAJ@Z ; CTerrain::GetWaterHeight
$LN1@GetWaterHe:

; 700  : }

  000df	c9		 leave
  000e0	c2 0c 00	 ret	 12			; 0000000cH
?GetWaterHeight@CMapOutdoor@@QAE_NHHPAJ@Z ENDP		; CMapOutdoor::GetWaterHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z
_TEXT	SEGMENT
_pTerrain$ = -36					; size = 4
_byTerrainNum$ = -32					; size = 1
_usCoordX$ = -28					; size = 2
_usCoordY$ = -24					; size = 2
_lx$ = -20						; size = 4
_ly$ = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv69 = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z PROC		; CMapOutdoor::GetTerrainHeight, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 944  : 	if (fy < 0)

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  00010	76 11		 jbe	 SHORT $LN2@GetTerrain

; 945  : 		fy = -fy;

  00012	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00017	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001e	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
$LN2@GetTerrain:

; 946  : 	long lx, ly;
; 947  : 	PR_FLOAT_TO_INT(fx, lx);

  00023	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00028	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00030	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00036	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0003c	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00044	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0004b	76 0b		 jbe	 SHORT $LN6@GetTerrain
  0004d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00052	48		 dec	 eax
  00053	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00056	eb 08		 jmp	 SHORT $LN7@GetTerrain
$LN6@GetTerrain:
  00058	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0005d	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
$LN7@GetTerrain:
  00060	8b 45 fc	 mov	 eax, DWORD PTR tv69[ebp]
  00063	89 45 ec	 mov	 DWORD PTR _lx$[ebp], eax

; 948  : 	PR_FLOAT_TO_INT(fy, ly);

  00066	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0006b	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  00073	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00079	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0007f	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00087	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  0008e	76 0b		 jbe	 SHORT $LN8@GetTerrain
  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00095	48		 dec	 eax
  00096	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  00099	eb 08		 jmp	 SHORT $LN9@GetTerrain
$LN8@GetTerrain:
  0009b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  000a0	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
$LN9@GetTerrain:
  000a3	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  000a6	89 45 f0	 mov	 DWORD PTR _ly$[ebp], eax

; 949  : 
; 950  : 	WORD usCoordX, usCoordY;
; 951  : 
; 952  : 	usCoordX = (WORD) (lx / CTerrainImpl::TERRAIN_XSIZE);

  000a9	8b 45 ec	 mov	 eax, DWORD PTR _lx$[ebp]
  000ac	99		 cdq
  000ad	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000b2	f7 f9		 idiv	 ecx
  000b4	66 89 45 e4	 mov	 WORD PTR _usCoordX$[ebp], ax

; 953  : 	usCoordY = (WORD) (ly / CTerrainImpl::TERRAIN_YSIZE);

  000b8	8b 45 f0	 mov	 eax, DWORD PTR _ly$[ebp]
  000bb	99		 cdq
  000bc	b9 00 64 00 00	 mov	 ecx, 25600		; 00006400H
  000c1	f7 f9		 idiv	 ecx
  000c3	66 89 45 e8	 mov	 WORD PTR _usCoordY$[ebp], ax

; 954  : 
; 955  : 	BYTE byTerrainNum;
; 956  : 	if (!GetTerrainNumFromCoord(usCoordX, usCoordY, &byTerrainNum))

  000c7	8d 45 e0	 lea	 eax, DWORD PTR _byTerrainNum$[ebp]
  000ca	50		 push	 eax
  000cb	ff 75 e8	 push	 DWORD PTR _usCoordY$[ebp]
  000ce	ff 75 e4	 push	 DWORD PTR _usCoordX$[ebp]
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  000d9	0f b6 c0	 movzx	 eax, al
  000dc	85 c0		 test	 eax, eax
  000de	75 04		 jne	 SHORT $LN3@GetTerrain

; 957  : 		return 0.0f;

  000e0	d9 ee		 fldz
  000e2	eb 25		 jmp	 SHORT $LN1@GetTerrain
$LN3@GetTerrain:

; 958  : 
; 959  : 	CTerrain * pTerrain;
; 960  : 	
; 961  : 	if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  000e4	8d 45 dc	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000e7	50		 push	 eax
  000e8	ff 75 e0	 push	 DWORD PTR _byTerrainNum$[ebp]
  000eb	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000f3	85 c0		 test	 eax, eax
  000f5	75 04		 jne	 SHORT $LN4@GetTerrain

; 962  : 		return 0.0f;

  000f7	d9 ee		 fldz
  000f9	eb 0e		 jmp	 SHORT $LN1@GetTerrain
$LN4@GetTerrain:

; 963  : 
; 964  : 	return pTerrain->GetHeight(lx, ly);

  000fb	ff 75 f0	 push	 DWORD PTR _ly$[ebp]
  000fe	ff 75 ec	 push	 DWORD PTR _lx$[ebp]
  00101	8b 4d dc	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00104	e8 00 00 00 00	 call	 ?GetHeight@CTerrain@@QAEMHH@Z ; CTerrain::GetHeight
$LN1@GetTerrain:

; 965  : }

  00109	c9		 leave
  0010a	c2 08 00	 ret	 8
?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z ENDP		; CMapOutdoor::GetTerrainHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_byTerrainNum$ = 8					; size = 1
_ppTerrain$ = 12					; size = 4
?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z PROC ; CMapOutdoor::GetTerrainPointer, COMDAT
; _this$ = ecx

; 1037 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1038 : 	if (c_byTerrainNum >= AROUND_AREA_NUM)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byTerrainNum$[ebp]
  0000b	83 f8 09	 cmp	 eax, 9
  0000e	7c 0a		 jl	 SHORT $LN2@GetTerrain

; 1039 : 	{
; 1040 : 		*ppTerrain = NULL;

  00010	8b 45 0c	 mov	 eax, DWORD PTR _ppTerrain$[ebp]
  00013	83 20 00	 and	 DWORD PTR [eax], 0

; 1041 : 		return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	eb 2b		 jmp	 SHORT $LN1@GetTerrain
$LN2@GetTerrain:

; 1042 : 	}
; 1043 : 
; 1044 : 	if (NULL == m_pTerrain[c_byTerrainNum])

  0001a	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byTerrainNum$[ebp]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  00026	75 0a		 jne	 SHORT $LN3@GetTerrain

; 1045 : 	{
; 1046 : 		*ppTerrain = NULL;

  00028	8b 45 0c	 mov	 eax, DWORD PTR _ppTerrain$[ebp]
  0002b	83 20 00	 and	 DWORD PTR [eax], 0

; 1047 : 		return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 13		 jmp	 SHORT $LN1@GetTerrain
$LN3@GetTerrain:

; 1048 : 	}
; 1049 : 
; 1050 : 	*ppTerrain = m_pTerrain[c_byTerrainNum];

  00032	0f b6 45 08	 movzx	 eax, BYTE PTR _c_byTerrainNum$[ebp]
  00036	8b 4d 0c	 mov	 ecx, DWORD PTR _ppTerrain$[ebp]
  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 44 82 40	 mov	 eax, DWORD PTR [edx+eax*4+64]
  00040	89 01		 mov	 DWORD PTR [ecx], eax

; 1051 : 	return TRUE;

  00042	33 c0		 xor	 eax, eax
  00044	40		 inc	 eax
$LN1@GetTerrain:

; 1052 : }

  00045	c9		 leave
  00046	c2 08 00	 ret	 8
?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ENDP ; CMapOutdoor::GetTerrainPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?DestroyTerrainPatchProxyList@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
tv79 = -24						; size = 4
tv78 = -20						; size = 4
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
?DestroyTerrainPatchProxyList@CMapOutdoor@@IAEXXZ PROC	; CMapOutdoor::DestroyTerrainPatchProxyList, COMDAT
; _this$ = ecx

; 370  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 371  : 	if (m_pTerrainPatchProxyList)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 64 00	 cmp	 DWORD PTR [eax+100], 0
  00010	74 56		 je	 SHORT $LN5@DestroyTer

; 372  : 	{
; 373  : 		delete [] m_pTerrainPatchProxyList;

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00018	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  0001b	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00021	83 7d f0 00	 cmp	 DWORD PTR $T1[ebp], 0
  00025	74 36		 je	 SHORT $LN9@DestroyTer
  00027	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0002a	83 78 fc 00	 cmp	 DWORD PTR [eax-4], 0
  0002e	74 11		 je	 SHORT $LN7@DestroyTer
  00030	6a 03		 push	 3
  00032	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0003a	ff 10		 call	 DWORD PTR [eax]
  0003c	89 45 ec	 mov	 DWORD PTR tv78[ebp], eax
  0003f	eb 14		 jmp	 SHORT $LN8@DestroyTer
$LN7@DestroyTer:
  00041	6a 04		 push	 4
  00043	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00046	83 e8 04	 sub	 eax, 4
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  0004f	59		 pop	 ecx
  00050	59		 pop	 ecx
  00051	83 65 ec 00	 and	 DWORD PTR tv78[ebp], 0
$LN8@DestroyTer:
  00055	8b 45 ec	 mov	 eax, DWORD PTR tv78[ebp]
  00058	89 45 e8	 mov	 DWORD PTR tv79[ebp], eax
  0005b	eb 04		 jmp	 SHORT $LN10@DestroyTer
$LN9@DestroyTer:
  0005d	83 65 e8 00	 and	 DWORD PTR tv79[ebp], 0
$LN10@DestroyTer:

; 374  : 		m_pTerrainPatchProxyList = NULL;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 64 00	 and	 DWORD PTR [eax+100], 0
$LN5@DestroyTer:

; 375  : 	}
; 376  : 
; 377  : #ifdef WORLD_EDITOR	
; 378  : 	m_IndexBuffer.Destroy();
; 379  : #else
; 380  : 	for (int i = 0; i < TERRAINPATCH_LODMAX; ++i)

  00068	83 65 fc 00	 and	 DWORD PTR _i$3[ebp], 0
  0006c	eb 07		 jmp	 SHORT $LN4@DestroyTer
$LN2@DestroyTer:
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  00071	40		 inc	 eax
  00072	89 45 fc	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@DestroyTer:
  00075	83 7d fc 03	 cmp	 DWORD PTR _i$3[ebp], 3
  00079	7d 15		 jge	 SHORT $LN1@DestroyTer

; 381  : 		m_IndexBuffer[i].Destroy();

  0007b	6b 45 fc 14	 imul	 eax, DWORD PTR _i$3[ebp], 20
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	8d 8c 01 9c 00
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+156]
  00089	e8 00 00 00 00	 call	 ?Destroy@CGraphicIndexBuffer@@QAEXXZ ; CGraphicIndexBuffer::Destroy
  0008e	eb de		 jmp	 SHORT $LN2@DestroyTer
$LN1@DestroyTer:

; 382  : #endif
; 383  : }

  00090	c9		 leave
  00091	c3		 ret	 0
?DestroyTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ENDP	; CMapOutdoor::DestroyTerrainPatchProxyList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
tv144 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ PROC	; CMapOutdoor::CreateTerrainPatchProxyList, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 357  : 	m_wPatchCount = ((m_lViewRadius * 2) / TERRAIN_PATCHSIZE) + 2;

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  0002f	d1 e0		 shl	 eax, 1
  00031	99		 cdq
  00032	83 e2 0f	 and	 edx, 15			; 0000000fH
  00035	03 c2		 add	 eax, edx
  00037	c1 f8 04	 sar	 eax, 4
  0003a	40		 inc	 eax
  0003b	40		 inc	 eax
  0003c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	66 89 81 8c 00
	00 00		 mov	 WORD PTR [ecx+140], ax

; 358  : 	
; 359  : 	m_pTerrainPatchProxyList = new CTerrainPatchProxy[m_wPatchCount * m_wPatchCount];

  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	0f b7 80 8c 00
	00 00		 movzx	 eax, WORD PTR [eax+140]
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	0f b7 89 8c 00
	00 00		 movzx	 ecx, WORD PTR [ecx+140]
  0005a	0f af c1	 imul	 eax, ecx
  0005d	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  00060	33 c9		 xor	 ecx, ecx
  00062	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00065	6a 1c		 push	 28			; 0000001cH
  00067	5a		 pop	 edx
  00068	f7 e2		 mul	 edx
  0006a	0f 90 c1	 seto	 cl
  0006d	f7 d9		 neg	 ecx
  0006f	0b c8		 or	 ecx, eax
  00071	33 c0		 xor	 eax, eax
  00073	83 c1 04	 add	 ecx, 4
  00076	0f 92 c0	 setb	 al
  00079	f7 d8		 neg	 eax
  0007b	0b c1		 or	 eax, ecx
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00083	59		 pop	 ecx
  00084	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  00087	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0008b	83 7d ec 00	 cmp	 DWORD PTR $T4[ebp], 0
  0008f	74 2e		 je	 SHORT $LN3@CreateTerr
  00091	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00094	8b 4d e8	 mov	 ecx, DWORD PTR $T3[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx
  00099	68 00 00 00 00	 push	 OFFSET ??1CTerrainPatchProxy@@UAE@XZ ; CTerrainPatchProxy::~CTerrainPatchProxy
  0009e	68 00 00 00 00	 push	 OFFSET ??0CTerrainPatchProxy@@QAE@XZ ; CTerrainPatchProxy::CTerrainPatchProxy
  000a3	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  000a6	6a 1c		 push	 28			; 0000001cH
  000a8	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  000ab	83 c0 04	 add	 eax, 4
  000ae	50		 push	 eax
  000af	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  000b4	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  000b7	83 c0 04	 add	 eax, 4
  000ba	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  000bd	eb 04		 jmp	 SHORT $LN4@CreateTerr
$LN3@CreateTerr:
  000bf	83 65 e4 00	 and	 DWORD PTR tv144[ebp], 0
$LN4@CreateTerr:
  000c3	8b 45 e4	 mov	 eax, DWORD PTR tv144[ebp]
  000c6	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  000c9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000cd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	8b 4d e0	 mov	 ecx, DWORD PTR $T2[ebp]
  000d3	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 360  : 	
; 361  : 	m_iPatchTerrainVertexCount = (TERRAIN_PATCHSIZE+1)*(TERRAIN_PATCHSIZE+1);

  000d6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	c7 80 a0 09 00
	00 21 01 00 00	 mov	 DWORD PTR [eax+2464], 289 ; 00000121H

; 362  : 	m_iPatchWaterVertexCount = TERRAIN_PATCHSIZE * TERRAIN_PATCHSIZE * 6;

  000e3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	c7 80 a4 09 00
	00 00 06 00 00	 mov	 DWORD PTR [eax+2468], 1536 ; 00000600H

; 363  : 	m_iPatchTerrainVertexSize = 24;

  000f0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	c7 80 a8 09 00
	00 18 00 00 00	 mov	 DWORD PTR [eax+2472], 24 ; 00000018H

; 364  : 	m_iPatchWaterVertexSize = 16;

  000fd	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00100	c7 80 ac 09 00
	00 10 00 00 00	 mov	 DWORD PTR [eax+2476], 16 ; 00000010H

; 365  : 
; 366  : 	SetIndexBuffer();

  0010a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	e8 00 00 00 00	 call	 ?SetIndexBuffer@CMapOutdoor@@IAEXXZ ; CMapOutdoor::SetIndexBuffer

; 367  : }

  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5b		 pop	 ebx
  0011e	c9		 leave
  0011f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ$0:
  00000	33 db		 xor	 ebx, ebx
  00002	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00005	6a 1c		 push	 28			; 0000001cH
  00007	59		 pop	 ecx
  00008	f7 e1		 mul	 ecx
  0000a	0f 90 c3	 seto	 bl
  0000d	f7 db		 neg	 ebx
  0000f	0b d8		 or	 ebx, eax
  00011	33 c0		 xor	 eax, eax
  00013	83 c3 04	 add	 ebx, 4
  00016	0f 92 c0	 setb	 al
  00019	f7 d8		 neg	 eax
  0001b	0b c3		 or	 eax, ebx
  0001d	50		 push	 eax
  0001e	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  00021	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00026	59		 pop	 ecx
  00027	59		 pop	 ecx
  00028	c3		 ret	 0
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
__ehhandler$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ:
  0002e	90		 npad	 1
  0002f	90		 npad	 1
  00030	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00034	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00037	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ
  00046	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CreateTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ENDP	; CMapOutdoor::CreateTerrainPatchProxyList
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?DestroyTerrain@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?DestroyTerrain@CMapOutdoor@@MAEXXZ PROC		; CMapOutdoor::DestroyTerrain, COMDAT
; _this$ = ecx

; 414  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 415  : 	m_TerrainVector.clear();

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 18 09 00
	00		 add	 ecx, 2328		; 00000918H
  00011	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 416  : 	m_TerrainDeleteVector.clear();

  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 24 09 00
	00		 add	 ecx, 2340		; 00000924H
  0001f	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 417  : 
; 418  : 	CTerrain::ms_kPool.FreeAll();

  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CTerrain@@2V?$CDynamicPool@VCTerrain@@@@A ; CTerrain::ms_kPool
  00029	e8 00 00 00 00	 call	 ?FreeAll@?$CDynamicPool@VCTerrain@@@@QAEXXZ ; CDynamicPool<CTerrain>::FreeAll

; 419  : 	for (int i=0; i < AROUND_AREA_NUM; ++i)

  0002e	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  00032	eb 07		 jmp	 SHORT $LN4@DestroyTer
$LN2@DestroyTer:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	40		 inc	 eax
  00038	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DestroyTer:
  0003b	83 7d fc 09	 cmp	 DWORD PTR _i$1[ebp], 9
  0003f	7d 0d		 jge	 SHORT $LN1@DestroyTer

; 420  : 		m_pTerrain[i] = NULL;

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	83 64 81 40 00	 and	 DWORD PTR [ecx+eax*4+64], 0
  0004c	eb e6		 jmp	 SHORT $LN2@DestroyTer
$LN1@DestroyTer:

; 421  : }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?DestroyTerrain@CMapOutdoor@@MAEXXZ ENDP		; CMapOutdoor::DestroyTerrain
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$map@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$map@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$map@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S15$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S15$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
__Scary$ = -8						; size = 4
__Head$ = -4						; size = 4
?clear@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::clear, COMDAT
; _this$ = ecx

; 1444 :     void clear() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Scary$[ebp], eax

; 1445 :         const auto _Scary = _Get_scary();
; 1446 :         _Scary->_Orphan_ptr(nullptr);
; 1447 :         auto _Head = _Scary->_Myhead;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00018	8b 00		 mov	 eax, DWORD PTR [eax]
  0001a	89 45 fc	 mov	 DWORD PTR __Head$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00026	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1448 :         _Scary->_Erase_tree(_Getal(), _Head->_Parent);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >

; 1449 :         _Head->_Parent  = _Head;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1450 :         _Head->_Left    = _Head;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00049	89 08		 mov	 DWORD PTR [eax], ecx

; 1451 :         _Head->_Right   = _Head;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Head$[ebp]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR __Head$[ebp]
  00051	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 1452 :         _Scary->_Mysize = 0;

  00054	8b 45 f8	 mov	 eax, DWORD PTR __Scary$[ebp]
  00057	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1453 :     }

  0005b	c9		 leave
  0005c	c3		 ret	 0
?clear@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetWaterHeight@CMapOutdoor@@IAEXEEPAJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_byTerrainNum$ = 8					; size = 1
_byWaterNum$ = 12					; size = 1
_plWaterHeight$ = 16					; size = 4
?GetWaterHeight@CMapOutdoor@@IAEXEEPAJ@Z PROC		; CMapOutdoor::GetWaterHeight, COMDAT
; _this$ = ecx

; 669  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 670  : 	if (byTerrainNum < 0 || byTerrainNum > AROUND_AREA_NUM - 1 || !m_pTerrain[byTerrainNum])

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	7c 17		 jl	 SHORT $LN3@GetWaterHe
  0000f	0f b6 45 08	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00013	83 f8 08	 cmp	 eax, 8
  00016	7f 0e		 jg	 SHORT $LN3@GetWaterHe
  00018	0f b6 45 08	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  00024	75 08		 jne	 SHORT $LN2@GetWaterHe
$LN3@GetWaterHe:

; 671  : 	{
; 672  : 		*plWaterHeight = -1;

  00026	8b 45 10	 mov	 eax, DWORD PTR _plWaterHeight$[ebp]
  00029	83 08 ff	 or	 DWORD PTR [eax], -1

; 673  : 		return;

  0002c	eb 16		 jmp	 SHORT $LN1@GetWaterHe
$LN2@GetWaterHe:

; 674  : 	}
; 675  : 
; 676  : 	m_pTerrain[byTerrainNum]->GetWaterHeight(byWaterNum, plWaterHeight);

  0002e	ff 75 10	 push	 DWORD PTR _plWaterHeight$[ebp]
  00031	ff 75 0c	 push	 DWORD PTR _byWaterNum$[ebp]
  00034	0f b6 45 08	 movzx	 eax, BYTE PTR _byTerrainNum$[ebp]
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	8b 4c 81 40	 mov	 ecx, DWORD PTR [ecx+eax*4+64]
  0003f	e8 00 00 00 00	 call	 ?GetWaterHeight@CTerrain@@QAEXEPAJ@Z ; CTerrain::GetWaterHeight
$LN1@GetWaterHe:

; 677  : }

  00044	c9		 leave
  00045	c2 0c 00	 ret	 12			; 0000000cH
?GetWaterHeight@CMapOutdoor@@IAEXEEPAJ@Z ENDP		; CMapOutdoor::GetWaterHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetWaterMap@CMapOutdoor@@IAEXABEPAPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rucTerrainNum$ = 8					; size = 4
_pucWaterMap$ = 12					; size = 4
?GetWaterMap@CMapOutdoor@@IAEXABEPAPAE@Z PROC		; CMapOutdoor::GetWaterMap, COMDAT
; _this$ = ecx

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 659  : 	if (c_rucTerrainNum < 0 || c_rucTerrainNum > AROUND_AREA_NUM - 1 || !m_pTerrain[c_rucTerrainNum])

  00007	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000d	85 c0		 test	 eax, eax
  0000f	7c 1b		 jl	 SHORT $LN3@GetWaterMa
  00011	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00014	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00017	83 f8 08	 cmp	 eax, 8
  0001a	7f 10		 jg	 SHORT $LN3@GetWaterMa
  0001c	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0001f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  0002a	75 08		 jne	 SHORT $LN5@GetWaterMa
$LN3@GetWaterMa:

; 660  : 	{
; 661  : 		*pucWaterMap = NULL;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pucWaterMap$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0

; 662  : 		return;

  00032	eb 17		 jmp	 SHORT $LN1@GetWaterMa
$LN5@GetWaterMa:

; 665  : 	*pucWaterMap = m_pTerrain[c_rucTerrainNum]->GetWaterMap();

  00034	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00037	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 69   : 		BYTE *			GetWaterMap()	{ return m_abyWaterMap; }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 44 81 40	 mov	 eax, DWORD PTR [ecx+eax*4+64]
  00041	05 1a 8e 02 00	 add	 eax, 167450		; 00028e1aH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 665  : 	*pucWaterMap = m_pTerrain[c_rucTerrainNum]->GetWaterMap();

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pucWaterMap$[ebp]
  00049	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@GetWaterMa:

; 666  : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?GetWaterMap@CMapOutdoor@@IAEXABEPAPAE@Z ENDP		; CMapOutdoor::GetWaterMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetNormalMap@CMapOutdoor@@IAEXABEPAPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rucTerrainNum$ = 8					; size = 4
_pucNormalMap$ = 12					; size = 4
?GetNormalMap@CMapOutdoor@@IAEXABEPAPAD@Z PROC		; CMapOutdoor::GetNormalMap, COMDAT
; _this$ = ecx

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 	if (c_rucTerrainNum < 0 || c_rucTerrainNum > AROUND_AREA_NUM - 1 || !m_pTerrain[c_rucTerrainNum])

  00007	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000d	85 c0		 test	 eax, eax
  0000f	7c 1b		 jl	 SHORT $LN3@GetNormalM
  00011	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00014	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00017	83 f8 08	 cmp	 eax, 8
  0001a	7f 10		 jg	 SHORT $LN3@GetNormalM
  0001c	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0001f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  0002a	75 08		 jne	 SHORT $LN5@GetNormalM
$LN3@GetNormalM:

; 649  : 	{
; 650  : 		*pucNormalMap = NULL;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pucNormalMap$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0

; 651  : 		return;

  00032	eb 17		 jmp	 SHORT $LN1@GetNormalM
$LN5@GetNormalM:

; 654  : 	*pucNormalMap = m_pTerrain[c_rucTerrainNum]->GetNormalMap();

  00034	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00037	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 59   : 		char *			GetNormalMap()			{ return m_acNormalMap; }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 44 81 40	 mov	 eax, DWORD PTR [ecx+eax*4+64]
  00041	05 1a ce 02 00	 add	 eax, 183834		; 0002ce1aH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 654  : 	*pucNormalMap = m_pTerrain[c_rucTerrainNum]->GetNormalMap();

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pucNormalMap$[ebp]
  00049	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@GetNormalM:

; 655  : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?GetNormalMap@CMapOutdoor@@IAEXABEPAPAD@Z ENDP		; CMapOutdoor::GetNormalMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetHeightMap@CMapOutdoor@@IAEXABEPAPAG@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rucTerrainNum$ = 8					; size = 4
_pwHeightMap$ = 12					; size = 4
?GetHeightMap@CMapOutdoor@@IAEXABEPAPAG@Z PROC		; CMapOutdoor::GetHeightMap, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 637  : 	if (c_rucTerrainNum < 0 || c_rucTerrainNum > AROUND_AREA_NUM - 1 || !m_pTerrain[c_rucTerrainNum])

  00007	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000d	85 c0		 test	 eax, eax
  0000f	7c 1b		 jl	 SHORT $LN3@GetHeightM
  00011	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00014	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00017	83 f8 08	 cmp	 eax, 8
  0001a	7f 10		 jg	 SHORT $LN3@GetHeightM
  0001c	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  0001f	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  0002a	75 08		 jne	 SHORT $LN5@GetHeightM
$LN3@GetHeightM:

; 638  : 	{
; 639  : 		*pwHeightMap = NULL;

  0002c	8b 45 0c	 mov	 eax, DWORD PTR _pwHeightMap$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0

; 640  : 		return;

  00032	eb 17		 jmp	 SHORT $LN1@GetHeightM
$LN5@GetHeightM:

; 643  : 	*pwHeightMap = m_pTerrain[c_rucTerrainNum]->GetHeightMap();

  00034	8b 45 08	 mov	 eax, DWORD PTR _c_rucTerrainNum$[ebp]
  00037	0f b6 00	 movzx	 eax, BYTE PTR [eax]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 51   : 		WORD *			GetHeightMap()			{ return m_awRawHeightMap; }

  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 44 81 40	 mov	 eax, DWORD PTR [ecx+eax*4+64]
  00041	05 04 04 00 00	 add	 eax, 1028		; 00000404H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 643  : 	*pwHeightMap = m_pTerrain[c_rucTerrainNum]->GetHeightMap();

  00046	8b 4d 0c	 mov	 ecx, DWORD PTR _pwHeightMap$[ebp]
  00049	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@GetHeightM:

; 644  : }

  0004b	c9		 leave
  0004c	c2 08 00	 ret	 8
?GetHeightMap@CMapOutdoor@@IAEXABEPAPAG@Z ENDP		; CMapOutdoor::GetHeightMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?RestoreAlphaFogOperation@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RestoreAlphaFogOperation@CMapOutdoor@@IAEXXZ PROC	; CMapOutdoor::RestoreAlphaFogOperation, COMDAT
; _this$ = ecx

; 1080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1081 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);

  00007	6a 00		 push	 0
  00009	6a 18		 push	 24			; 00000018H
  0000b	6a 01		 push	 1
  0000d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00013	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1082 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, 1);

  00018	6a 01		 push	 1
  0001a	6a 0b		 push	 11			; 0000000bH
  0001c	6a 01		 push	 1
  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1083 : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00029	6a 1b		 push	 27			; 0000001bH
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00031	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 1084 : }

  00036	c9		 leave
  00037	c3		 ret	 0
?RestoreAlphaFogOperation@CMapOutdoor@@IAEXXZ ENDP	; CMapOutdoor::RestoreAlphaFogOperation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SaveAlphaFogOperation@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?SaveAlphaFogOperation@CMapOutdoor@@IAEXXZ PROC		; CMapOutdoor::SaveAlphaFogOperation, COMDAT
; _this$ = ecx

; 1063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1064 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1,	D3DTA_CURRENT);

  00008	6a 01		 push	 1
  0000a	6a 02		 push	 2
  0000c	6a 01		 push	 1
  0000e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00014	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1065 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  00019	6a 02		 push	 2
  0001b	6a 01		 push	 1
  0001d	6a 01		 push	 1
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00025	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1066 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1,	D3DTA_CURRENT);

  0002a	6a 01		 push	 1
  0002c	6a 05		 push	 5
  0002e	6a 01		 push	 1
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00036	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1067 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG2,	D3DTA_TEXTURE);

  0003b	6a 02		 push	 2
  0003d	6a 06		 push	 6
  0003f	6a 01		 push	 1
  00041	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00047	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1068 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,	D3DTOP_MODULATE);

  0004c	6a 04		 push	 4
  0004e	6a 04		 push	 4
  00050	6a 01		 push	 1
  00052	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00058	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1069 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  0005d	6a 02		 push	 2
  0005f	6a 18		 push	 24			; 00000018H
  00061	6a 01		 push	 1
  00063	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00069	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1070 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  0006e	68 00 00 02 00	 push	 131072			; 00020000H
  00073	6a 0b		 push	 11			; 0000000bH
  00075	6a 01		 push	 1
  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0007d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1071 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);

  00082	6a 03		 push	 3
  00084	6a 0d		 push	 13			; 0000000dH
  00086	6a 01		 push	 1
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0008e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1072 : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

  00093	6a 03		 push	 3
  00095	6a 0e		 push	 14			; 0000000eH
  00097	6a 01		 push	 1
  00099	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0009f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1073 : 
; 1074 : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &m_matAlphaFogTexture);

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	05 94 01 00 00	 add	 eax, 404		; 00000194H
  000ac	50		 push	 eax
  000ad	6a 11		 push	 17			; 00000011H
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000b5	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 1075 : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  000ba	6a 01		 push	 1
  000bc	6a 1b		 push	 27			; 0000001bH
  000be	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000c4	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000ce	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1076 : 	STATEMANAGER.SetTexture(1, m_AlphaFogImageInstance.GetTexturePointer()->GetD3DTexture());

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  000da	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImageInstance@@QAEPAVCGraphicTexture@@XZ ; CGraphicImageInstance::GetTexturePointer
  000df	8b c8		 mov	 ecx, eax
  000e1	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  000e6	50		 push	 eax
  000e7	6a 01		 push	 1
  000e9	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  000ec	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 1077 : }

  000f1	c9		 leave
  000f2	c3		 ret	 0
?SaveAlphaFogOperation@CMapOutdoor@@IAEXXZ ENDP		; CMapOutdoor::SaveAlphaFogOperation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z
_TEXT	SEGMENT
_pTerrain$ = -68					; size = 4
_ix$1 = -64						; size = 4
_iy$2 = -60						; size = 4
$T3 = -56						; size = 4
__Xx$ = -52						; size = 4
_byTerrainNum$4 = -48					; size = 1
_fRayRangeInv$ = -44					; size = 4
_fMultiplier$5 = -40					; size = 4
_fMapHeight$6 = -36					; size = 4
tv146 = -32						; size = 4
tv135 = -28						; size = 4
_this$ = -24						; size = 4
_s$ = -20						; size = 4
_v3CurPos$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_fPos$ = 8						; size = 4
_v3Start$ = 12						; size = 4
_v3End$ = 16						; size = 4
_fStep$ = 20						; size = 4
_fRayRange$ = 24					; size = 4
_fLimitRange$ = 28					; size = 4
_pv3Pick$ = 32						; size = 4
?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z PROC ; CMapOutdoor::__PickTerrainHeight, COMDAT
; _this$ = ecx

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 450  : 	CTerrain * pTerrain;
; 451  : 
; 452  : 	D3DXVECTOR3 v3CurPos;
; 453  : 
; 454  : 	float fRayRangeInv=1.0f/fRayRange;

  00015	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001d	f3 0f 5e 45 18	 divss	 xmm0, DWORD PTR _fRayRange$[ebp]
  00022	f3 0f 11 45 d4	 movss	 DWORD PTR _fRayRangeInv$[ebp], xmm0
$LN2@PickTerrai:

; 455  : 	while (fPos < fRayRange && fPos<fLimitRange)

  00027	8b 45 08	 mov	 eax, DWORD PTR _fPos$[ebp]
  0002a	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  0002f	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00032	0f 86 f4 01 00
	00		 jbe	 $LN3@PickTerrai
  00038	8b 45 08	 mov	 eax, DWORD PTR _fPos$[ebp]
  0003b	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR _fLimitRange$[ebp]
  00040	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00043	0f 86 e3 01 00
	00		 jbe	 $LN3@PickTerrai

; 456  : 	{
; 457  : 		D3DXVec3Lerp(&v3CurPos, &v3Start, &v3End, fPos*fRayRangeInv);

  00049	8b 45 08	 mov	 eax, DWORD PTR _fPos$[ebp]
  0004c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00050	f3 0f 59 45 d4	 mulss	 xmm0, DWORD PTR _fRayRangeInv$[ebp]
  00055	f3 0f 11 45 ec	 movss	 DWORD PTR _s$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1364 :     pOut->x = pV1->x + s * (pV2->x - pV1->x);

  0005a	8b 45 10	 mov	 eax, DWORD PTR _v3End$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _v3Start$[ebp]
  00060	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00064	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  00068	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _s$[ebp]
  0006d	8b 45 0c	 mov	 eax, DWORD PTR _v3Start$[ebp]
  00070	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00074	f3 0f 11 45 f0	 movss	 DWORD PTR _v3CurPos$[ebp], xmm0

; 1365 :     pOut->y = pV1->y + s * (pV2->y - pV1->y);

  00079	8b 45 10	 mov	 eax, DWORD PTR _v3End$[ebp]
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR _v3Start$[ebp]
  0007f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00084	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00089	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _s$[ebp]
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _v3Start$[ebp]
  00091	f3 0f 58 40 04	 addss	 xmm0, DWORD PTR [eax+4]
  00096	f3 0f 11 45 f4	 movss	 DWORD PTR _v3CurPos$[ebp+4], xmm0

; 1366 :     pOut->z = pV1->z + s * (pV2->z - pV1->z);

  0009b	8b 45 10	 mov	 eax, DWORD PTR _v3End$[ebp]
  0009e	8b 4d 0c	 mov	 ecx, DWORD PTR _v3Start$[ebp]
  000a1	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000a6	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  000ab	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _s$[ebp]
  000b0	8b 45 0c	 mov	 eax, DWORD PTR _v3Start$[ebp]
  000b3	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  000b8	f3 0f 11 45 f8	 movss	 DWORD PTR _v3CurPos$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 459  : 		float fMultiplier = 1.0f;

  000bd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000c5	f3 0f 11 45 d8	 movss	 DWORD PTR _fMultiplier$5[ebp], xmm0

; 460  : 		if (GetTerrainNum(v3CurPos.x, v3CurPos.y, &byTerrainNum))

  000ca	8d 45 d0	 lea	 eax, DWORD PTR _byTerrainNum$4[ebp]
  000cd	50		 push	 eax
  000ce	51		 push	 ecx
  000cf	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3CurPos$[ebp+4]
  000d4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d9	51		 push	 ecx
  000da	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3CurPos$[ebp]
  000df	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	e8 00 00 00 00	 call	 ?GetTerrainNum@CMapOutdoor@@QAE_NMMPAE@Z ; CMapOutdoor::GetTerrainNum
  000ec	0f b6 c0	 movzx	 eax, al
  000ef	85 c0		 test	 eax, eax
  000f1	0f 84 18 01 00
	00		 je	 $LN7@PickTerrai

; 461  : 		{
; 462  : 			if (GetTerrainPointer(byTerrainNum, &pTerrain))

  000f7	8d 45 bc	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000fa	50		 push	 eax
  000fb	ff 75 d0	 push	 DWORD PTR _byTerrainNum$4[ebp]
  000fe	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00106	85 c0		 test	 eax, eax
  00108	0f 84 01 01 00
	00		 je	 $LN7@PickTerrai

; 463  : 			{
; 464  : 				int ix, iy;
; 465  : 				PR_FLOAT_TO_INT(v3CurPos.x, ix);

  0010e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3CurPos$[ebp]
  00113	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  0011b	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00121	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  00127	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0012f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00136	76 0b		 jbe	 SHORT $LN9@PickTerrai
  00138	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  0013d	48		 dec	 eax
  0013e	89 45 e4	 mov	 DWORD PTR tv135[ebp], eax
  00141	eb 08		 jmp	 SHORT $LN10@PickTerrai
$LN9@PickTerrai:
  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00148	89 45 e4	 mov	 DWORD PTR tv135[ebp], eax
$LN10@PickTerrai:
  0014b	8b 45 e4	 mov	 eax, DWORD PTR tv135[ebp]
  0014e	89 45 c0	 mov	 DWORD PTR _ix$1[ebp], eax

; 466  : 				PR_FLOAT_TO_INT(fabs(v3CurPos.y), iy);

  00151	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3CurPos$[ebp+4]
  00156	f3 0f 11 45 cc	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  0015b	f3 0f 5a 45 cc	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00160	51		 push	 ecx
  00161	51		 push	 ecx
  00162	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00167	e8 00 00 00 00	 call	 _fabs
  0016c	59		 pop	 ecx
  0016d	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  0016e	d9 5d c8	 fstp	 DWORD PTR $T3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 466  : 				PR_FLOAT_TO_INT(fabs(v3CurPos.y), iy);

  00171	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T3[ebp]
  00176	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?PR_FCNV@@3MA, xmm0
  0017e	d9 05 00 00 00
	00		 fld	 DWORD PTR ?PR_FCNV@@3MA	; PR_FCNV
  00184	db 1d 00 00 00
	00		 fistp	 DWORD PTR ?PR_ICNV@@3JA
  0018a	f3 0f 2a 05 00
	00 00 00	 cvtsi2ss xmm0, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  00192	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?PR_FCNV@@3MA
  00199	76 0b		 jbe	 SHORT $LN11@PickTerrai
  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001a0	48		 dec	 eax
  001a1	89 45 e0	 mov	 DWORD PTR tv146[ebp], eax
  001a4	eb 08		 jmp	 SHORT $LN12@PickTerrai
$LN11@PickTerrai:
  001a6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?PR_ICNV@@3JA ; PR_ICNV
  001ab	89 45 e0	 mov	 DWORD PTR tv146[ebp], eax
$LN12@PickTerrai:
  001ae	8b 45 e0	 mov	 eax, DWORD PTR tv146[ebp]
  001b1	89 45 c4	 mov	 DWORD PTR _iy$2[ebp], eax

; 467  : 				float fMapHeight = pTerrain->GetHeight(ix, iy);

  001b4	ff 75 c4	 push	 DWORD PTR _iy$2[ebp]
  001b7	ff 75 c0	 push	 DWORD PTR _ix$1[ebp]
  001ba	8b 4d bc	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  001bd	e8 00 00 00 00	 call	 ?GetHeight@CTerrain@@QAEMHH@Z ; CTerrain::GetHeight
  001c2	d9 5d dc	 fstp	 DWORD PTR _fMapHeight$6[ebp]

; 468  : 				if ( fMapHeight >= v3CurPos.z)

  001c5	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fMapHeight$6[ebp]
  001ca	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _v3CurPos$[ebp+8]
  001ce	72 0f		 jb	 SHORT $LN6@PickTerrai

; 469  : 				{
; 470  : 					*pv3Pick = v3CurPos;

  001d0	8d 75 f0	 lea	 esi, DWORD PTR _v3CurPos$[ebp]
  001d3	8b 7d 20	 mov	 edi, DWORD PTR _pv3Pick$[ebp]
  001d6	a5		 movsd
  001d7	a5		 movsd
  001d8	a5		 movsd

; 471  : 					return true;

  001d9	b0 01		 mov	 al, 1
  001db	eb 51		 jmp	 SHORT $LN1@PickTerrai

; 472  : 				}

  001dd	eb 30		 jmp	 SHORT $LN7@PickTerrai
$LN6@PickTerrai:

; 473  : 				else
; 474  : 				{
; 475  : 					fMultiplier = fMAX(1.0f, 0.01f * ( v3CurPos.z - fMapHeight ) );

  001df	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3CurPos$[ebp+8]
  001e4	f3 0f 5c 45 dc	 subss	 xmm0, DWORD PTR _fMapHeight$6[ebp]
  001e9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c23d70a
  001f1	51		 push	 ecx
  001f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001f7	51		 push	 ecx
  001f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00200	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00205	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  0020a	59		 pop	 ecx
  0020b	59		 pop	 ecx
  0020c	d9 5d d8	 fstp	 DWORD PTR _fMultiplier$5[ebp]
$LN7@PickTerrai:

; 476  : 				}
; 477  : 			}
; 478  : 		}
; 479  : 		fPos += fStep * fMultiplier;

  0020f	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fStep$[ebp]
  00214	f3 0f 59 45 d8	 mulss	 xmm0, DWORD PTR _fMultiplier$5[ebp]
  00219	8b 45 08	 mov	 eax, DWORD PTR _fPos$[ebp]
  0021c	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00220	8b 45 08	 mov	 eax, DWORD PTR _fPos$[ebp]
  00223	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 480  : 	}

  00227	e9 fb fd ff ff	 jmp	 $LN2@PickTerrai
$LN3@PickTerrai:

; 481  : 
; 482  : 	return false;

  0022c	32 c0		 xor	 al, al
$LN1@PickTerrai:

; 483  : }

  0022e	5f		 pop	 edi
  0022f	5e		 pop	 esi
  00230	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00233	33 cd		 xor	 ecx, ebp
  00235	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023a	c9		 leave
  0023b	c2 1c 00	 ret	 28			; 0000001cH
?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ENDP ; CMapOutdoor::__PickTerrainHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetShadowMapColor@CMapOutdoor@@QAEKMM@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_fYRef$ = -16						; size = 4
_pTerrain$ = -12					; size = 4
_fXRef$ = -8						; size = 4
_fTerrainSize$ = -4					; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?GetShadowMapColor@CMapOutdoor@@QAEKMM@Z PROC		; CMapOutdoor::GetShadowMapColor, COMDAT
; _this$ = ecx

; 1098 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1099 : 	if (fy < 0)

  00009	0f 57 c0	 xorps	 xmm0, xmm0
  0000c	0f 2f 45 0c	 comiss	 xmm0, DWORD PTR _fy$[ebp]
  00010	76 11		 jbe	 SHORT $LN2@GetShadowM

; 1100 : 		fy = -fy;

  00012	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00017	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0001e	f3 0f 11 45 0c	 movss	 DWORD PTR _fy$[ebp], xmm0
$LN2@GetShadowM:

; 1101 : 
; 1102 : 	float fTerrainSize = (float) (CTerrainImpl::TERRAIN_XSIZE);

  00023	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c80000
  0002b	f3 0f 11 45 fc	 movss	 DWORD PTR _fTerrainSize$[ebp], xmm0

; 1103 : 	float fXRef = fx - (float) (m_lCurCoordStartX);

  00030	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00033	f3 0f 2a 40 78	 cvtsi2ss xmm0, DWORD PTR [eax+120]
  00038	f3 0f 10 4d 08	 movss	 xmm1, DWORD PTR _fx$[ebp]
  0003d	f3 0f 5c c8	 subss	 xmm1, xmm0
  00041	f3 0f 11 4d f8	 movss	 DWORD PTR _fXRef$[ebp], xmm1

; 1104 : 	float fYRef = fy - (float) (m_lCurCoordStartY);

  00046	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00049	f3 0f 2a 40 7c	 cvtsi2ss xmm0, DWORD PTR [eax+124]
  0004e	f3 0f 10 4d 0c	 movss	 xmm1, DWORD PTR _fy$[ebp]
  00053	f3 0f 5c c8	 subss	 xmm1, xmm0
  00057	f3 0f 11 4d f0	 movss	 DWORD PTR _fYRef$[ebp], xmm1

; 1105 : 
; 1106 : 	CTerrain * pTerrain;
; 1107 : 
; 1108 : 	if (fYRef < -fTerrainSize)

  0005c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00061	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00068	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fYRef$[ebp]
  0006c	76 0d		 jbe	 SHORT $LN3@GetShadowM

; 1109 : 		return 0xFFFFFFFF;

  0006e	83 c8 ff	 or	 eax, -1
  00071	e9 7d 04 00 00	 jmp	 $LN1@GetShadowM
  00076	e9 75 04 00 00	 jmp	 $LN38@GetShadowM
$LN3@GetShadowM:

; 1110 : 	else if (fYRef >= -fTerrainSize && fYRef < 0.0f)

  0007b	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00080	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00087	f3 0f 10 4d f0	 movss	 xmm1, DWORD PTR _fYRef$[ebp]
  0008c	0f 2f c8	 comiss	 xmm1, xmm0
  0008f	0f 82 6e 01 00
	00		 jb	 $LN5@GetShadowM
  00095	0f 57 c0	 xorps	 xmm0, xmm0
  00098	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fYRef$[ebp]
  0009c	0f 86 61 01 00
	00		 jbe	 $LN5@GetShadowM

; 1111 : 	{
; 1112 : 		if (fXRef < -fTerrainSize)

  000a2	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  000a7	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000ae	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  000b2	76 0d		 jbe	 SHORT $LN7@GetShadowM

; 1113 : 			return 0xFFFFFFFF;

  000b4	83 c8 ff	 or	 eax, -1
  000b7	e9 37 04 00 00	 jmp	 $LN1@GetShadowM
  000bc	e9 3d 01 00 00	 jmp	 $LN18@GetShadowM
$LN7@GetShadowM:

; 1114 : 		else if (fXRef >= -fTerrainSize && fXRef < 0.0f)

  000c1	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  000c6	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  000cd	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fXRef$[ebp]
  000d2	0f 2f c8	 comiss	 xmm1, xmm0
  000d5	72 57		 jb	 SHORT $LN9@GetShadowM
  000d7	0f 57 c0	 xorps	 xmm0, xmm0
  000da	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  000de	76 4e		 jbe	 SHORT $LN9@GetShadowM

; 1115 : 		{
; 1116 : 			if (GetTerrainPointer(0, &pTerrain))

  000e0	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  000e3	50		 push	 eax
  000e4	6a 00		 push	 0
  000e6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e9	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  000ee	85 c0		 test	 eax, eax
  000f0	74 2f		 je	 SHORT $LN11@GetShadowM

; 1117 : 				return pTerrain->GetShadowMapColor(fXRef + fTerrainSize, fYRef + fTerrainSize);

  000f2	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  000f7	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  000fc	51		 push	 ecx
  000fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00102	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00107	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0010c	51		 push	 ecx
  0010d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00112	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00115	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  0011a	e9 d4 03 00 00	 jmp	 $LN1@GetShadowM
  0011f	eb 08		 jmp	 SHORT $LN12@GetShadowM
$LN11@GetShadowM:

; 1118 : 			else
; 1119 : 				return 0xFFFFFFFF;

  00121	83 c8 ff	 or	 eax, -1
  00124	e9 ca 03 00 00	 jmp	 $LN1@GetShadowM
$LN12@GetShadowM:

; 1120 : 		}

  00129	e9 d0 00 00 00	 jmp	 $LN18@GetShadowM
$LN9@GetShadowM:

; 1121 : 		else if (fXRef >= 0.0f && fXRef < fTerrainSize)

  0012e	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00133	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0013a	72 51		 jb	 SHORT $LN13@GetShadowM
  0013c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00141	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  00145	76 46		 jbe	 SHORT $LN13@GetShadowM

; 1122 : 		{
; 1123 : 			if (GetTerrainPointer(1, &pTerrain))

  00147	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  0014a	50		 push	 eax
  0014b	6a 01		 push	 1
  0014d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00155	85 c0		 test	 eax, eax
  00157	74 2a		 je	 SHORT $LN15@GetShadowM

; 1124 : 				return pTerrain->GetShadowMapColor(fXRef, fYRef + fTerrainSize);

  00159	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  0015e	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00163	51		 push	 ecx
  00164	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00169	51		 push	 ecx
  0016a	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  0016f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00174	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00177	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  0017c	e9 72 03 00 00	 jmp	 $LN1@GetShadowM
  00181	eb 08		 jmp	 SHORT $LN16@GetShadowM
$LN15@GetShadowM:

; 1125 : 			else
; 1126 : 				return 0xFFFFFFFF;

  00183	83 c8 ff	 or	 eax, -1
  00186	e9 68 03 00 00	 jmp	 $LN1@GetShadowM
$LN16@GetShadowM:

; 1127 : 		}

  0018b	eb 71		 jmp	 SHORT $LN18@GetShadowM
$LN13@GetShadowM:

; 1128 : 		else if (fXRef >= fTerrainSize && fXRef < 2.0f * fTerrainSize)

  0018d	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00192	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00196	72 5e		 jb	 SHORT $LN17@GetShadowM
  00198	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  001a0	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  001a5	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  001a9	76 4b		 jbe	 SHORT $LN17@GetShadowM

; 1129 : 		{
; 1130 : 			if (GetTerrainPointer(2, &pTerrain))

  001ab	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  001ae	50		 push	 eax
  001af	6a 02		 push	 2
  001b1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  001b9	85 c0		 test	 eax, eax
  001bb	74 2f		 je	 SHORT $LN19@GetShadowM

; 1131 : 				return pTerrain->GetShadowMapColor(fXRef - fTerrainSize, fYRef + fTerrainSize);

  001bd	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  001c2	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  001c7	51		 push	 ecx
  001c8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001cd	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  001d2	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  001d7	51		 push	 ecx
  001d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001dd	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  001e0	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  001e5	e9 09 03 00 00	 jmp	 $LN1@GetShadowM
  001ea	eb 08		 jmp	 SHORT $LN20@GetShadowM
$LN19@GetShadowM:

; 1132 : 			else
; 1133 : 				return 0xFFFFFFFF;

  001ec	83 c8 ff	 or	 eax, -1
  001ef	e9 ff 02 00 00	 jmp	 $LN1@GetShadowM
$LN20@GetShadowM:

; 1134 : 		}

  001f4	eb 08		 jmp	 SHORT $LN18@GetShadowM
$LN17@GetShadowM:

; 1135 : 		else
; 1136 : 			return 0xFFFFFFFF;

  001f6	83 c8 ff	 or	 eax, -1
  001f9	e9 f5 02 00 00	 jmp	 $LN1@GetShadowM
$LN18@GetShadowM:

; 1137 : 	}

  001fe	e9 ed 02 00 00	 jmp	 $LN38@GetShadowM
$LN5@GetShadowM:

; 1138 : 	else if (fYRef >= 0.0f && fYRef < fTerrainSize)

  00203	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  00208	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0020f	0f 82 61 01 00
	00		 jb	 $LN21@GetShadowM
  00215	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0021a	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fYRef$[ebp]
  0021e	0f 86 52 01 00
	00		 jbe	 $LN21@GetShadowM

; 1139 : 	{
; 1140 : 		if (fXRef < -fTerrainSize)

  00224	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00229	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00230	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  00234	76 0d		 jbe	 SHORT $LN23@GetShadowM

; 1141 : 			return 0xFFFFFFFF;

  00236	83 c8 ff	 or	 eax, -1
  00239	e9 b5 02 00 00	 jmp	 $LN1@GetShadowM
  0023e	e9 2e 01 00 00	 jmp	 $LN34@GetShadowM
$LN23@GetShadowM:

; 1142 : 		else if (fXRef >= -fTerrainSize && fXRef < 0.0f)

  00243	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00248	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0024f	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fXRef$[ebp]
  00254	0f 2f c8	 comiss	 xmm1, xmm0
  00257	72 52		 jb	 SHORT $LN25@GetShadowM
  00259	0f 57 c0	 xorps	 xmm0, xmm0
  0025c	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  00260	76 49		 jbe	 SHORT $LN25@GetShadowM

; 1143 : 		{
; 1144 : 			if (GetTerrainPointer(3, &pTerrain))

  00262	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00265	50		 push	 eax
  00266	6a 03		 push	 3
  00268	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0026b	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00270	85 c0		 test	 eax, eax
  00272	74 2a		 je	 SHORT $LN27@GetShadowM

; 1145 : 				return pTerrain->GetShadowMapColor(fXRef + fTerrainSize, fYRef);

  00274	51		 push	 ecx
  00275	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  0027a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00284	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00289	51		 push	 ecx
  0028a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028f	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00292	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  00297	e9 57 02 00 00	 jmp	 $LN1@GetShadowM
  0029c	eb 08		 jmp	 SHORT $LN28@GetShadowM
$LN27@GetShadowM:

; 1146 : 			else
; 1147 : 				return 0xFFFFFFFF;

  0029e	83 c8 ff	 or	 eax, -1
  002a1	e9 4d 02 00 00	 jmp	 $LN1@GetShadowM
$LN28@GetShadowM:

; 1148 : 		}

  002a6	e9 c6 00 00 00	 jmp	 $LN34@GetShadowM
$LN25@GetShadowM:

; 1149 : 		else if (fXRef >= 0.0f && fXRef < fTerrainSize)

  002ab	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  002b0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  002b7	72 4c		 jb	 SHORT $LN29@GetShadowM
  002b9	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  002be	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  002c2	76 41		 jbe	 SHORT $LN29@GetShadowM

; 1150 : 		{
; 1151 : 			if (GetTerrainPointer(4, &pTerrain))

  002c4	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  002c7	50		 push	 eax
  002c8	6a 04		 push	 4
  002ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  002d2	85 c0		 test	 eax, eax
  002d4	74 25		 je	 SHORT $LN31@GetShadowM

; 1152 : 				return pTerrain->GetShadowMapColor(fXRef, fYRef);

  002d6	51		 push	 ecx
  002d7	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  002dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002e1	51		 push	 ecx
  002e2	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  002e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ec	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  002ef	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  002f4	e9 fa 01 00 00	 jmp	 $LN1@GetShadowM
  002f9	eb 08		 jmp	 SHORT $LN32@GetShadowM
$LN31@GetShadowM:

; 1153 : 			else
; 1154 : 				return 0xFFFFFFFF;

  002fb	83 c8 ff	 or	 eax, -1
  002fe	e9 f0 01 00 00	 jmp	 $LN1@GetShadowM
$LN32@GetShadowM:

; 1155 : 		}

  00303	eb 6c		 jmp	 SHORT $LN34@GetShadowM
$LN29@GetShadowM:

; 1156 : 		else if (fXRef >= fTerrainSize && fXRef < 2.0f * fTerrainSize)

  00305	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  0030a	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0030e	72 59		 jb	 SHORT $LN33@GetShadowM
  00310	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00318	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0031d	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  00321	76 46		 jbe	 SHORT $LN33@GetShadowM

; 1157 : 		{
; 1158 : 			if (GetTerrainPointer(5, &pTerrain))

  00323	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00326	50		 push	 eax
  00327	6a 05		 push	 5
  00329	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0032c	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00331	85 c0		 test	 eax, eax
  00333	74 2a		 je	 SHORT $LN35@GetShadowM

; 1159 : 				return pTerrain->GetShadowMapColor(fXRef - fTerrainSize, fYRef);

  00335	51		 push	 ecx
  00336	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  0033b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00340	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00345	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0034a	51		 push	 ecx
  0034b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00350	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00353	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  00358	e9 96 01 00 00	 jmp	 $LN1@GetShadowM
  0035d	eb 08		 jmp	 SHORT $LN36@GetShadowM
$LN35@GetShadowM:

; 1160 : 			else
; 1161 : 				return 0xFFFFFFFF;

  0035f	83 c8 ff	 or	 eax, -1
  00362	e9 8c 01 00 00	 jmp	 $LN1@GetShadowM
$LN36@GetShadowM:

; 1162 : 		}

  00367	eb 08		 jmp	 SHORT $LN34@GetShadowM
$LN33@GetShadowM:

; 1163 : 		else
; 1164 : 			return 0xFFFFFFFF;

  00369	83 c8 ff	 or	 eax, -1
  0036c	e9 82 01 00 00	 jmp	 $LN1@GetShadowM
$LN34@GetShadowM:

; 1165 : 	}

  00371	e9 7a 01 00 00	 jmp	 $LN38@GetShadowM
$LN21@GetShadowM:

; 1166 : 	else if (fYRef >= fTerrainSize && fYRef < 2.0f * fTerrainSize)

  00376	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  0037b	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0037f	0f 82 66 01 00
	00		 jb	 $LN37@GetShadowM
  00385	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0038d	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00392	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fYRef$[ebp]
  00396	0f 86 4f 01 00
	00		 jbe	 $LN37@GetShadowM

; 1167 : 	{
; 1168 : 		if (fXRef < -fTerrainSize)

  0039c	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  003a1	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003a8	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  003ac	76 0d		 jbe	 SHORT $LN39@GetShadowM

; 1169 : 			return 0xFFFFFFFF;

  003ae	83 c8 ff	 or	 eax, -1
  003b1	e9 3d 01 00 00	 jmp	 $LN1@GetShadowM
  003b6	e9 2e 01 00 00	 jmp	 $LN50@GetShadowM
$LN39@GetShadowM:

; 1170 : 		else if (fXRef >= -fTerrainSize && fXRef < 0.0f)

  003bb	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  003c0	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  003c7	f3 0f 10 4d f8	 movss	 xmm1, DWORD PTR _fXRef$[ebp]
  003cc	0f 2f c8	 comiss	 xmm1, xmm0
  003cf	72 57		 jb	 SHORT $LN41@GetShadowM
  003d1	0f 57 c0	 xorps	 xmm0, xmm0
  003d4	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  003d8	76 4e		 jbe	 SHORT $LN41@GetShadowM

; 1171 : 		{
; 1172 : 			if (GetTerrainPointer(6, &pTerrain))

  003da	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  003dd	50		 push	 eax
  003de	6a 06		 push	 6
  003e0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003e3	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  003e8	85 c0		 test	 eax, eax
  003ea	74 2f		 je	 SHORT $LN43@GetShadowM

; 1173 : 				return pTerrain->GetShadowMapColor(fXRef + fTerrainSize, fYRef - fTerrainSize);

  003ec	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  003f1	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  003f6	51		 push	 ecx
  003f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fc	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00401	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00406	51		 push	 ecx
  00407	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0040c	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  0040f	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  00414	e9 da 00 00 00	 jmp	 $LN1@GetShadowM
  00419	eb 08		 jmp	 SHORT $LN44@GetShadowM
$LN43@GetShadowM:

; 1174 : 			else
; 1175 : 				return 0xFFFFFFFF;

  0041b	83 c8 ff	 or	 eax, -1
  0041e	e9 d0 00 00 00	 jmp	 $LN1@GetShadowM
$LN44@GetShadowM:

; 1176 : 		}

  00423	e9 c1 00 00 00	 jmp	 $LN50@GetShadowM
$LN41@GetShadowM:

; 1177 : 		else if (fXRef >= 0.0f && fXRef < fTerrainSize)

  00428	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  0042d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00434	72 4b		 jb	 SHORT $LN45@GetShadowM
  00436	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0043b	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  0043f	76 40		 jbe	 SHORT $LN45@GetShadowM

; 1178 : 		{
; 1179 : 			if (GetTerrainPointer(7, &pTerrain))

  00441	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00444	50		 push	 eax
  00445	6a 07		 push	 7
  00447	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0044a	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0044f	85 c0		 test	 eax, eax
  00451	74 27		 je	 SHORT $LN47@GetShadowM

; 1180 : 				return pTerrain->GetShadowMapColor(fXRef, fYRef - fTerrainSize);

  00453	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  00458	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0045d	51		 push	 ecx
  0045e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00463	51		 push	 ecx
  00464	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00469	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0046e	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  00471	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  00476	eb 7b		 jmp	 SHORT $LN1@GetShadowM
  00478	eb 05		 jmp	 SHORT $LN48@GetShadowM
$LN47@GetShadowM:

; 1181 : 			else
; 1182 : 				return 0xFFFFFFFF;

  0047a	83 c8 ff	 or	 eax, -1
  0047d	eb 74		 jmp	 SHORT $LN1@GetShadowM
$LN48@GetShadowM:

; 1183 : 		}

  0047f	eb 68		 jmp	 SHORT $LN50@GetShadowM
$LN45@GetShadowM:

; 1184 : 		else if (fXRef >= fTerrainSize && fXRef < 2.0f * fTerrainSize)

  00481	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  00486	0f 2f 45 fc	 comiss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  0048a	72 58		 jb	 SHORT $LN49@GetShadowM
  0048c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00494	f3 0f 59 45 fc	 mulss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  00499	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fXRef$[ebp]
  0049d	76 45		 jbe	 SHORT $LN49@GetShadowM

; 1185 : 		{
; 1186 : 			if (GetTerrainPointer(8, &pTerrain))

  0049f	8d 45 f4	 lea	 eax, DWORD PTR _pTerrain$[ebp]
  004a2	50		 push	 eax
  004a3	6a 08		 push	 8
  004a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004a8	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  004ad	85 c0		 test	 eax, eax
  004af	74 2c		 je	 SHORT $LN51@GetShadowM

; 1187 : 				return pTerrain->GetShadowMapColor(fXRef - fTerrainSize, fYRef - fTerrainSize);

  004b1	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fYRef$[ebp]
  004b6	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  004bb	51		 push	 ecx
  004bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c1	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fXRef$[ebp]
  004c6	f3 0f 5c 45 fc	 subss	 xmm0, DWORD PTR _fTerrainSize$[ebp]
  004cb	51		 push	 ecx
  004cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004d1	8b 4d f4	 mov	 ecx, DWORD PTR _pTerrain$[ebp]
  004d4	e8 00 00 00 00	 call	 ?GetShadowMapColor@CTerrainImpl@@QAEKMM@Z ; CTerrainImpl::GetShadowMapColor
  004d9	eb 18		 jmp	 SHORT $LN1@GetShadowM
  004db	eb 05		 jmp	 SHORT $LN52@GetShadowM
$LN51@GetShadowM:

; 1188 : 			else
; 1189 : 				return 0xFFFFFFFF;

  004dd	83 c8 ff	 or	 eax, -1
  004e0	eb 11		 jmp	 SHORT $LN1@GetShadowM
$LN52@GetShadowM:

; 1190 : 		}

  004e2	eb 05		 jmp	 SHORT $LN50@GetShadowM
$LN49@GetShadowM:

; 1191 : 		else
; 1192 : 			return 0xFFFFFFFF;

  004e4	83 c8 ff	 or	 eax, -1
  004e7	eb 0a		 jmp	 SHORT $LN1@GetShadowM
$LN50@GetShadowM:

; 1193 : 	}

  004e9	eb 05		 jmp	 SHORT $LN38@GetShadowM
$LN37@GetShadowM:

; 1194 : 	else
; 1195 : 		return 0xFFFFFFFF;

  004eb	83 c8 ff	 or	 eax, -1
  004ee	eb 03		 jmp	 SHORT $LN1@GetShadowM
$LN38@GetShadowM:

; 1196 : 
; 1197 : 	return 0xFFFFFFFF;

  004f0	83 c8 ff	 or	 eax, -1
$LN1@GetShadowM:

; 1198 : }

  004f3	c9		 leave
  004f4	c2 08 00	 ret	 8
?GetShadowMapColor@CMapOutdoor@@QAEKMM@Z ENDP		; CMapOutdoor::GetShadowMapColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetDrawCharacterShadow@CMapOutdoor@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDrawChrShadow$ = 8					; size = 1
?SetDrawCharacterShadow@CMapOutdoor@@QAEX_N@Z PROC	; CMapOutdoor::SetDrawCharacterShadow, COMDAT
; _this$ = ecx

; 1093 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1094 : 	m_bDrawChrShadow = bDrawChrShadow;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bDrawChrShadow$[ebp]
  0000d	88 88 32 01 00
	00		 mov	 BYTE PTR [eax+306], cl

; 1095 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetDrawCharacterShadow@CMapOutdoor@@QAEX_N@Z ENDP	; CMapOutdoor::SetDrawCharacterShadow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetDrawShadow@CMapOutdoor@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bDrawShadow$ = 8					; size = 1
?SetDrawShadow@CMapOutdoor@@QAEX_N@Z PROC		; CMapOutdoor::SetDrawShadow, COMDAT
; _this$ = ecx

; 1088 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1089 : 	m_bDrawShadow = bDrawShadow;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bDrawShadow$[ebp]
  0000d	88 88 31 01 00
	00		 mov	 BYTE PTR [eax+305], cl

; 1090 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetDrawShadow@CMapOutdoor@@QAEX_N@Z ENDP		; CMapOutdoor::SetDrawShadow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sTerrainCountX$ = 8					; size = 2
_sTerrainCountY$ = 12					; size = 2
?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z PROC		; CMapOutdoor::SetTerrainCount, COMDAT
; _this$ = ecx

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 235  : 	if (0 == sTerrainCountX || MAX_MAPSIZE < sTerrainCountX)

  00007	0f bf 45 08	 movsx	 eax, WORD PTR _sTerrainCountX$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	74 0b		 je	 SHORT $LN3@SetTerrain
  0000f	0f bf 45 08	 movsx	 eax, WORD PTR _sTerrainCountX$[ebp]
  00013	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00018	7e 04		 jle	 SHORT $LN2@SetTerrain
$LN3@SetTerrain:

; 236  : 		return false;

  0001a	32 c0		 xor	 al, al
  0001c	eb 2f		 jmp	 SHORT $LN1@SetTerrain
$LN2@SetTerrain:

; 237  : 	
; 238  : 	if (0 == sTerrainCountY || MAX_MAPSIZE < sTerrainCountY)

  0001e	0f bf 45 0c	 movsx	 eax, WORD PTR _sTerrainCountY$[ebp]
  00022	85 c0		 test	 eax, eax
  00024	74 0b		 je	 SHORT $LN5@SetTerrain
  00026	0f bf 45 0c	 movsx	 eax, WORD PTR _sTerrainCountY$[ebp]
  0002a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0002f	7e 04		 jle	 SHORT $LN4@SetTerrain
$LN5@SetTerrain:

; 239  : 		return false;

  00031	32 c0		 xor	 al, al
  00033	eb 18		 jmp	 SHORT $LN1@SetTerrain
$LN4@SetTerrain:

; 240  : 
; 241  : 	m_sTerrainCountX = sTerrainCountX;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	66 8b 4d 08	 mov	 cx, WORD PTR _sTerrainCountX$[ebp]
  0003c	66 89 48 70	 mov	 WORD PTR [eax+112], cx

; 242  : 	m_sTerrainCountY = sTerrainCountY;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	66 8b 4d 0c	 mov	 cx, WORD PTR _sTerrainCountY$[ebp]
  00047	66 89 48 72	 mov	 WORD PTR [eax+114], cx

; 243  : 	return true;

  0004b	b0 01		 mov	 al, 1
$LN1@SetTerrain:

; 244  : }

  0004d	c9		 leave
  0004e	c2 08 00	 ret	 8
?SetTerrainCount@CMapOutdoor@@QAE_NFF@Z ENDP		; CMapOutdoor::SetTerrainCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetPickingPoint@CMapOutdoor@@QAE_NPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_v3IntersectPt$ = 8					; size = 4
?GetPickingPoint@CMapOutdoor@@QAE_NPAUD3DXVECTOR3@@@Z PROC ; CMapOutdoor::GetPickingPoint, COMDAT
; _this$ = ecx

; 444  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 445  : 	return GetPickingPointWithRay(ms_Ray, v3IntersectPt);

  00007	ff 75 08	 push	 DWORD PTR _v3IntersectPt$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ?ms_Ray@CGraphicBase@@1VCRay@@A ; CGraphicBase::ms_Ray
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetPickingPointWithRay@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CMapOutdoor::GetPickingPointWithRay

; 446  : }

  00017	c9		 leave
  00018	c2 04 00	 ret	 4
?GetPickingPoint@CMapOutdoor@@QAE_NPAUD3DXVECTOR3@@@Z ENDP ; CMapOutdoor::GetPickingPoint
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Ray.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetPickingPointWithRayOnlyTerrain@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_c$ = -116						; size = 4
_b$ = -112						; size = 4
_a$ = -108						; size = 4
_c$ = -104						; size = 4
_b$ = -100						; size = 4
_a$ = -96						; size = 4
_this$ = -92						; size = 4
_fPos$ = -88						; size = 4
_fRayRange$ = -84					; size = 4
_bTerrainPick$ = -77					; size = 1
_v3Dir$ = -76						; size = 12
_v3dEnd$ = -64						; size = 12
_v3dStart$ = -52					; size = 12
_v3TerrainPick$ = -40					; size = 12
_v3End$ = -28						; size = 12
_v3Start$ = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
_rRay$ = 8						; size = 4
_v3IntersectPt$ = 12					; size = 4
?GetPickingPointWithRayOnlyTerrain@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z PROC ; CMapOutdoor::GetPickingPointWithRayOnlyTerrain, COMDAT
; _this$ = ecx

; 548  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 549  : 	bool bTerrainPick = false;

  00015	c6 45 b3 00	 mov	 BYTE PTR _bTerrainPick$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Ray.h

; 36   : 			*pv3Start = m_v3Start;

  00019	8b 75 08	 mov	 esi, DWORD PTR _rRay$[ebp]
  0001c	8d 7d f0	 lea	 edi, DWORD PTR _v3Start$[ebp]
  0001f	a5		 movsd
  00020	a5		 movsd
  00021	a5		 movsd

; 41   : 			*pv3Dir = m_v3Direction;

  00022	8b 75 08	 mov	 esi, DWORD PTR _rRay$[ebp]
  00025	83 c6 18	 add	 esi, 24			; 00000018H
  00028	8d 7d b4	 lea	 edi, DWORD PTR _v3Dir$[ebp]
  0002b	a5		 movsd
  0002c	a5		 movsd
  0002d	a5		 movsd

; 42   : 			*pfRayRange = m_fRayRange;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _rRay$[ebp]
  00031	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  00036	f3 0f 11 45 ac	 movss	 DWORD PTR _fRayRange$[ebp], xmm0

; 47   : 			*pv3End = m_v3End;

  0003b	8b 75 08	 mov	 esi, DWORD PTR _rRay$[ebp]
  0003e	83 c6 0c	 add	 esi, 12			; 0000000cH
  00041	8d 7d e4	 lea	 edi, DWORD PTR _v3End$[ebp]
  00044	a5		 movsd
  00045	a5		 movsd
  00046	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 559  : 	v3dStart.Set(v3Start.x, v3Start.y, v3Start.z);

  00047	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _v3Start$[ebp]
  0004c	f3 0f 11 45 a0	 movss	 DWORD PTR _a$[ebp], xmm0
  00051	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  00056	f3 0f 11 45 9c	 movss	 DWORD PTR _b$[ebp], xmm0
  0005b	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  00060	f3 0f 11 45 98	 movss	 DWORD PTR _c$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  00065	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _a$[ebp]
  0006a	f3 0f 11 45 cc	 movss	 DWORD PTR _v3dStart$[ebp], xmm0

; 108  : 		y = b;

  0006f	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _b$[ebp]
  00074	f3 0f 11 45 d0	 movss	 DWORD PTR _v3dStart$[ebp+4], xmm0

; 109  : 		z = c;

  00079	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _c$[ebp]
  0007e	f3 0f 11 45 d4	 movss	 DWORD PTR _v3dStart$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 560  : 	v3dEnd.Set(v3End.x - v3Start.x, v3End.y - v3Start.y, v3End.z - v3Start.z);

  00083	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _v3End$[ebp]
  00088	f3 0f 5c 45 f0	 subss	 xmm0, DWORD PTR _v3Start$[ebp]
  0008d	f3 0f 11 45 94	 movss	 DWORD PTR _a$[ebp], xmm0
  00092	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _v3End$[ebp+4]
  00097	f3 0f 5c 45 f4	 subss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  0009c	f3 0f 11 45 90	 movss	 DWORD PTR _b$[ebp], xmm0
  000a1	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v3End$[ebp+8]
  000a6	f3 0f 5c 45 f8	 subss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  000ab	f3 0f 11 45 8c	 movss	 DWORD PTR _c$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  000b0	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _a$[ebp]
  000b5	f3 0f 11 45 c0	 movss	 DWORD PTR _v3dEnd$[ebp], xmm0

; 108  : 		y = b;

  000ba	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _b$[ebp]
  000bf	f3 0f 11 45 c4	 movss	 DWORD PTR _v3dEnd$[ebp+4], xmm0

; 109  : 		z = c;

  000c4	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _c$[ebp]
  000c9	f3 0f 11 45 c8	 movss	 DWORD PTR _v3dEnd$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 564  : 	float fPos = 0.0f;	

  000ce	0f 57 c0	 xorps	 xmm0, xmm0
  000d1	f3 0f 11 45 a8	 movss	 DWORD PTR _fPos$[ebp], xmm0

; 565  : 	bTerrainPick=true;

  000d6	c6 45 b3 01	 mov	 BYTE PTR _bTerrainPick$[ebp], 1

; 566  : 	if (!__PickTerrainHeight(fPos, v3Start, v3End, 5.0f, fRayRange, 5000.0f, &v3TerrainPick))

  000da	8d 45 d8	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  000dd	50		 push	 eax
  000de	51		 push	 ecx
  000df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  000e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ec	51		 push	 ecx
  000ed	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  000f2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f7	51		 push	 ecx
  000f8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  00100	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00105	8d 45 e4	 lea	 eax, DWORD PTR _v3End$[ebp]
  00108	50		 push	 eax
  00109	8d 45 f0	 lea	 eax, DWORD PTR _v3Start$[ebp]
  0010c	50		 push	 eax
  0010d	8d 45 a8	 lea	 eax, DWORD PTR _fPos$[ebp]
  00110	50		 push	 eax
  00111	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  00119	0f b6 c0	 movzx	 eax, al
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 90 00 00
	00		 jne	 $LN4@GetPicking

; 567  : 		if (!__PickTerrainHeight(fPos, v3Start, v3End, 10.0f, fRayRange, 10000.0f, &v3TerrainPick))

  00124	8d 45 d8	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  00127	50		 push	 eax
  00128	51		 push	 ecx
  00129	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  00131	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00136	51		 push	 ecx
  00137	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  0013c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00141	51		 push	 ecx
  00142	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  0014a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0014f	8d 45 e4	 lea	 eax, DWORD PTR _v3End$[ebp]
  00152	50		 push	 eax
  00153	8d 45 f0	 lea	 eax, DWORD PTR _v3Start$[ebp]
  00156	50		 push	 eax
  00157	8d 45 a8	 lea	 eax, DWORD PTR _fPos$[ebp]
  0015a	50		 push	 eax
  0015b	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  00163	0f b6 c0	 movzx	 eax, al
  00166	85 c0		 test	 eax, eax
  00168	75 4a		 jne	 SHORT $LN4@GetPicking

; 568  : 			if (!__PickTerrainHeight(fPos, v3Start, v3End, 100.0f, fRayRange, 100000.0f, &v3TerrainPick))

  0016a	8d 45 d8	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  0016d	50		 push	 eax
  0016e	51		 push	 ecx
  0016f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@47c35000
  00177	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0017c	51		 push	 ecx
  0017d	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  00182	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00187	51		 push	 ecx
  00188	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  00190	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00195	8d 45 e4	 lea	 eax, DWORD PTR _v3End$[ebp]
  00198	50		 push	 eax
  00199	8d 45 f0	 lea	 eax, DWORD PTR _v3Start$[ebp]
  0019c	50		 push	 eax
  0019d	8d 45 a8	 lea	 eax, DWORD PTR _fPos$[ebp]
  001a0	50		 push	 eax
  001a1	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  001a9	0f b6 c0	 movzx	 eax, al
  001ac	85 c0		 test	 eax, eax
  001ae	75 04		 jne	 SHORT $LN4@GetPicking

; 569  : 					bTerrainPick=false;

  001b0	c6 45 b3 00	 mov	 BYTE PTR _bTerrainPick$[ebp], 0
$LN4@GetPicking:

; 570  : 	
; 571  : 	if (bTerrainPick)

  001b4	0f b6 45 b3	 movzx	 eax, BYTE PTR _bTerrainPick$[ebp]
  001b8	85 c0		 test	 eax, eax
  001ba	74 0d		 je	 SHORT $LN5@GetPicking

; 572  : 	{
; 573  : 		*v3IntersectPt = v3TerrainPick;

  001bc	8d 75 d8	 lea	 esi, DWORD PTR _v3TerrainPick$[ebp]
  001bf	8b 7d 0c	 mov	 edi, DWORD PTR _v3IntersectPt$[ebp]
  001c2	a5		 movsd
  001c3	a5		 movsd
  001c4	a5		 movsd

; 574  : 		return true;

  001c5	b0 01		 mov	 al, 1
  001c7	eb 02		 jmp	 SHORT $LN1@GetPicking
$LN5@GetPicking:

; 575  : 	}
; 576  : 	
; 577  : 	return false;

  001c9	32 c0		 xor	 al, al
$LN1@GetPicking:

; 578  : }

  001cb	5f		 pop	 edi
  001cc	5e		 pop	 esi
  001cd	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d0	33 cd		 xor	 ecx, ebp
  001d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d7	c9		 leave
  001d8	c2 08 00	 ret	 8
?GetPickingPointWithRayOnlyTerrain@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ENDP ; CMapOutdoor::GetPickingPointWithRayOnlyTerrain
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Ray.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetPickingPointWithRay@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_fx$ = -128						; size = 4
_c$ = -124						; size = 4
_a$ = -120						; size = 4
_b$ = -116						; size = 4
_c$ = -112						; size = 4
_rkCullingMgr$1 = -108					; size = 4
_fx$ = -104						; size = 4
_fy$ = -100						; size = 4
_fz$ = -96						; size = 4
__X$ = -92						; size = 4
tv719 = -88						; size = 4
$T2 = -84						; size = 4
tv718 = -80						; size = 4
__X$ = -76						; size = 4
_fz$ = -72						; size = 4
_fy$ = -68						; size = 4
_b$ = -64						; size = 4
_a$ = -60						; size = 4
_fPos$ = -56						; size = 4
_fRayRange$ = -52					; size = 4
_this$ = -48						; size = 4
_bObjectPick$ = -42					; size = 1
_bTerrainPick$ = -41					; size = 1
_kGetPickingPoint$3 = -40				; size = 40
_v3Dir$ = 0						; size = 12
_v3dEnd$ = 12						; size = 12
_v3dStart$ = 24						; size = 12
_v3ObjectPick$ = 36					; size = 12
_v3End$ = 48						; size = 12
_v3TerrainPick$ = 60					; size = 12
$T4 = 72						; size = 12
$T5 = 84						; size = 12
_v3Start$ = 96						; size = 12
__$ArrayPad$ = 108					; size = 4
_rRay$ = 120						; size = 4
_v3IntersectPt$ = 124					; size = 4
?GetPickingPointWithRay@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z PROC ; CMapOutdoor::GetPickingPointWithRay, COMDAT
; _this$ = ecx

; 485  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 486  : 	bool bObjectPick = false;

  0001a	c6 45 d6 00	 mov	 BYTE PTR _bObjectPick$[ebp], 0

; 487  : 	bool bTerrainPick = false;

  0001e	c6 45 d7 00	 mov	 BYTE PTR _bTerrainPick$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Ray.h

; 36   : 			*pv3Start = m_v3Start;

  00022	8b 75 78	 mov	 esi, DWORD PTR _rRay$[ebp]
  00025	8d 7d 60	 lea	 edi, DWORD PTR _v3Start$[ebp]
  00028	a5		 movsd
  00029	a5		 movsd
  0002a	a5		 movsd

; 41   : 			*pv3Dir = m_v3Direction;

  0002b	8b 75 78	 mov	 esi, DWORD PTR _rRay$[ebp]
  0002e	83 c6 18	 add	 esi, 24			; 00000018H
  00031	8d 7d 00	 lea	 edi, DWORD PTR _v3Dir$[ebp]
  00034	a5		 movsd
  00035	a5		 movsd
  00036	a5		 movsd

; 42   : 			*pfRayRange = m_fRayRange;

  00037	8b 45 78	 mov	 eax, DWORD PTR _rRay$[ebp]
  0003a	f3 0f 10 40 24	 movss	 xmm0, DWORD PTR [eax+36]
  0003f	f3 0f 11 45 cc	 movss	 DWORD PTR _fRayRange$[ebp], xmm0

; 47   : 			*pv3End = m_v3End;

  00044	8b 75 78	 mov	 esi, DWORD PTR _rRay$[ebp]
  00047	83 c6 0c	 add	 esi, 12			; 0000000cH
  0004a	8d 7d 30	 lea	 edi, DWORD PTR _v3End$[ebp]
  0004d	a5		 movsd
  0004e	a5		 movsd
  0004f	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 497  : 	v3dStart.Set(v3Start.x, v3Start.y, v3Start.z);

  00050	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3Start$[ebp]
  00055	f3 0f 11 45 c4	 movss	 DWORD PTR _a$[ebp], xmm0
  0005a	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  0005f	f3 0f 11 45 c0	 movss	 DWORD PTR _b$[ebp], xmm0
  00064	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  00069	f3 0f 11 45 84	 movss	 DWORD PTR _c$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  0006e	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _a$[ebp]
  00073	f3 0f 11 45 18	 movss	 DWORD PTR _v3dStart$[ebp], xmm0

; 108  : 		y = b;

  00078	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _b$[ebp]
  0007d	f3 0f 11 45 1c	 movss	 DWORD PTR _v3dStart$[ebp+4], xmm0

; 109  : 		z = c;

  00082	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _c$[ebp]
  00087	f3 0f 11 45 20	 movss	 DWORD PTR _v3dStart$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 498  : 	v3dEnd.Set(v3End.x - v3Start.x, v3End.y - v3Start.y, v3End.z - v3Start.z);

  0008c	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR _v3End$[ebp]
  00091	f3 0f 5c 45 60	 subss	 xmm0, DWORD PTR _v3Start$[ebp]
  00096	f3 0f 11 45 88	 movss	 DWORD PTR _a$[ebp], xmm0
  0009b	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _v3End$[ebp+4]
  000a0	f3 0f 5c 45 64	 subss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  000a5	f3 0f 11 45 8c	 movss	 DWORD PTR _b$[ebp], xmm0
  000aa	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR _v3End$[ebp+8]
  000af	f3 0f 5c 45 68	 subss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  000b4	f3 0f 11 45 90	 movss	 DWORD PTR _c$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  000b9	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR _a$[ebp]
  000be	f3 0f 11 45 0c	 movss	 DWORD PTR _v3dEnd$[ebp], xmm0

; 108  : 		y = b;

  000c3	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _b$[ebp]
  000c8	f3 0f 11 45 10	 movss	 DWORD PTR _v3dEnd$[ebp+4], xmm0

; 109  : 		z = c;

  000cd	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _c$[ebp]
  000d2	f3 0f 11 45 14	 movss	 DWORD PTR _v3dEnd$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 500  : 	if (!m_bEnableTerrainOnlyForHeight)

  000d7	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000da	0f b6 80 b6 0e
	00 00		 movzx	 eax, BYTE PTR [eax+3766]
  000e1	85 c0		 test	 eax, eax
  000e3	75 43		 jne	 SHORT $LN3@GetPicking

; 501  : 	{
; 502  : 		//DWORD baseTime = timeGetTime();
; 503  : 		CCullingManager & rkCullingMgr = CCullingManager::Instance();

  000e5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  000ea	89 45 94	 mov	 DWORD PTR _rkCullingMgr$1[ebp], eax

; 45   : 	FGetPickingPoint(D3DXVECTOR3 & v3Start, D3DXVECTOR3 & v3Dir) : m_v3Start(v3Start), m_v3Dir(v3Dir), m_bPicked(false) {}

  000ed	8d 7d d8	 lea	 edi, DWORD PTR _kGetPickingPoint$3[ebp]
  000f0	8d 75 60	 lea	 esi, DWORD PTR _v3Start$[ebp]
  000f3	a5		 movsd
  000f4	a5		 movsd
  000f5	a5		 movsd
  000f6	8d 7d e4	 lea	 edi, DWORD PTR _kGetPickingPoint$3[ebp+12]
  000f9	8d 75 00	 lea	 esi, DWORD PTR _v3Dir$[ebp]
  000fc	a5		 movsd
  000fd	a5		 movsd
  000fe	a5		 movsd
  000ff	c6 45 fc 00	 mov	 BYTE PTR _kGetPickingPoint$3[ebp+36], 0

; 504  : 		FGetPickingPoint kGetPickingPoint(v3Start, v3Dir);	
; 505  : 		rkCullingMgr.ForInRange2d(v3dStart, &kGetPickingPoint);

  00103	8d 45 d8	 lea	 eax, DWORD PTR _kGetPickingPoint$3[ebp]
  00106	50		 push	 eax
  00107	8d 45 18	 lea	 eax, DWORD PTR _v3dStart$[ebp]
  0010a	50		 push	 eax
  0010b	8b 4d 94	 mov	 ecx, DWORD PTR _rkCullingMgr$1[ebp]
  0010e	e8 00 00 00 00	 call	 ??$ForInRange2d@UFGetPickingPoint@@@CCullingManager@@QAEXABVVector3d@@PAUFGetPickingPoint@@@Z ; CCullingManager::ForInRange2d<FGetPickingPoint>

; 506  : 
; 507  : 		if (kGetPickingPoint.m_bPicked)

  00113	0f b6 45 fc	 movzx	 eax, BYTE PTR _kGetPickingPoint$3[ebp+36]
  00117	85 c0		 test	 eax, eax
  00119	74 0d		 je	 SHORT $LN3@GetPicking

; 508  : 		{
; 509  : 			bObjectPick = true;

  0011b	c6 45 d6 01	 mov	 BYTE PTR _bObjectPick$[ebp], 1

; 510  : 			v3ObjectPick = kGetPickingPoint.m_v3PickingPoint;

  0011f	8d 75 f0	 lea	 esi, DWORD PTR _kGetPickingPoint$3[ebp+24]
  00122	8d 7d 24	 lea	 edi, DWORD PTR _v3ObjectPick$[ebp]
  00125	a5		 movsd
  00126	a5		 movsd
  00127	a5		 movsd
$LN3@GetPicking:

; 511  : 		}		
; 512  : 	}	
; 513  : 	
; 514  : 	float fPos = 0.0f;

  00128	0f 57 c0	 xorps	 xmm0, xmm0
  0012b	f3 0f 11 45 c8	 movss	 DWORD PTR _fPos$[ebp], xmm0

; 515  : 	//float fStep = 1.0f;
; 516  : 	//float fRayRangeInv=1.0f/fRayRange;
; 517  : 
; 518  : 	bTerrainPick=true;

  00130	c6 45 d7 01	 mov	 BYTE PTR _bTerrainPick$[ebp], 1

; 519  : 	if (!__PickTerrainHeight(fPos, v3Start, v3End, 5.0f, fRayRange, 5000.0f, &v3TerrainPick))

  00134	8d 45 3c	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  00137	50		 push	 eax
  00138	51		 push	 ecx
  00139	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  00141	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00146	51		 push	 ecx
  00147	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  0014c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00151	51		 push	 ecx
  00152	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40a00000
  0015a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0015f	8d 45 30	 lea	 eax, DWORD PTR _v3End$[ebp]
  00162	50		 push	 eax
  00163	8d 45 60	 lea	 eax, DWORD PTR _v3Start$[ebp]
  00166	50		 push	 eax
  00167	8d 45 c8	 lea	 eax, DWORD PTR _fPos$[ebp]
  0016a	50		 push	 eax
  0016b	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  00173	0f b6 c0	 movzx	 eax, al
  00176	85 c0		 test	 eax, eax
  00178	0f 85 90 00 00
	00		 jne	 $LN6@GetPicking

; 520  : 		if (!__PickTerrainHeight(fPos, v3Start, v3End, 10.0f, fRayRange, 10000.0f, &v3TerrainPick))

  0017e	8d 45 3c	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  00181	50		 push	 eax
  00182	51		 push	 ecx
  00183	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	51		 push	 ecx
  00191	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  00196	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0019b	51		 push	 ecx
  0019c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41200000
  001a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a9	8d 45 30	 lea	 eax, DWORD PTR _v3End$[ebp]
  001ac	50		 push	 eax
  001ad	8d 45 60	 lea	 eax, DWORD PTR _v3Start$[ebp]
  001b0	50		 push	 eax
  001b1	8d 45 c8	 lea	 eax, DWORD PTR _fPos$[ebp]
  001b4	50		 push	 eax
  001b5	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001b8	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  001bd	0f b6 c0	 movzx	 eax, al
  001c0	85 c0		 test	 eax, eax
  001c2	75 4a		 jne	 SHORT $LN6@GetPicking

; 521  : 			if (!__PickTerrainHeight(fPos, v3Start, v3End, 100.0f, fRayRange, 100000.0f, &v3TerrainPick))

  001c4	8d 45 3c	 lea	 eax, DWORD PTR _v3TerrainPick$[ebp]
  001c7	50		 push	 eax
  001c8	51		 push	 ecx
  001c9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@47c35000
  001d1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d6	51		 push	 ecx
  001d7	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fRayRange$[ebp]
  001dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e1	51		 push	 ecx
  001e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42c80000
  001ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001ef	8d 45 30	 lea	 eax, DWORD PTR _v3End$[ebp]
  001f2	50		 push	 eax
  001f3	8d 45 60	 lea	 eax, DWORD PTR _v3Start$[ebp]
  001f6	50		 push	 eax
  001f7	8d 45 c8	 lea	 eax, DWORD PTR _fPos$[ebp]
  001fa	50		 push	 eax
  001fb	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fe	e8 00 00 00 00	 call	 ?__PickTerrainHeight@CMapOutdoor@@IAE_NAAMABUD3DXVECTOR3@@1MMMPAU2@@Z ; CMapOutdoor::__PickTerrainHeight
  00203	0f b6 c0	 movzx	 eax, al
  00206	85 c0		 test	 eax, eax
  00208	75 04		 jne	 SHORT $LN6@GetPicking

; 522  : 					bTerrainPick=false;

  0020a	c6 45 d7 00	 mov	 BYTE PTR _bTerrainPick$[ebp], 0
$LN6@GetPicking:

; 523  : 	
; 524  : 	
; 525  : 	if (bObjectPick && bTerrainPick)

  0020e	0f b6 45 d6	 movzx	 eax, BYTE PTR _bObjectPick$[ebp]
  00212	85 c0		 test	 eax, eax
  00214	0f 84 4f 01 00
	00		 je	 $LN7@GetPicking
  0021a	0f b6 45 d7	 movzx	 eax, BYTE PTR _bTerrainPick$[ebp]
  0021e	85 c0		 test	 eax, eax
  00220	0f 84 43 01 00
	00		 je	 $LN7@GetPicking
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00226	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _v3ObjectPick$[ebp]
  0022b	f3 0f 5c 45 60	 subss	 xmm0, DWORD PTR _v3Start$[ebp]
  00230	f3 0f 11 45 98	 movss	 DWORD PTR _fx$[ebp], xmm0
  00235	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _v3ObjectPick$[ebp+4]
  0023a	f3 0f 5c 45 64	 subss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  0023f	f3 0f 11 45 9c	 movss	 DWORD PTR _fy$[ebp], xmm0
  00244	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR _v3ObjectPick$[ebp+8]
  00249	f3 0f 5c 45 68	 subss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  0024e	f3 0f 11 45 a0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00253	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00258	f3 0f 11 45 48	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  0025d	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00262	f3 0f 11 45 4c	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  00267	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0026c	f3 0f 11 45 50	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00271	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR $T4[ebp+8]
  00276	f3 0f 59 45 50	 mulss	 xmm0, DWORD PTR $T4[ebp+8]
  0027b	f3 0f 10 4d 4c	 movss	 xmm1, DWORD PTR $T4[ebp+4]
  00280	f3 0f 59 4d 4c	 mulss	 xmm1, DWORD PTR $T4[ebp+4]
  00285	f3 0f 10 55 48	 movss	 xmm2, DWORD PTR $T4[ebp]
  0028a	f3 0f 59 55 48	 mulss	 xmm2, DWORD PTR $T4[ebp]
  0028f	f3 0f 58 d1	 addss	 xmm2, xmm1
  00293	f3 0f 58 d0	 addss	 xmm2, xmm0
  00297	f3 0f 11 55 a4	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0029c	f3 0f 5a 45 a4	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  002a1	51		 push	 ecx
  002a2	51		 push	 ecx
  002a3	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  002a8	e8 00 00 00 00	 call	 _sqrt
  002ad	59		 pop	 ecx
  002ae	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  002af	d9 5d ac	 fstp	 DWORD PTR $T2[ebp]

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  002b2	f3 0f 10 45 3c	 movss	 xmm0, DWORD PTR _v3TerrainPick$[ebp]
  002b7	f3 0f 5c 45 60	 subss	 xmm0, DWORD PTR _v3Start$[ebp]
  002bc	f3 0f 11 45 80	 movss	 DWORD PTR _fx$[ebp], xmm0
  002c1	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR _v3TerrainPick$[ebp+4]
  002c6	f3 0f 5c 45 64	 subss	 xmm0, DWORD PTR _v3Start$[ebp+4]
  002cb	f3 0f 11 45 bc	 movss	 DWORD PTR _fy$[ebp], xmm0
  002d0	f3 0f 10 45 44	 movss	 xmm0, DWORD PTR _v3TerrainPick$[ebp+8]
  002d5	f3 0f 5c 45 68	 subss	 xmm0, DWORD PTR _v3Start$[ebp+8]
  002da	f3 0f 11 45 b8	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002df	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002e4	f3 0f 11 45 54	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  002e9	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002ee	f3 0f 11 45 58	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  002f3	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002f8	f3 0f 11 45 5c	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  002fd	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR $T5[ebp+8]
  00302	f3 0f 59 45 5c	 mulss	 xmm0, DWORD PTR $T5[ebp+8]
  00307	f3 0f 10 4d 58	 movss	 xmm1, DWORD PTR $T5[ebp+4]
  0030c	f3 0f 59 4d 58	 mulss	 xmm1, DWORD PTR $T5[ebp+4]
  00311	f3 0f 10 55 54	 movss	 xmm2, DWORD PTR $T5[ebp]
  00316	f3 0f 59 55 54	 mulss	 xmm2, DWORD PTR $T5[ebp]
  0031b	f3 0f 58 d1	 addss	 xmm2, xmm1
  0031f	f3 0f 58 d0	 addss	 xmm2, xmm0
  00323	f3 0f 11 55 b4	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00328	f3 0f 5a 45 b4	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0032d	51		 push	 ecx
  0032e	51		 push	 ecx
  0032f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00334	e8 00 00 00 00	 call	 _sqrt
  00339	59		 pop	 ecx
  0033a	59		 pop	 ecx
  0033b	d9 5d b0	 fstp	 DWORD PTR tv718[ebp]
  0033e	d9 45 b0	 fld	 DWORD PTR tv718[ebp]
  00341	d9 5d a8	 fstp	 DWORD PTR tv719[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 527  : 		if ( D3DXVec3Length( &(v3ObjectPick - v3Start) ) >= D3DXVec3Length( &(v3TerrainPick - v3Start) ) )

  00344	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR $T2[ebp]
  00349	0f 2f 45 a8	 comiss	 xmm0, DWORD PTR tv719[ebp]
  0034d	72 0b		 jb	 SHORT $LN9@GetPicking

; 528  : 			*v3IntersectPt = v3TerrainPick;

  0034f	8d 75 3c	 lea	 esi, DWORD PTR _v3TerrainPick$[ebp]
  00352	8b 7d 7c	 mov	 edi, DWORD PTR _v3IntersectPt$[ebp]
  00355	a5		 movsd
  00356	a5		 movsd
  00357	a5		 movsd
  00358	eb 09		 jmp	 SHORT $LN10@GetPicking
$LN9@GetPicking:

; 529  : 		else
; 530  : 			*v3IntersectPt = v3ObjectPick;

  0035a	8d 75 24	 lea	 esi, DWORD PTR _v3ObjectPick$[ebp]
  0035d	8b 7d 7c	 mov	 edi, DWORD PTR _v3IntersectPt$[ebp]
  00360	a5		 movsd
  00361	a5		 movsd
  00362	a5		 movsd
$LN10@GetPicking:

; 531  : 		return true;

  00363	b0 01		 mov	 al, 1
  00365	eb 30		 jmp	 SHORT $LN1@GetPicking

; 532  : 	}

  00367	eb 2c		 jmp	 SHORT $LN13@GetPicking
$LN7@GetPicking:

; 533  : 	else if (bObjectPick)

  00369	0f b6 45 d6	 movzx	 eax, BYTE PTR _bObjectPick$[ebp]
  0036d	85 c0		 test	 eax, eax
  0036f	74 0f		 je	 SHORT $LN11@GetPicking

; 534  : 	{
; 535  : 		*v3IntersectPt = v3ObjectPick;

  00371	8d 75 24	 lea	 esi, DWORD PTR _v3ObjectPick$[ebp]
  00374	8b 7d 7c	 mov	 edi, DWORD PTR _v3IntersectPt$[ebp]
  00377	a5		 movsd
  00378	a5		 movsd
  00379	a5		 movsd

; 536  : 		return true;

  0037a	b0 01		 mov	 al, 1
  0037c	eb 19		 jmp	 SHORT $LN1@GetPicking

; 537  : 	}

  0037e	eb 15		 jmp	 SHORT $LN13@GetPicking
$LN11@GetPicking:

; 538  : 	else if (bTerrainPick)

  00380	0f b6 45 d7	 movzx	 eax, BYTE PTR _bTerrainPick$[ebp]
  00384	85 c0		 test	 eax, eax
  00386	74 0d		 je	 SHORT $LN13@GetPicking

; 539  : 	{
; 540  : 		*v3IntersectPt = v3TerrainPick;

  00388	8d 75 3c	 lea	 esi, DWORD PTR _v3TerrainPick$[ebp]
  0038b	8b 7d 7c	 mov	 edi, DWORD PTR _v3IntersectPt$[ebp]
  0038e	a5		 movsd
  0038f	a5		 movsd
  00390	a5		 movsd

; 541  : 		return true;

  00391	b0 01		 mov	 al, 1
  00393	eb 02		 jmp	 SHORT $LN1@GetPicking
$LN13@GetPicking:

; 542  : 	}
; 543  : 	
; 544  : 	return false;

  00395	32 c0		 xor	 al, al
$LN1@GetPicking:

; 545  : }

  00397	5f		 pop	 edi
  00398	5e		 pop	 esi
  00399	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0039c	33 cd		 xor	 ecx, ebp
  0039e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a3	83 c5 70	 add	 ebp, 112		; 00000070H
  003a6	c9		 leave
  003a7	c2 08 00	 ret	 8
?GetPickingPointWithRay@CMapOutdoor@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ENDP ; CMapOutdoor::GetPickingPointWithRay
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?IsWireframe@CMapOutdoor@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWireframe@CMapOutdoor@@QAE_NXZ PROC			; CMapOutdoor::IsWireframe, COMDAT
; _this$ = ecx

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 349  : 	return m_bDrawWireFrame;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 30 01 00
	00		 mov	 al, BYTE PTR [eax+304]

; 350  : }

  00010	c9		 leave
  00011	c3		 ret	 0
?IsWireframe@CMapOutdoor@@QAE_NXZ ENDP			; CMapOutdoor::IsWireframe
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetWireframe@CMapOutdoor@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bWireFrame$ = 8					; size = 1
?SetWireframe@CMapOutdoor@@QAEX_N@Z PROC		; CMapOutdoor::SetWireframe, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : 	m_bDrawWireFrame = bWireFrame;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bWireFrame$[ebp]
  0000d	88 88 30 01 00
	00		 mov	 BYTE PTR [eax+304], cl

; 345  : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetWireframe@CMapOutdoor@@QAEX_N@Z ENDP		; CMapOutdoor::SetWireframe
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?DisableMarkedArea@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?DisableMarkedArea@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::DisableMarkedArea, COMDAT
; _this$ = ecx

; 1536 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1537 : 	for (int i = 0; i < AROUND_AREA_NUM; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@DisableMar
$LN2@DisableMar:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@DisableMar:
  00015	83 7d fc 09	 cmp	 DWORD PTR _i$1[ebp], 9
  00019	7d 20		 jge	 SHORT $LN1@DisableMar

; 1538 : 	{
; 1539 : 		if (!m_pTerrain[i])

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 7c 81 40 00	 cmp	 DWORD PTR [ecx+eax*4+64], 0
  00026	75 02		 jne	 SHORT $LN5@DisableMar

; 1540 : 			continue;

  00028	eb e4		 jmp	 SHORT $LN2@DisableMar
$LN5@DisableMar:

; 1541 : 
; 1542 : 		m_pTerrain[i]->DeallocateMarkedSplats();

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 4c 81 40	 mov	 ecx, DWORD PTR [ecx+eax*4+64]
  00034	e8 00 00 00 00	 call	 ?DeallocateMarkedSplats@CTerrain@@QAEXXZ ; CTerrain::DeallocateMarkedSplats

; 1543 : 	}

  00039	eb d3		 jmp	 SHORT $LN2@DisableMar
$LN1@DisableMar:

; 1544 : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?DisableMarkedArea@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::DisableMarkedArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?VisibleMarkedArea@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T2 = -200						; size = 8
$T3 = -192						; size = 8
_kSet_iProcessedMapIndex$ = -184			; size = 8
$T4 = -176						; size = 4
$T5 = -172						; size = 4
_pTerrain$6 = -168					; size = 4
___param0$ = -164					; size = 4
_pTerrain$7 = -160					; size = 4
_pbyBuf$8 = -156					; size = 4
_byTerrainNum$9 = -152					; size = 1
_ixTerrain$10 = -148					; size = 4
_iyTerrain$11 = -144					; size = 4
$T12 = -140						; size = 4
$T13 = -136						; size = 4
$T14 = -132						; size = 4
$T15 = -128						; size = 4
$T16 = -124						; size = 4
$T17 = -120						; size = 4
$T18 = -116						; size = 4
$T19 = -112						; size = 4
$T20 = -108						; size = 4
$T21 = -104						; size = 4
$T22 = -100						; size = 4
$T23 = -96						; size = 4
___param0$ = -92					; size = 4
__Scary$24 = -88					; size = 4
$T25 = -84						; size = 4
___param0$ = -80					; size = 4
__Scary$26 = -76					; size = 4
$T27 = -72						; size = 4
_pbyBuf$28 = -68					; size = 4
_ixLocalCell$29 = -64					; size = 4
_iyLocalCell$30 = -60					; size = 4
$T31 = -56						; size = 4
__Right$ = -52						; size = 4
$T32 = -48						; size = 4
$T33 = -44						; size = 4
___param0$ = -40					; size = 4
__Scary$34 = -36					; size = 4
$T35 = -32						; size = 4
_byTerrainNum$36 = -28					; size = 1
$T37 = -24						; size = 4
$T38 = -20						; size = 4
$T39 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_iTerrainNum$40 = 0					; size = 4
tv541 = 4						; size = 4
tv568 = 8						; size = 4
_pbyBuf$41 = 12						; size = 4
tv491 = 16						; size = 4
_ixTerrain$42 = 20					; size = 4
_iyTerrain$43 = 24					; size = 4
tv375 = 28						; size = 4
tv399 = 32						; size = 4
_this$ = 36						; size = 4
_iTerrainNum$44 = 40					; size = 4
_iy2Cell$45 = 44					; size = 4
_iy1Cell$46 = 48					; size = 4
_ix2Cell$47 = 52					; size = 4
_ix1Cell$48 = 56					; size = 4
_wx1TerrainNum$49 = 60					; size = 2
_wy2TerrainNum$50 = 64					; size = 2
_wx2TerrainNum$51 = 68					; size = 2
_wy1TerrainNum$52 = 72					; size = 2
_byx2SubCell$53 = 76					; size = 1
_byy2SubCell$54 = 77					; size = 1
_byx1SubCell$55 = 78					; size = 1
_byy1SubCell$56 = 79					; size = 1
_kMap_pbyMarkBuf$ = 80					; size = 8
_rkRect$57 = 88						; size = 4
_itorTerrain$ = 92					; size = 4
_itorRect$ = 96						; size = 4
_iyCell$58 = 100					; size = 4
_ixCell$59 = 104					; size = 4
$T60 = 111						; size = 1
$T61 = 112						; size = 1
$T62 = 113						; size = 1
$T63 = 114						; size = 1
$T64 = 115						; size = 1
_this$ = 116						; size = 4
?VisibleMarkedArea@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::VisibleMarkedArea, COMDAT
; _this$ = ecx

; 1455 : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec bc 00 00
	00		 sub	 esp, 188		; 000000bcH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx

; 1456 : 	std::map<int, BYTE*> kMap_pbyMarkBuf;

  00030	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1457 : 	std::set<int> kSet_iProcessedMapIndex;

  0003c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _kSet_iProcessedMapIndex$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1458 : 
; 1459 : 	std::list<RECT>::iterator itorRect = m_rkList_kGuildArea.begin();

  0004b	8d 45 60	 lea	 eax, DWORD PTR _itorRect$[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
  00058	e8 00 00 00 00	 call	 ?begin@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@UtagRECT@@@std@@@std@@@2@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::begin

; 1460 : 	for (; itorRect != m_rkList_kGuildArea.end(); ++itorRect)

  0005d	eb 08		 jmp	 SHORT $LN44@VisibleMar
$LN2@VisibleMar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0005f	8b 45 60	 mov	 eax, DWORD PTR _itorRect$[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	89 45 60	 mov	 DWORD PTR _itorRect$[ebp], eax
$LN44@VisibleMar:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1460 : 	for (; itorRect != m_rkList_kGuildArea.end(); ++itorRect)

  00067	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	05 b8 09 00 00	 add	 eax, 2488		; 000009b8H
  0006f	89 45 24	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00072	8b 45 24	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00075	89 85 50 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0007b	8b 45 24	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 85 5c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00086	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR ___param0$[ebp]
  0008c	89 45 f0	 mov	 DWORD PTR $T39[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0008f	8d 45 f0	 lea	 eax, DWORD PTR $T39[ebp]
  00092	89 45 ec	 mov	 DWORD PTR $T38[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00095	8b 45 ec	 mov	 eax, DWORD PTR $T38[ebp]
  00098	8b 4d 60	 mov	 ecx, DWORD PTR _itorRect$[ebp]
  0009b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0009d	75 09		 jne	 SHORT $LN75@VisibleMar
  0009f	c7 45 20 01 00
	00 00		 mov	 DWORD PTR tv399[ebp], 1
  000a6	eb 04		 jmp	 SHORT $LN76@VisibleMar
$LN75@VisibleMar:
  000a8	83 65 20 00	 and	 DWORD PTR tv399[ebp], 0
$LN76@VisibleMar:
  000ac	8a 45 20	 mov	 al, BYTE PTR tv399[ebp]
  000af	88 45 73	 mov	 BYTE PTR $T64[ebp], al

; 203  :         return !(*this == _Right);

  000b2	0f b6 45 73	 movzx	 eax, BYTE PTR $T64[ebp]
  000b6	85 c0		 test	 eax, eax
  000b8	75 09		 jne	 SHORT $LN70@VisibleMar
  000ba	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv375[ebp], 1
  000c1	eb 04		 jmp	 SHORT $LN71@VisibleMar
$LN70@VisibleMar:
  000c3	83 65 1c 00	 and	 DWORD PTR tv375[ebp], 0
$LN71@VisibleMar:
  000c7	8a 45 1c	 mov	 al, BYTE PTR tv375[ebp]
  000ca	88 45 72	 mov	 BYTE PTR $T63[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1460 : 	for (; itorRect != m_rkList_kGuildArea.end(); ++itorRect)

  000cd	0f b6 45 72	 movzx	 eax, BYTE PTR $T63[ebp]
  000d1	85 c0		 test	 eax, eax
  000d3	0f 84 57 02 00
	00		 je	 $LN3@VisibleMar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000d9	8b 45 60	 mov	 eax, DWORD PTR _itorRect$[ebp]
  000dc	83 c0 08	 add	 eax, 8
  000df	89 45 e8	 mov	 DWORD PTR $T37[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000e2	8b 45 e8	 mov	 eax, DWORD PTR $T37[ebp]
  000e5	89 45 58	 mov	 DWORD PTR _rkRect$57[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1478 : 		ConvertToMapCoords(float(rkRect.left), float(rkRect.top), &ix1Cell, &iy1Cell, &byx1SubCell, &byy1SubCell, &wx1TerrainNum, &wy1TerrainNum);

  000e8	8d 45 48	 lea	 eax, DWORD PTR _wy1TerrainNum$52[ebp]
  000eb	50		 push	 eax
  000ec	8d 45 3c	 lea	 eax, DWORD PTR _wx1TerrainNum$49[ebp]
  000ef	50		 push	 eax
  000f0	8d 45 4f	 lea	 eax, DWORD PTR _byy1SubCell$56[ebp]
  000f3	50		 push	 eax
  000f4	8d 45 4e	 lea	 eax, DWORD PTR _byx1SubCell$55[ebp]
  000f7	50		 push	 eax
  000f8	8d 45 30	 lea	 eax, DWORD PTR _iy1Cell$46[ebp]
  000fb	50		 push	 eax
  000fc	8d 45 38	 lea	 eax, DWORD PTR _ix1Cell$48[ebp]
  000ff	50		 push	 eax
  00100	8b 45 58	 mov	 eax, DWORD PTR _rkRect$57[ebp]
  00103	f3 0f 2a 40 04	 cvtsi2ss xmm0, DWORD PTR [eax+4]
  00108	51		 push	 ecx
  00109	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010e	8b 45 58	 mov	 eax, DWORD PTR _rkRect$57[ebp]
  00111	f3 0f 2a 00	 cvtsi2ss xmm0, DWORD PTR [eax]
  00115	51		 push	 ecx
  00116	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011b	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0011e	e8 00 00 00 00	 call	 ?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z ; CMapOutdoor::ConvertToMapCoords

; 1479 : 		ConvertToMapCoords(float(rkRect.right), float(rkRect.bottom), &ix2Cell, &iy2Cell, &byx2SubCell, &byy2SubCell, &wx2TerrainNum, &wy2TerrainNum);

  00123	8d 45 40	 lea	 eax, DWORD PTR _wy2TerrainNum$50[ebp]
  00126	50		 push	 eax
  00127	8d 45 44	 lea	 eax, DWORD PTR _wx2TerrainNum$51[ebp]
  0012a	50		 push	 eax
  0012b	8d 45 4d	 lea	 eax, DWORD PTR _byy2SubCell$54[ebp]
  0012e	50		 push	 eax
  0012f	8d 45 4c	 lea	 eax, DWORD PTR _byx2SubCell$53[ebp]
  00132	50		 push	 eax
  00133	8d 45 2c	 lea	 eax, DWORD PTR _iy2Cell$45[ebp]
  00136	50		 push	 eax
  00137	8d 45 34	 lea	 eax, DWORD PTR _ix2Cell$47[ebp]
  0013a	50		 push	 eax
  0013b	8b 45 58	 mov	 eax, DWORD PTR _rkRect$57[ebp]
  0013e	f3 0f 2a 40 0c	 cvtsi2ss xmm0, DWORD PTR [eax+12]
  00143	51		 push	 ecx
  00144	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00149	8b 45 58	 mov	 eax, DWORD PTR _rkRect$57[ebp]
  0014c	f3 0f 2a 40 08	 cvtsi2ss xmm0, DWORD PTR [eax+8]
  00151	51		 push	 ecx
  00152	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00157	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?ConvertToMapCoords@CMapOutdoor@@IAEXMMPAH0PAE1PAG2@Z ; CMapOutdoor::ConvertToMapCoords

; 1480 : 
; 1481 : 		ix1Cell = ix1Cell + wx1TerrainNum*CTerrain::ATTRMAP_XSIZE;

  0015f	0f b7 45 3c	 movzx	 eax, WORD PTR _wx1TerrainNum$49[ebp]
  00163	c1 e0 08	 shl	 eax, 8
  00166	03 45 38	 add	 eax, DWORD PTR _ix1Cell$48[ebp]
  00169	89 45 38	 mov	 DWORD PTR _ix1Cell$48[ebp], eax

; 1482 : 		iy1Cell = iy1Cell + wy1TerrainNum*CTerrain::ATTRMAP_YSIZE;

  0016c	0f b7 45 48	 movzx	 eax, WORD PTR _wy1TerrainNum$52[ebp]
  00170	c1 e0 08	 shl	 eax, 8
  00173	03 45 30	 add	 eax, DWORD PTR _iy1Cell$46[ebp]
  00176	89 45 30	 mov	 DWORD PTR _iy1Cell$46[ebp], eax

; 1483 : 		ix2Cell = ix2Cell + wx2TerrainNum*CTerrain::ATTRMAP_XSIZE;

  00179	0f b7 45 44	 movzx	 eax, WORD PTR _wx2TerrainNum$51[ebp]
  0017d	c1 e0 08	 shl	 eax, 8
  00180	03 45 34	 add	 eax, DWORD PTR _ix2Cell$47[ebp]
  00183	89 45 34	 mov	 DWORD PTR _ix2Cell$47[ebp], eax

; 1484 : 		iy2Cell = iy2Cell + wy2TerrainNum*CTerrain::ATTRMAP_YSIZE;

  00186	0f b7 45 40	 movzx	 eax, WORD PTR _wy2TerrainNum$50[ebp]
  0018a	c1 e0 08	 shl	 eax, 8
  0018d	03 45 2c	 add	 eax, DWORD PTR _iy2Cell$45[ebp]
  00190	89 45 2c	 mov	 DWORD PTR _iy2Cell$45[ebp], eax

; 1485 : 
; 1486 : 		for (int ixCell = ix1Cell; ixCell <= ix2Cell; ++ixCell)

  00193	8b 45 38	 mov	 eax, DWORD PTR _ix1Cell$48[ebp]
  00196	89 45 68	 mov	 DWORD PTR _ixCell$59[ebp], eax
  00199	eb 07		 jmp	 SHORT $LN7@VisibleMar
$LN5@VisibleMar:
  0019b	8b 45 68	 mov	 eax, DWORD PTR _ixCell$59[ebp]
  0019e	40		 inc	 eax
  0019f	89 45 68	 mov	 DWORD PTR _ixCell$59[ebp], eax
$LN7@VisibleMar:
  001a2	8b 45 68	 mov	 eax, DWORD PTR _ixCell$59[ebp]
  001a5	3b 45 34	 cmp	 eax, DWORD PTR _ix2Cell$47[ebp]
  001a8	0f 8f 7d 01 00
	00		 jg	 $LN6@VisibleMar

; 1487 : 		for (int iyCell = iy1Cell; iyCell <= iy2Cell; ++iyCell)

  001ae	8b 45 30	 mov	 eax, DWORD PTR _iy1Cell$46[ebp]
  001b1	89 45 64	 mov	 DWORD PTR _iyCell$58[ebp], eax
  001b4	eb 07		 jmp	 SHORT $LN10@VisibleMar
$LN8@VisibleMar:
  001b6	8b 45 64	 mov	 eax, DWORD PTR _iyCell$58[ebp]
  001b9	40		 inc	 eax
  001ba	89 45 64	 mov	 DWORD PTR _iyCell$58[ebp], eax
$LN10@VisibleMar:
  001bd	8b 45 64	 mov	 eax, DWORD PTR _iyCell$58[ebp]
  001c0	3b 45 2c	 cmp	 eax, DWORD PTR _iy2Cell$45[ebp]
  001c3	0f 8f 5d 01 00
	00		 jg	 $LN9@VisibleMar

; 1488 : 		{
; 1489 : 			int ixLocalCell = ixCell % CTerrain::ATTRMAP_XSIZE;

  001c9	8b 45 68	 mov	 eax, DWORD PTR _ixCell$59[ebp]
  001cc	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  001d1	79 07		 jns	 SHORT $LN438@VisibleMar
  001d3	48		 dec	 eax
  001d4	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  001d9	40		 inc	 eax
$LN438@VisibleMar:
  001da	89 45 c0	 mov	 DWORD PTR _ixLocalCell$29[ebp], eax

; 1490 : 			int iyLocalCell = iyCell % CTerrain::ATTRMAP_YSIZE;

  001dd	8b 45 64	 mov	 eax, DWORD PTR _iyCell$58[ebp]
  001e0	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  001e5	79 07		 jns	 SHORT $LN439@VisibleMar
  001e7	48		 dec	 eax
  001e8	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  001ed	40		 inc	 eax
$LN439@VisibleMar:
  001ee	89 45 c4	 mov	 DWORD PTR _iyLocalCell$30[ebp], eax

; 1491 : 			int ixTerrain = ixCell / CTerrain::ATTRMAP_XSIZE;

  001f1	8b 45 68	 mov	 eax, DWORD PTR _ixCell$59[ebp]
  001f4	99		 cdq
  001f5	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  001fb	03 c2		 add	 eax, edx
  001fd	c1 f8 08	 sar	 eax, 8
  00200	89 45 14	 mov	 DWORD PTR _ixTerrain$42[ebp], eax

; 1492 : 			int iyTerrain = iyCell / CTerrain::ATTRMAP_YSIZE;

  00203	8b 45 64	 mov	 eax, DWORD PTR _iyCell$58[ebp]
  00206	99		 cdq
  00207	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0020d	03 c2		 add	 eax, edx
  0020f	c1 f8 08	 sar	 eax, 8
  00212	89 45 18	 mov	 DWORD PTR _iyTerrain$43[ebp], eax

; 1493 : 			int iTerrainNum = ixTerrain+iyTerrain*100;

  00215	6b 45 18 64	 imul	 eax, DWORD PTR _iyTerrain$43[ebp], 100
  00219	03 45 14	 add	 eax, DWORD PTR _ixTerrain$42[ebp]
  0021c	89 45 28	 mov	 DWORD PTR _iTerrainNum$44[ebp], eax

; 1494 : 
; 1495 : 			BYTE byTerrainNum;
; 1496 : 			if (!GetTerrainNumFromCoord(ixTerrain, iyTerrain, &byTerrainNum))

  0021f	8d 45 e4	 lea	 eax, DWORD PTR _byTerrainNum$36[ebp]
  00222	50		 push	 eax
  00223	ff 75 18	 push	 DWORD PTR _iyTerrain$43[ebp]
  00226	ff 75 14	 push	 DWORD PTR _ixTerrain$42[ebp]
  00229	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0022c	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  00231	0f b6 c0	 movzx	 eax, al
  00234	85 c0		 test	 eax, eax
  00236	75 05		 jne	 SHORT $LN14@VisibleMar

; 1497 : 				continue;

  00238	e9 79 ff ff ff	 jmp	 $LN8@VisibleMar
$LN14@VisibleMar:

; 1498 : 			CTerrain * pTerrain;
; 1499 : 			if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  0023d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _pTerrain$6[ebp]
  00243	50		 push	 eax
  00244	ff 75 e4	 push	 DWORD PTR _byTerrainNum$36[ebp]
  00247	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0024a	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0024f	85 c0		 test	 eax, eax
  00251	75 05		 jne	 SHORT $LN15@VisibleMar

; 1500 : 				continue;

  00253	e9 5e ff ff ff	 jmp	 $LN8@VisibleMar
$LN15@VisibleMar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00258	8d 45 50	 lea	 eax, DWORD PTR _kMap_pbyMarkBuf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0025b	89 45 e0	 mov	 DWORD PTR $T35[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0025e	8b 45 e0	 mov	 eax, DWORD PTR $T35[ebp]
  00261	89 45 dc	 mov	 DWORD PTR __Scary$34[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00264	8b 45 dc	 mov	 eax, DWORD PTR __Scary$34[ebp]
  00267	8b 00		 mov	 eax, DWORD PTR [eax]
  00269	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0026c	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  0026f	89 45 d4	 mov	 DWORD PTR $T33[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00272	8d 45 d4	 lea	 eax, DWORD PTR $T33[ebp]
  00275	89 45 d0	 mov	 DWORD PTR $T32[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1502 : 			if (kMap_pbyMarkBuf.end() == kMap_pbyMarkBuf.find(iTerrainNum))

  00278	8d 45 28	 lea	 eax, DWORD PTR _iTerrainNum$44[ebp]
  0027b	50		 push	 eax
  0027c	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00282	50		 push	 eax
  00283	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  00286	e8 00 00 00 00	 call	 ?find@?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@@2@ABH@Z ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::find
  0028b	89 45 cc	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 232  :         return this->_Ptr == _Right._Ptr;

  0028e	8b 45 d0	 mov	 eax, DWORD PTR $T32[ebp]
  00291	8b 4d cc	 mov	 ecx, DWORD PTR __Right$[ebp]
  00294	8b 00		 mov	 eax, DWORD PTR [eax]
  00296	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00298	75 09		 jne	 SHORT $LN146@VisibleMar
  0029a	c7 45 10 01 00
	00 00		 mov	 DWORD PTR tv491[ebp], 1
  002a1	eb 04		 jmp	 SHORT $LN147@VisibleMar
$LN146@VisibleMar:
  002a3	83 65 10 00	 and	 DWORD PTR tv491[ebp], 0
$LN147@VisibleMar:
  002a7	8a 45 10	 mov	 al, BYTE PTR tv491[ebp]
  002aa	88 45 71	 mov	 BYTE PTR $T62[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1502 : 			if (kMap_pbyMarkBuf.end() == kMap_pbyMarkBuf.find(iTerrainNum))

  002ad	0f b6 45 71	 movzx	 eax, BYTE PTR $T62[ebp]
  002b1	85 c0		 test	 eax, eax
  002b3	74 41		 je	 SHORT $LN16@VisibleMar

; 1503 : 			{
; 1504 : 				BYTE * pbyBuf = new BYTE [CTerrain::ATTRMAP_XSIZE*CTerrain::ATTRMAP_YSIZE];

  002b5	68 00 00 01 00	 push	 65536			; 00010000H
  002ba	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002bf	59		 pop	 ecx
  002c0	89 45 c8	 mov	 DWORD PTR $T31[ebp], eax
  002c3	8b 45 c8	 mov	 eax, DWORD PTR $T31[ebp]
  002c6	89 45 0c	 mov	 DWORD PTR _pbyBuf$41[ebp], eax

; 1505 : 				ZeroMemory(pbyBuf, CTerrain::ATTRMAP_XSIZE*CTerrain::ATTRMAP_YSIZE);

  002c9	68 00 00 01 00	 push	 65536			; 00010000H
  002ce	6a 00		 push	 0
  002d0	ff 75 0c	 push	 DWORD PTR _pbyBuf$41[ebp]
  002d3	e8 00 00 00 00	 call	 _memset
  002d8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  002db	8d 45 28	 lea	 eax, DWORD PTR _iTerrainNum$44[ebp]
  002de	50		 push	 eax
  002df	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  002e5	50		 push	 eax
  002e6	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  002e9	e8 00 00 00 00	 call	 ??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::_Try_emplace<int const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1506 : 				kMap_pbyMarkBuf[iTerrainNum] = pbyBuf;

  002ee	8b 00		 mov	 eax, DWORD PTR [eax]
  002f0	8b 4d 0c	 mov	 ecx, DWORD PTR _pbyBuf$41[ebp]
  002f3	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN16@VisibleMar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 325  :         return _Try_emplace(_Keyval).first->_Myval.second;

  002f6	8d 45 28	 lea	 eax, DWORD PTR _iTerrainNum$44[ebp]
  002f9	50		 push	 eax
  002fa	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00300	50		 push	 eax
  00301	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  00304	e8 00 00 00 00	 call	 ??$_Try_emplace@ABH$$V@?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@AAE?AU?$pair@PAU?$_Tree_node@U?$pair@$$CBHPAE@std@@PAX@std@@_N@1@ABH@Z ; std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > >::_Try_emplace<int const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1509 : 			BYTE * pbyBuf = kMap_pbyMarkBuf[iTerrainNum];

  00309	8b 00		 mov	 eax, DWORD PTR [eax]
  0030b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0030e	89 45 bc	 mov	 DWORD PTR _pbyBuf$28[ebp], eax

; 1510 : 			pbyBuf[ixLocalCell+iyLocalCell*CTerrain::ATTRMAP_XSIZE] = 0xff;

  00311	8b 45 c4	 mov	 eax, DWORD PTR _iyLocalCell$30[ebp]
  00314	c1 e0 08	 shl	 eax, 8
  00317	03 45 c0	 add	 eax, DWORD PTR _ixLocalCell$29[ebp]
  0031a	8b 4d bc	 mov	 ecx, DWORD PTR _pbyBuf$28[ebp]
  0031d	c6 04 01 ff	 mov	 BYTE PTR [ecx+eax], 255	; 000000ffH

; 1511 : 		}

  00321	e9 90 fe ff ff	 jmp	 $LN8@VisibleMar
$LN9@VisibleMar:
  00326	e9 70 fe ff ff	 jmp	 $LN5@VisibleMar
$LN6@VisibleMar:

; 1512 : 	}

  0032b	e9 2f fd ff ff	 jmp	 $LN2@VisibleMar
$LN3@VisibleMar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00330	8d 45 50	 lea	 eax, DWORD PTR _kMap_pbyMarkBuf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00333	89 45 b8	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00336	8b 45 b8	 mov	 eax, DWORD PTR $T27[ebp]
  00339	89 45 b4	 mov	 DWORD PTR __Scary$26[ebp], eax

; 1240 :         return iterator(_Scary->_Myhead->_Left, _Scary);

  0033c	8b 45 b4	 mov	 eax, DWORD PTR __Scary$26[ebp]
  0033f	8b 00		 mov	 eax, DWORD PTR [eax]
  00341	8b 00		 mov	 eax, DWORD PTR [eax]
  00343	89 45 b0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  00346	8b 45 b0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00349	89 45 5c	 mov	 DWORD PTR _itorTerrain$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1515 : 	for (; itorTerrain != kMap_pbyMarkBuf.end(); ++itorTerrain)

  0034c	eb 08		 jmp	 SHORT $LN174@VisibleMar
$LN11@VisibleMar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 198  :         _Mybase::operator++();

  0034e	8d 4d 5c	 lea	 ecx, DWORD PTR _itorTerrain$[ebp]
  00351	e8 00 00 00 00	 call	 ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBHPAE@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<int const ,unsigned char *> > >,std::_Iterator_base0>::operator++
$LN174@VisibleMar:

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00356	8d 45 50	 lea	 eax, DWORD PTR _kMap_pbyMarkBuf$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00359	89 45 ac	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0035c	8b 45 ac	 mov	 eax, DWORD PTR $T25[ebp]
  0035f	89 45 a8	 mov	 DWORD PTR __Scary$24[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00362	8b 45 a8	 mov	 eax, DWORD PTR __Scary$24[ebp]
  00365	8b 00		 mov	 eax, DWORD PTR [eax]
  00367	89 45 a4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree* _Plist) noexcept : _Ptr(_Pnode) {

  0036a	8b 45 a4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0036d	89 45 a0	 mov	 DWORD PTR $T23[ebp], eax

; 1250 :         return iterator(_Scary->_Myhead, _Scary);

  00370	8d 45 a0	 lea	 eax, DWORD PTR $T23[ebp]
  00373	89 45 9c	 mov	 DWORD PTR $T22[ebp], eax

; 232  :         return this->_Ptr == _Right._Ptr;

  00376	8b 45 9c	 mov	 eax, DWORD PTR $T22[ebp]
  00379	8b 4d 5c	 mov	 ecx, DWORD PTR _itorTerrain$[ebp]
  0037c	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0037e	75 09		 jne	 SHORT $LN220@VisibleMar
  00380	c7 45 08 01 00
	00 00		 mov	 DWORD PTR tv568[ebp], 1
  00387	eb 04		 jmp	 SHORT $LN221@VisibleMar
$LN220@VisibleMar:
  00389	83 65 08 00	 and	 DWORD PTR tv568[ebp], 0
$LN221@VisibleMar:
  0038d	8a 45 08	 mov	 al, BYTE PTR tv568[ebp]
  00390	88 45 70	 mov	 BYTE PTR $T61[ebp], al

; 236  :         return !(*this == _Right);

  00393	0f b6 45 70	 movzx	 eax, BYTE PTR $T61[ebp]
  00397	85 c0		 test	 eax, eax
  00399	75 09		 jne	 SHORT $LN215@VisibleMar
  0039b	c7 45 04 01 00
	00 00		 mov	 DWORD PTR tv541[ebp], 1
  003a2	eb 04		 jmp	 SHORT $LN216@VisibleMar
$LN215@VisibleMar:
  003a4	83 65 04 00	 and	 DWORD PTR tv541[ebp], 0
$LN216@VisibleMar:
  003a8	8a 45 04	 mov	 al, BYTE PTR tv541[ebp]
  003ab	88 45 6f	 mov	 BYTE PTR $T60[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1515 : 	for (; itorTerrain != kMap_pbyMarkBuf.end(); ++itorTerrain)

  003ae	0f b6 45 6f	 movzx	 eax, BYTE PTR $T60[ebp]
  003b2	85 c0		 test	 eax, eax
  003b4	0f 84 e1 00 00
	00		 je	 $LN12@VisibleMar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  003ba	8b 45 5c	 mov	 eax, DWORD PTR _itorTerrain$[ebp]
  003bd	83 c0 10	 add	 eax, 16			; 00000010H
  003c0	89 45 98	 mov	 DWORD PTR $T21[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  003c3	8b 45 98	 mov	 eax, DWORD PTR $T21[ebp]
  003c6	89 45 94	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  003c9	8b 45 94	 mov	 eax, DWORD PTR $T20[ebp]
  003cc	89 45 90	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  003cf	8b 45 90	 mov	 eax, DWORD PTR $T19[ebp]
  003d2	89 45 8c	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  003d5	8b 45 8c	 mov	 eax, DWORD PTR $T18[ebp]
  003d8	89 45 88	 mov	 DWORD PTR $T17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1517 : 		int iTerrainNum = itorTerrain->first;

  003db	8b 45 88	 mov	 eax, DWORD PTR $T17[ebp]
  003de	8b 00		 mov	 eax, DWORD PTR [eax]
  003e0	89 45 00	 mov	 DWORD PTR _iTerrainNum$40[ebp], eax

; 1518 : 		int ixTerrain = iTerrainNum%100;

  003e3	8b 45 00	 mov	 eax, DWORD PTR _iTerrainNum$40[ebp]
  003e6	99		 cdq
  003e7	6a 64		 push	 100			; 00000064H
  003e9	59		 pop	 ecx
  003ea	f7 f9		 idiv	 ecx
  003ec	89 95 6c ff ff
	ff		 mov	 DWORD PTR _ixTerrain$10[ebp], edx

; 1519 : 		int iyTerrain = iTerrainNum/100;

  003f2	8b 45 00	 mov	 eax, DWORD PTR _iTerrainNum$40[ebp]
  003f5	99		 cdq
  003f6	6a 64		 push	 100			; 00000064H
  003f8	59		 pop	 ecx
  003f9	f7 f9		 idiv	 ecx
  003fb	89 85 70 ff ff
	ff		 mov	 DWORD PTR _iyTerrain$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 185  :         return this->_Ptr->_Myval;

  00401	8b 45 5c	 mov	 eax, DWORD PTR _itorTerrain$[ebp]
  00404	83 c0 10	 add	 eax, 16			; 00000010H
  00407	89 45 84	 mov	 DWORD PTR $T16[ebp], eax

; 273  :         return const_cast<reference>(_Mybase::operator*());

  0040a	8b 45 84	 mov	 eax, DWORD PTR $T16[ebp]
  0040d	89 45 80	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00410	8b 45 80	 mov	 eax, DWORD PTR $T15[ebp]
  00413	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00419	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T14[ebp]
  0041f	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 277  :         return pointer_traits<pointer>::pointer_to(**this);

  00425	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  0042b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1520 : 		BYTE * pbyBuf = itorTerrain->second;

  00431	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  00437	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0043a	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pbyBuf$8[ebp], eax

; 1521 : 
; 1522 : 		BYTE byTerrainNum;
; 1523 : 		if (!GetTerrainNumFromCoord(ixTerrain, iyTerrain, &byTerrainNum))

  00440	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _byTerrainNum$9[ebp]
  00446	50		 push	 eax
  00447	ff b5 70 ff ff
	ff		 push	 DWORD PTR _iyTerrain$11[ebp]
  0044d	ff b5 6c ff ff
	ff		 push	 DWORD PTR _ixTerrain$10[ebp]
  00453	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00456	e8 00 00 00 00	 call	 ?GetTerrainNumFromCoord@CMapOutdoor@@QAE_NGGPAE@Z ; CMapOutdoor::GetTerrainNumFromCoord
  0045b	0f b6 c0	 movzx	 eax, al
  0045e	85 c0		 test	 eax, eax
  00460	75 05		 jne	 SHORT $LN17@VisibleMar

; 1524 : 			continue;

  00462	e9 e7 fe ff ff	 jmp	 $LN11@VisibleMar
$LN17@VisibleMar:

; 1525 : 		CTerrain * pTerrain;
; 1526 : 		if (!GetTerrainPointer(byTerrainNum, &pTerrain))

  00467	8d 85 60 ff ff
	ff		 lea	 eax, DWORD PTR _pTerrain$7[ebp]
  0046d	50		 push	 eax
  0046e	ff b5 68 ff ff
	ff		 push	 DWORD PTR _byTerrainNum$9[ebp]
  00474	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00477	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  0047c	85 c0		 test	 eax, eax
  0047e	75 05		 jne	 SHORT $LN18@VisibleMar

; 1527 : 			continue;

  00480	e9 c9 fe ff ff	 jmp	 $LN11@VisibleMar
$LN18@VisibleMar:

; 1528 : 
; 1529 : 		pTerrain->AllocateMarkedSplats(pbyBuf);

  00485	ff b5 64 ff ff
	ff		 push	 DWORD PTR _pbyBuf$8[ebp]
  0048b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _pTerrain$7[ebp]
  00491	e8 00 00 00 00	 call	 ?AllocateMarkedSplats@CTerrain@@QAEXPAE@Z ; CTerrain::AllocateMarkedSplats

; 1530 : 	}

  00496	e9 b3 fe ff ff	 jmp	 $LN11@VisibleMar
$LN12@VisibleMar:

; 1531 : 
; 1532 : 	stl_wipe_second(kMap_pbyMarkBuf);

  0049b	8d 45 50	 lea	 eax, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  0049e	50		 push	 eax
  0049f	e8 00 00 00 00	 call	 ??$stl_wipe_second@V?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@@YAXAAV?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@@Z ; stl_wipe_second<std::map<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> > > >
  004a4	59		 pop	 ecx

; 1533 : }

  004a5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004a9	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _kSet_iProcessedMapIndex$[ebp]
  004af	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
  004b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  004b8	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  004bb	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >::~_Tree<std::_Tmap_traits<int,unsigned char *,std::less<int>,std::allocator<std::pair<int const ,unsigned char *> >,0> >
  004c0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004c3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004ca	59		 pop	 ecx
  004cb	83 c5 78	 add	 ebp, 120		; 00000078H
  004ce	c9		 leave
  004cf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ$0:
  00000	8d 4d 50	 lea	 ecx, DWORD PTR _kMap_pbyMarkBuf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$map@HPAEU?$less@H@std@@V?$allocator@U?$pair@$$CBHPAE@std@@@2@@std@@QAE@XZ
__unwindfunclet$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ$1:
  00008	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR _kSet_iProcessedMapIndex$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 8a 40 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-192]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?VisibleMarkedArea@CMapOutdoor@@QAEXXZ
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?VisibleMarkedArea@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::VisibleMarkedArea
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?RegisterGuildArea@CMapOutdoor@@QAEXHHHH@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_isx$ = 8						; size = 4
_isy$ = 12						; size = 4
_iex$ = 16						; size = 4
_iey$ = 20						; size = 4
?RegisterGuildArea@CMapOutdoor@@QAEXHHHH@Z PROC		; CMapOutdoor::RegisterGuildArea, COMDAT
; _this$ = ecx

; 1445 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1446 : 	RECT rect;
; 1447 : 	rect.left = isx;

  00013	8b 45 08	 mov	 eax, DWORD PTR _isx$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR _rect$[ebp], eax

; 1448 : 	rect.top = isy;

  00019	8b 45 0c	 mov	 eax, DWORD PTR _isy$[ebp]
  0001c	89 45 f0	 mov	 DWORD PTR _rect$[ebp+4], eax

; 1449 : 	rect.right = iex;

  0001f	8b 45 10	 mov	 eax, DWORD PTR _iex$[ebp]
  00022	89 45 f4	 mov	 DWORD PTR _rect$[ebp+8], eax

; 1450 : 	rect.bottom = iey;

  00025	8b 45 14	 mov	 eax, DWORD PTR _iey$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR _rect$[ebp+12], eax

; 1451 : 	m_rkList_kGuildArea.push_back(rect);

  0002b	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	05 b8 09 00 00	 add	 eax, 2488		; 000009b8H
  00033	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00036	8d 45 ec	 lea	 eax, DWORD PTR _rect$[ebp]
  00039	50		 push	 eax
  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 30		 push	 DWORD PTR [eax]
  0003f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Emplace@ABUtagRECT@@@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEPAU?$_List_node@UtagRECT@@PAX@1@QAU21@ABUtagRECT@@@Z ; std::list<tagRECT,std::allocator<tagRECT> >::_Emplace<tagRECT const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 1452 : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	c9		 leave
  00052	c2 10 00	 ret	 16			; 00000010H
?RegisterGuildArea@CMapOutdoor@@QAEXHHHH@Z ENDP		; CMapOutdoor::RegisterGuildArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?ClearGuildArea@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearGuildArea@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::ClearGuildArea, COMDAT
; _this$ = ecx

; 1440 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1441 : 	m_rkList_kGuildArea.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
  00010	e8 00 00 00 00	 call	 ?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::clear

; 1442 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?ClearGuildArea@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::ClearGuildArea
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
tv213 = -20						; size = 4
tv279 = -16						; size = 4
tv278 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ PROC	; CMapOutdoor::SetEnvironmentLensFlare, COMDAT
; _this$ = ecx

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 327  : 	if (!mc_pEnvironmentData)

  0000a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00011	75 05		 jne	 SHORT $LN2@SetEnviron

; 328  : 		return;

  00013	e9 01 01 00 00	 jmp	 $LN1@SetEnviron
$LN2@SetEnviron:

; 329  : 
; 330  : 	m_LensFlare.CharacterizeFlare(mc_pEnvironmentData->bLensFlareEnable == 1 ? true : false,

  00018	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0001e	83 b8 78 02 00
	00 01		 cmp	 DWORD PTR [eax+632], 1
  00025	75 06		 jne	 SHORT $LN5@SetEnviron
  00027	c6 45 f4 01	 mov	 BYTE PTR tv278[ebp], 1
  0002b	eb 04		 jmp	 SHORT $LN6@SetEnviron
$LN5@SetEnviron:
  0002d	c6 45 f4 00	 mov	 BYTE PTR tv278[ebp], 0
$LN6@SetEnviron:
  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00037	83 b8 60 02 00
	00 01		 cmp	 DWORD PTR [eax+608], 1
  0003e	75 06		 jne	 SHORT $LN7@SetEnviron
  00040	c6 45 f0 01	 mov	 BYTE PTR tv279[ebp], 1
  00044	eb 04		 jmp	 SHORT $LN8@SetEnviron
$LN7@SetEnviron:
  00046	c6 45 f0 00	 mov	 BYTE PTR tv279[ebp], 0
$LN8@SetEnviron:
  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00050	05 64 02 00 00	 add	 eax, 612		; 00000264H
  00055	50		 push	 eax
  00056	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0005c	51		 push	 ecx
  0005d	f3 0f 10 80 74
	02 00 00	 movss	 xmm0, DWORD PTR [eax+628]
  00065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006a	ff 75 f4	 push	 DWORD PTR tv278[ebp]
  0006d	ff 75 f0	 push	 DWORD PTR tv279[ebp]
  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  00079	e8 00 00 00 00	 call	 ?CharacterizeFlare@CLensFlare@@QAEX_N0MABUD3DXCOLOR@@@Z ; CLensFlare::CharacterizeFlare

; 331  : 								  mc_pEnvironmentData->bMainFlareEnable == 1 ? true : false,
; 332  : 								  mc_pEnvironmentData->fLensFlareMaxBrightness,
; 333  : 								  mc_pEnvironmentData->LensFlareBrightnessColor);
; 334  : 
; 335  : 	m_LensFlare.Initialize("d:/ymir work/environment");

  0007e	83 ec 18	 sub	 esp, 24			; 00000018H
  00081	8b cc		 mov	 ecx, esp
  00083	89 65 e0	 mov	 DWORD PTR $T2[ebp], esp
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@GGJMMCMN@d?3?1ymir?5work?1environment@
  0008b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  00099	e8 00 00 00 00	 call	 ?Initialize@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CLensFlare::Initialize

; 337  : 	if (!mc_pEnvironmentData->strMainFlareTextureFileName.empty())

  0009e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000a4	05 7c 02 00 00	 add	 eax, 636		; 0000027cH
  000a9	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  000ac	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000b2	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 3848 :         return size() == 0;

  000b5	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  000b9	75 09		 jne	 SHORT $LN42@SetEnviron
  000bb	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv213[ebp], 1
  000c2	eb 04		 jmp	 SHORT $LN43@SetEnviron
$LN42@SetEnviron:
  000c4	83 65 ec 00	 and	 DWORD PTR tv213[ebp], 0
$LN43@SetEnviron:
  000c8	8a 45 ec	 mov	 al, BYTE PTR tv213[ebp]
  000cb	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 337  : 	if (!mc_pEnvironmentData->strMainFlareTextureFileName.empty())

  000ce	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  000d2	85 c0		 test	 eax, eax
  000d4	75 43		 jne	 SHORT $LN3@SetEnviron

; 338  : 		m_LensFlare.SetMainFlare(mc_pEnvironmentData->strMainFlareTextureFileName.c_str(),

  000d6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d9	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000dc	51		 push	 ecx
  000dd	f3 0f 10 80 94
	02 00 00	 movss	 xmm0, DWORD PTR [eax+660]
  000e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ea	83 ec 18	 sub	 esp, 24			; 00000018H
  000ed	8b f4		 mov	 esi, esp
  000ef	89 65 dc	 mov	 DWORD PTR $T1[ebp], esp
  000f2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000f8	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  000fe	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00103	50		 push	 eax
  00104	8b ce		 mov	 ecx, esi
  00106	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  00114	e8 00 00 00 00	 call	 ?SetMainFlare@CLensFlare@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@M@Z ; CLensFlare::SetMainFlare
$LN3@SetEnviron:
$LN1@SetEnviron:

; 339  : 								 mc_pEnvironmentData->fMainFlareSize);
; 340  : }

  00119	5e		 pop	 esi
  0011a	c9		 leave
  0011b	c3		 ret	 0
?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ ENDP	; CMapOutdoor::SetEnvironmentLensFlare
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\SkyBox.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T1 = -52						; size = 4
$T2 = -48						; size = 4
_this$ = -44						; size = 4
$T3 = -40						; size = 4
_this$ = -36						; size = 4
tv312 = -32						; size = 4
__My_data$4 = -28					; size = 4
tv296 = -24						; size = 4
tv285 = -20						; size = 4
$T5 = -16						; size = 4
_i$6 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -3						; size = 1
$T8 = -2						; size = 1
$T9 = -1						; size = 1
?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ PROC		; CMapOutdoor::SetEnvironmentSkyBox, COMDAT
; _this$ = ecx

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 293  : 	if (!mc_pEnvironmentData)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00010	75 05		 jne	 SHORT $LN5@SetEnviron

; 294  : 		return;

  00012	e9 6a 02 00 00	 jmp	 $LN1@SetEnviron
$LN5@SetEnviron:

; 295  : 
; 296  : 	m_SkyBox.SetSkyBoxScale(mc_pEnvironmentData->v3SkyBoxScale);

  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0001d	05 5c 01 00 00	 add	 eax, 348		; 0000015cH
  00022	50		 push	 eax
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  0002c	e8 00 00 00 00	 call	 ?SetSkyBoxScale@CSkyBox@@QAEXABUD3DXVECTOR3@@@Z ; CSkyBox::SetSkyBoxScale

; 297  : 	m_SkyBox.SetGradientLevel(mc_pEnvironmentData->bySkyBoxGradientLevelUpper, mc_pEnvironmentData->bySkyBoxGradientLevelLower);

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00037	0f b6 80 6d 01
	00 00		 movzx	 eax, BYTE PTR [eax+365]
  0003e	50		 push	 eax
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00045	0f b6 80 6c 01
	00 00		 movzx	 eax, BYTE PTR [eax+364]
  0004c	50		 push	 eax
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00056	e8 00 00 00 00	 call	 ?SetGradientLevel@CSkyBox@@QAEXEE@Z ; CSkyBox::SetGradientLevel

; 298  : 	m_SkyBox.SetRenderMode( (mc_pEnvironmentData->bSkyBoxTextureRenderMode == TRUE) ? CSkyObject::SKY_RENDER_MODE_TEXTURE : CSkyObject::SKY_RENDER_MODE_DIFFUSE);

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00061	83 b8 68 01 00
	00 01		 cmp	 DWORD PTR [eax+360], 1
  00068	75 09		 jne	 SHORT $LN10@SetEnviron
  0006a	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR $T5[ebp], 2
  00071	eb 07		 jmp	 SHORT $LN11@SetEnviron
$LN10@SetEnviron:
  00073	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T5[ebp], 1
$LN11@SetEnviron:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\SkyBox.h

; 92   : 	void SetRenderMode(unsigned char ucRenderMode) { m_ucRenderMode = ucRenderMode;	}

  0007a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8a 4d f0	 mov	 cl, BYTE PTR $T5[ebp]
  00080	88 88 0c 05 00
	00		 mov	 BYTE PTR [eax+1292], cl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 300  : 	for( int i = 0; i < 6; ++i )

  00086	83 65 f4 00	 and	 DWORD PTR _i$6[ebp], 0
  0008a	eb 07		 jmp	 SHORT $LN4@SetEnviron
$LN2@SetEnviron:
  0008c	8b 45 f4	 mov	 eax, DWORD PTR _i$6[ebp]
  0008f	40		 inc	 eax
  00090	89 45 f4	 mov	 DWORD PTR _i$6[ebp], eax
$LN4@SetEnviron:
  00093	83 7d f4 06	 cmp	 DWORD PTR _i$6[ebp], 6
  00097	7d 68		 jge	 SHORT $LN3@SetEnviron

; 302  : 		if (!mc_pEnvironmentData->strSkyBoxFaceFileName[i].empty())

  00099	6b 45 f4 18	 imul	 eax, DWORD PTR _i$6[ebp], 24
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  000a3	8d 84 01 70 01
	00 00		 lea	 eax, DWORD PTR [ecx+eax+368]
  000aa	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  000ad	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000b3	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 3848 :         return size() == 0;

  000b6	83 7d d8 00	 cmp	 DWORD PTR $T3[ebp], 0
  000ba	75 09		 jne	 SHORT $LN16@SetEnviron
  000bc	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv285[ebp], 1
  000c3	eb 04		 jmp	 SHORT $LN17@SetEnviron
$LN16@SetEnviron:
  000c5	83 65 ec 00	 and	 DWORD PTR tv285[ebp], 0
$LN17@SetEnviron:
  000c9	8a 45 ec	 mov	 al, BYTE PTR tv285[ebp]
  000cc	88 45 ff	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 302  : 		if (!mc_pEnvironmentData->strSkyBoxFaceFileName[i].empty())

  000cf	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  000d3	85 c0		 test	 eax, eax
  000d5	75 28		 jne	 SHORT $LN6@SetEnviron

; 303  : 			m_SkyBox.SetFaceTexture( mc_pEnvironmentData->strSkyBoxFaceFileName[i].c_str(), i );

  000d7	ff 75 f4	 push	 DWORD PTR _i$6[ebp]
  000da	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  000e0	6b 4d f4 18	 imul	 ecx, DWORD PTR _i$6[ebp], 24
  000e4	8d 8c 08 70 01
	00 00		 lea	 ecx, DWORD PTR [eax+ecx+368]
  000eb	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000f0	50		 push	 eax
  000f1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  000fa	e8 00 00 00 00	 call	 ?SetFaceTexture@CSkyBox@@QAEXPBDH@Z ; CSkyBox::SetFaceTexture
$LN6@SetEnviron:

; 304  : 	}

  000ff	eb 8b		 jmp	 SHORT $LN2@SetEnviron
$LN3@SetEnviron:

; 306  : 	if (!mc_pEnvironmentData->strCloudTextureFileName.empty())

  00101	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00107	05 1c 02 00 00	 add	 eax, 540		; 0000021cH
  0010c	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  0010f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00112	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00115	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax

; 3848 :         return size() == 0;

  00118	83 7d d0 00	 cmp	 DWORD PTR $T2[ebp], 0
  0011c	75 09		 jne	 SHORT $LN39@SetEnviron
  0011e	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv296[ebp], 1
  00125	eb 04		 jmp	 SHORT $LN40@SetEnviron
$LN39@SetEnviron:
  00127	83 65 e8 00	 and	 DWORD PTR tv296[ebp], 0
$LN40@SetEnviron:
  0012b	8a 45 e8	 mov	 al, BYTE PTR tv296[ebp]
  0012e	88 45 fe	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 306  : 	if (!mc_pEnvironmentData->strCloudTextureFileName.empty())

  00131	0f b6 45 fe	 movzx	 eax, BYTE PTR $T8[ebp]
  00135	85 c0		 test	 eax, eax
  00137	75 20		 jne	 SHORT $LN7@SetEnviron

; 307  : 		m_SkyBox.SetCloudTexture(mc_pEnvironmentData->strCloudTextureFileName.c_str());

  00139	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013c	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  0013f	81 c1 1c 02 00
	00		 add	 ecx, 540		; 0000021cH
  00145	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0014a	50		 push	 eax
  0014b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014e	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00154	e8 00 00 00 00	 call	 ?SetCloudTexture@CSkyBox@@QAEXPBD@Z ; CSkyBox::SetCloudTexture
$LN7@SetEnviron:

; 308  : 
; 309  : 	m_SkyBox.SetCloudScale(mc_pEnvironmentData->v2CloudScale);

  00159	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0015f	05 00 02 00 00	 add	 eax, 512		; 00000200H
  00164	50		 push	 eax
  00165	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00168	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  0016e	e8 00 00 00 00	 call	 ?SetCloudScale@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z ; CSkyBox::SetCloudScale

; 310  : 	m_SkyBox.SetCloudHeight(mc_pEnvironmentData->fCloudHeight);

  00173	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00179	51		 push	 ecx
  0017a	f3 0f 10 80 08
	02 00 00	 movss	 xmm0, DWORD PTR [eax+520]
  00182	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00187	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00190	e8 00 00 00 00	 call	 ?SetCloudHeight@CSkyBox@@QAEXM@Z ; CSkyBox::SetCloudHeight

; 311  : 	m_SkyBox.SetCloudTextureScale(mc_pEnvironmentData->v2CloudTextureScale);

  00195	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00198	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0019b	05 0c 02 00 00	 add	 eax, 524		; 0000020cH
  001a0	50		 push	 eax
  001a1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a4	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  001aa	e8 00 00 00 00	 call	 ?SetCloudTextureScale@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z ; CSkyBox::SetCloudTextureScale

; 312  : 	m_SkyBox.SetCloudScrollSpeed(mc_pEnvironmentData->v2CloudSpeed);

  001af	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  001b5	05 14 02 00 00	 add	 eax, 532		; 00000214H
  001ba	50		 push	 eax
  001bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  001c4	e8 00 00 00 00	 call	 ?SetCloudScrollSpeed@CSkyBox@@QAEXABUD3DXVECTOR2@@@Z ; CSkyBox::SetCloudScrollSpeed

; 313  : 	m_SkyBox.Refresh();

  001c9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  001d2	e8 00 00 00 00	 call	 ?Refresh@CSkyBox@@QAEXXZ ; CSkyBox::Refresh

; 314  : 
; 315  : 	// Temporary
; 316  : 	m_SkyBox.SetCloudColor(mc_pEnvironmentData->CloudGradientColor, mc_pEnvironmentData->CloudGradientColor, 1);

  001d7	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  001de	8d 45 cc	 lea	 eax, DWORD PTR $T1[ebp]
  001e1	50		 push	 eax
  001e2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e5	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  001e8	05 34 02 00 00	 add	 eax, 564		; 00000234H
  001ed	50		 push	 eax
  001ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  001f4	05 34 02 00 00	 add	 eax, 564		; 00000234H
  001f9	50		 push	 eax
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00203	e8 00 00 00 00	 call	 ?SetCloudColor@CSkyBox@@QAEXABUTGradientColor@@0ABK@Z ; CSkyBox::SetCloudColor

; 318  : 	if (!mc_pEnvironmentData->SkyBoxGradientColorVector.empty())

  00208	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0020b	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0020e	05 54 02 00 00	 add	 eax, 596		; 00000254H
  00213	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00216	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00219	89 45 e4	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  0021c	8b 45 e4	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0021f	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  00222	8b 00		 mov	 eax, DWORD PTR [eax]
  00224	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00227	75 09		 jne	 SHORT $LN62@SetEnviron
  00229	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv312[ebp], 1
  00230	eb 04		 jmp	 SHORT $LN63@SetEnviron
$LN62@SetEnviron:
  00232	83 65 e0 00	 and	 DWORD PTR tv312[ebp], 0
$LN63@SetEnviron:
  00236	8a 45 e0	 mov	 al, BYTE PTR tv312[ebp]
  00239	88 45 fd	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 318  : 	if (!mc_pEnvironmentData->SkyBoxGradientColorVector.empty())

  0023c	0f b6 45 fd	 movzx	 eax, BYTE PTR $T7[ebp]
  00240	85 c0		 test	 eax, eax
  00242	75 28		 jne	 SHORT $LN8@SetEnviron

; 319  : 		m_SkyBox.SetSkyColor(mc_pEnvironmentData->SkyBoxGradientColorVector, mc_pEnvironmentData->SkyBoxGradientColorVector, 1);

  00244	6a 01		 push	 1
  00246	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00249	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0024c	05 54 02 00 00	 add	 eax, 596		; 00000254H
  00251	50		 push	 eax
  00252	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00255	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00258	05 54 02 00 00	 add	 eax, 596		; 00000254H
  0025d	50		 push	 eax
  0025e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00261	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00267	e8 00 00 00 00	 call	 ?SetSkyColor@CSkyBox@@QAEXABV?$vector@UTGradientColor@@V?$allocator@UTGradientColor@@@std@@@std@@0J@Z ; CSkyBox::SetSkyColor
$LN8@SetEnviron:

; 320  : 	// Temporary
; 321  : 
; 322  : 	m_SkyBox.StartTransition();

  0026c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0026f	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00275	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00278	8b 80 38 03 00
	00		 mov	 eax, DWORD PTR [eax+824]
  0027e	ff 50 10	 call	 DWORD PTR [eax+16]
$LN1@SetEnviron:

; 323  : }

  00281	c9		 leave
  00282	c3		 ret	 0
?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ ENDP		; CMapOutdoor::SetEnvironmentSkyBox
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ PROC	; CMapOutdoor::SetEnvironmentScreenFilter, COMDAT
; _this$ = ecx

; 282  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 283  : 	if (!mc_pEnvironmentData)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0000e	75 02		 jne	 SHORT $LN2@SetEnviron

; 284  : 		return;

  00010	eb 5e		 jmp	 SHORT $LN1@SetEnviron
$LN2@SetEnviron:

; 285  : 
; 286  : 	m_ScreenFilter.SetEnable(mc_pEnvironmentData->bFilteringEnable);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00018	ff b0 3c 01 00
	00		 push	 DWORD PTR [eax+316]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  00027	e8 00 00 00 00	 call	 ?SetEnable@CScreenFilter@@QAEXH@Z ; CScreenFilter::SetEnable

; 287  : 	m_ScreenFilter.SetBlendType(mc_pEnvironmentData->byFilteringAlphaSrc, mc_pEnvironmentData->byFilteringAlphaDest);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00032	0f b6 80 51 01
	00 00		 movzx	 eax, BYTE PTR [eax+337]
  00039	50		 push	 eax
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00040	0f b6 80 50 01
	00 00		 movzx	 eax, BYTE PTR [eax+336]
  00047	50		 push	 eax
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  00051	e8 00 00 00 00	 call	 ?SetBlendType@CScreenFilter@@QAEXEE@Z ; CScreenFilter::SetBlendType

; 288  : 	m_ScreenFilter.SetColor(mc_pEnvironmentData->FilteringColor);

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  0005c	05 40 01 00 00	 add	 eax, 320		; 00000140H
  00061	50		 push	 eax
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  0006b	e8 00 00 00 00	 call	 ?SetColor@CScreenFilter@@QAEXABUD3DXCOLOR@@@Z ; CScreenFilter::SetColor
$LN1@SetEnviron:

; 289  : }

  00070	c9		 leave
  00071	c3		 ret	 0
?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ ENDP	; CMapOutdoor::SetEnvironmentScreenFilter
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?Clear@CMapOutdoor@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Clear@CMapOutdoor@@UAEXXZ PROC				; CMapOutdoor::Clear, COMDAT
; _this$ = ecx

; 227  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 228  : 	UnloadWaterTexture();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?UnloadWaterTexture@CMapOutdoor@@IAEXXZ ; CMapOutdoor::UnloadWaterTexture

; 229  : 	Destroy();		// 

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	ff 50 0c	 call	 DWORD PTR [eax+12]

; 230  : 	Initialize();	// 

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	ff 50 08	 call	 DWORD PTR [eax+8]

; 231  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?Clear@CMapOutdoor@@UAEXXZ ENDP				; CMapOutdoor::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetCacheHeight@CMapOutdoor@@UAEMMM@Z
_TEXT	SEGMENT
_kItem$2 = -216						; size = 8
_kGetObjHeight$3 = -208					; size = 16
_kGetObjHeight$4 = -192					; size = 16
$T5 = -176						; size = 4
___param0$ = -172					; size = 4
$T6 = -168						; size = 4
$T7 = -164						; size = 4
$T8 = -160						; size = 4
$T9 = -156						; size = 4
$T10 = -152						; size = 4
___param0$ = -148					; size = 4
$T11 = -144						; size = 4
$T12 = -140						; size = 4
_kRangeTester_kGetObjHeight$13 = -136			; size = 12
tv286 = -124						; size = 4
__My_data$14 = -120					; size = 4
__My_data$15 = -116					; size = 4
_fHeight$ = -112					; size = 4
__My_data$16 = -108					; size = 4
_rkCullingMgr$ = -104					; size = 4
_CHECK_HEIGHT$ = -100					; size = 4
_rkItem$17 = -96					; size = 4
tv277 = -92						; size = 4
_fObjectHeight$ = -88					; size = 4
_fTerrainHeight$ = -84					; size = 4
_this$ = -80						; size = 4
_dwKey$ = -76						; size = 4
_nx$ = -72						; size = 4
_ny$ = -68						; size = 4
_i$18 = -64						; size = 4
_pkVct_kItem$ = -60					; size = 4
$T19 = -54						; size = 1
$T20 = -53						; size = 1
_aVector3d$21 = -52					; size = 12
_toTop$22 = -40						; size = 12
_aVector3d$23 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?GetCacheHeight@CMapOutdoor@@UAEMMM@Z PROC		; CMapOutdoor::GetCacheHeight, COMDAT
; _this$ = ecx

; 775  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 776  : 	unsigned int nx=int(fx);

  0002e	f3 0f 2c 45 08	 cvttss2si eax, DWORD PTR _fx$[ebp]
  00033	89 45 b8	 mov	 DWORD PTR _nx$[ebp], eax

; 777  : 	unsigned int ny=int(fy);

  00036	f3 0f 2c 45 0c	 cvttss2si eax, DWORD PTR _fy$[ebp]
  0003b	89 45 bc	 mov	 DWORD PTR _ny$[ebp], eax

; 778  : 
; 779  : 	DWORD dwKey=0;

  0003e	83 65 b4 00	 and	 DWORD PTR _dwKey$[ebp], 0

; 780  : 
; 781  : #ifdef __HEIGHT_CACHE_TRACE__
; 782  : 	static DWORD s_dwTotalCount=0;
; 783  : 	static DWORD s_dwHitCount=0;
; 784  : 	static DWORD s_dwErrorCount=0;
; 785  : 
; 786  : 	s_dwTotalCount++;
; 787  : #endif
; 788  : 
; 789  : 	std::vector<SHeightCache::SItem>* pkVct_kItem=NULL;

  00042	83 65 c4 00	 and	 DWORD PTR _pkVct_kItem$[ebp], 0

; 790  : 	if (m_kHeightCache.m_isUpdated && nx<16*30000 && ny<16*30000)

  00046	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	0f b6 80 78 13
	00 00		 movzx	 eax, BYTE PTR [eax+4984]
  00050	85 c0		 test	 eax, eax
  00052	0f 84 56 01 00
	00		 je	 $LN5@GetCacheHe
  00058	81 7d b8 00 53
	07 00		 cmp	 DWORD PTR _nx$[ebp], 480000 ; 00075300H
  0005f	0f 83 49 01 00
	00		 jae	 $LN5@GetCacheHe
  00065	81 7d bc 00 53
	07 00		 cmp	 DWORD PTR _ny$[ebp], 480000 ; 00075300H
  0006c	0f 83 3c 01 00
	00		 jae	 $LN5@GetCacheHe

; 791  : 	{
; 792  : 		nx>>=4;

  00072	8b 45 b8	 mov	 eax, DWORD PTR _nx$[ebp]
  00075	c1 e8 04	 shr	 eax, 4
  00078	89 45 b8	 mov	 DWORD PTR _nx$[ebp], eax

; 793  : 		ny>>=4;

  0007b	8b 45 bc	 mov	 eax, DWORD PTR _ny$[ebp]
  0007e	c1 e8 04	 shr	 eax, 4
  00081	89 45 bc	 mov	 DWORD PTR _ny$[ebp], eax

; 794  : 		//short aPos[2]={nx, ny};
; 795  : 
; 796  : 		dwKey=(ny<<16)|nx;//CalcCRC16Words(2, aPos);

  00084	8b 45 bc	 mov	 eax, DWORD PTR _ny$[ebp]
  00087	c1 e0 10	 shl	 eax, 16			; 00000010H
  0008a	0b 45 b8	 or	 eax, DWORD PTR _nx$[ebp]
  0008d	89 45 b4	 mov	 DWORD PTR _dwKey$[ebp], eax

; 797  : 		pkVct_kItem=&m_kHeightCache.m_akVct_kItem[dwKey%SHeightCache::HASH_SIZE];

  00090	8b 45 b4	 mov	 eax, DWORD PTR _dwKey$[ebp]
  00093	33 d2		 xor	 edx, edx
  00095	6a 64		 push	 100			; 00000064H
  00097	59		 pop	 ecx
  00098	f7 f1		 div	 ecx
  0009a	6b c2 0c	 imul	 eax, edx, 12
  0009d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	8d 84 01 c8 0e
	00 00		 lea	 eax, DWORD PTR [ecx+eax+3784]
  000a7	89 45 c4	 mov	 DWORD PTR _pkVct_kItem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  000aa	83 65 c0 00	 and	 DWORD PTR _i$18[ebp], 0

; 1410 :         auto& _My_data = _Mypair._Myval2;

  000ae	8b 45 c4	 mov	 eax, DWORD PTR _pkVct_kItem$[ebp]
  000b1	89 45 8c	 mov	 DWORD PTR __My_data$15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000b4	8b 45 8c	 mov	 eax, DWORD PTR __My_data$15[ebp]
  000b7	89 85 58 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  000bd	8b 45 8c	 mov	 eax, DWORD PTR __My_data$15[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 85 54 ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax
  000c8	ff b5 58 ff ff
	ff		 push	 DWORD PTR $T6[ebp]
  000ce	ff b5 54 ff ff
	ff		 push	 DWORD PTR ___param0$[ebp]
  000d4	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  000da	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >
  000df	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  000e5	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 799  : 		for (i=pkVct_kItem->begin(); i!=pkVct_kItem->end(); ++i)

  000eb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  000f1	8b 00		 mov	 eax, DWORD PTR [eax]
  000f3	89 45 c0	 mov	 DWORD PTR _i$18[ebp], eax
  000f6	eb 09		 jmp	 SHORT $LN31@GetCacheHe
$LN2@GetCacheHe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  000f8	8b 45 c0	 mov	 eax, DWORD PTR _i$18[ebp]
  000fb	83 c0 08	 add	 eax, 8
  000fe	89 45 c0	 mov	 DWORD PTR _i$18[ebp], eax
$LN31@GetCacheHe:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00101	8b 45 c4	 mov	 eax, DWORD PTR _pkVct_kItem$[ebp]
  00104	89 45 88	 mov	 DWORD PTR __My_data$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00107	8b 45 88	 mov	 eax, DWORD PTR __My_data$14[ebp]
  0010a	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00110	8b 45 88	 mov	 eax, DWORD PTR __My_data$14[ebp]
  00113	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00116	89 85 6c ff ff
	ff		 mov	 DWORD PTR ___param0$[ebp], eax
  0011c	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T11[ebp]
  00122	ff b5 6c ff ff
	ff		 push	 DWORD PTR ___param0$[ebp]
  00128	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0012e	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@@std@@QAE@PAUSItem@SHeightCache@CMapOutdoor@@PBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<CMapOutdoor::SHeightCache::SItem> > >
  00133	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00139	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0013f	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00145	8b 4d c0	 mov	 ecx, DWORD PTR _i$18[ebp]
  00148	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0014a	75 09		 jne	 SHORT $LN53@GetCacheHe
  0014c	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv286[ebp], 1
  00153	eb 04		 jmp	 SHORT $LN54@GetCacheHe
$LN53@GetCacheHe:
  00155	83 65 84 00	 and	 DWORD PTR tv286[ebp], 0
$LN54@GetCacheHe:
  00159	8a 45 84	 mov	 al, BYTE PTR tv286[ebp]
  0015c	88 45 cb	 mov	 BYTE PTR $T20[ebp], al

; 153  :         return !(*this == _Right);

  0015f	0f b6 45 cb	 movzx	 eax, BYTE PTR $T20[ebp]
  00163	85 c0		 test	 eax, eax
  00165	75 09		 jne	 SHORT $LN48@GetCacheHe
  00167	c7 45 a4 01 00
	00 00		 mov	 DWORD PTR tv277[ebp], 1
  0016e	eb 04		 jmp	 SHORT $LN49@GetCacheHe
$LN48@GetCacheHe:
  00170	83 65 a4 00	 and	 DWORD PTR tv277[ebp], 0
$LN49@GetCacheHe:
  00174	8a 45 a4	 mov	 al, BYTE PTR tv277[ebp]
  00177	88 45 ca	 mov	 BYTE PTR $T19[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 799  : 		for (i=pkVct_kItem->begin(); i!=pkVct_kItem->end(); ++i)

  0017a	0f b6 45 ca	 movzx	 eax, BYTE PTR $T19[ebp]
  0017e	85 c0		 test	 eax, eax
  00180	74 2c		 je	 SHORT $LN3@GetCacheHe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  00182	8b 45 c0	 mov	 eax, DWORD PTR _i$18[ebp]
  00185	89 85 60 ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  0018b	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR $T8[ebp]
  00191	89 45 a0	 mov	 DWORD PTR _rkItem$17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 802  : 			if (rkItem.m_dwKey==dwKey)

  00194	8b 45 a0	 mov	 eax, DWORD PTR _rkItem$17[ebp]
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	3b 45 b4	 cmp	 eax, DWORD PTR _dwKey$[ebp]
  0019c	75 0b		 jne	 SHORT $LN7@GetCacheHe

; 803  : 			{
; 804  : #ifdef __HEIGHT_CACHE_TRACE__
; 805  : 				s_dwHitCount++;
; 806  : 				
; 807  : 				if (s_dwTotalCount>1000)
; 808  : 				{
; 809  : 					DWORD dwHitRate=s_dwHitCount*1000/s_dwTotalCount;
; 810  : 					static DWORD s_dwMaxHitRate=0;
; 811  : 					if (s_dwMaxHitRate<dwHitRate)
; 812  : 					{
; 813  : 						s_dwMaxHitRate=dwHitRate;
; 814  : 						printf("HitRate %f\n", s_dwMaxHitRate*0.1f);
; 815  : 					}
; 816  : 
; 817  : 
; 818  : 				}			
; 819  : #endif
; 820  : 				return rkItem.m_fHeight;

  0019e	8b 45 a0	 mov	 eax, DWORD PTR _rkItem$17[ebp]
  001a1	d9 40 04	 fld	 DWORD PTR [eax+4]
  001a4	e9 3e 02 00 00	 jmp	 $LN1@GetCacheHe
$LN7@GetCacheHe:

; 821  : 			}
; 822  : 		}		

  001a9	e9 4a ff ff ff	 jmp	 $LN2@GetCacheHe
$LN3@GetCacheHe:
$LN5@GetCacheHe:

; 823  : 	}
; 824  : 	else
; 825  : 	{
; 826  : #ifdef __HEIGHT_CACHE_TRACE__
; 827  : 		s_dwErrorCount++;
; 828  : 		//printf("NoCache (%f, %f)\n", fx/100.0f, fy/100.0f);
; 829  : #endif
; 830  : 	}
; 831  : #ifdef __HEIGHT_CACHE_TRACE__	
; 832  : 	if (s_dwTotalCount>=1000000)
; 833  : 	{
; 834  : 		printf("HitRate %f\n", s_dwHitCount*1000/s_dwTotalCount*0.1f);
; 835  : 		printf("ErrRate %f\n", s_dwErrorCount*1000/s_dwTotalCount*0.1f);
; 836  : 		s_dwHitCount=0;
; 837  : 		s_dwTotalCount=0;
; 838  : 		s_dwErrorCount=0;
; 839  : 	}
; 840  : #endif
; 841  : 	
; 842  : 	float fTerrainHeight = GetTerrainHeight(fx, fy);

  001ae	51		 push	 ecx
  001af	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001b9	51		 push	 ecx
  001ba	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001bf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c4	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z ; CMapOutdoor::GetTerrainHeight
  001cc	d9 5d ac	 fstp	 DWORD PTR _fTerrainHeight$[ebp]

; 843  : #ifdef SPHERELIB_STRICT
; 844  : 	if (MAPOUTDOOR_GET_HEIGHT_TRACE)
; 845  : 		printf("Terrain %f\n", fTerrainHeight);
; 846  : #endif
; 847  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  001d4	89 45 98	 mov	 DWORD PTR _rkCullingMgr$[ebp], eax

; 848  : 
; 849  : 	float CHECK_HEIGHT = 25000.0f;

  001d7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c35000
  001df	f3 0f 11 45 9c	 movss	 DWORD PTR _CHECK_HEIGHT$[ebp], xmm0

; 850  : 	float fObjectHeight = -CHECK_HEIGHT;

  001e4	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _CHECK_HEIGHT$[ebp]
  001e9	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001f0	f3 0f 11 45 a8	 movss	 DWORD PTR _fObjectHeight$[ebp], xmm0

; 851  : 
; 852  : 	if (MAPOUTDOOR_GET_HEIGHT_USE2D)

  001f5	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?MAPOUTDOOR_GET_HEIGHT_USE2D@@3_NA ; MAPOUTDOOR_GET_HEIGHT_USE2D
  001fc	85 c0		 test	 eax, eax
  001fe	0f 84 cd 00 00
	00		 je	 $LN8@GetCacheHe
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  00204	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00209	f3 0f 11 45 e4	 movss	 DWORD PTR _aVector3d$23[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 855  : 		aVector3d.Set(fx, -fy, fTerrainHeight);

  0020e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00213	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 108  : 		y = b;

  0021a	f3 0f 11 45 e8	 movss	 DWORD PTR _aVector3d$23[ebp+4], xmm0

; 109  : 		z = c;

  0021f	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fTerrainHeight$[ebp]
  00224	f3 0f 11 45 ec	 movss	 DWORD PTR _aVector3d$23[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 21   : 		m_fRequestX=fRequestX;

  00229	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0022e	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$4[ebp+8], xmm0

; 22   : 		m_fRequestY=fRequestY;

  00236	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0023b	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$4[ebp+12], xmm0

; 23   : 		m_bHeightFound=false;

  00243	c6 85 40 ff ff
	ff 00		 mov	 BYTE PTR _kGetObjHeight$4[ebp], 0

; 24   : 		m_fReturnHeight=0.0f;

  0024a	0f 57 c0	 xorps	 xmm0, xmm0
  0024d	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$4[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  00255	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  0025f	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@

; 15   : 		: f(fn), dist(distance)

  00269	8d 85 40 ff ff
	ff		 lea	 eax, DWORD PTR _kGetObjHeight$4[ebp]
  0026f	89 85 7c ff ff
	ff		 mov	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp+4], eax
  00275	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0027d	f3 0f 11 45 80	 movss	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 859  : 		RangeTester<FGetObjectHeight> kRangeTester_kGetObjHeight(&kGetObjHeight);

  00282	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 100  : 		m_Factory->PointTest2d(p, callback);

  00286	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR _kRangeTester_kGetObjHeight$13[ebp]
  0028c	50		 push	 eax
  0028d	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$23[ebp]
  00290	50		 push	 eax
  00291	8b 45 98	 mov	 eax, DWORD PTR _rkCullingMgr$[ebp]
  00294	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00297	e8 00 00 00 00	 call	 ?PointTest2d@SpherePackFactory@@QAEXABVVector3d@@PAVSpherePackCallback@@@Z ; SpherePackFactory::PointTest2d
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 862  : 		if (kGetObjHeight.m_bHeightFound)

  0029c	0f b6 85 40 ff
	ff ff		 movzx	 eax, BYTE PTR _kGetObjHeight$4[ebp]
  002a3	85 c0		 test	 eax, eax
  002a5	74 0d		 je	 SHORT $LN10@GetCacheHe

; 863  : 			fObjectHeight = kGetObjHeight.m_fReturnHeight;

  002a7	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _kGetObjHeight$4[ebp+4]
  002af	f3 0f 11 45 a8	 movss	 DWORD PTR _fObjectHeight$[ebp], xmm0
$LN10@GetCacheHe:

; 864  : 	}

  002b4	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  002b8	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  002c2	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _kRangeTester_kGetObjHeight$13[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 864  : 	}

  002cc	e9 9a 00 00 00	 jmp	 $LN11@GetCacheHe
$LN8@GetCacheHe:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  002d1	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002d6	f3 0f 11 45 cc	 movss	 DWORD PTR _aVector3d$21[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 868  : 		aVector3d.Set(fx, -fy, fTerrainHeight);

  002db	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002e0	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 108  : 		y = b;

  002e7	f3 0f 11 45 d0	 movss	 DWORD PTR _aVector3d$21[ebp+4], xmm0

; 109  : 		z = c;

  002ec	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fTerrainHeight$[ebp]
  002f1	f3 0f 11 45 d4	 movss	 DWORD PTR _aVector3d$21[ebp+8], xmm0

; 107  : 		x = a;

  002f6	0f 57 c0	 xorps	 xmm0, xmm0
  002f9	f3 0f 11 45 d8	 movss	 DWORD PTR _toTop$22[ebp], xmm0

; 108  : 		y = b;

  002fe	0f 57 c0	 xorps	 xmm0, xmm0
  00301	f3 0f 11 45 dc	 movss	 DWORD PTR _toTop$22[ebp+4], xmm0

; 109  : 		z = c;

  00306	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _CHECK_HEIGHT$[ebp]
  0030b	f3 0f 11 45 e0	 movss	 DWORD PTR _toTop$22[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 21   : 		m_fRequestX=fRequestX;

  00310	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00315	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$3[ebp+8], xmm0

; 22   : 		m_fRequestY=fRequestY;

  0031d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00322	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$3[ebp+12], xmm0

; 23   : 		m_bHeightFound=false;

  0032a	c6 85 30 ff ff
	ff 00		 mov	 BYTE PTR _kGetObjHeight$3[ebp], 0

; 24   : 		m_fReturnHeight=0.0f;

  00331	0f 57 c0	 xorps	 xmm0, xmm0
  00334	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _kGetObjHeight$3[ebp+4], xmm0

; 869  : 
; 870  : 		Vector3d toTop;
; 871  : 		toTop.Set(0,0,CHECK_HEIGHT);
; 872  : 
; 873  : 		FGetObjectHeight kGetObjHeight(fx, fy);
; 874  : 		rkCullingMgr.ForInRay(aVector3d, toTop, &kGetObjHeight);

  0033c	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _kGetObjHeight$3[ebp]
  00342	50		 push	 eax
  00343	8d 45 d8	 lea	 eax, DWORD PTR _toTop$22[ebp]
  00346	50		 push	 eax
  00347	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$21[ebp]
  0034a	50		 push	 eax
  0034b	8b 4d 98	 mov	 ecx, DWORD PTR _rkCullingMgr$[ebp]
  0034e	e8 00 00 00 00	 call	 ??$ForInRay@UFGetObjectHeight@@@CCullingManager@@QAEXABVVector3d@@0PAUFGetObjectHeight@@@Z ; CCullingManager::ForInRay<FGetObjectHeight>

; 875  : 
; 876  : 		if (kGetObjHeight.m_bHeightFound)

  00353	0f b6 85 30 ff
	ff ff		 movzx	 eax, BYTE PTR _kGetObjHeight$3[ebp]
  0035a	85 c0		 test	 eax, eax
  0035c	74 0d		 je	 SHORT $LN11@GetCacheHe

; 877  : 			fObjectHeight = kGetObjHeight.m_fReturnHeight;

  0035e	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _kGetObjHeight$3[ebp+4]
  00366	f3 0f 11 45 a8	 movss	 DWORD PTR _fObjectHeight$[ebp], xmm0
$LN11@GetCacheHe:

; 878  : 	}
; 879  : 
; 880  : 	float fHeight=fMAX(fObjectHeight, fTerrainHeight);

  0036b	51		 push	 ecx
  0036c	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fTerrainHeight$[ebp]
  00371	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00376	51		 push	 ecx
  00377	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fObjectHeight$[ebp]
  0037c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00381	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00386	59		 pop	 ecx
  00387	59		 pop	 ecx
  00388	d9 5d 90	 fstp	 DWORD PTR _fHeight$[ebp]

; 881  : 
; 882  : 	if (pkVct_kItem)

  0038b	83 7d c4 00	 cmp	 DWORD PTR _pkVct_kItem$[ebp], 0
  0038f	74 53		 je	 SHORT $LN133@GetCacheHe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00391	8b 45 c4	 mov	 eax, DWORD PTR _pkVct_kItem$[ebp]
  00394	89 45 94	 mov	 DWORD PTR __My_data$16[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00397	8b 45 94	 mov	 eax, DWORD PTR __My_data$16[ebp]
  0039a	8b 4d 94	 mov	 ecx, DWORD PTR __My_data$16[ebp]
  0039d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003a0	2b 01		 sub	 eax, DWORD PTR [ecx]
  003a2	c1 f8 03	 sar	 eax, 3
  003a5	89 85 5c ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 884  : 		if (pkVct_kItem->size()>=200)

  003ab	81 bd 5c ff ff
	ff c8 00 00 00	 cmp	 DWORD PTR $T7[ebp], 200	; 000000c8H
  003b5	72 08		 jb	 SHORT $LN13@GetCacheHe

; 885  : 		{
; 886  : #ifdef __HEIGHT_CACHE_TRACE__
; 887  : 			printf("ClearCacheHeight[%d]\n", dwKey%SHeightCache::HASH_SIZE);
; 888  : #endif
; 889  : 			pkVct_kItem->clear();

  003b7	8b 4d c4	 mov	 ecx, DWORD PTR _pkVct_kItem$[ebp]
  003ba	e8 00 00 00 00	 call	 ?clear@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXXZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::clear
$LN13@GetCacheHe:

; 890  : 		}
; 891  : 		
; 892  : 		SHeightCache::SItem kItem;
; 893  : 		kItem.m_dwKey=dwKey;

  003bf	8b 45 b4	 mov	 eax, DWORD PTR _dwKey$[ebp]
  003c2	89 85 28 ff ff
	ff		 mov	 DWORD PTR _kItem$2[ebp], eax

; 894  : 		kItem.m_fHeight=fHeight;

  003c8	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  003cd	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _kItem$2[ebp+4], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  003d5	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR _kItem$2[ebp]
  003db	50		 push	 eax
  003dc	8b 4d c4	 mov	 ecx, DWORD PTR _pkVct_kItem$[ebp]
  003df	e8 00 00 00 00	 call	 ??$emplace_back@ABUSItem@SHeightCache@CMapOutdoor@@@?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAEXABUSItem@SHeightCache@CMapOutdoor@@@Z ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::emplace_back<CMapOutdoor::SHeightCache::SItem const &>
$LN133@GetCacheHe:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 898  : 	return fHeight;

  003e4	d9 45 90	 fld	 DWORD PTR _fHeight$[ebp]
$LN1@GetCacheHe:

; 899  : }

  003e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f1	59		 pop	 ecx
  003f2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003f5	33 cd		 xor	 ecx, ebp
  003f7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003fc	c9		 leave
  003fd	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR _kRangeTester_kGetObjHeight$13[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ ; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetCacheHeight@CMapOutdoor@@UAEMMM@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetCacheHeight@CMapOutdoor@@UAEMMM@Z ENDP		; CMapOutdoor::GetCacheHeight
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?GetHeight@CMapOutdoor@@UAEMMM@Z
_TEXT	SEGMENT
_kGetObjHeight$2 = -80					; size = 16
$T3 = -64						; size = 4
_rkCullingMgr$4 = -60					; size = 4
_CHECK_HEIGHT$5 = -56					; size = 4
_kRangeTester_kGetObjHeight$6 = -52			; size = 12
_fObjectHeight$7 = -40					; size = 4
_this$ = -36						; size = 4
_fTerrainHeight$ = -32					; size = 4
_aVector3d$8 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?GetHeight@CMapOutdoor@@UAEMMM@Z PROC			; CMapOutdoor::GetHeight, COMDAT
; _this$ = ecx

; 747  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetHeight@CMapOutdoor@@UAEMMM@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 748  : 	float fTerrainHeight = GetTerrainHeight(fx, fy);

  0002b	51		 push	 ecx
  0002c	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00031	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00036	51		 push	 ecx
  00037	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0003c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00041	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetTerrainHeight@CMapOutdoor@@QAEMMM@Z ; CMapOutdoor::GetTerrainHeight
  00049	d9 5d e0	 fstp	 DWORD PTR _fTerrainHeight$[ebp]

; 749  : 
; 750  : 	if (!m_bEnableTerrainOnlyForHeight)

  0004c	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	0f b6 80 b6 0e
	00 00		 movzx	 eax, BYTE PTR [eax+3766]
  00056	85 c0		 test	 eax, eax
  00058	0f 85 ec 00 00
	00		 jne	 $LN2@GetHeight

; 751  : 	{
; 752  : 		CCullingManager & rkCullingMgr = CCullingManager::Instance();

  0005e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  00063	89 45 c4	 mov	 DWORD PTR _rkCullingMgr$4[ebp], eax

; 753  : 
; 754  : 		float CHECK_HEIGHT = 25000.0f;

  00066	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@46c35000
  0006e	f3 0f 11 45 c8	 movss	 DWORD PTR _CHECK_HEIGHT$5[ebp], xmm0

; 755  : 		float fObjectHeight = -CHECK_HEIGHT;

  00073	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _CHECK_HEIGHT$5[ebp]
  00078	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0007f	f3 0f 11 45 d8	 movss	 DWORD PTR _fObjectHeight$7[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  00084	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00089	f3 0f 11 45 e4	 movss	 DWORD PTR _aVector3d$8[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 758  : 		aVector3d.Set(fx, -fy, fTerrainHeight);

  0008e	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00093	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 108  : 		y = b;

  0009a	f3 0f 11 45 e8	 movss	 DWORD PTR _aVector3d$8[ebp+4], xmm0

; 109  : 		z = c;

  0009f	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fTerrainHeight$[ebp]
  000a4	f3 0f 11 45 ec	 movss	 DWORD PTR _aVector3d$8[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 21   : 		m_fRequestX=fRequestX;

  000a9	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000ae	f3 0f 11 45 b8	 movss	 DWORD PTR _kGetObjHeight$2[ebp+8], xmm0

; 22   : 		m_fRequestY=fRequestY;

  000b3	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000b8	f3 0f 11 45 bc	 movss	 DWORD PTR _kGetObjHeight$2[ebp+12], xmm0

; 23   : 		m_bHeightFound=false;

  000bd	c6 45 b0 00	 mov	 BYTE PTR _kGetObjHeight$2[ebp], 0

; 24   : 		m_fReturnHeight=0.0f;

  000c1	0f 57 c0	 xorps	 xmm0, xmm0
  000c4	f3 0f 11 45 b4	 movss	 DWORD PTR _kGetObjHeight$2[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  000c9	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  000d0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@

; 15   : 		: f(fn), dist(distance)

  000d7	8d 45 b0	 lea	 eax, DWORD PTR _kGetObjHeight$2[ebp]
  000da	89 45 d0	 mov	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp+4], eax
  000dd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  000e5	f3 0f 11 45 d4	 movss	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 762  : 		RangeTester<FGetObjectHeight> kRangeTester_kGetObjHeight(&kGetObjHeight);

  000ea	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 100  : 		m_Factory->PointTest2d(p, callback);

  000ee	8d 45 cc	 lea	 eax, DWORD PTR _kRangeTester_kGetObjHeight$6[ebp]
  000f1	50		 push	 eax
  000f2	8d 45 e4	 lea	 eax, DWORD PTR _aVector3d$8[ebp]
  000f5	50		 push	 eax
  000f6	8b 45 c4	 mov	 eax, DWORD PTR _rkCullingMgr$4[ebp]
  000f9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000fc	e8 00 00 00 00	 call	 ?PointTest2d@SpherePackFactory@@QAEXABVVector3d@@PAVSpherePackCallback@@@Z ; SpherePackFactory::PointTest2d
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 765  : 		if (kGetObjHeight.m_bHeightFound)

  00101	0f b6 45 b0	 movzx	 eax, BYTE PTR _kGetObjHeight$2[ebp]
  00105	85 c0		 test	 eax, eax
  00107	74 0a		 je	 SHORT $LN3@GetHeight

; 766  : 			fObjectHeight = kGetObjHeight.m_fReturnHeight;

  00109	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _kGetObjHeight$2[ebp+4]
  0010e	f3 0f 11 45 d8	 movss	 DWORD PTR _fObjectHeight$7[ebp], xmm0
$LN3@GetHeight:

; 768  : 		return fMAX(fObjectHeight, fTerrainHeight);

  00113	51		 push	 ecx
  00114	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fTerrainHeight$[ebp]
  00119	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011e	51		 push	 ecx
  0011f	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fObjectHeight$7[ebp]
  00124	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00129	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  0012e	59		 pop	 ecx
  0012f	59		 pop	 ecx
  00130	d9 5d c0	 fstp	 DWORD PTR $T3[ebp]
  00133	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00137	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp], OFFSET ??_7?$RangeTester@UFGetObjectHeight@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  0013e	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _kRangeTester_kGetObjHeight$6[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 768  : 		return fMAX(fObjectHeight, fTerrainHeight);

  00145	d9 45 c0	 fld	 DWORD PTR $T3[ebp]
  00148	eb 03		 jmp	 SHORT $LN1@GetHeight
$LN2@GetHeight:

; 769  : 	}
; 770  : 
; 771  : 	return fTerrainHeight;

  0014a	d9 45 e0	 fld	 DWORD PTR _fTerrainHeight$[ebp]
$LN1@GetHeight:

; 772  : }

  0014d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00150	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00157	59		 pop	 ecx
  00158	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015b	33 cd		 xor	 ecx, ebp
  0015d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00162	c9		 leave
  00163	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetHeight@CMapOutdoor@@UAEMMM@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _kRangeTester_kGetObjHeight$6[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UFGetObjectHeight@@@@UAE@XZ ; RangeTester<FGetObjectHeight>::~RangeTester<FGetObjectHeight>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetHeight@CMapOutdoor@@UAEMMM@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetHeight@CMapOutdoor@@UAEMMM@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetHeight@CMapOutdoor@@UAEMMM@Z ENDP			; CMapOutdoor::GetHeight
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.h
;	COMDAT ?OnPreAssignTerrainPtr@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnPreAssignTerrainPtr@CMapOutdoor@@MAEXXZ PROC		; CMapOutdoor::OnPreAssignTerrainPtr, COMDAT
; _this$ = ecx

; 82   : 		virtual void	OnPreAssignTerrainPtr() {};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnPreAssignTerrainPtr@CMapOutdoor@@MAEXXZ ENDP		; CMapOutdoor::OnPreAssignTerrainPtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?OnResetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnResetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ PROC	; CMapOutdoor::OnResetEnvironmentDataPtr, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	m_SkyBox.Unload();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00010	e8 00 00 00 00	 call	 ?Unload@CSkyBox@@QAEXXZ	; CSkyBox::Unload

; 276  : 	SetEnvironmentScreenFilter();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentScreenFilter

; 277  : 	SetEnvironmentSkyBox();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentSkyBox

; 278  : 	SetEnvironmentLensFlare();

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentLensFlare

; 279  : }

  0002d	c9		 leave
  0002e	c3		 ret	 0
?OnResetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ ENDP	; CMapOutdoor::OnResetEnvironmentDataPtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?OnSetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnSetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ PROC	; CMapOutdoor::OnSetEnvironmentDataPtr, COMDAT
; _this$ = ecx

; 267  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 268  : 	SetEnvironmentScreenFilter();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?SetEnvironmentScreenFilter@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentScreenFilter

; 269  : 	SetEnvironmentSkyBox();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?SetEnvironmentSkyBox@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentSkyBox

; 270  : 	SetEnvironmentLensFlare();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?SetEnvironmentLensFlare@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SetEnvironmentLensFlare

; 271  : }

  0001f	c9		 leave
  00020	c3		 ret	 0
?OnSetEnvironmentDataPtr@CMapOutdoor@@MAEXXZ ENDP	; CMapOutdoor::OnSetEnvironmentDataPtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?Destroy@CMapOutdoor@@MAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CMapOutdoor@@MAE_NXZ PROC			; CMapOutdoor::Destroy, COMDAT
; _this$ = ecx

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 200  : 	m_bEnableTerrainOnlyForHeight = FALSE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 80 b6 0e 00
	00 00		 mov	 BYTE PTR [eax+3766], 0

; 201  : 	m_bEnablePortal = FALSE;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c6 80 b7 0e 00
	00 00		 mov	 BYTE PTR [eax+3767], 0

; 202  : 
; 203  : 	XMasTree_Destroy();

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?XMasTree_Destroy@CMapOutdoor@@QAEXXZ ; CMapOutdoor::XMasTree_Destroy

; 204  : 
; 205  : 	DestroyTerrain();

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	ff 50 50	 call	 DWORD PTR [eax+80]

; 206  :  	DestroyArea();

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	ff 50 54	 call	 DWORD PTR [eax+84]

; 207  : 	DestroyTerrainPatchProxyList();

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?DestroyTerrainPatchProxyList@CMapOutdoor@@IAEXXZ ; CMapOutdoor::DestroyTerrainPatchProxyList

; 208  : 
; 209  : 	FreeQuadTree();

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?FreeQuadTree@CMapOutdoor@@IAEXXZ ; CMapOutdoor::FreeQuadTree

; 210  : 	ReleaseCharacterShadowTexture();

  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?ReleaseCharacterShadowTexture@CMapOutdoor@@QAEXXZ ; CMapOutdoor::ReleaseCharacterShadowTexture

; 211  : 
; 212  : 	CTerrain::DestroySystem();

  00051	e8 00 00 00 00	 call	 ?DestroySystem@CTerrain@@SAXXZ ; CTerrain::DestroySystem

; 213  : 	CArea::DestroySystem();

  00056	e8 00 00 00 00	 call	 ?DestroySystem@CArea@@SAXXZ ; CArea::DestroySystem

; 214  : 
; 215  : 	RemoveAllMonsterAreaInfo();

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?RemoveAllMonsterAreaInfo@CMapOutdoor@@QAEXXZ ; CMapOutdoor::RemoveAllMonsterAreaInfo

; 216  : 
; 217  : 	m_rkList_kGuildArea.clear();

  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
  0006c	e8 00 00 00 00	 call	 ?clear@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::clear

; 218  : 	m_kPool_kMonsterAreaInfo.Destroy();

  00071	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  0007a	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCMonsterAreaInfo@@@@QAEXXZ ; CDynamicPool<CMonsterAreaInfo>::Destroy

; 219  : 	m_AlphaFogImageInstance.Destroy();

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  00088	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 220  : 
; 221  : 	CSpeedTreeForestDirectX8::Instance().Clear();

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00093	e8 00 00 00 00	 call	 ?Clear@CSpeedTreeForest@@QAEXXZ ; CSpeedTreeForest::Clear

; 222  : 
; 223  : 	return true;

  00098	b0 01		 mov	 al, 1

; 224  : }

  0009a	c9		 leave
  0009b	c3		 ret	 0
?Destroy@CMapOutdoor@@MAE_NXZ ENDP			; CMapOutdoor::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?InitializeFog@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?InitializeFog@CMapOutdoor@@IAEXXZ PROC			; CMapOutdoor::InitializeFog, COMDAT
; _this$ = ecx

; 1055 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1056 : 	memset(&m_matAlphaFogTexture, 0, sizeof(D3DXMATRIX));

  00007	6a 40		 push	 64			; 00000040H
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	05 94 01 00 00	 add	 eax, 404		; 00000194H
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _memset
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1057 : 	m_matAlphaFogTexture._31 = -0.001f;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@ba83126f
  00027	f3 0f 11 80 b4
	01 00 00	 movss	 DWORD PTR [eax+436], xmm0

; 1058 : 	m_matAlphaFogTexture._41 = -7.0f;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0e00000
  0003a	f3 0f 11 80 c4
	01 00 00	 movss	 DWORD PTR [eax+452], xmm0

; 1059 : 	m_matAlphaFogTexture._42 = 0.5f;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0004d	f3 0f 11 80 c8
	01 00 00	 movss	 DWORD PTR [eax+456], xmm0

; 1060 : }

  00055	c9		 leave
  00056	c3		 ret	 0
?InitializeFog@CMapOutdoor@@IAEXXZ ENDP			; CMapOutdoor::InitializeFog
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?Initialize@CMapOutdoor@@MAE_NXZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_pOut$ = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -1						; size = 1
?Initialize@CMapOutdoor@@MAE_NXZ PROC			; CMapOutdoor::Initialize, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 	BYTE i;
; 96   : 	for (i = 0; i < AROUND_AREA_NUM; ++i)

  00009	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  0000d	eb 08		 jmp	 SHORT $LN4@Initialize
$LN2@Initialize:
  0000f	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  00012	04 01		 add	 al, 1
  00014	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN4@Initialize:
  00017	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  0001b	83 f8 09	 cmp	 eax, 9
  0001e	7d 1d		 jge	 SHORT $LN3@Initialize

; 97   : 	{
; 98   :  		m_pArea[i] = NULL;

  00020	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 a4 81 e0 00
	00 00 00	 and	 DWORD PTR [ecx+eax*4+224], 0

; 99   : 		m_pTerrain[i] = NULL;

  0002f	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	83 64 81 40 00	 and	 DWORD PTR [ecx+eax*4+64], 0

; 100  : 	}

  0003b	eb d2		 jmp	 SHORT $LN2@Initialize
$LN3@Initialize:

; 101  : 
; 102  : 	m_pTerrainPatchProxyList = NULL;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 60 64 00	 and	 DWORD PTR [eax+100], 0

; 103  : 
; 104  : 	m_lViewRadius	= 0L;

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 60 68 00	 and	 DWORD PTR [eax+104], 0

; 105  : 	m_fHeightScale	= 0.0f;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	0f 57 c0	 xorps	 xmm0, xmm0
  00051	f3 0f 11 40 6c	 movss	 DWORD PTR [eax+108], xmm0

; 106  : 		
; 107  : 	m_sTerrainCountX = m_sTerrainCountY = 0;

  00056	33 c0		 xor	 eax, eax
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	66 89 41 72	 mov	 WORD PTR [ecx+114], ax
  0005f	33 c0		 xor	 eax, eax
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	66 89 41 70	 mov	 WORD PTR [ecx+112], ax

; 108  : 
; 109  : 	m_CurCoordinate.m_sTerrainCoordX = -1;

  00068	83 c8 ff	 or	 eax, -1
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	66 89 41 74	 mov	 WORD PTR [ecx+116], ax

; 110  : 	m_CurCoordinate.m_sTerrainCoordY = -1;

  00072	83 c8 ff	 or	 eax, -1
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	66 89 41 76	 mov	 WORD PTR [ecx+118], ax

; 111  : 	m_PrevCoordinate.m_sTerrainCoordX = -1;

  0007c	83 c8 ff	 or	 eax, -1
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	66 89 81 80 00
	00 00		 mov	 WORD PTR [ecx+128], ax

; 112  : 	m_PrevCoordinate.m_sTerrainCoordY = -1;

  00089	83 c8 ff	 or	 eax, -1
  0008c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	66 89 81 82 00
	00 00		 mov	 WORD PTR [ecx+130], ax

; 113  : 
; 114  : 	m_EntryPointMap.clear();

  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0009f	e8 00 00 00 00	 call	 ?clear@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::clear

; 115  : 
; 116  : 	m_lCenterX = m_lCenterY = 0;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	83 a0 08 01 00
	00 00		 and	 DWORD PTR [eax+264], 0
  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	83 a0 04 01 00
	00 00		 and	 DWORD PTR [eax+260], 0

; 117  : 	m_lOldReadX = m_lOldReadY = -1;

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	83 88 10 01 00
	00 ff		 or	 DWORD PTR [eax+272], -1
  000c2	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	83 88 0c 01 00
	00 ff		 or	 DWORD PTR [eax+268], -1

; 118  : 
; 119  : #ifdef WORLD_EDITOR
; 120  : 	m_pwIndices = NULL;
; 121  : #else
; 122  : 	memset(m_pwaIndices, 0, sizeof(m_pwaIndices));

  000cc	6a 0c		 push	 12			; 0000000cH
  000ce	6a 00		 push	 0
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	05 90 00 00 00	 add	 eax, 144		; 00000090H
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 _memset
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : 	for (i = 0; i < TERRAINPATCH_LODMAX; ++i)

  000e1	c6 45 ff 00	 mov	 BYTE PTR _i$[ebp], 0
  000e5	eb 08		 jmp	 SHORT $LN7@Initialize
$LN5@Initialize:
  000e7	8a 45 ff	 mov	 al, BYTE PTR _i$[ebp]
  000ea	04 01		 add	 al, 1
  000ec	88 45 ff	 mov	 BYTE PTR _i$[ebp], al
$LN7@Initialize:
  000ef	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000f3	83 f8 03	 cmp	 eax, 3
  000f6	7d 18		 jge	 SHORT $LN6@Initialize

; 124  : 		m_IndexBuffer[i].Destroy();

  000f8	0f b6 45 ff	 movzx	 eax, BYTE PTR _i$[ebp]
  000fc	6b c0 14	 imul	 eax, eax, 20
  000ff	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	8d 8c 01 9c 00
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+156]
  00109	e8 00 00 00 00	 call	 ?Destroy@CGraphicIndexBuffer@@QAEXXZ ; CGraphicIndexBuffer::Destroy
  0010e	eb d7		 jmp	 SHORT $LN5@Initialize
$LN6@Initialize:

; 125  : #endif
; 126  : 
; 127  : 	m_bSettingTerrainVisible = false;

  00110	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00113	c6 80 ac 13 00
	00 00		 mov	 BYTE PTR [eax+5036], 0

; 128  : 	m_bDrawWireFrame	= false;

  0011a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	c6 80 30 01 00
	00 00		 mov	 BYTE PTR [eax+304], 0

; 129  : 	m_bDrawShadow		= false;

  00124	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00127	c6 80 31 01 00
	00 00		 mov	 BYTE PTR [eax+305], 0

; 130  : 	m_bDrawChrShadow	= false;

  0012e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00131	c6 80 32 01 00
	00 00		 mov	 BYTE PTR [eax+306], 0

; 131  : 
; 132  : 	m_iSplatLimit = 50000;

  00138	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	c7 80 9c 09 00
	00 50 c3 00 00	 mov	 DWORD PTR [eax+2460], 50000 ; 0000c350H

; 133  : 
; 134  : 	m_wPatchCount = 0;

  00145	33 c0		 xor	 eax, eax
  00147	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	66 89 81 8c 00
	00 00		 mov	 WORD PTR [ecx+140], ax

; 135  : 
; 136  : 	m_pRootNode = NULL;

  00151	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00154	83 a0 14 01 00
	00 00		 and	 DWORD PTR [eax+276], 0

; 137  : 	
; 138  : 	//////////////////////////////////////////////////////////////////////////
; 139  : 	// Character Shadow
; 140  : 	m_lpCharacterShadowMapTexture = NULL;

  0015b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0015e	83 a0 d4 01 00
	00 00		 and	 DWORD PTR [eax+468], 0

; 141  : 	m_lpCharacterShadowMapRenderTargetSurface = NULL;

  00165	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00168	83 a0 d8 01 00
	00 00		 and	 DWORD PTR [eax+472], 0

; 142  : 	m_lpCharacterShadowMapDepthSurface = NULL;

  0016f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00172	83 a0 dc 01 00
	00 00		 and	 DWORD PTR [eax+476], 0

; 143  : 
; 144  : 	m_lpBackupRenderTargetSurface = NULL;

  00179	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	83 a0 fc 01 00
	00 00		 and	 DWORD PTR [eax+508], 0

; 145  : 	m_lpBackupDepthSurface = NULL;

  00183	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00186	83 a0 00 02 00
	00 00		 and	 DWORD PTR [eax+512], 0

; 146  : 	// Character Shadow
; 147  : 	//////////////////////////////////////////////////////////////////////////
; 148  : 
; 149  : 	m_iRenderedPatchNum = 0;

  0018d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00190	83 a0 8c 09 00
	00 00		 and	 DWORD PTR [eax+2444], 0

; 150  : 	m_iRenderedSplatNum = 0;

  00197	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	83 a0 88 09 00
	00 00		 and	 DWORD PTR [eax+2440], 0

; 151  : 
; 152  : 	//////////////////////////////////////////////////////////////////////////
; 153  : 	m_fOpaqueWaterDepth = 400.0f;

  001a1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43c80000
  001ac	f3 0f 11 80 24
	0a 00 00	 movss	 DWORD PTR [eax+2596], xmm0

; 154  : 
; 155  : 	//////////////////////////////////////////////////////////////////////////
; 156  : 	m_TerrainVector.clear();

  001b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	81 c1 18 09 00
	00		 add	 ecx, 2328		; 00000918H
  001bd	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 157  : 	m_TerrainDeleteVector.clear();

  001c2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	81 c1 24 09 00
	00		 add	 ecx, 2340		; 00000924H
  001cb	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 158  : 	m_TerrainLoadRequestVector.clear();

  001d0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	81 c1 30 09 00
	00		 add	 ecx, 2352		; 00000930H
  001d9	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 159  : 	m_TerrainLoadWaitVector.clear();

  001de	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e1	81 c1 3c 09 00
	00		 add	 ecx, 2364		; 0000093cH
  001e7	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::clear

; 160  : 
; 161  : 	m_AreaVector.clear();

  001ec	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	81 c1 4c 09 00
	00		 add	 ecx, 2380		; 0000094cH
  001f5	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 162  : 	m_AreaDeleteVector.clear();

  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	81 c1 58 09 00
	00		 add	 ecx, 2392		; 00000958H
  00203	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 163  : 	m_AreaLoadRequestVector.clear();

  00208	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	81 c1 64 09 00
	00		 add	 ecx, 2404		; 00000964H
  00211	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 164  : 	m_AreaLoadWaitVector.clear();

  00216	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00219	81 c1 70 09 00
	00		 add	 ecx, 2416		; 00000970H
  0021f	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::clear

; 165  : 	//////////////////////////////////////////////////////////////////////////	
; 166  : 	
; 167  : 	m_PatchVector.clear();

  00224	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00227	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  0022d	e8 00 00 00 00	 call	 ?clear@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::clear

; 168  : 	
; 169  : 	// 2004.10.14.myevan.TEMP_CAreaLoaderThread
; 170  : 	//m_bBGLoadingEnable = false;
; 171  : 	m_eTerrainRenderSort = DISTANCE_SORT;

  00232	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00235	83 a0 e8 0d 00
	00 00		 and	 DWORD PTR [eax+3560], 0

; 172  : 
; 173  : 	D3DXMatrixIdentity(&m_matWorldForCommonUse);

  0023c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0023f	05 48 07 00 00	 add	 eax, 1864		; 00000748H
  00244	89 45 f4	 mov	 DWORD PTR _pOut$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00247	6a 10		 push	 16			; 00000010H
  00249	58		 pop	 eax
  0024a	6b c0 03	 imul	 eax, eax, 3
  0024d	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00250	6a 04		 push	 4
  00252	59		 pop	 ecx
  00253	d1 e1		 shl	 ecx, 1
  00255	0f 57 c0	 xorps	 xmm0, xmm0
  00258	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0025d	6a 10		 push	 16			; 00000010H
  0025f	58		 pop	 eax
  00260	6b c0 03	 imul	 eax, eax, 3
  00263	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00266	6a 04		 push	 4
  00268	59		 pop	 ecx
  00269	c1 e1 00	 shl	 ecx, 0
  0026c	0f 57 c0	 xorps	 xmm0, xmm0
  0026f	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00274	6a 10		 push	 16			; 00000010H
  00276	58		 pop	 eax
  00277	6b c0 03	 imul	 eax, eax, 3
  0027a	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0027d	6a 04		 push	 4
  0027f	59		 pop	 ecx
  00280	6b c9 00	 imul	 ecx, ecx, 0
  00283	0f 57 c0	 xorps	 xmm0, xmm0
  00286	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0028b	6a 10		 push	 16			; 00000010H
  0028d	58		 pop	 eax
  0028e	d1 e0		 shl	 eax, 1
  00290	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00293	6a 04		 push	 4
  00295	59		 pop	 ecx
  00296	6b c9 03	 imul	 ecx, ecx, 3
  00299	0f 57 c0	 xorps	 xmm0, xmm0
  0029c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002a1	6a 10		 push	 16			; 00000010H
  002a3	58		 pop	 eax
  002a4	d1 e0		 shl	 eax, 1
  002a6	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002a9	6a 04		 push	 4
  002ab	59		 pop	 ecx
  002ac	c1 e1 00	 shl	 ecx, 0
  002af	0f 57 c0	 xorps	 xmm0, xmm0
  002b2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002b7	6a 10		 push	 16			; 00000010H
  002b9	58		 pop	 eax
  002ba	d1 e0		 shl	 eax, 1
  002bc	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002bf	6a 04		 push	 4
  002c1	59		 pop	 ecx
  002c2	6b c9 00	 imul	 ecx, ecx, 0
  002c5	0f 57 c0	 xorps	 xmm0, xmm0
  002c8	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002cd	6a 10		 push	 16			; 00000010H
  002cf	58		 pop	 eax
  002d0	c1 e0 00	 shl	 eax, 0
  002d3	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002d6	6a 04		 push	 4
  002d8	59		 pop	 ecx
  002d9	6b c9 03	 imul	 ecx, ecx, 3
  002dc	0f 57 c0	 xorps	 xmm0, xmm0
  002df	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002e4	6a 10		 push	 16			; 00000010H
  002e6	58		 pop	 eax
  002e7	c1 e0 00	 shl	 eax, 0
  002ea	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  002ed	6a 04		 push	 4
  002ef	59		 pop	 ecx
  002f0	d1 e1		 shl	 ecx, 1
  002f2	0f 57 c0	 xorps	 xmm0, xmm0
  002f5	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  002fa	6a 10		 push	 16			; 00000010H
  002fc	58		 pop	 eax
  002fd	c1 e0 00	 shl	 eax, 0
  00300	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00303	6a 04		 push	 4
  00305	59		 pop	 ecx
  00306	6b c9 00	 imul	 ecx, ecx, 0
  00309	0f 57 c0	 xorps	 xmm0, xmm0
  0030c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00311	6a 10		 push	 16			; 00000010H
  00313	58		 pop	 eax
  00314	6b c0 00	 imul	 eax, eax, 0
  00317	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0031a	6a 04		 push	 4
  0031c	59		 pop	 ecx
  0031d	6b c9 03	 imul	 ecx, ecx, 3
  00320	0f 57 c0	 xorps	 xmm0, xmm0
  00323	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00328	6a 10		 push	 16			; 00000010H
  0032a	58		 pop	 eax
  0032b	6b c0 00	 imul	 eax, eax, 0
  0032e	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00331	6a 04		 push	 4
  00333	59		 pop	 ecx
  00334	d1 e1		 shl	 ecx, 1
  00336	0f 57 c0	 xorps	 xmm0, xmm0
  00339	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0033e	6a 10		 push	 16			; 00000010H
  00340	58		 pop	 eax
  00341	6b c0 00	 imul	 eax, eax, 0
  00344	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00347	6a 04		 push	 4
  00349	59		 pop	 ecx
  0034a	c1 e1 00	 shl	 ecx, 0
  0034d	0f 57 c0	 xorps	 xmm0, xmm0
  00350	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  00355	6a 10		 push	 16			; 00000010H
  00357	58		 pop	 eax
  00358	6b c0 03	 imul	 eax, eax, 3
  0035b	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  0035e	6a 04		 push	 4
  00360	59		 pop	 ecx
  00361	6b c9 03	 imul	 ecx, ecx, 3
  00364	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0036c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00371	6a 10		 push	 16			; 00000010H
  00373	58		 pop	 eax
  00374	d1 e0		 shl	 eax, 1
  00376	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00379	6a 04		 push	 4
  0037b	59		 pop	 ecx
  0037c	d1 e1		 shl	 ecx, 1
  0037e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00386	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0038b	6a 10		 push	 16			; 00000010H
  0038d	58		 pop	 eax
  0038e	c1 e0 00	 shl	 eax, 0
  00391	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  00394	6a 04		 push	 4
  00396	59		 pop	 ecx
  00397	c1 e1 00	 shl	 ecx, 0
  0039a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003a2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  003a7	6a 10		 push	 16			; 00000010H
  003a9	58		 pop	 eax
  003aa	6b c0 00	 imul	 eax, eax, 0
  003ad	03 45 f4	 add	 eax, DWORD PTR _pOut$[ebp]
  003b0	6a 04		 push	 4
  003b2	59		 pop	 ecx
  003b3	6b c9 00	 imul	 ecx, ecx, 0
  003b6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  003be	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 175  : 	InitializeFog();

  003c3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003c6	e8 00 00 00 00	 call	 ?InitializeFog@CMapOutdoor@@IAEXXZ ; CMapOutdoor::InitializeFog

; 176  : 	InitializeVisibleParts();

  003cb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ce	e8 00 00 00 00	 call	 ?InitializeVisibleParts@CMapOutdoor@@IAEXXZ ; CMapOutdoor::InitializeVisibleParts

; 177  : 
; 178  : 	m_dwBaseX = 0;

  003d3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003d6	83 a0 a0 0e 00
	00 00		 and	 DWORD PTR [eax+3744], 0

; 179  : 	m_dwBaseY = 0;

  003dd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  003e0	83 a0 a4 0e 00
	00 00		 and	 DWORD PTR [eax+3748], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  003e7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  003ec	e8 00 00 00 00	 call	 _strlen
  003f1	59		 pop	 ecx
  003f2	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  003f5	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  003f8	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  003fb	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  003fe	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 181  : 	m_settings_envDataName = "";

  00403	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00406	81 c1 7c 13 00
	00		 add	 ecx, 4988		; 0000137cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0040c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 182  : 	m_bShowEntirePatchTextureCount = false;

  00411	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00414	c6 80 b4 0e 00
	00 00		 mov	 BYTE PTR [eax+3764], 0

; 183  : 	m_bTransparentTree = true;

  0041b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0041e	c6 80 b5 0e 00
	00 01		 mov	 BYTE PTR [eax+3765], 1

; 184  : 	
; 185  : 	CMapBase::Clear();

  00425	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00428	e8 00 00 00 00	 call	 ?Clear@CMapBase@@UAEXXZ	; CMapBase::Clear

; 186  : 
; 187  : 	__XMasTree_Initialize();

  0042d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00430	e8 00 00 00 00	 call	 ?__XMasTree_Initialize@CMapOutdoor@@AAEXXZ ; CMapOutdoor::__XMasTree_Initialize

; 188  : 	SpecialEffect_Destroy();

  00435	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00438	e8 00 00 00 00	 call	 ?SpecialEffect_Destroy@CMapOutdoor@@QAEXXZ ; CMapOutdoor::SpecialEffect_Destroy

; 189  : 
; 190  : 	m_bEnableTerrainOnlyForHeight = FALSE;

  0043d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00440	c6 80 b6 0e 00
	00 00		 mov	 BYTE PTR [eax+3766], 0

; 191  : 	m_bEnablePortal = FALSE;

  00447	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0044a	c6 80 b7 0e 00
	00 00		 mov	 BYTE PTR [eax+3767], 0

; 192  : 
; 193  : 	m_wShadowMapSize = 512;

  00451	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00456	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00459	66 89 81 f8 01
	00 00		 mov	 WORD PTR [ecx+504], ax

; 194  : 	return true;

  00460	b0 01		 mov	 al, 1

; 195  : }

  00462	c9		 leave
  00463	c3		 ret	 0
?Initialize@CMapOutdoor@@MAE_NXZ ENDP			; CMapOutdoor::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?OnBeginEnvironment@CMapOutdoor@@UAEXXZ
_TEXT	SEGMENT
_rkForest$ = -12					; size = 4
_c_rkLight$ = -8					; size = 4
_this$ = -4						; size = 4
?OnBeginEnvironment@CMapOutdoor@@UAEXXZ PROC		; CMapOutdoor::OnBeginEnvironment, COMDAT
; _this$ = ecx

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 248  : 	if (!mc_pEnvironmentData)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00010	75 02		 jne	 SHORT $LN2@OnBeginEnv

; 249  : 		return;

  00012	eb 7a		 jmp	 SHORT $LN1@OnBeginEnv
$LN2@OnBeginEnv:

; 250  : 
; 251  : 	CSpeedTreeForestDirectX8& rkForest=CSpeedTreeForestDirectX8::Instance();

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCSpeedTreeForestDirectX8@@@@0PAVCSpeedTreeForestDirectX8@@A ; CSingleton<CSpeedTreeForestDirectX8>::ms_singleton
  00019	89 45 f4	 mov	 DWORD PTR _rkForest$[ebp], eax

; 252  : 	rkForest.SetFog(

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00022	e8 00 00 00 00	 call	 ?GetFogFarDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogFarDistance
  00027	51		 push	 ecx
  00028	d9 1c 24	 fstp	 DWORD PTR [esp]
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00031	e8 00 00 00 00	 call	 ?GetFogNearDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogNearDistance
  00036	51		 push	 ecx
  00037	d9 1c 24	 fstp	 DWORD PTR [esp]
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _rkForest$[ebp]
  0003d	e8 00 00 00 00	 call	 ?SetFog@CSpeedTreeForest@@QAEXMM@Z ; CSpeedTreeForest::SetFog

; 253  : 		mc_pEnvironmentData->GetFogNearDistance(), 
; 254  : 		mc_pEnvironmentData->GetFogFarDistance()
; 255  : 	);
; 256  : 
; 257  : 	const D3DLIGHT8& c_rkLight = mc_pEnvironmentData->DirLights[ENV_DIRLIGHT_CHARACTER];

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00048	6a 68		 push	 104			; 00000068H
  0004a	59		 pop	 ecx
  0004b	c1 e1 00	 shl	 ecx, 0
  0004e	8d 44 08 08	 lea	 eax, DWORD PTR [eax+ecx+8]
  00052	89 45 f8	 mov	 DWORD PTR _c_rkLight$[ebp], eax

; 258  : 	rkForest.SetLight(

  00055	8b 45 f8	 mov	 eax, DWORD PTR _c_rkLight$[ebp]
  00058	83 c0 04	 add	 eax, 4
  0005b	50		 push	 eax
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _c_rkLight$[ebp]
  0005f	83 c0 24	 add	 eax, 36			; 00000024H
  00062	50		 push	 eax
  00063	8b 45 f8	 mov	 eax, DWORD PTR _c_rkLight$[ebp]
  00066	83 c0 40	 add	 eax, 64			; 00000040H
  00069	50		 push	 eax
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR _rkForest$[ebp]
  0006d	e8 00 00 00 00	 call	 ?SetLight@CSpeedTreeForest@@QAEXPBM00@Z ; CSpeedTreeForest::SetLight

; 259  : 		(const float *)&c_rkLight.Direction,
; 260  : 		(const float *)&c_rkLight.Ambient, 
; 261  : 		(const float *)&c_rkLight.Diffuse);
; 262  : 	
; 263  : 	rkForest.SetWindStrength(mc_pEnvironmentData->fWindStrength);

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  00078	51		 push	 ecx
  00079	f3 0f 10 80 54
	01 00 00	 movss	 xmm0, DWORD PTR [eax+340]
  00081	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00086	8b 4d f4	 mov	 ecx, DWORD PTR _rkForest$[ebp]
  00089	e8 00 00 00 00	 call	 ?SetWindStrength@CSpeedTreeForest@@QAEXM@Z ; CSpeedTreeForest::SetWindStrength
$LN1@OnBeginEnv:

; 264  : }

  0008e	c9		 leave
  0008f	c3		 ret	 0
?OnBeginEnvironment@CMapOutdoor@@UAEXXZ ENDP		; CMapOutdoor::OnBeginEnvironment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ??1CMapOutdoor@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CMapOutdoor@@UAE@XZ PROC				; CMapOutdoor::~CMapOutdoor, COMDAT
; _this$ = ecx

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CMapOutdoor@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMapOutdoor@@6B@

; 86   : 	__SoftwareTransformPatch_Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_Destroy@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Destroy

; 87   : 
; 88   : 	// 2004.10.14.myevan.TEMP_CAreaLoaderThread
; 89   : 	//ms_AreaLoaderThread.Shutdown();
; 90   : 	Destroy();

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?Destroy@CMapOutdoor@@MAE_NXZ ; CMapOutdoor::Destroy

; 91   : }

  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	81 c1 94 13 00
	00		 add	 ecx, 5012		; 00001394H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00048	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 7c 13 00
	00		 add	 ecx, 4988		; 0000137cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00056	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0005b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005f	68 00 00 00 00	 push	 OFFSET ??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  00064	6a 64		 push	 100			; 00000064H
  00066	6a 0c		 push	 12			; 0000000cH
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	05 c8 0e 00 00	 add	 eax, 3784		; 00000ec8H
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00076	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
  00083	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
  00088	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00091	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  0009f	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ ; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	81 c1 0c 0e 00
	00		 add	 ecx, 3596		; 00000e0cH
  000ad	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	81 c1 ec 0d 00
	00		 add	 ecx, 3564		; 00000decH
  000bb	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  000c0	68 00 00 00 00	 push	 OFFSET ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  000c5	6a 1e		 push	 30			; 0000001eH
  000c7	6a 20		 push	 32			; 00000020H
  000c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	05 28 0a 00 00	 add	 eax, 2600		; 00000a28H
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000d7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	81 c1 18 0a 00
	00		 add	 ecx, 2584		; 00000a18H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000e0	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  000e5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	81 c1 0c 0a 00
	00		 add	 ecx, 2572		; 00000a0cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  000ee	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  000f3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  000fc	e8 00 00 00 00	 call	 ?_Tidy@?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@AAEXXZ ; std::list<tagRECT,std::allocator<tagRECT> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00101	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0010a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	81 c1 70 09 00
	00		 add	 ecx, 2416		; 00000970H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00118	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0011d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	81 c1 64 09 00
	00		 add	 ecx, 2404		; 00000964H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00126	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0012b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	81 c1 58 09 00
	00		 add	 ecx, 2392		; 00000958H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00134	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00139	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0013c	81 c1 4c 09 00
	00		 add	 ecx, 2380		; 0000094cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00142	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@AAEXXZ ; std::vector<CArea *,std::allocator<CArea *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00147	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014a	81 c1 3c 09 00
	00		 add	 ecx, 2364		; 0000093cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00150	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00155	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	81 c1 30 09 00
	00		 add	 ecx, 2352		; 00000930H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0015e	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00163	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	81 c1 24 09 00
	00		 add	 ecx, 2340		; 00000924H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0016c	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  00171	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	81 c1 18 09 00
	00		 add	 ecx, 2328		; 00000918H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0017a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@AAEXXZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  0017f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  00188	e8 00 00 00 00	 call	 ??1CScreenFilter@@UAE@XZ ; CScreenFilter::~CScreenFilter
  0018d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00190	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  00196	e8 00 00 00 00	 call	 ??1CLensFlare@@UAE@XZ	; CLensFlare::~CLensFlare
  0019b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  001a4	e8 00 00 00 00	 call	 ??1CSkyBox@@UAE@XZ	; CSkyBox::~CSkyBox
  001a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ac	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  001b2	e8 00 00 00 00	 call	 ??1CTextureSet@@UAE@XZ	; CTextureSet::~CTextureSet
  001b7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  001c0	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  001c5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  001ce	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@AAEXXZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  001d3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  001dc	e8 00 00 00 00	 call	 ?_Tidy@?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@AAEXXZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 91   : }

  001e1	68 00 00 00 00	 push	 OFFSET ??1CGraphicIndexBuffer@@UAE@XZ ; CGraphicIndexBuffer::~CGraphicIndexBuffer
  001e6	6a 03		 push	 3
  001e8	6a 14		 push	 20			; 00000014H
  001ea	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001ed	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  001f2	50		 push	 eax
  001f3	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  001f8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001fb	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00201	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >
  00206	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	e8 00 00 00 00	 call	 ??1CMapBase@@UAE@XZ	; CMapBase::~CMapBase
  0020e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00211	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00218	59		 pop	 ecx
  00219	c9		 leave
  0021a	c3		 ret	 0
  0021b	cc		 int	 3
  0021c	cc		 int	 3
  0021d	cc		 int	 3
  0021e	cc		 int	 3
  0021f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CMapOutdoor@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CMapOutdoor@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CMapOutdoor@@UAE@XZ ENDP				; CMapOutdoor::~CMapOutdoor
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ??0CMapOutdoor@@QAE@XZ
_TEXT	SEGMENT
$T2 = -100						; size = 1
_pBuildTransparentImage$ = -96				; size = 4
_pAttrImage$ = -92					; size = 4
_pAlphaFogImage$ = -88					; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
_this$ = -72						; size = 4
_this$ = -68						; size = 4
_this$ = -64						; size = 4
_this$ = -60						; size = 4
_this$ = -56						; size = 4
_this$ = -52						; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 0						; size = 4
_this$ = 4						; size = 4
_this$ = 8						; size = 4
_this$ = 12						; size = 4
_this$ = 16						; size = 4
_this$ = 20						; size = 4
_this$ = 24						; size = 4
_this$ = 28						; size = 4
_this$ = 32						; size = 4
_this$ = 36						; size = 4
_this$ = 40						; size = 4
_this$ = 44						; size = 4
_this$ = 48						; size = 4
_this$ = 52						; size = 4
_this$ = 56						; size = 4
_this$ = 60						; size = 4
tv436 = 64						; size = 4
_this$ = 68						; size = 4
_this$ = 72						; size = 4
_this$ = 76						; size = 4
_this$ = 80						; size = 4
_this$ = 84						; size = 4
_this$ = 88						; size = 4
___t$ = 92						; size = 4
_this$ = 96						; size = 4
_this$6 = 100						; size = 4
_this$7 = 104						; size = 4
___n$ = 108						; size = 4
$T8 = 113						; size = 1
$T9 = 114						; size = 1
$T10 = 115						; size = 1
_this$ = 116						; size = 4
??0CMapOutdoor@@QAE@XZ PROC				; CMapOutdoor::CMapOutdoor, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??0CMapOutdoor@@QAE@XZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 58	 sub	 esp, 88			; 00000058H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??0CMapBase@@QAE@XZ	; CMapBase::CMapBase
  00035	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CMapOutdoor@@6B@
  00042	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00045	05 84 00 00 00	 add	 eax, 132		; 00000084H
  0004a	89 45 60	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  0004d	8d 45 73	 lea	 eax, DWORD PTR $T10[ebp]
  00050	50		 push	 eax
  00051	8d 45 72	 lea	 eax, DWORD PTR $T9[ebp]
  00054	50		 push	 eax
  00055	ff 75 9c	 push	 DWORD PTR $T2[ebp]
  00058	8b 4d 60	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ??$?0ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@PAX@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::_Compressed_pair<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate>,void *> >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const > const &,std::_Zero_then_variadic_args_t>

; 886  :         _Alloc_sentinel_and_proxy();

  00060	8b 4d 60	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,SOutdoorMapCoordinate> >,0> >::_Alloc_sentinel_and_proxy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006c	68 00 00 00 00	 push	 OFFSET ??1CGraphicIndexBuffer@@UAE@XZ ; CGraphicIndexBuffer::~CGraphicIndexBuffer
  00071	68 00 00 00 00	 push	 OFFSET ??0CGraphicIndexBuffer@@QAE@XZ ; CGraphicIndexBuffer::CGraphicIndexBuffer
  00076	6a 03		 push	 3
  00078	6a 14		 push	 20			; 00000014H
  0007a	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00088	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0008c	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	05 18 01 00 00	 add	 eax, 280		; 00000118H
  00094	89 45 50	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00097	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	89 45 4c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0009d	8b 4d 4c	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::pair<float,long> > >::_Vector_val<std::_Simple_types<std::pair<float,long> > >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  000a5	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000a9	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	05 24 01 00 00	 add	 eax, 292		; 00000124H
  000b1	89 45 48	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000b4	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	89 45 44	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000ba	8b 4d 44	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >::_Vector_val<std::_Simple_types<CMapOutdoor::TPatchDrawStruct> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  000c2	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000c6	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  000cf	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  000d4	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000d8	c7 45 6c 06 00
	00 00		 mov	 DWORD PTR ___n$[ebp], 6
  000df	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	05 1c 02 00 00	 add	 eax, 540		; 0000021cH
  000e7	89 45 5c	 mov	 DWORD PTR ___t$[ebp], eax
$LN68@CMapOutdoo:
  000ea	8b 45 6c	 mov	 eax, DWORD PTR ___n$[ebp]
  000ed	89 45 40	 mov	 DWORD PTR tv436[ebp], eax
  000f0	8b 45 6c	 mov	 eax, DWORD PTR ___n$[ebp]
  000f3	48		 dec	 eax
  000f4	89 45 6c	 mov	 DWORD PTR ___n$[ebp], eax
  000f7	83 7d 40 00	 cmp	 DWORD PTR tv436[ebp], 0
  000fb	76 0b		 jbe	 SHORT $LN67@CMapOutdoo
  000fd	8b 45 5c	 mov	 eax, DWORD PTR ___t$[ebp]
  00100	83 c0 10	 add	 eax, 16			; 00000010H
  00103	89 45 5c	 mov	 DWORD PTR ___t$[ebp], eax
  00106	eb e2		 jmp	 SHORT $LN68@CMapOutdoo
$LN67@CMapOutdoo:
  00108	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  00111	e8 00 00 00 00	 call	 ??0CTextureSet@@QAE@XZ	; CTextureSet::CTextureSet
  00116	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0011a	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  00123	e8 00 00 00 00	 call	 ??0CSkyBox@@QAE@XZ	; CSkyBox::CSkyBox
  00128	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  0012c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  00135	e8 00 00 00 00	 call	 ??0CLensFlare@@QAE@XZ	; CLensFlare::CLensFlare
  0013a	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0013e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  00147	e8 00 00 00 00	 call	 ??0CScreenFilter@@QAE@XZ ; CScreenFilter::CScreenFilter
  0014c	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00150	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00153	05 18 09 00 00	 add	 eax, 2328		; 00000918H
  00158	89 45 3c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0015b	8b 45 3c	 mov	 eax, DWORD PTR _this$[ebp]
  0015e	89 45 38	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00161	8b 4d 38	 mov	 ecx, DWORD PTR _this$[ebp]
  00164	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00169	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  0016d	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00170	05 24 09 00 00	 add	 eax, 2340		; 00000924H
  00175	89 45 34	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00178	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	89 45 30	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0017e	8b 4d 30	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00186	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  0018a	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	05 30 09 00 00	 add	 eax, 2352		; 00000930H
  00192	89 45 2c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00195	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  00198	89 45 28	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0019b	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0019e	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  001a3	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  001a7	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001aa	05 3c 09 00 00	 add	 eax, 2364		; 0000093cH
  001af	89 45 24	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  001b2	8b 45 24	 mov	 eax, DWORD PTR _this$[ebp]
  001b5	89 45 20	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  001b8	8b 4d 20	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CTerrain *> >::_Vector_val<std::_Simple_types<CTerrain *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  001c0	c6 45 fc 0d	 mov	 BYTE PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  001c4	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	05 48 09 00 00	 add	 eax, 2376		; 00000948H
  001cc	89 45 1c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  001cf	8b 45 1c	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  001d5	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001d8	05 4c 09 00 00	 add	 eax, 2380		; 0000094cH
  001dd	89 45 18	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  001e0	8b 45 18	 mov	 eax, DWORD PTR _this$[ebp]
  001e3	89 45 14	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  001e6	8b 4d 14	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  001ee	c6 45 fc 0e	 mov	 BYTE PTR __$EHRec$[ebp+8], 14 ; 0000000eH
  001f2	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001f5	05 58 09 00 00	 add	 eax, 2392		; 00000958H
  001fa	89 45 10	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  001fd	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00200	89 45 0c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00203	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00206	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  0020b	c6 45 fc 0f	 mov	 BYTE PTR __$EHRec$[ebp+8], 15 ; 0000000fH
  0020f	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00212	05 64 09 00 00	 add	 eax, 2404		; 00000964H
  00217	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0021a	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0021d	89 45 04	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00220	8b 4d 04	 mov	 ecx, DWORD PTR _this$[ebp]
  00223	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00228	c6 45 fc 10	 mov	 BYTE PTR __$EHRec$[ebp+8], 16 ; 00000010H
  0022c	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0022f	05 70 09 00 00	 add	 eax, 2416		; 00000970H
  00234	89 45 00	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00237	8b 45 00	 mov	 eax, DWORD PTR _this$[ebp]
  0023a	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0023d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCArea@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CArea *> >::_Vector_val<std::_Simple_types<CArea *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00245	c6 45 fc 11	 mov	 BYTE PTR __$EHRec$[ebp+8], 17 ; 00000011H
  00249	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0024c	05 7c 09 00 00	 add	 eax, 2428		; 0000097cH
  00251	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00254	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00257	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  0025a	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0025d	05 90 09 00 00	 add	 eax, 2448		; 00000990H
  00262	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00265	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00268	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0026b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0026e	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00273	c6 45 fc 12	 mov	 BYTE PTR __$EHRec$[ebp+8], 18 ; 00000012H
  00277	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
  00280	e8 00 00 00 00	 call	 ??0?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::list<tagRECT,std::allocator<tagRECT> >
  00285	c6 45 fc 13	 mov	 BYTE PTR __$EHRec$[ebp+8], 19 ; 00000013H
  00289	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0028c	05 0c 0a 00 00	 add	 eax, 2572		; 00000a0cH
  00291	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00294	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00297	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0029a	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0029d	89 45 68	 mov	 DWORD PTR _this$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  002a0	8b 45 68	 mov	 eax, DWORD PTR _this$7[ebp]
  002a3	83 20 00	 and	 DWORD PTR [eax], 0
  002a6	8b 45 68	 mov	 eax, DWORD PTR _this$7[ebp]
  002a9	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  002ad	8b 45 68	 mov	 eax, DWORD PTR _this$7[ebp]
  002b0	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  002b4	c6 45 fc 14	 mov	 BYTE PTR __$EHRec$[ebp+8], 20 ; 00000014H
  002b8	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  002bb	05 18 0a 00 00	 add	 eax, 2584		; 00000a18H
  002c0	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  002c3	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  002c6	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  002c9	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  002cc	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  002d1	c6 45 fc 15	 mov	 BYTE PTR __$EHRec$[ebp+8], 21 ; 00000015H
  002d5	68 00 00 00 00	 push	 OFFSET ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  002da	68 00 00 00 00	 push	 OFFSET ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  002df	6a 1e		 push	 30			; 0000001eH
  002e1	6a 20		 push	 32			; 00000020H
  002e3	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  002e6	05 28 0a 00 00	 add	 eax, 2600		; 00000a28H
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  002f1	c6 45 fc 16	 mov	 BYTE PTR __$EHRec$[ebp+8], 22 ; 00000016H
  002f5	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  002f8	81 c1 ec 0d 00
	00		 add	 ecx, 3564		; 00000decH
  002fe	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00303	c6 45 fc 17	 mov	 BYTE PTR __$EHRec$[ebp+8], 23 ; 00000017H
  00307	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0030a	81 c1 0c 0e 00
	00		 add	 ecx, 3596		; 00000e0cH
  00310	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  00315	c6 45 fc 18	 mov	 BYTE PTR __$EHRec$[ebp+8], 24 ; 00000018H
  00319	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0031c	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  00322	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCMonsterAreaInfo@@@@QAE@XZ ; CDynamicPool<CMonsterAreaInfo>::CDynamicPool<CMonsterAreaInfo>
  00327	c6 45 fc 19	 mov	 BYTE PTR __$EHRec$[ebp+8], 25 ; 00000019H
  0032b	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0032e	05 90 0e 00 00	 add	 eax, 3728		; 00000e90H
  00333	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00336	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00339	89 45 cc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0033c	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  0033f	89 45 64	 mov	 DWORD PTR _this$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00342	8b 45 64	 mov	 eax, DWORD PTR _this$6[ebp]
  00345	83 20 00	 and	 DWORD PTR [eax], 0
  00348	8b 45 64	 mov	 eax, DWORD PTR _this$6[ebp]
  0034b	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0034f	8b 45 64	 mov	 eax, DWORD PTR _this$6[ebp]
  00352	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00356	c6 45 fc 1a	 mov	 BYTE PTR __$EHRec$[ebp+8], 26 ; 0000001aH
  0035a	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0035d	05 9c 0e 00 00	 add	 eax, 3740		; 00000e9cH
  00362	89 45 c8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 40   :     _Vector_const_iterator() noexcept : _Ptr() {}

  00365	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00368	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  0036b	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0036e	05 c0 0e 00 00	 add	 eax, 3776		; 00000ec0H
  00373	89 45 c4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00376	8d 45 71	 lea	 eax, DWORD PTR $T8[ebp]
  00379	50		 push	 eax
  0037a	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0037d	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >::_Tree<std::_Tmap_traits<unsigned long,int,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,int> >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  00382	c6 45 fc 1b	 mov	 BYTE PTR __$EHRec$[ebp+8], 27 ; 0000001bH
  00386	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00389	05 c8 0e 00 00	 add	 eax, 3784		; 00000ec8H
  0038e	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
  00391	c6 45 fc 1c	 mov	 BYTE PTR __$EHRec$[ebp+8], 28 ; 0000001cH
  00395	68 00 00 00 00	 push	 OFFSET ??1?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::~vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  0039a	68 00 00 00 00	 push	 OFFSET ??0?$vector@USItem@SHeightCache@CMapOutdoor@@V?$allocator@USItem@SHeightCache@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >::vector<CMapOutdoor::SHeightCache::SItem,std::allocator<CMapOutdoor::SHeightCache::SItem> >
  0039f	6a 64		 push	 100			; 00000064H
  003a1	6a 0c		 push	 12			; 0000000cH
  003a3	ff 75 c0	 push	 DWORD PTR _this$[ebp]
  003a6	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  003ab	c6 45 fc 1d	 mov	 BYTE PTR __$EHRec$[ebp+8], 29 ; 0000001dH
  003af	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  003b2	05 7c 13 00 00	 add	 eax, 4988		; 0000137cH
  003b7	89 45 58	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  003ba	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  003bd	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  003c0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c3	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  003c8	8b 4d 58	 mov	 ecx, DWORD PTR _this$[ebp]
  003cb	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  003d0	c6 45 fc 1e	 mov	 BYTE PTR __$EHRec$[ebp+8], 30 ; 0000001eH
  003d4	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  003d7	05 94 13 00 00	 add	 eax, 5012		; 00001394H
  003dc	89 45 54	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  003df	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  003e2	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  003e5	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  003e8	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  003ed	8b 4d 54	 mov	 ecx, DWORD PTR _this$[ebp]
  003f0	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 70   : {

  003f5	c6 45 fc 1f	 mov	 BYTE PTR __$EHRec$[ebp+8], 31 ; 0000001fH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  003f9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  003fe	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 71   : 	CGraphicImage * pAlphaFogImage = (CGraphicImage *) CResourceManager::Instance().GetResourcePointer("D:/ymir work/special/fog.tga");

  00401	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@FIOHACND@D?3?1ymir?5work?1special?1fog?4tga@
  00406	8b 4d b4	 mov	 ecx, DWORD PTR $T5[ebp]
  00409	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0040e	89 45 a8	 mov	 DWORD PTR _pAlphaFogImage$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00411	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00416	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 72   : 	CGraphicImage * pAttrImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer("d:/ymir work/special/white.dds");

  00419	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JMMOMCFP@d?3?1ymir?5work?1special?1white?4dds@
  0041e	8b 4d b0	 mov	 ecx, DWORD PTR $T4[ebp]
  00421	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00426	89 45 a4	 mov	 DWORD PTR _pAttrImage$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00429	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  0042e	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp

; 73   : 	CGraphicImage * pBuildTransparentImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer("d:/ymir Work/special/PCBlockerAlpha.dds");

  00431	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OKIKMFPM@d?3?1ymir?5Work?1special?1PCBlockerA@
  00436	8b 4d ac	 mov	 ecx, DWORD PTR $T3[ebp]
  00439	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0043e	89 45 a0	 mov	 DWORD PTR _pBuildTransparentImage$[ebp], eax

; 74   : 	m_AlphaFogImageInstance.SetImagePointer(pAlphaFogImage);

  00441	ff 75 a8	 push	 DWORD PTR _pAlphaFogImage$[ebp]
  00444	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00447	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  0044d	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 75   : 	m_attrImageInstance.SetImagePointer(pAttrImage);

  00452	ff 75 a4	 push	 DWORD PTR _pAttrImage$[ebp]
  00455	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00458	81 c1 ec 0d 00
	00		 add	 ecx, 3564		; 00000decH
  0045e	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 76   : 	m_BuildingTransparentImageInstance.SetImagePointer(pBuildTransparentImage);

  00463	ff 75 a0	 push	 DWORD PTR _pBuildTransparentImage$[ebp]
  00466	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00469	81 c1 0c 0e 00
	00		 add	 ecx, 3596		; 00000e0cH
  0046f	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 77   : 
; 78   : 	Initialize();

  00474	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00477	e8 00 00 00 00	 call	 ?Initialize@CMapOutdoor@@MAE_NXZ ; CMapOutdoor::Initialize

; 79   : 
; 80   : 	__SoftwareTransformPatch_Initialize();

  0047c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0047f	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_Initialize@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__SoftwareTransformPatch_Initialize

; 81   : 	__SoftwareTransformPatch_Create();

  00484	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00487	e8 00 00 00 00	 call	 ?__SoftwareTransformPatch_Create@CMapOutdoor@@IAE_NXZ ; CMapOutdoor::__SoftwareTransformPatch_Create

; 82   : }

  0048c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00490	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00493	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00496	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0049d	59		 pop	 ecx
  0049e	83 c5 78	 add	 ebp, 120		; 00000078H
  004a1	c9		 leave
  004a2	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$0:
  00000	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMapBase@@UAE@XZ	; CMapBase::~CMapBase
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$1:
  00008	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00011	e9 00 00 00 00	 jmp	 ??1?$map@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@U?$less@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@USOutdoorMapCoordinate@@@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$2:
  00016	68 00 00 00 00	 push	 OFFSET ??1CGraphicIndexBuffer@@UAE@XZ ; CGraphicIndexBuffer::~CGraphicIndexBuffer
  0001b	6a 03		 push	 3
  0001d	6a 14		 push	 20			; 00000014H
  0001f	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00022	05 9c 00 00 00	 add	 eax, 156		; 0000009cH
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0002d	c3		 ret	 0
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$3:
  0002e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	81 c1 18 01 00
	00		 add	 ecx, 280		; 00000118H
  00037	e9 00 00 00 00	 jmp	 ??1?$vector@U?$pair@MJ@std@@V?$allocator@U?$pair@MJ@std@@@2@@std@@QAE@XZ ; std::vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >::~vector<std::pair<float,long>,std::allocator<std::pair<float,long> > >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$4:
  0003c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	81 c1 24 01 00
	00		 add	 ecx, 292		; 00000124H
  00045	e9 00 00 00 00	 jmp	 ??1?$vector@UTPatchDrawStruct@CMapOutdoor@@V?$allocator@UTPatchDrawStruct@CMapOutdoor@@@std@@@std@@QAE@XZ ; std::vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >::~vector<CMapOutdoor::TPatchDrawStruct,std::allocator<CMapOutdoor::TPatchDrawStruct> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$5:
  0004a	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	81 c1 74 01 00
	00		 add	 ecx, 372		; 00000174H
  00053	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$6:
  00058	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	81 c1 7c 02 00
	00		 add	 ecx, 636		; 0000027cH
  00061	e9 00 00 00 00	 jmp	 ??1CTextureSet@@UAE@XZ	; CTextureSet::~CTextureSet
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$7:
  00066	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	81 c1 38 03 00
	00		 add	 ecx, 824		; 00000338H
  0006f	e9 00 00 00 00	 jmp	 ??1CSkyBox@@UAE@XZ	; CSkyBox::~CSkyBox
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$8:
  00074	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	81 c1 b8 06 00
	00		 add	 ecx, 1720		; 000006b8H
  0007d	e9 00 00 00 00	 jmp	 ??1CLensFlare@@UAE@XZ	; CLensFlare::~CLensFlare
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$9:
  00082	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	81 c1 2c 07 00
	00		 add	 ecx, 1836		; 0000072cH
  0008b	e9 00 00 00 00	 jmp	 ??1CScreenFilter@@UAE@XZ ; CScreenFilter::~CScreenFilter
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$10:
  00090	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	81 c1 18 09 00
	00		 add	 ecx, 2328		; 00000918H
  00099	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$11:
  0009e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	81 c1 24 09 00
	00		 add	 ecx, 2340		; 00000924H
  000a7	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$12:
  000ac	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	81 c1 30 09 00
	00		 add	 ecx, 2352		; 00000930H
  000b5	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$13:
  000ba	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	81 c1 3c 09 00
	00		 add	 ecx, 2364		; 0000093cH
  000c3	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCTerrain@@V?$allocator@PAVCTerrain@@@std@@@std@@QAE@XZ ; std::vector<CTerrain *,std::allocator<CTerrain *> >::~vector<CTerrain *,std::allocator<CTerrain *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$14:
  000c8	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	81 c1 4c 09 00
	00		 add	 ecx, 2380		; 0000094cH
  000d1	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$15:
  000d6	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	81 c1 58 09 00
	00		 add	 ecx, 2392		; 00000958H
  000df	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$16:
  000e4	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000e7	81 c1 64 09 00
	00		 add	 ecx, 2404		; 00000964H
  000ed	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$17:
  000f2	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	81 c1 70 09 00
	00		 add	 ecx, 2416		; 00000970H
  000fb	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCArea@@V?$allocator@PAVCArea@@@std@@@std@@QAE@XZ ; std::vector<CArea *,std::allocator<CArea *> >::~vector<CArea *,std::allocator<CArea *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$18:
  00100	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	81 c1 90 09 00
	00		 add	 ecx, 2448		; 00000990H
  00109	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$19:
  0010e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	81 c1 b8 09 00
	00		 add	 ecx, 2488		; 000009b8H
  00117	e9 00 00 00 00	 jmp	 ??1?$list@UtagRECT@@V?$allocator@UtagRECT@@@std@@@std@@QAE@XZ ; std::list<tagRECT,std::allocator<tagRECT> >::~list<tagRECT,std::allocator<tagRECT> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$20:
  0011c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	81 c1 0c 0a 00
	00		 add	 ecx, 2572		; 00000a0cH
  00125	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$21:
  0012a	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0012d	81 c1 18 0a 00
	00		 add	 ecx, 2584		; 00000a18H
  00133	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$22:
  00138	68 00 00 00 00	 push	 OFFSET ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0013d	6a 1e		 push	 30			; 0000001eH
  0013f	6a 20		 push	 32			; 00000020H
  00141	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00144	05 28 0a 00 00	 add	 eax, 2600		; 00000a28H
  00149	50		 push	 eax
  0014a	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0014f	c3		 ret	 0
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$23:
  00150	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	81 c1 ec 0d 00
	00		 add	 ecx, 3564		; 00000decH
  00159	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$24:
  0015e	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	81 c1 0c 0e 00
	00		 add	 ecx, 3596		; 00000e0cH
  00167	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$25:
  0016c	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	81 c1 6c 0e 00
	00		 add	 ecx, 3692		; 00000e6cH
  00175	e9 00 00 00 00	 jmp	 ??1?$CDynamicPool@VCMonsterAreaInfo@@@@UAE@XZ ; CDynamicPool<CMonsterAreaInfo>::~CDynamicPool<CMonsterAreaInfo>
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$26:
  0017a	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	81 c1 90 0e 00
	00		 add	 ecx, 3728		; 00000e90H
  00183	e9 00 00 00 00	 jmp	 ??1?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAE@XZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::~vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$27:
  00188	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	81 c1 c0 0e 00
	00		 add	 ecx, 3776		; 00000ec0H
  00191	e9 00 00 00 00	 jmp	 ??1?$map@KHU?$less@K@std@@V?$allocator@U?$pair@$$CBKH@std@@@2@@std@@QAE@XZ
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$28:
  00196	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	81 c1 c8 0e 00
	00		 add	 ecx, 3784		; 00000ec8H
  0019f	e9 00 00 00 00	 jmp	 ??1SHeightCache@CMapOutdoor@@QAE@XZ
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$29:
  001a4	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001a7	81 c1 7c 13 00
	00		 add	 ecx, 4988		; 0000137cH
  001ad	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CMapOutdoor@@QAE@XZ$30:
  001b2	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001b5	81 c1 94 13 00
	00		 add	 ecx, 5012		; 00001394H
  001bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001c0	cc		 int	 3
  001c1	cc		 int	 3
  001c2	cc		 int	 3
  001c3	cc		 int	 3
  001c4	cc		 int	 3
__ehhandler$??0CMapOutdoor@@QAE@XZ:
  001c5	90		 npad	 1
  001c6	90		 npad	 1
  001c7	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  001cb	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  001ce	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  001d1	33 c8		 xor	 ecx, eax
  001d3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d8	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CMapOutdoor@@QAE@XZ
  001dd	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CMapOutdoor@@QAE@XZ ENDP				; CMapOutdoor::CMapOutdoor
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXQAPAVCMonsterAreaInfo@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXQAPAVCMonsterAreaInfo@@II@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXQAPAVCMonsterAreaInfo@@II@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$1 = -44					; size = 4
$T2 = -40						; size = 4
__Myend$ = -36						; size = 4
__Mylast$ = -32						; size = 4
__Myfirst$ = -28					; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
_this$ = -16						; size = 4
__Newvec$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1633 :     void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1634 :         // allocate array with _Newcapacity elements
; 1635 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1636 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 e4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1637 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1638 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 dc	 mov	 DWORD PTR __Myend$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002a	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002d	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00030	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00033	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00037	c7 45 d4 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0003e	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00045	76 05		 jbe	 SHORT $LN12@Buy_raw

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00047	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Buy_raw:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0004c	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0004f	c1 e0 02	 shl	 eax, 2
  00052	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00055	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0005d	59		 pop	 ecx
  0005e	89 45 f4	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1644 :         _Myfirst           = _Newvec;

  00061	8b 45 e4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00064	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00067	89 08		 mov	 DWORD PTR [eax], ecx

; 1645 :         _Mylast            = _Newvec;

  00069	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006c	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx

; 1646 :         _Myend             = _Newvec + _Newcapacity;

  00071	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00074	8b 4d f4	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00077	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0007a	8b 4d dc	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
$LN15@Buy_raw:

; 1647 :     }

  0007f	c9		 leave
  00080	c2 04 00	 ret	 4
?_Buy_raw@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?max_size@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
tv68 = -12						; size = 4
$T6 = -8						; size = 4
$T7 = -4						; size = 4
?max_size@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QBEIXZ PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::max_size, COMDAT
; _this$ = ecx

; 1487 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 fc ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0001c	c7 45 e8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00023	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00026	89 45 f8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00029	8b 45 fc	 mov	 eax, DWORD PTR $T7[ebp]
  0002c	3b 45 f8	 cmp	 eax, DWORD PTR $T6[ebp]
  0002f	73 08		 jae	 SHORT $LN17@max_size
  00031	8d 45 fc	 lea	 eax, DWORD PTR $T7[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
  00037	eb 06		 jmp	 SHORT $LN18@max_size
$LN17@max_size:
  00039	8d 45 f8	 lea	 eax, DWORD PTR $T6[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR tv68[ebp], eax
$LN18@max_size:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR tv68[ebp]
  00042	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00045	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004b	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1489 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1490 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?max_size@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QBEIXZ ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAEXXZ ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Clear_and_reserve_geometric@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
__Newcapacity$ = -52					; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Myfirst$ = -8						; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
?_Clear_and_reserve_geometric@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Clear_and_reserve_geometric, COMDAT
; _this$ = ecx

; 1271 :     void _Clear_and_reserve_geometric(const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1272 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1273 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1274 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1275 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1276 : 
; 1277 : #if _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1278 :         _STL_INTERNAL_CHECK(_Newsize != 0);
; 1279 :         {
; 1280 :             _Lockit _Lock(_LOCK_DEBUG);
; 1281 :             _STL_INTERNAL_CHECK(!_My_data._Myproxy->_Myfirstiter); // asserts that all iterators are orphaned
; 1282 :         } // unlock
; 1283 : #endif // _ITERATOR_DEBUG_LEVEL != 0 && defined(_ENABLE_STL_INTERNAL_CHECK)
; 1284 : 
; 1285 :         if (_Newsize > max_size()) {

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QBEIXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::max_size
  0002f	39 45 08	 cmp	 DWORD PTR __Newsize$[ebp], eax
  00032	76 05		 jbe	 SHORT $LN2@Clear_and_

; 1286 :             _Xlength();

  00034	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@CAXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Xlength
$LN2@Clear_and_:

; 1287 :         }
; 1288 : 
; 1289 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00039	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@ABEII@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Calculate_growth
  00044	89 45 cc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1290 : 
; 1291 :         if (_Myfirst) { // destroy and deallocate old array

  00047	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0004a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004d	74 74		 je	 SHORT $LN3@Clear_and_

; 1292 :             _Destroy(_Myfirst, _Mylast);

  0004f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00057	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00062	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00068	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0006b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0006e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00071	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00074	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXPAPAVCMonsterAreaInfo@@QAPAV1@AAV?$allocator@PAVCMonsterAreaInfo@@@0@@Z ; std::_Destroy_range<std::allocator<CMonsterAreaInfo *> >
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0007f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00082	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00085	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax

; 1293 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00088	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	2b 01		 sub	 eax, DWORD PTR [ecx]
  00092	c1 f8 02	 sar	 eax, 2
  00095	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00098	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009b	8b 00		 mov	 eax, DWORD PTR [eax]
  0009d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000a3	c1 e0 02	 shl	 eax, 2
  000a6	50		 push	 eax
  000a7	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  000aa	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000af	59		 pop	 ecx
  000b0	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1295 :             _Myfirst = pointer();

  000b1	8b 45 f8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b4	83 20 00	 and	 DWORD PTR [eax], 0

; 1296 :             _Mylast  = pointer();

  000b7	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ba	83 20 00	 and	 DWORD PTR [eax], 0

; 1297 :             _Myend   = pointer();

  000bd	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Clear_and_:

; 1298 :         }
; 1299 : 
; 1300 :         _Buy_raw(_Newcapacity);

  000c3	ff 75 cc	 push	 DWORD PTR __Newcapacity$[ebp]
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Buy_raw
$LN4@Clear_and_:

; 1301 :     }

  000ce	c9		 leave
  000cf	c2 04 00	 ret	 4
?_Clear_and_reserve_geometric@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Clear_and_reserve_geometric
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Copy_assign@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 1
__First$ = -36						; size = 4
$T2 = -32						; size = 4
__Last$ = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Right_data$ = -4					; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Copy_assign, COMDAT
; _this$ = ecx

; 1150 :     void _Copy_assign(const vector& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1151 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 ec	 push	 DWORD PTR $T4[ebp]
  00024	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@YAXAAV?$allocator@PAVCMonsterAreaInfo@@@0@ABV10@@Z ; std::_Pocca<std::allocator<CMonsterAreaInfo *> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 1152 :         auto& _Right_data = _Right._Mypair._Myval2;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 fc	 mov	 DWORD PTR __Right_data$[ebp], eax

; 1153 :         assign(_Right_data._Myfirst, _Right_data._Mylast);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1303 :         return _It + 0;

  00045	8b 45 e4	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1142 :         _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});

  0004b	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Assign_range@PAPAVCMonsterAreaInfo@@@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXPAPAVCMonsterAreaInfo@@0Uforward_iterator_tag@1@@Z ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Assign_range<CMonsterAreaInfo * *>

; 1154 :     }

  0005c	c9		 leave
  0005d	c2 08 00	 ret	 8
?_Copy_assign@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAE@XZ PROC ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::~vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@AAEXXZ ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCMonsterAreaInfo@@V?$allocator@PAVCMonsterAreaInfo@@@std@@@std@@QAE@XZ ENDP ; std::vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >::~vector<CMonsterAreaInfo *,std::allocator<CMonsterAreaInfo *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCMonsterAreaInfo@@@std@@QAEXQAPAVCMonsterAreaInfo@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCMonsterAreaInfo@@@std@@QAEXQAPAVCMonsterAreaInfo@@I@Z PROC ; std::allocator<CMonsterAreaInfo *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCMonsterAreaInfo@@@std@@QAEXQAPAVCMonsterAreaInfo@@I@Z ENDP ; std::allocator<CMonsterAreaInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECTerrainPatchProxy@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_ECTerrainPatchProxy@@UAEPAXI@Z PROC			; CTerrainPatchProxy::`vector deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_ECTerrainPatchProxy@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00029	83 e0 02	 and	 eax, 2
  0002c	74 3e		 je	 SHORT $LN2@vector
  0002e	68 00 00 00 00	 push	 OFFSET ??1CTerrainPatchProxy@@UAE@XZ ; CTerrainPatchProxy::~CTerrainPatchProxy
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	ff 70 fc	 push	 DWORD PTR [eax-4]
  00039	6a 1c		 push	 28			; 0000001cH
  0003b	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00043	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00046	83 e0 01	 and	 eax, 1
  00049	74 19		 je	 SHORT $LN3@vector
  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	6b 40 fc 1c	 imul	 eax, DWORD PTR [eax-4], 28
  00052	83 c0 04	 add	 eax, 4
  00055	50		 push	 eax
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	83 e8 04	 sub	 eax, 4
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 ??_V@YAXPAXI@Z		; operator delete[]
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
$LN3@vector:
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 e8 04	 sub	 eax, 4
  0006a	eb 1f		 jmp	 SHORT $LN5@vector
$LN2@vector:
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ??1CTerrainPatchProxy@@UAE@XZ ; CTerrainPatchProxy::~CTerrainPatchProxy
  00074	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00077	83 e0 01	 and	 eax, 1
  0007a	74 0c		 je	 SHORT $LN4@vector
  0007c	6a 1c		 push	 28			; 0000001cH
  0007e	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00086	59		 pop	 ecx
  00087	59		 pop	 ecx
$LN4@vector:
  00088	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@vector:
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	c9		 leave
  00097	c2 04 00	 ret	 4
  0009a	cc		 int	 3
  0009b	cc		 int	 3
  0009c	cc		 int	 3
  0009d	cc		 int	 3
  0009e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_ECTerrainPatchProxy@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_ECTerrainPatchProxy@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_ECTerrainPatchProxy@@UAEPAXI@Z ENDP			; CTerrainPatchProxy::`vector deleting destructor'
; Function compile flags: /Odspy
;	COMDAT ??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::set<int,std::less<int>,std::allocator<int> >::~set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\set
;	COMDAT ??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ PROC ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >, COMDAT
; _this$ = ecx

; 84   :     set() : _Mybase(key_compare()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
??0?$set@HU?$less@H@std@@V?$allocator@H@2@@std@@QAE@XZ ENDP ; std::set<int,std::less<int>,std::allocator<int> >::set<int,std::less<int>,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S16$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S16$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@HPAX@std@@@1@@Z ; std::_Tree_node<int,void *>::_Buyheadnode<std::allocator<std::_Tree_node<int,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@H@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU?$_Tree_node@HPAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<int> >::_Erase_tree<std::allocator<std::_Tree_node<int,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@HPAX@std@@@std@@@?$_Tree_node@HPAX@std@@SAXAAV?$allocator@U?$_Tree_node@HPAX@std@@@1@PAU01@@Z ; std::_Tree_node<int,void *>::_Freenode0<std::allocator<std::_Tree_node<int,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::~_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z PROC ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tset_traits@HU?$less@H@std@@V?$allocator@H@2@$0A@@std@@@std@@QAE@ABU?$less@H@1@@Z ENDP ; std::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >::_Tree<std::_Tset_traits<int,std::less<int>,std::allocator<int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >::_Vector_val<std::_Simple_types<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@YAXPAPAVCGraphicObjectInstance@@QAPAV1@AAV?$allocator@PAVCGraphicObjectInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicObjectInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ PROC ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@PAVCGraphicObjectInstance@@V?$allocator@PAVCGraphicObjectInstance@@@std@@@std@@QAE@XZ ENDP ; std::vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >::~vector<CGraphicObjectInstance *,std::allocator<CGraphicObjectInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $LN2@scalar
  00018	6a 04		 push	 4
  0001a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Throw_tree_length_error@std@@YAXXZ
_TEXT	SEGMENT
?_Throw_tree_length_error@std@@YAXXZ PROC		; std::_Throw_tree_length_error, COMDAT

; 414  : [[noreturn]] inline void _Throw_tree_length_error() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 415  :     _Xlength_error("map/set too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@GCADKGJO@map?1set?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Throw_tree:

; 416  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Throw_tree_length_error@std@@YAXXZ ENDP		; std::_Throw_tree_length_error
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
__Ptr$ = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
__Result$6 = -16					; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 2826 :     void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0001b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2827 :         _Pocca(_Getal(), _Right._Getal());

  00021	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00024	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00041	72 09		 jb	 SHORT $LN21@Copy_assig
  00043	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004a	eb 04		 jmp	 SHORT $LN22@Copy_assig
$LN21@Copy_assig:
  0004c	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN22@Copy_assig:
  00050	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00053	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00056	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0005a	85 c0		 test	 eax, eax
  0005c	74 0e		 je	 SHORT $LN16@Copy_assig

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00066	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00069	89 45 f0	 mov	 DWORD PTR __Result$6[ebp], eax
$LN16@Copy_assig:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Result$6[ebp]
  0006f	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 2828 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00072	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00075	ff 70 10	 push	 DWORD PTR [eax+16]
  00078	ff 75 d4	 push	 DWORD PTR $T1[ebp]
  0007b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2829 :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoor.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
