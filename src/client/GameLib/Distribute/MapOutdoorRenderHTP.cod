; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0D3DXMATRIX@@QAE@XZ				; D3DXMATRIX::D3DXMATRIX
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
PUBLIC	?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat
PUBLIC	?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone
PUBLIC	??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
PUBLIC	??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
PUBLIC	??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z		; std::_Refancy<int *,0>
PUBLIC	??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
PUBLIC	??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
PUBLIC	??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@437f0000
PUBLIC	__real@44c80000
PUBLIC	__real@45480000
PUBLIC	__real@459c4000
PUBLIC	__real@461c4000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	_D3DXMatrixMultiply@12:PROC
EXTRN	_D3DXMatrixScaling@16:PROC
EXTRN	?GetFogNearDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogNearDistance
EXTRN	?GetFogFarDistance@SEnvironmentData@@QBEMXZ:PROC ; SEnvironmentData::GetFogFarDistance
EXTRN	?GetTextureCount@CTextureSet@@QAEKXZ:PROC	; CTextureSet::GetTextureCount
EXTRN	?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z:PROC ; CTextureSet::GetTexture
EXTRN	?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ:PROC ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr
EXTRN	?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z:PROC ; CMapOutdoor::GetTerrainPointer
EXTRN	?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::DrawWireFrame
EXTRN	?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z:PROC ; CMapOutdoor::SelectIndexBuffer
EXTRN	?__GetNoFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetNoFogDistance
EXTRN	?__GetFogDistance@CMapOutdoor@@IAEMXZ:PROC	; CMapOutdoor::__GetFogDistance
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SaveTextureStageState
EXTRN	?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z:PROC ; CStateManager::RestoreTextureStageState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?SetBestFiltering@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetBestFiltering
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SaveTransform
EXTRN	?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z:PROC ; CStateManager::RestoreTransform
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z:PROC ; CStateManager::SetStreamSource
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::GetRenderState
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__ftoui3:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_faceCount@CGraphicBase@@1KA:DWORD		; CGraphicBase::ms_faceCount
EXTRN	?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA:BYTE	; CSpeedTreeWrapper::ms_bSelfShadowOn
EXTRN	?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A:DWORD ; CTerrainImpl::ms_pTextureSet
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __real@461c4000
CONST	SEGMENT
__real@461c4000 DD 0461c4000r			; 10000
CONST	ENDS
;	COMDAT __real@459c4000
CONST	SEGMENT
__real@459c4000 DD 0459c4000r			; 5000
CONST	ENDS
;	COMDAT __real@45480000
CONST	SEGMENT
__real@45480000 DD 045480000r			; 3200
CONST	ENDS
;	COMDAT __real@44c80000
CONST	SEGMENT
__real@44c80000 DD 044c80000r			; 1600
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4535 : _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4536 :     // implement copy_backward-like function as memmove
; 4537 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4538 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4539 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4540 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b c8		 sub	 ecx, eax

; 4541 :     return static_cast<_BidIt2>(_CSTD memmove(_Dest_ch - _Count, _First_ch, _Count));

  0000b	51		 push	 ecx
  0000c	50		 push	 eax
  0000d	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00010	2b c1		 sub	 eax, ecx
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4542 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z
_TEXT	SEGMENT
tv670 = -4						; size = 4
tv693 = 8						; size = 4
tv677 = 8						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Tmp$1$ = 16						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<int *,std::less<void> >, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00004	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00007	56		 push	 esi
  00008	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
  0000b	8b c6		 mov	 eax, esi
  0000d	2b c1		 sub	 eax, ecx
  0000f	c1 f8 02	 sar	 eax, 2
  00012	57		 push	 edi

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00013	83 f8 28	 cmp	 eax, 40			; 00000028H
  00016	0f 8e e1 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001c	40		 inc	 eax
  0001d	c1 f8 03	 sar	 eax, 3
  00020	53		 push	 ebx

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00021	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00028	8d 1c 85 00 00
	00 00		 lea	 ebx, DWORD PTR [eax*4]
  0002f	89 55 fc	 mov	 DWORD PTR tv670[ebp], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00032	8b 3c 0b	 mov	 edi, DWORD PTR [ebx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00035	8d 14 0b	 lea	 edx, DWORD PTR [ebx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00038	8b 01		 mov	 eax, DWORD PTR [ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  0003a	89 5d 08	 mov	 DWORD PTR tv693[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0003d	3b f8		 cmp	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0003f	7d 06		 jge	 SHORT $LN15@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00041	89 02		 mov	 DWORD PTR [edx], eax

; 106  :     _Right   = _STD move(_Tmp);

  00043	89 39		 mov	 DWORD PTR [ecx], edi
  00045	8b 3a		 mov	 edi, DWORD PTR [edx]
$LN15@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00047	8b 45 fc	 mov	 eax, DWORD PTR tv670[ebp]
  0004a	8b 04 08	 mov	 eax, DWORD PTR [eax+ecx]
  0004d	3b c7		 cmp	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  0004f	7d 15		 jge	 SHORT $LN27@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00051	8b 75 fc	 mov	 esi, DWORD PTR tv670[ebp]
  00054	89 3c 0e	 mov	 DWORD PTR [esi+ecx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00057	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0005a	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0005c	8b 39		 mov	 edi, DWORD PTR [ecx]
  0005e	3b c7		 cmp	 eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00060	7d 04		 jge	 SHORT $LN27@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00062	89 3a		 mov	 DWORD PTR [edx], edi

; 106  :     _Right   = _STD move(_Tmp);

  00064	89 01		 mov	 DWORD PTR [ecx], eax
$LN27@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  00066	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00069	8b c8		 mov	 ecx, eax
  0006b	2b cb		 sub	 ecx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0006d	8b 38		 mov	 edi, DWORD PTR [eax]
  0006f	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00071	3b fb		 cmp	 edi, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00073	7d 06		 jge	 SHORT $LN38@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00075	89 18		 mov	 DWORD PTR [eax], ebx

; 106  :     _Right   = _STD move(_Tmp);

  00077	89 39		 mov	 DWORD PTR [ecx], edi
  00079	8b 38		 mov	 edi, DWORD PTR [eax]
$LN38@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0007b	8b 5d 08	 mov	 ebx, DWORD PTR tv693[ebp]
  0007e	8b 1c 03	 mov	 ebx, DWORD PTR [ebx+eax]
  00081	3b df		 cmp	 ebx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00083	7d 15		 jge	 SHORT $LN50@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00085	8b 75 08	 mov	 esi, DWORD PTR tv693[ebp]
  00088	89 3c 06	 mov	 DWORD PTR [esi+eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0008b	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  0008e	89 18		 mov	 DWORD PTR [eax], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00090	8b 39		 mov	 edi, DWORD PTR [ecx]
  00092	3b df		 cmp	 ebx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00094	7d 04		 jge	 SHORT $LN50@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00096	89 38		 mov	 DWORD PTR [eax], edi

; 106  :     _Right   = _STD move(_Tmp);

  00098	89 19		 mov	 DWORD PTR [ecx], ebx
$LN50@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0009a	8b ce		 mov	 ecx, esi
  0009c	8b fe		 mov	 edi, esi
  0009e	2b 4d 08	 sub	 ecx, DWORD PTR tv693[ebp]
  000a1	2b 7d fc	 sub	 edi, DWORD PTR tv670[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000a4	8b 19		 mov	 ebx, DWORD PTR [ecx]
  000a6	8b 07		 mov	 eax, DWORD PTR [edi]
  000a8	3b d8		 cmp	 ebx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000aa	7d 0b		 jge	 SHORT $LN61@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000ac	8b f0		 mov	 esi, eax
  000ae	89 31		 mov	 DWORD PTR [ecx], esi
  000b0	8b 75 10	 mov	 esi, DWORD PTR __Last$[ebp]

; 106  :     _Right   = _STD move(_Tmp);

  000b3	89 1f		 mov	 DWORD PTR [edi], ebx
  000b5	8b 19		 mov	 ebx, DWORD PTR [ecx]
$LN61@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000b7	8b 06		 mov	 eax, DWORD PTR [esi]
  000b9	3b c3		 cmp	 eax, ebx
  000bb	89 45 10	 mov	 DWORD PTR __Tmp$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  000be	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  000c1	7d 11		 jge	 SHORT $LN73@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000c3	89 1e		 mov	 DWORD PTR [esi], ebx

; 106  :     _Right   = _STD move(_Tmp);

  000c5	8b 5d 10	 mov	 ebx, DWORD PTR __Tmp$1$[ebp]
  000c8	89 19		 mov	 DWORD PTR [ecx], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ca	8b 37		 mov	 esi, DWORD PTR [edi]
  000cc	3b de		 cmp	 ebx, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000ce	7d 04		 jge	 SHORT $LN73@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000d0	89 31		 mov	 DWORD PTR [ecx], esi

; 106  :     _Right   = _STD move(_Tmp);

  000d2	89 1f		 mov	 DWORD PTR [edi], ebx
$LN73@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000d4	8b 30		 mov	 esi, DWORD PTR [eax]
  000d6	8b 3a		 mov	 edi, DWORD PTR [edx]
  000d8	5b		 pop	 ebx
  000d9	3b f7		 cmp	 esi, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000db	7d 06		 jge	 SHORT $LN84@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000dd	89 38		 mov	 DWORD PTR [eax], edi

; 106  :     _Right   = _STD move(_Tmp);

  000df	89 32		 mov	 DWORD PTR [edx], esi
  000e1	8b 30		 mov	 esi, DWORD PTR [eax]
$LN84@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e3	8b 39		 mov	 edi, DWORD PTR [ecx]
  000e5	3b fe		 cmp	 edi, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  000e7	7d 39		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000e9	89 31		 mov	 DWORD PTR [ecx], esi

; 106  :     _Right   = _STD move(_Tmp);

  000eb	89 38		 mov	 DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000ed	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000ef	3b f9		 cmp	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  000f1	7d 2f		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  000f3	89 08		 mov	 DWORD PTR [eax], ecx

; 106  :     _Right   = _STD move(_Tmp);

  000f5	89 3a		 mov	 DWORD PTR [edx], edi
  000f7	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7464 : }

  000f8	5e		 pop	 esi
  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN2@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000fd	8b 45 0c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00100	8b 39		 mov	 edi, DWORD PTR [ecx]
  00102	8b 10		 mov	 edx, DWORD PTR [eax]
  00104	3b d7		 cmp	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00106	7d 06		 jge	 SHORT $LN107@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00108	89 38		 mov	 DWORD PTR [eax], edi

; 106  :     _Right   = _STD move(_Tmp);

  0010a	89 11		 mov	 DWORD PTR [ecx], edx
  0010c	8b 10		 mov	 edx, DWORD PTR [eax]
$LN107@Guess_medi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0010e	8b 3e		 mov	 edi, DWORD PTR [esi]
  00110	3b fa		 cmp	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00112	7d 0e		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00114	89 16		 mov	 DWORD PTR [esi], edx

; 106  :     _Right   = _STD move(_Tmp);

  00116	89 38		 mov	 DWORD PTR [eax], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00118	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011a	3b fa		 cmp	 edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0011c	7d 04		 jge	 SHORT $LN119@Guess_medi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0011e	89 10		 mov	 DWORD PTR [eax], edx

; 106  :     _Right   = _STD move(_Tmp);

  00120	89 39		 mov	 DWORD PTR [ecx], edi
$LN119@Guess_medi:
  00122	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7464 : }

  00123	5e		 pop	 esi
  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c3		 ret	 0
??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
tv253 = 12						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;
; 6192 :     _Diff _Idx       = _Hole;
; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	8b d0		 mov	 edx, eax
  0000b	53		 push	 ebx
  0000c	56		 push	 esi
  0000d	8d 71 ff	 lea	 esi, DWORD PTR [ecx-1]
  00010	8b d8		 mov	 ebx, eax
  00012	57		 push	 edi
  00013	8b fe		 mov	 edi, esi
  00015	89 75 0c	 mov	 DWORD PTR tv253[ebp], esi

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  00018	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  0001b	d1 ff		 sar	 edi, 1
  0001d	3b c7		 cmp	 eax, edi
  0001f	7d 21		 jge	 SHORT $LN3@Pop_heap_h
$LL2@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00021	8b 4c d6 08	 mov	 ecx, DWORD PTR [esi+edx*8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6198 :         _Idx = 2 * _Idx + 2;

  00025	8d 14 55 02 00
	00 00		 lea	 edx, DWORD PTR [edx*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0002c	3b 4c 96 fc	 cmp	 ecx, DWORD PTR [esi+edx*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00030	7d 01		 jge	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  00032	4a		 dec	 edx
$LN4@Pop_heap_h:

; 6201 :         }
; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00033	8b 0c 96	 mov	 ecx, DWORD PTR [esi+edx*4]
  00036	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 6203 :         _Hole             = _Idx;

  00039	8b c2		 mov	 eax, edx
  0003b	3b d7		 cmp	 edx, edi
  0003d	7c e2		 jl	 SHORT $LL2@Pop_heap_h
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR __Bottom$[ebp]
$LN3@Pop_heap_h:

; 6204 :     }
; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00042	3b d7		 cmp	 edx, edi
  00044	75 0f		 jne	 SHORT $LN5@Pop_heap_h
  00046	f6 c1 01	 test	 cl, 1
  00049	75 0a		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  0004b	8b 4c 8e fc	 mov	 ecx, DWORD PTR [esi+ecx*4-4]
  0004f	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx

; 6208 :         _Hole             = _Bottom - 1;

  00052	8b 45 0c	 mov	 eax, DWORD PTR tv253[ebp]
$LN5@Pop_heap_h:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00055	3b d8		 cmp	 ebx, eax
  00057	7d 26		 jge	 SHORT $LN24@Pop_heap_h
  00059	8b 7d 14	 mov	 edi, DWORD PTR __Val$[ebp]
  0005c	0f 1f 40 00	 npad	 4
$LL12@Pop_heap_h:

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00060	8d 48 ff	 lea	 ecx, DWORD PTR [eax-1]
  00063	d1 f9		 sar	 ecx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00065	8b 14 8e	 mov	 edx, DWORD PTR [esi+ecx*4]
  00068	3b 17		 cmp	 edx, DWORD PTR [edi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  0006a	7d 09		 jge	 SHORT $LN25@Pop_heap_h

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6079 :         // move _Hole up to parent
; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0006c	89 14 86	 mov	 DWORD PTR [esi+eax*4], edx

; 6081 :         _Hole             = _Idx;

  0006f	8b c1		 mov	 eax, ecx
  00071	3b d9		 cmp	 ebx, ecx
  00073	7c eb		 jl	 SHORT $LL12@Pop_heap_h
$LN25@Pop_heap_h:

; 6209 :     }
; 6210 : 
; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6212 : }

  00075	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00077	5f		 pop	 edi
  00078	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN24@Pop_heap_h:

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  0007f	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00082	5f		 pop	 edi
  00083	8b 09		 mov	 ecx, DWORD PTR [ecx]

; 6209 :     }
; 6210 : 
; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);
; 6212 : }

  00085	89 0c 86	 mov	 DWORD PTR [esi+eax*4], ecx
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z PROC ; std::_Refancy<std::pair<float,long> *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ENDP ; std::_Refancy<std::pair<float,long> *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z
_TEXT	SEGMENT
tv557 = -12						; size = 4
__Gfirst$1$ = -12					; size = 4
tv551 = -8						; size = 4
__Glast$1$ = -8						; size = 4
__Plast$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00009	53		 push	 ebx
  0000a	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000d	8b c3		 mov	 eax, ebx
  0000f	56		 push	 esi
  00010	2b c1		 sub	 eax, ecx
  00012	c1 f8 03	 sar	 eax, 3
  00015	57		 push	 edi

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00016	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00019	8d 34 81	 lea	 esi, DWORD PTR [ecx+eax*4]
  0001c	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  0001f	50		 push	 eax
  00020	56		 push	 esi
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAHU?$less@X@std@@@std@@YAXPAH00U?$less@X@0@@Z ; std::_Guess_median_unchecked<int *,std::less<void> >
  00027	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;
; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0002a	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  0002d	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00030	39 75 0c	 cmp	 DWORD PTR __First$[ebp], esi
  00033	73 20		 jae	 SHORT $LN82@Partition_
  00035	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00037	8b 5d 0c	 mov	 ebx, DWORD PTR __First$[ebp]
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL2@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00040	8b 46 fc	 mov	 eax, DWORD PTR [esi-4]
  00043	3b c1		 cmp	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00045	7c 0b		 jl	 SHORT $LN107@Partition_
  00047	7f 09		 jg	 SHORT $LN107@Partition_

; 7476 :         --_Pfirst;

  00049	83 c6 fc	 add	 esi, -4			; fffffffcH
  0004c	8b c8		 mov	 ecx, eax
  0004e	3b de		 cmp	 ebx, esi
  00050	72 ee		 jb	 SHORT $LL2@Partition_
$LN107@Partition_:
  00052	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
$LN82@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00055	3b fb		 cmp	 edi, ebx
  00057	73 17		 jae	 SHORT $LN5@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00059	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0005b	0f 1f 44 00 00	 npad	 5
$LL4@Partition_:
  00060	39 0f		 cmp	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00062	7c 09		 jl	 SHORT $LN108@Partition_
  00064	7f 07		 jg	 SHORT $LN108@Partition_

; 7480 :         ++_Plast;

  00066	83 c7 04	 add	 edi, 4
  00069	3b fb		 cmp	 edi, ebx
  0006b	72 f3		 jb	 SHORT $LL4@Partition_
$LN108@Partition_:
  0006d	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
$LN5@Partition_:

; 7481 :     }
; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  00070	8b d7		 mov	 edx, edi

; 7484 :     _RanIt _Glast  = _Pfirst;

  00072	8b de		 mov	 ebx, esi
$LN113@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00074	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
$LN112@Partition_:
  00077	89 55 f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
  0007a	66 0f 1f 44 00
	00		 npad	 6
$LL6@Partition_:
  00080	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  00083	73 32		 jae	 SHORT $LN86@Partition_
  00085	8b 5d 10	 mov	 ebx, DWORD PTR __Last$[ebp]
$LL11@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00088	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0008a	39 0e		 cmp	 DWORD PTR [esi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0008c	7c 19		 jl	 SHORT $LN9@Partition_

; 7489 :                 continue;
; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0008e	7f 1e		 jg	 SHORT $LN109@Partition_

; 7491 :                 break;
; 7492 :             } else if (_Plast != _Gfirst) {

  00090	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00093	89 45 f4	 mov	 DWORD PTR tv557[ebp], eax
  00096	3b fa		 cmp	 edi, edx
  00098	74 0b		 je	 SHORT $LN19@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0009a	8b 07		 mov	 eax, DWORD PTR [edi]

; 105  :     _Left    = _STD move(_Right);

  0009c	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  0009e	8b 7d f4	 mov	 edi, DWORD PTR tv557[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  000a1	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7495 :             } else {

  000a3	eb 02		 jmp	 SHORT $LN9@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  000a5	8b f8		 mov	 edi, eax
$LN9@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  000a7	83 c2 04	 add	 edx, 4
  000aa	3b d3		 cmp	 edx, ebx
  000ac	72 da		 jb	 SHORT $LL11@Partition_
$LN109@Partition_:
  000ae	8b 5d f8	 mov	 ebx, DWORD PTR __Glast$1$[ebp]
  000b1	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
  000b4	89 55 f4	 mov	 DWORD PTR __Gfirst$1$[ebp], edx
$LN86@Partition_:

; 7500 :         for (; _First < _Glast; --_Glast) {

  000b7	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  000ba	3b d8		 cmp	 ebx, eax
  000bc	76 34		 jbe	 SHORT $LN111@Partition_
  000be	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  000c1	8b f8		 mov	 edi, eax
$LL14@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000c3	8b 01		 mov	 eax, DWORD PTR [ecx]
  000c5	3b 06		 cmp	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  000c7	7c 11		 jl	 SHORT $LN12@Partition_

; 7502 :                 continue;
; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  000c9	7f 19		 jg	 SHORT $LN110@Partition_

; 7504 :                 break;
; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  000cb	83 ee 04	 sub	 esi, 4
  000ce	3b f1		 cmp	 esi, ecx
  000d0	74 08		 je	 SHORT $LN12@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000d2	8b 06		 mov	 eax, DWORD PTR [esi]

; 105  :     _Left    = _STD move(_Right);

  000d4	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d6	89 16		 mov	 DWORD PTR [esi], edx

; 106  :     _Right   = _STD move(_Tmp);

  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$LN12@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7500 :         for (; _First < _Glast; --_Glast) {

  000da	83 eb 04	 sub	 ebx, 4
  000dd	83 e9 04	 sub	 ecx, 4
  000e0	3b fb		 cmp	 edi, ebx
  000e2	72 df		 jb	 SHORT $LL14@Partition_
$LN110@Partition_:
  000e4	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));
; 7507 :             }
; 7508 :         }
; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  000e7	3b d8		 cmp	 ebx, eax
  000e9	8b 55 f4	 mov	 edx, DWORD PTR __Gfirst$1$[ebp]
  000ec	8b 7d fc	 mov	 edi, DWORD PTR __Plast$1$[ebp]
  000ef	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
$LN111@Partition_:
  000f2	75 2a		 jne	 SHORT $LN27@Partition_
  000f4	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  000f7	74 73		 je	 SHORT $LN88@Partition_

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward
; 7515 :             if (_Plast != _Gfirst) {

  000f9	3b fa		 cmp	 edi, edx
  000fb	74 08		 je	 SHORT $LN63@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  000fd	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 105  :     _Left    = _STD move(_Right);

  000ff	8b 07		 mov	 eax, DWORD PTR [edi]
  00101	89 06		 mov	 DWORD PTR [esi], eax

; 106  :     _Right   = _STD move(_Tmp);

  00103	89 0f		 mov	 DWORD PTR [edi], ecx
$LN63@Partition_:

; 104  :     _Ty _Tmp = _STD move(_Left);

  00105	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  00107	83 c7 04	 add	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  0010e	83 c6 04	 add	 esi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00111	89 0a		 mov	 DWORD PTR [edx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7522 :             ++_Gfirst;

  00113	83 c2 04	 add	 edx, 4
  00116	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
  00119	e9 59 ff ff ff	 jmp	 $LN112@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  0011e	83 c3 fc	 add	 ebx, -4			; fffffffcH
  00121	89 5d f8	 mov	 DWORD PTR __Glast$1$[ebp], ebx
  00124	3b 55 10	 cmp	 edx, DWORD PTR __Last$[ebp]
  00127	75 33		 jne	 SHORT $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  00129	83 ee 04	 sub	 esi, 4
  0012c	3b de		 cmp	 ebx, esi
  0012e	74 19		 je	 SHORT $LN98@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00130	8b 06		 mov	 eax, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  00132	83 ef 04	 sub	 edi, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  00135	8b 0b		 mov	 ecx, DWORD PTR [ebx]

; 105  :     _Left    = _STD move(_Right);

  00137	89 03		 mov	 DWORD PTR [ebx], eax

; 106  :     _Right   = _STD move(_Tmp);

  00139	89 0e		 mov	 DWORD PTR [esi], ecx

; 105  :     _Left    = _STD move(_Right);

  0013b	8b 07		 mov	 eax, DWORD PTR [edi]
  0013d	89 06		 mov	 DWORD PTR [esi], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  0013f	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00142	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  00144	e9 37 ff ff ff	 jmp	 $LL6@Partition_
$LN98@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00149	8b 0e		 mov	 ecx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  0014b	83 ef 04	 sub	 edi, 4
  0014e	89 7d fc	 mov	 DWORD PTR __Plast$1$[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 105  :     _Left    = _STD move(_Right);

  00151	8b 07		 mov	 eax, DWORD PTR [edi]
  00153	89 06		 mov	 DWORD PTR [esi], eax

; 106  :     _Right   = _STD move(_Tmp);

  00155	89 0f		 mov	 DWORD PTR [edi], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  00157	e9 24 ff ff ff	 jmp	 $LL6@Partition_
$LN30@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 104  :     _Ty _Tmp = _STD move(_Left);

  0015c	8b 0a		 mov	 ecx, DWORD PTR [edx]

; 105  :     _Left    = _STD move(_Right);

  0015e	8b 03		 mov	 eax, DWORD PTR [ebx]
  00160	89 02		 mov	 DWORD PTR [edx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  00162	83 c2 04	 add	 edx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 106  :     _Right   = _STD move(_Tmp);

  00165	89 0b		 mov	 DWORD PTR [ebx], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7533 :     }

  00167	e9 08 ff ff ff	 jmp	 $LN113@Partition_
$LN88@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0016c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0016f	89 78 04	 mov	 DWORD PTR [eax+4], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00172	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00173	89 30		 mov	 DWORD PTR [eax], esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  00175	5e		 pop	 esi
  00176	5b		 pop	 ebx

; 7534 : }

  00177	8b e5		 mov	 esp, ebp
  00179	5d		 pop	 ebp
  0017a	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z PROC		; std::_Refancy<int *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ENDP		; std::_Refancy<int *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4367 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
tv656 = -8						; size = 4
__Bottom$1$ = -4					; size = 4
__Val$1$ = 8						; size = 4
__First$ = 8						; size = 4
__Val$2 = 12						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<int *,std::less<void> >, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0000a	8b c3		 mov	 eax, ebx
  0000c	56		 push	 esi
  0000d	8b 75 08	 mov	 esi, DWORD PTR __First$[ebp]
  00010	2b c6		 sub	 eax, esi
  00012	83 e0 fc	 and	 eax, -4			; fffffffcH
  00015	57		 push	 edi
  00016	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0001b	7e 71		 jle	 SHORT $LN67@Sort_unche
  0001d	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00020	8b 7d 10	 mov	 edi, DWORD PTR __Ideal$[ebp]
$LL2@Sort_unche:

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);
; 7542 :             return;
; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  00023	85 ff		 test	 edi, edi
  00025	0f 8e 97 00 00
	00		 jle	 $LN68@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);
; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);
; 7548 :             return;
; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0002b	51		 push	 ecx
  0002c	53		 push	 ebx
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00030	56		 push	 esi
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAHU?$less@X@std@@@std@@YA?AU?$pair@PAHPAH@0@PAH0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<int *,std::less<void> >

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions
; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  00037	8b 55 f8	 mov	 edx, DWORD PTR __Mid$1[ebp+4]
  0003a	8b c7		 mov	 eax, edi
  0003c	c1 f8 02	 sar	 eax, 2
  0003f	8b cb		 mov	 ecx, ebx
  00041	d1 ff		 sar	 edi, 1
  00043	83 c4 10	 add	 esp, 16			; 00000010H
  00046	03 f8		 add	 edi, eax
  00048	2b ca		 sub	 ecx, edx
  0004a	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  0004d	83 e1 fc	 and	 ecx, -4			; fffffffcH
  00050	2b c6		 sub	 eax, esi
  00052	83 e0 fc	 and	 eax, -4			; fffffffcH
  00055	3b c1		 cmp	 eax, ecx
  00057	8b 45 14	 mov	 eax, DWORD PTR __Pred$[ebp]
  0005a	50		 push	 eax
  0005b	57		 push	 edi
  0005c	7d 0f		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  0005e	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  00061	50		 push	 eax
  00062	56		 push	 esi
  00063	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >

; 7558 :             _First = _Mid.second;

  00068	8b 75 f8	 mov	 esi, DWORD PTR __Mid$1[ebp+4]

; 7559 :         } else { // loop on first half

  0006b	eb 0d		 jmp	 SHORT $LN91@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  0006d	53		 push	 ebx
  0006e	52		 push	 edx
  0006f	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >

; 7561 :             _Last = _Mid.first;

  00074	8b 5d f4	 mov	 ebx, DWORD PTR __Mid$1[ebp]
  00077	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
$LN91@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  0007a	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0007d	8b c3		 mov	 eax, ebx
  0007f	2b c6		 sub	 eax, esi
  00081	83 c4 10	 add	 esp, 16			; 00000010H
  00084	83 e0 fc	 and	 eax, -4			; fffffffcH
  00087	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0008c	7f 95		 jg	 SHORT $LL2@Sort_unche
$LN67@Sort_unche:

; 7412 :     if (_First != _Last) {

  0008e	3b f3		 cmp	 esi, ebx
  00090	0f 84 26 01 00
	00		 je	 $LN51@Sort_unche

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00096	8d 7e 04	 lea	 edi, DWORD PTR [esi+4]
  00099	3b fb		 cmp	 edi, ebx
  0009b	0f 84 1b 01 00
	00		 je	 $LN51@Sort_unche
$LL11@Sort_unche:

; 7414 :             _BidIt _Hole               = _Mid;
; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  000a1	8b 1f		 mov	 ebx, DWORD PTR [edi]
  000a3	8b d7		 mov	 edx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000a5	3b 1e		 cmp	 ebx, DWORD PTR [esi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  000a7	0f 8d e3 00 00
	00		 jge	 $LN18@Sort_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);

  000ad	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000b0	50		 push	 eax
  000b1	57		 push	 edi
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
  000b8	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7419 :                 *_First = _STD move(_Val);

  000bb	89 1e		 mov	 DWORD PTR [esi], ebx

; 7420 :             } else { // look for insertion point after first

  000bd	e9 ee 00 00 00	 jmp	 $LN19@Sort_unche
$LN68@Sort_unche:

; 6360 :     _Diff _Bottom = _Last - _First;

  000c2	2b de		 sub	 ebx, esi
  000c4	8b c3		 mov	 eax, ebx
  000c6	89 5d 0c	 mov	 DWORD PTR __Last$[ebp], ebx
  000c9	c1 f8 02	 sar	 eax, 2

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  000cc	8b f8		 mov	 edi, eax
  000ce	89 45 fc	 mov	 DWORD PTR __Bottom$1$[ebp], eax
  000d1	d1 ff		 sar	 edi, 1
  000d3	85 ff		 test	 edi, edi
  000d5	7e 79		 jle	 SHORT $LN31@Sort_unche
  000d7	48		 dec	 eax
  000d8	8b d8		 mov	 ebx, eax
  000da	89 45 f8	 mov	 DWORD PTR tv656[ebp], eax
  000dd	d1 fb		 sar	 ebx, 1
  000df	90		 npad	 1
$LL30@Sort_unche:

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;
; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  000e0	8b 44 be fc	 mov	 eax, DWORD PTR [esi+edi*4-4]
  000e4	4f		 dec	 edi
  000e5	89 45 08	 mov	 DWORD PTR __Val$1$[ebp], eax

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  000e8	8b d7		 mov	 edx, edi

; 6192 :     _Diff _Idx       = _Hole;

  000ea	8b cf		 mov	 ecx, edi

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen
; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  000ec	3b fb		 cmp	 edi, ebx
  000ee	7d 1e		 jge	 SHORT $LN36@Sort_unche
$LL35@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000f0	8b 44 ce 08	 mov	 eax, DWORD PTR [esi+ecx*8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6198 :         _Idx = 2 * _Idx + 2;

  000f4	8d 0c 4d 02 00
	00 00		 lea	 ecx, DWORD PTR [ecx*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000fb	3b 44 8e fc	 cmp	 eax, DWORD PTR [esi+ecx*4-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  000ff	7d 01		 jge	 SHORT $LN37@Sort_unche

; 6200 :             --_Idx;

  00101	49		 dec	 ecx
$LN37@Sort_unche:

; 6201 :         }
; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00102	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  00105	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 6203 :         _Hole             = _Idx;

  00108	8b d1		 mov	 edx, ecx
  0010a	3b cb		 cmp	 ecx, ebx
  0010c	7c e2		 jl	 SHORT $LL35@Sort_unche
$LN36@Sort_unche:

; 6204 :     }
; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  0010e	3b cb		 cmp	 ecx, ebx
  00110	75 11		 jne	 SHORT $LN38@Sort_unche
  00112	8b 45 fc	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
  00115	a8 01		 test	 al, 1
  00117	75 0a		 jne	 SHORT $LN38@Sort_unche

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  00119	8b 44 86 fc	 mov	 eax, DWORD PTR [esi+eax*4-4]
  0011d	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 6208 :         _Hole             = _Bottom - 1;

  00120	8b 55 f8	 mov	 edx, DWORD PTR tv656[ebp]
$LN38@Sort_unche:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00123	3b fa		 cmp	 edi, edx
  00125	7d 16		 jge	 SHORT $LN90@Sort_unche
$LL45@Sort_unche:

; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00127	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  0012a	d1 f8		 sar	 eax, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0012c	8b 0c 86	 mov	 ecx, DWORD PTR [esi+eax*4]
  0012f	3b 4d 08	 cmp	 ecx, DWORD PTR __Val$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00132	7d 09		 jge	 SHORT $LN90@Sort_unche

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen
; 6079 :         // move _Hole up to parent
; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00134	89 0c 96	 mov	 DWORD PTR [esi+edx*4], ecx

; 6081 :         _Hole             = _Idx;

  00137	8b d0		 mov	 edx, eax
  00139	3b f8		 cmp	 edi, eax
  0013b	7c ea		 jl	 SHORT $LL45@Sort_unche
$LN90@Sort_unche:

; 6082 :     }
; 6083 : 
; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  0013d	8b 45 08	 mov	 eax, DWORD PTR __Val$1$[ebp]
  00140	89 04 96	 mov	 DWORD PTR [esi+edx*4], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00143	85 ff		 test	 edi, edi
  00145	7f 99		 jg	 SHORT $LL30@Sort_unche
  00147	8b 5d 0c	 mov	 ebx, DWORD PTR __Last$[ebp]
  0014a	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  0014d	8b 45 fc	 mov	 eax, DWORD PTR __Bottom$1$[ebp]
$LN31@Sort_unche:

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00150	83 f8 02	 cmp	 eax, 2
  00153	7c 67		 jl	 SHORT $LN51@Sort_unche
$LL52@Sort_unche:

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00155	8b 44 1e fc	 mov	 eax, DWORD PTR [esi+ebx-4]
  00159	89 45 0c	 mov	 DWORD PTR __Val$2[ebp], eax

; 6219 :     *_Dest      = _STD move(*_First);

  0015c	8b 06		 mov	 eax, DWORD PTR [esi]
  0015e	89 44 1e fc	 mov	 DWORD PTR [esi+ebx-4], eax

; 6220 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6221 :     _Pop_heap_hole_by_index(

  00162	8d 45 0c	 lea	 eax, DWORD PTR __Val$2[ebp]
  00165	51		 push	 ecx
  00166	50		 push	 eax
  00167	8d 43 fc	 lea	 eax, DWORD PTR [ebx-4]
  0016a	c1 f8 02	 sar	 eax, 2
  0016d	50		 push	 eax
  0016e	6a 00		 push	 0
  00170	56		 push	 esi
  00171	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAHHU?$less@X@std@@@std@@YAXPAHHH$$QAHU?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<int *,int,std::less<void> >

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00176	8b 4d 14	 mov	 ecx, DWORD PTR __Pred$[ebp]
  00179	83 eb 04	 sub	 ebx, 4
  0017c	8b c3		 mov	 eax, ebx

; 6221 :     _Pop_heap_hole_by_index(

  0017e	83 c4 14	 add	 esp, 20			; 00000014H

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  00181	83 e0 fc	 and	 eax, -4			; fffffffcH
  00184	83 f8 08	 cmp	 eax, 8
  00187	7d cc		 jge	 SHORT $LL52@Sort_unche

; 7562 :         }
; 7563 :     }
; 7564 : }

  00189	5f		 pop	 edi
  0018a	5e		 pop	 esi
  0018b	5b		 pop	 ebx
  0018c	8b e5		 mov	 esp, ebp
  0018e	5d		 pop	 ebp
  0018f	c3		 ret	 0
$LN18@Sort_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00190	8b 4f fc	 mov	 ecx, DWORD PTR [edi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00193	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00196	3b d9		 cmp	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  00198	7d 14		 jge	 SHORT $LN15@Sort_unche
  0019a	66 0f 1f 44 00
	00		 npad	 6
$LL16@Sort_unche:

; 7422 :                     *_Hole = _STD move(*_Prev); // move hole down

  001a0	89 0a		 mov	 DWORD PTR [edx], ecx
  001a2	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001a4	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  001a7	83 e8 04	 sub	 eax, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001aa	3b d9		 cmp	 ebx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  001ac	7c f2		 jl	 SHORT $LL16@Sort_unche
$LN15@Sort_unche:

; 7423 :                 }
; 7424 : 
; 7425 :                 *_Hole = _STD move(_Val); // insert element in hole

  001ae	89 1a		 mov	 DWORD PTR [edx], ebx
$LN19@Sort_unche:

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  001b0	83 c7 04	 add	 edi, 4
  001b3	3b 7d 0c	 cmp	 edi, DWORD PTR __Last$[ebp]
  001b6	0f 85 e5 fe ff
	ff		 jne	 $LL11@Sort_unche
$LN51@Sort_unche:
  001bc	5f		 pop	 edi

; 7562 :         }
; 7563 :     }
; 7564 : }

  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<int *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);
; 1690 :     const auto _ULast = _Get_unwrapped(_Last);
; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>

; 1694 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	c1 ff 02	 sar	 edi, 2
  0001e	8d 04 bb	 lea	 eax, DWORD PTR [ebx+edi*4]
  00021	5f		 pop	 edi
  00022	5b		 pop	 ebx

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z
_TEXT	SEGMENT
tv435 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv434 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	c1 fb 02	 sar	 ebx, 2
  0001a	c1 f8 02	 sar	 eax, 2

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001d	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00022	0f 84 c4 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00028	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002b	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002e	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00030	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00033	c1 f9 02	 sar	 ecx, 2

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00036	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  0003b	8b d1		 mov	 edx, ecx
  0003d	d1 ea		 shr	 edx, 1
  0003f	2b c2		 sub	 eax, edx
  00041	3b c8		 cmp	 ecx, eax
  00043	76 3a		 jbe	 SHORT $LN12@Emplace_re

; 1621 :             return _Max; // geometric growth would overflow

  00045	b9 ff ff ff 3f	 mov	 ecx, 1073741823		; 3fffffffH
$LN20@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 65   :     return _Count * _Ty_size;

  0004a	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00051	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  00052	89 45 f4	 mov	 DWORD PTR tv435[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00055	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005d	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0005f	8d 04 9f	 lea	 eax, DWORD PTR [edi+ebx*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00062	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00065	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00068	89 45 fc	 mov	 DWORD PTR tv434[ebp], eax
  0006b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00072	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00074	3b da		 cmp	 ebx, edx
  00076	75 1b		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00078	8b 5d fc	 mov	 ebx, DWORD PTR tv434[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0007b	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  0007d	eb 2b		 jmp	 SHORT $LN5@Emplace_re
$LN12@Emplace_re:

; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007f	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  00082	8b cf		 mov	 ecx, edi
  00084	3b c7		 cmp	 eax, edi
  00086	0f 43 c8	 cmovae	 ecx, eax
  00089	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0008f	77 60		 ja	 SHORT $LN40@Emplace_re
  00091	eb b7		 jmp	 SHORT $LN20@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00093	56		 push	 esi
  00094	57		 push	 edi
  00095	53		 push	 ebx
  00096	51		 push	 ecx
  00097	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  0009c	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009f	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a1	8b 5d fc	 mov	 ebx, DWORD PTR tv434[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000a4	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a7	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
$LN5@Emplace_re:
  000aa	56		 push	 esi
  000ab	50		 push	 eax
  000ac	52		 push	 edx
  000ad	51		 push	 ecx
  000ae	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  000b3	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000b5	83 c4 10	 add	 esp, 16			; 00000010H

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  000b8	85 c9		 test	 ecx, ecx
  000ba	74 12		 je	 SHORT $LN33@Emplace_re

; 1677 :             _Destroy(_Myfirst, _Mylast);
; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000bc	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000bf	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c1	83 e0 fc	 and	 eax, -4			; fffffffcH
  000c4	50		 push	 eax
  000c5	51		 push	 ecx
  000c6	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000cb	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1682 :         _Mylast  = _Newvec + _Newsize;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  000d1	89 3e		 mov	 DWORD PTR [esi], edi
  000d3	8d 0c 87	 lea	 ecx, DWORD PTR [edi+eax*4]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000d6	8b c3		 mov	 eax, ebx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  000d8	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000db	8b 4d f4	 mov	 ecx, DWORD PTR tv435[ebp]
  000de	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000e0	5f		 pop	 edi

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000e1	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000e4	5e		 pop	 esi
  000e5	5b		 pop	 ebx

; 767  :     }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000ec	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f1	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f6	cc		 int	 3
??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z PROC ; std::_Const_cast<std::pair<float,long> const >, COMDAT

; 292  : auto _Const_cast(_Ty* _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 293  :     return const_cast<remove_const_t<_Ty>*>(_Ptr);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 294  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ENDP ; std::_Const_cast<std::pair<float,long> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z PROC ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >, COMDAT

; 6747 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00003	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6747 : _NODISCARD _CONSTEXPR20 _FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val) {

  00006	57		 push	 edi

; 6728 :     auto _UFirst                = _Get_unwrapped(_First);

  00007	8b 7d 0c	 mov	 edi, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  0000a	2b cf		 sub	 ecx, edi
  0000c	c1 f9 03	 sar	 ecx, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6731 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0000f	85 c9		 test	 ecx, ecx
  00011	7e 3f		 jle	 SHORT $LN5@upper_boun
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00013	53		 push	 ebx
  00014	8b 5d 14	 mov	 ebx, DWORD PTR __Val$[ebp]
  00017	56		 push	 esi
  00018	f3 0f 10 0b	 movss	 xmm1, DWORD PTR [ebx]
  0001c	0f 1f 40 00	 npad	 4
$LL4@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6732 :         _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00020	8b d1		 mov	 edx, ecx
  00022	d1 ea		 shr	 edx, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  00024	f3 0f 10 04 d7	 movss	 xmm0, DWORD PTR [edi+edx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1714 :         _Where += _Off;

  00029	8d 34 d7	 lea	 esi, DWORD PTR [edi+edx*8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 352  :     return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);

  0002c	0f 2f c1	 comiss	 xmm0, xmm1
  0002f	77 19		 ja	 SHORT $LN28@upper_boun
  00031	0f 2f c8	 comiss	 xmm1, xmm0
  00034	77 08		 ja	 SHORT $LN6@upper_boun
  00036	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  00039	3b 46 04	 cmp	 eax, DWORD PTR [esi+4]
  0003c	7c 0c		 jl	 SHORT $LN28@upper_boun
$LN6@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6738 :             _Count -= _Count2 + 1;

  0003e	83 c8 ff	 or	 eax, -1
  00041	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  00044	2b c2		 sub	 eax, edx
  00046	03 c8		 add	 ecx, eax
  00048	eb 02		 jmp	 SHORT $LN7@upper_boun
$LN28@upper_boun:

; 6733 :         const auto _UMid             = _STD next(_UFirst, _Count2);
; 6734 :         if (_Pred(_Val, *_UMid)) {
; 6735 :             _Count = _Count2;

  0004a	8b ca		 mov	 ecx, edx
$LN7@upper_boun:

; 6731 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0004c	85 c9		 test	 ecx, ecx
  0004e	7f d0		 jg	 SHORT $LL4@upper_boun
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
$LN5@upper_boun:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  00052	57		 push	 edi
  00053	e8 00 00 00 00	 call	 ??$_Refancy@PAU?$pair@MJ@std@@$0A@@std@@YAPAU?$pair@MJ@0@PAU10@@Z ; std::_Refancy<std::pair<float,long> *,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6743 :     return _First;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0005b	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6743 :     return _First;

  0005e	89 01		 mov	 DWORD PTR [ecx], eax

; 6748 :     // find first element that _Val is before
; 6749 :     return _STD upper_bound(_First, _Last, _Val, less<>{});

  00060	8b c1		 mov	 eax, ecx
  00062	5f		 pop	 edi

; 6750 : }

  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ENDP ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_patchnum$ = 8						; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone, COMDAT
; _this$ = ecx

; 683  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 684  : 	assert(NULL!=m_pTerrainPatchProxyList && "__HardwareTransformPatch_RenderPatchNone");
; 685  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00003	8b 45 08	 mov	 eax, DWORD PTR _patchnum$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00010	2b d0		 sub	 edx, eax
  00012	8b 46 64	 mov	 eax, DWORD PTR [esi+100]

; 686  : 	
; 687  : 	if (!pTerrainPatchProxy->isUsed())

  00015	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  0001a	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  0001d	74 3c		 je	 SHORT $LN1@HardwareTr

; 688  : 		return;
; 689  : 
; 690  : 	CGraphicVertexBuffer* pkVB=pTerrainPatchProxy->HardwareTransformPatch_GetVertexBufferPtr();

  0001f	e8 00 00 00 00	 call	 ?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr

; 691  : 	if (!pkVB)

  00024	85 c0		 test	 eax, eax
  00026	74 33		 je	 SHORT $LN1@HardwareTr

; 692  : 		return;
; 693  : 
; 694  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  00028	ff b6 a8 09 00
	00		 push	 DWORD PTR [esi+2472]
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00034	ff 70 04	 push	 DWORD PTR [eax+4]
  00037	6a 00		 push	 0
  00039	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 695  : 	STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  0003e	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  00042	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00048	50		 push	 eax
  00049	6a 00		 push	 0
  0004b	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  00051	6a 00		 push	 0
  00053	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00056	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN1@HardwareTr:
  0005b	5e		 pop	 esi

; 696  : }

  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z
_TEXT	SEGMENT
_iPrevRenderedSplatNum$1$ = -360			; size = 4
_sPatchNum$1$ = -356					; size = 4
_pTerrain$ = -352					; size = 4
_pTerrainPatchProxy$1$ = -348				; size = 4
$T1 = -348						; size = 4
_dwFogColor$1$ = -344					; size = 4
_ucTerrainNum$ = -344					; size = 1
_dwB$1$ = -340						; size = 4
_rTexture$1$ = -340					; size = 4
_dwG$1$ = -336						; size = 4
tv1222 = -336						; size = 4
_dwR$1$ = -332						; size = 4
_pTerrain$1$ = -332					; size = 4
_isFirst$1$ = -325					; size = 1
_matShadowTexTransform$2 = -324				; size = 64
_matSplatAlphaTexTransform$ = -260			; size = 64
_matTexTransform$ = -196				; size = 64
_matSplatColorTexTransform$ = -132			; size = 64
_matTiling$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
_patchnum$ = 8						; size = 4
_wPrimitiveCount$ = 12					; size = 2
_ePrimitiveType$ = 16					; size = 4
?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z PROC ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat, COMDAT
; _this$ = ecx

; 256  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 68 01 00
	00		 sub	 esp, 360		; 00000168H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _patchnum$[ebp]
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx

; 257  : 	assert(NULL!=m_pTerrainPatchProxyList && "__HardwareTransformPatch_RenderPatchSplat");
; 258  : 	CTerrainPatchProxy * pTerrainPatchProxy = &m_pTerrainPatchProxyList[patchnum];

  00019	8d 14 c5 00 00
	00 00		 lea	 edx, DWORD PTR [eax*8]
  00020	2b d0		 sub	 edx, eax
  00022	8b 46 64	 mov	 eax, DWORD PTR [esi+100]

; 259  : 	
; 260  : 	if (!pTerrainPatchProxy->isUsed())

  00025	80 7c 90 04 00	 cmp	 BYTE PTR [eax+edx*4+4], 0
  0002a	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0002d	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _pTerrainPatchProxy$1$[ebp], eax
  00033	0f 84 bc 07 00
	00		 je	 $LN1@HardwareTr

; 261  : 		return;
; 262  : 
; 263  : 	long sPatchNum = pTerrainPatchProxy->GetPatchNum();

  00039	0f bf 48 06	 movsx	 ecx, WORD PTR [eax+6]
  0003d	89 8d 9c fe ff
	ff		 mov	 DWORD PTR _sPatchNum$1$[ebp], ecx

; 264  : 	if (sPatchNum < 0)

  00043	85 c9		 test	 ecx, ecx
  00045	0f 88 aa 07 00
	00		 js	 $LN1@HardwareTr

; 265  : 		return;
; 266  : 
; 267  : 	BYTE ucTerrainNum = pTerrainPatchProxy->GetTerrainNum();

  0004b	8a 40 08	 mov	 al, BYTE PTR [eax+8]
  0004e	88 85 a8 fe ff
	ff		 mov	 BYTE PTR _ucTerrainNum$[ebp], al

; 268  : 	if (0xFF == ucTerrainNum)

  00054	3c ff		 cmp	 al, 255			; 000000ffH
  00056	0f 84 99 07 00
	00		 je	 $LN1@HardwareTr

; 269  : 		return;
; 270  : 
; 271  : 	CTerrain * pTerrain;
; 272  : 	if (!GetTerrainPointer(ucTerrainNum, &pTerrain))

  0005c	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR _pTerrain$[ebp]
  00062	8b ce		 mov	 ecx, esi
  00064	50		 push	 eax
  00065	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _ucTerrainNum$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetTerrainPointer@CMapOutdoor@@QAEHEPAPAVCTerrain@@@Z ; CMapOutdoor::GetTerrainPointer
  00070	85 c0		 test	 eax, eax
  00072	0f 84 7d 07 00
	00		 je	 $LN1@HardwareTr

; 273  : 		return;
; 274  : 
; 275  : 	DWORD dwFogColor;
; 276  : 	if (mc_pEnvironmentData)

  00078	53		 push	 ebx
  00079	57		 push	 edi
  0007a	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  0007d	85 ff		 test	 edi, edi
  0007f	0f 84 52 01 00
	00		 je	 $LN9@HardwareTr
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00085	f3 0f 10 87 2c
	01 00 00	 movss	 xmm0, DWORD PTR [edi+300]
  0008d	0f 57 c9	 xorps	 xmm1, xmm1
  00090	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00097	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  0009f	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  000a7	72 0c		 jb	 SHORT $LN27@HardwareTr
  000a9	c7 85 b4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  000b3	eb 37		 jmp	 SHORT $LN26@HardwareTr
$LN27@HardwareTr:
  000b5	0f 2f c8	 comiss	 xmm1, xmm0
  000b8	72 0c		 jb	 SHORT $LN25@HardwareTr
  000ba	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwR$1$[ebp], 0
  000c4	eb 26		 jmp	 SHORT $LN26@HardwareTr
$LN25@HardwareTr:
  000c6	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000ca	f3 0f 58 c4	 addss	 xmm0, xmm4
  000ce	e8 00 00 00 00	 call	 __ftoui3
  000d3	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  000db	0f 57 c9	 xorps	 xmm1, xmm1
  000de	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  000e6	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN26@HardwareTr:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  000ec	f3 0f 10 87 30
	01 00 00	 movss	 xmm0, DWORD PTR [edi+304]
  000f4	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000fb	72 0c		 jb	 SHORT $LN31@HardwareTr
  000fd	c7 85 b0 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwG$1$[ebp], 255 ; 000000ffH
  00107	eb 24		 jmp	 SHORT $LN30@HardwareTr
$LN31@HardwareTr:
  00109	0f 2f c8	 comiss	 xmm1, xmm0
  0010c	72 0c		 jb	 SHORT $LN29@HardwareTr
  0010e	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwG$1$[ebp], 0
  00118	eb 13		 jmp	 SHORT $LN30@HardwareTr
$LN29@HardwareTr:
  0011a	f3 0f 59 c3	 mulss	 xmm0, xmm3
  0011e	f3 0f 58 c4	 addss	 xmm0, xmm4
  00122	e8 00 00 00 00	 call	 __ftoui3
  00127	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _dwG$1$[ebp], eax
$LN30@HardwareTr:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0012d	f3 0f 10 87 34
	01 00 00	 movss	 xmm0, DWORD PTR [edi+308]
  00135	0f 57 c9	 xorps	 xmm1, xmm1
  00138	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0013f	72 0c		 jb	 SHORT $LN35@HardwareTr
  00141	c7 85 ac fe ff
	ff ff 00 00 00	 mov	 DWORD PTR _dwB$1$[ebp], 255 ; 000000ffH
  0014b	eb 2f		 jmp	 SHORT $LN34@HardwareTr
$LN35@HardwareTr:
  0014d	0f 2f c8	 comiss	 xmm1, xmm0
  00150	72 0c		 jb	 SHORT $LN33@HardwareTr
  00152	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwB$1$[ebp], 0
  0015c	eb 1e		 jmp	 SHORT $LN34@HardwareTr
$LN33@HardwareTr:
  0015e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00166	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0016e	e8 00 00 00 00	 call	 __ftoui3
  00173	89 85 ac fe ff
	ff		 mov	 DWORD PTR _dwB$1$[ebp], eax
  00179	0f 57 c9	 xorps	 xmm1, xmm1
$LN34@HardwareTr:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  0017c	f3 0f 10 87 38
	01 00 00	 movss	 xmm0, DWORD PTR [edi+312]
  00184	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0018b	72 07		 jb	 SHORT $LN39@HardwareTr
  0018d	bb ff 00 00 00	 mov	 ebx, 255		; 000000ffH
  00192	eb 20		 jmp	 SHORT $LN38@HardwareTr
$LN39@HardwareTr:
  00194	0f 2f c8	 comiss	 xmm1, xmm0
  00197	72 04		 jb	 SHORT $LN37@HardwareTr
  00199	33 db		 xor	 ebx, ebx
  0019b	eb 17		 jmp	 SHORT $LN38@HardwareTr
$LN37@HardwareTr:
  0019d	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  001a5	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  001ad	e8 00 00 00 00	 call	 __ftoui3
  001b2	8b d8		 mov	 ebx, eax
$LN38@HardwareTr:

; 935  : 
; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  001b4	c1 e3 08	 shl	 ebx, 8
  001b7	0b 9d b4 fe ff
	ff		 or	 ebx, DWORD PTR _dwR$1$[ebp]
  001bd	c1 e3 08	 shl	 ebx, 8
  001c0	0b 9d b0 fe ff
	ff		 or	 ebx, DWORD PTR _dwG$1$[ebp]
  001c6	c1 e3 08	 shl	 ebx, 8
  001c9	0b 9d ac fe ff
	ff		 or	 ebx, DWORD PTR _dwB$1$[ebp]
  001cf	89 9d a8 fe ff
	ff		 mov	 DWORD PTR _dwFogColor$1$[ebp], ebx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 277  : 		dwFogColor=mc_pEnvironmentData->FogColor;

  001d5	eb 0a		 jmp	 SHORT $LN10@HardwareTr
$LN9@HardwareTr:

; 278  : 	else
; 279  : 		dwFogColor=0xffffffff;

  001d7	c7 85 a8 fe ff
	ff ff ff ff ff	 mov	 DWORD PTR _dwFogColor$1$[ebp], -1
$LN10@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 93   : 			*usCoordY = m_wY;

  001e1	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 289  : 	D3DXMatrixMultiply(&matTexTransform, &m_matViewInverse, &m_matWorldForCommonUse);

  001e7	8d 9e 88 07 00
	00		 lea	 ebx, DWORD PTR [esi+1928]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\AreaTerrain.h

; 93   : 			*usCoordY = m_wY;

  001ed	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _pTerrain$1$[ebp], eax
  001f3	0f b7 88 6e a5
	06 00		 movzx	 ecx, WORD PTR [eax+435566]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 287  : 	m_matWorldForCommonUse._41 = -(float) (wCoordX * CTerrainImpl::TERRAIN_XSIZE);

  001fa	0f b7 80 6c a5
	06 00		 movzx	 eax, WORD PTR [eax+435564]
  00201	69 c0 00 9c ff
	ff		 imul	 eax, eax, -25600
  00207	66 0f 6e c0	 movd	 xmm0, eax

; 288  : 	m_matWorldForCommonUse._42 = (float) (wCoordY * CTerrainImpl::TERRAIN_YSIZE);

  0020b	8b c1		 mov	 eax, ecx
  0020d	69 c0 00 64 00
	00		 imul	 eax, eax, 25600
  00213	0f 5b c0	 cvtdq2ps xmm0, xmm0
  00216	f3 0f 11 86 78
	07 00 00	 movss	 DWORD PTR [esi+1912], xmm0
  0021e	66 0f 6e c0	 movd	 xmm0, eax

; 289  : 	D3DXMatrixMultiply(&matTexTransform, &m_matViewInverse, &m_matWorldForCommonUse);

  00222	8d 86 48 07 00
	00		 lea	 eax, DWORD PTR [esi+1864]
  00228	0f 5b c0	 cvtdq2ps xmm0, xmm0
  0022b	50		 push	 eax
  0022c	53		 push	 ebx
  0022d	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  00233	50		 push	 eax
  00234	f3 0f 11 86 7c
	07 00 00	 movss	 DWORD PTR [esi+1916], xmm0
  0023c	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 290  : 	D3DXMatrixMultiply(&matSplatAlphaTexTransform, &matTexTransform, &m_matSplatAlpha);

  00241	8d 86 c8 07 00
	00		 lea	 eax, DWORD PTR [esi+1992]
  00247	50		 push	 eax
  00248	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  0024e	50		 push	 eax
  0024f	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matSplatAlphaTexTransform$[ebp]
  00255	50		 push	 eax
  00256	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 291  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &matSplatAlphaTexTransform);

  0025b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00261	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _matSplatAlphaTexTransform$[ebp]
  00267	50		 push	 eax
  00268	6a 11		 push	 17			; 00000011H
  0026a	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 292  : 
; 293  : 	D3DXMATRIX matTiling;
; 294  : 	D3DXMatrixScaling(&matTiling, 1.0f/640.0f, -1.0f/640.0f, 0.0f);

  0026f	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00272	8d 45 bc	 lea	 eax, DWORD PTR _matTiling$[ebp]
  00275	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR [esp+8], 0
  0027d	c7 44 24 04 cd
	cc cc ba	 mov	 DWORD PTR [esp+4], -1160983347 ; bacccccdH
  00285	c7 04 24 cd cc
	cc 3a		 mov	 DWORD PTR [esp], 986500301 ; 3acccccdH
  0028c	50		 push	 eax
  0028d	e8 00 00 00 00	 call	 _D3DXMatrixScaling@16

; 295  : 	matTiling._41=0.0f;
; 296  : 	matTiling._42=0.0f;
; 297  : 	
; 298  : 	D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &matTiling);

  00292	8d 45 bc	 lea	 eax, DWORD PTR _matTiling$[ebp]
  00295	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _matTiling$[ebp+48], 0
  0029c	50		 push	 eax
  0029d	53		 push	 ebx
  0029e	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  002a4	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _matTiling$[ebp+52], 0
  002ab	50		 push	 eax
  002ac	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 299  : 	STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);

  002b1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002b7	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  002bd	50		 push	 eax
  002be	6a 10		 push	 16			; 00000010H
  002c0	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 300  : 					
; 301  : 	CGraphicVertexBuffer* pkVB=pTerrainPatchProxy->HardwareTransformPatch_GetVertexBufferPtr();

  002c5	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR _pTerrainPatchProxy$1$[ebp]
  002cb	e8 00 00 00 00	 call	 ?HardwareTransformPatch_GetVertexBufferPtr@CTerrainPatchProxy@@QAEPAVCGraphicVertexBuffer@@XZ ; CTerrainPatchProxy::HardwareTransformPatch_GetVertexBufferPtr

; 302  : 	if (!pkVB)

  002d0	85 c0		 test	 eax, eax
  002d2	0f 84 1b 05 00
	00		 je	 $LN98@HardwareTr

; 303  : 		return;
; 304  : 
; 305  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  002d8	ff b6 a8 09 00
	00		 push	 DWORD PTR [esi+2472]
  002de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002e4	ff 70 04	 push	 DWORD PTR [eax+4]
  002e7	6a 00		 push	 0
  002e9	e8 00 00 00 00	 call	 ?SetStreamSource@CStateManager@@QAEXIPAUIDirect3DVertexBuffer8@@I@Z ; CStateManager::SetStreamSource

; 306  : 	
; 307  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  002ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002f4	6a 00		 push	 0
  002f6	68 89 00 00 00	 push	 137			; 00000089H
  002fb	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 309  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  00300	8b 9e 88 09 00
	00		 mov	 ebx, DWORD PTR [esi+2440]

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  00306	bf 01 00 00 00	 mov	 edi, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  0030b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 309  : 	int iPrevRenderedSplatNum=m_iRenderedSplatNum;

  00311	89 9d 98 fe ff
	ff		 mov	 DWORD PTR _iPrevRenderedSplatNum$1$[ebp], ebx

; 310  : 
; 311  : #ifdef WORLD_EDITOR
; 312  : 
; 313  : 	int nRenderTextureCount = 0;
; 314  : 
; 315  : //	if (!m_bShowEntirePatchTextureCount && !(GetAsyncKeyState(VK_LCONTROL) & 0x8000) )
; 316  : 	if (1)
; 317  : 	{
; 318  : 		for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 319  : 		{
; 320  : 			TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 321  : 			
; 322  : 			if (!rSplat.Active)
; 323  : 				continue;
; 324  : 			
; 325  : 			if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)
; 326  : 				continue;
; 327  : 
; 328  : 			++nRenderTextureCount;
; 329  : 		}
; 330  : 		
; 331  : 		DWORD dwTextureFactor = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 332  : 		
; 333  : 		int TextureCountThreshold = 8;
; 334  : 		DWORD dwTFactor = 0xFFFFFFFF;
; 335  : 		
; 336  : 		if (GetAsyncKeyState(VK_LSHIFT) & 0x8000)
; 337  : 		{
; 338  : 			if (GetAsyncKeyState(VK_1) & 0x8000)
; 339  : 			{
; 340  : 				TextureCountThreshold = 2;
; 341  : 				dwTFactor = 0xFF0000FF;
; 342  : 			}
; 343  : 			else if (GetAsyncKeyState(VK_2) & 0x8000)
; 344  : 			{
; 345  : 				TextureCountThreshold = 3;
; 346  : 				dwTFactor = 0xFF00FF00;
; 347  : 			}
; 348  : 			else if (GetAsyncKeyState(VK_3) & 0x8000)
; 349  : 			{
; 350  : 				TextureCountThreshold = 4;
; 351  : 				dwTFactor = 0xFF00FFFF;
; 352  : 			}
; 353  : 			else if (GetAsyncKeyState(VK_4) & 0x8000)
; 354  : 			{
; 355  : 				TextureCountThreshold = 5;
; 356  : 				dwTFactor = 0xFFFF0000;
; 357  : 			}
; 358  : 			else if (GetAsyncKeyState(VK_5) & 0x8000)
; 359  : 			{
; 360  : 				TextureCountThreshold = 6;
; 361  : 				dwTFactor = 0xFFFFFF00;
; 362  : 			}
; 363  : 			else if (GetAsyncKeyState(VK_6) & 0x8000)
; 364  : 			{
; 365  : 				TextureCountThreshold = 7;
; 366  : 				dwTFactor = 0xFFFF00ff;
; 367  : 			}
; 368  : 			
; 369  : 		}
; 370  : 
; 371  : 		if (nRenderTextureCount>=TextureCountThreshold)
; 372  : 		{
; 373  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTFactor);
; 374  : 			STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 375  : 			STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 376  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 377  : 			STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactor);
; 378  : 			STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 379  : 			STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 380  : 		}
; 381  : 		else
; 382  : 		{
; 383  : 			// 0 
; 384  : 			if ( 0 < rTerrainSplatPatch.PatchTileCount[sPatchNum][0] )
; 385  : 			{
; 386  : 				DWORD dwTextureFactorFor0Texture = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 387  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFF88FF88);
; 388  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 389  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 390  : 				STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 391  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactorFor0Texture);
; 392  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 393  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 394  : 			}
; 395  : 
; 396  : 			for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 397  : 			{
; 398  : 				TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 399  : 				
; 400  : 				if (!rSplat.Active)
; 401  : 					continue;
; 402  : 				
; 403  : 				DWORD dwTextureCount = rTerrainSplatPatch.PatchTileCount[sPatchNum][j];
; 404  : 				if (dwTextureCount == 0)
; 405  : 					continue;
; 406  : 				
; 407  : 				DWORD dwTextureFactorForTextureBalance = 0xFFFFFFFF;
; 408  : 
; 409  : 				if (!(GetAsyncKeyState(VK_LSHIFT) & 0x8000))
; 410  : 				{
; 411  : 					const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 412  : 					
; 413  : 					D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 414  : 					STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 415  : 					
; 416  : 					STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 417  : 					STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 418  : 					STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 419  : 				}
; 420  : 				else
; 421  : 				{
; 422  : 					if (dwTextureCount < 71)
; 423  : 					{
; 424  : 						dwTextureFactorForTextureBalance = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 425  : 						if (dwTextureCount < 51)
; 426  : 							STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFFFF0000);
; 427  : 						else
; 428  : 							STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, 0xFF0000FF);
; 429  : 						STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 430  : 						STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 431  : 						STATEMANAGER.SetTexture(0, NULL);
; 432  : 					}
; 433  : 					else
; 434  : 					{
; 435  : 						const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 436  : 						
; 437  : 						D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 438  : 						STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 439  : 						
; 440  : 						STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 441  : 					}
; 442  : 					STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 443  : 					STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 444  : 					if (dwTextureCount < 71)
; 445  : 					{
; 446  : 						STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactorForTextureBalance);
; 447  : 						STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 448  : 						STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 449  : 					}
; 450  : 				}
; 451  : 				
; 452  : 				std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);
; 453  : 				if (aIterator == m_RenderedTextureNumVector.end())
; 454  : 					m_RenderedTextureNumVector.push_back(j);
; 455  : 				++m_iRenderedSplatNum;
; 456  : 				if (m_iRenderedSplatNum >= m_iSplatLimit)
; 457  : 					break;
; 458  : 			}	
; 459  : 		}
; 460  : 	}
; 461  : 	else
; 462  : 	{
; 463  : 		int TextureCountThreshold = 6;
; 464  : 		DWORD dwTFactor = 0xFFFF00FF;
; 465  : 		
; 466  : 		if (GetAsyncKeyState(VK_LSHIFT) & 0x8000)
; 467  : 		{
; 468  : 			if (GetAsyncKeyState(VK_1) & 0x8000)
; 469  : 			{
; 470  : 				TextureCountThreshold = 1;
; 471  : 				dwTFactor = 0xFF0000FF;
; 472  : 			}
; 473  : 			else if (GetAsyncKeyState(VK_2) & 0x8000)
; 474  : 			{
; 475  : 				TextureCountThreshold = 2;
; 476  : 				dwTFactor = 0xFF00FF00;
; 477  : 			}
; 478  : 			else if (GetAsyncKeyState(VK_3) & 0x8000)
; 479  : 			{
; 480  : 				TextureCountThreshold = 3;
; 481  : 				dwTFactor = 0xFF00FFFF;
; 482  : 			}
; 483  : 			else if (GetAsyncKeyState(VK_4) & 0x8000)
; 484  : 			{
; 485  : 				TextureCountThreshold = 4;
; 486  : 				dwTFactor = 0xFFFF0000;
; 487  : 			}
; 488  : 			else if (GetAsyncKeyState(VK_5) & 0x8000)
; 489  : 			{
; 490  : 				TextureCountThreshold = 5;
; 491  : 				dwTFactor = 0xFFFFFF00;
; 492  : 			}
; 493  : 		}
; 494  : 		
; 495  : 		for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)
; 496  : 		{
; 497  : 			TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 498  : 			
; 499  : 			if (!rSplat.Active)
; 500  : 				continue;
; 501  : 			
; 502  : 			if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)
; 503  : 				continue;
; 504  : 			
; 505  : 			DWORD dwTextureFactor;
; 506  : 			
; 507  : 			if (nRenderTextureCount>=TextureCountThreshold)
; 508  : 			{
; 509  : 				dwTextureFactor = STATEMANAGER.GetRenderState(D3DRS_TEXTUREFACTOR);
; 510  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTFactor);
; 511  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
; 512  : 				STATEMANAGER.SaveTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
; 513  : 				STATEMANAGER.SetTexture(0, NULL);
; 514  : 			}
; 515  : 			else
; 516  : 			{
; 517  : 				const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);
; 518  : 				
; 519  : 				D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 520  : 				STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 521  : 				
; 522  : 				STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);
; 523  : 			}
; 524  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 525  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 526  : 			if (nRenderTextureCount>=TextureCountThreshold)
; 527  : 			{
; 528  : 				STATEMANAGER.SetRenderState(D3DRS_TEXTUREFACTOR, dwTextureFactor);
; 529  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLORARG1);
; 530  : 				STATEMANAGER.RestoreTextureStageState(0, D3DTSS_COLOROP);
; 531  : 			}
; 532  : 			
; 533  : 			++nRenderTextureCount;
; 534  : 			
; 535  : 			std::vector<int>::iterator aIterator = std::find(m_RenderedTextureNumVector.begin(), m_RenderedTextureNumVector.end(), (int)j);
; 536  : 			if (aIterator == m_RenderedTextureNumVector.end())
; 537  : 				m_RenderedTextureNumVector.push_back(j);
; 538  : 			++m_iRenderedSplatNum;
; 539  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)
; 540  : 				break;
; 541  : 			
; 542  : 		}	
; 543  : 	}
; 544  : 
; 545  : #else
; 546  : 	bool isFirst=true;

  00317	c6 85 bb fe ff
	ff 01		 mov	 BYTE PTR _isFirst$1$[ebp], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  0031e	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  00323	3b c7		 cmp	 eax, edi
  00325	0f 86 c1 01 00
	00		 jbe	 $LN89@HardwareTr

; 303  : 		return;
; 304  : 
; 305  : 	STATEMANAGER.SetStreamSource(0, pkVB->GetD3DVertexBuffer(), m_iPatchTerrainVertexSize);

  0032b	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _pTerrain$1$[ebp]
  00331	8d 99 50 95 04
	00		 lea	 ebx, DWORD PTR [ecx+300368]
  00337	89 9d b0 fe ff
	ff		 mov	 DWORD PTR tv1222[ebp], ebx
  0033d	0f 1f 00	 npad	 3
$LL4@HardwareTr:

; 548  : 	{
; 549  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[j];
; 550  : 		
; 551  : 		if (!rSplat.Active)

  00340	83 7b f8 00	 cmp	 DWORD PTR [ebx-8], 0
  00344	0f 84 79 01 00
	00		 je	 $LN2@HardwareTr

; 552  : 			continue;
; 553  : 		
; 554  : 		if (rTerrainSplatPatch.PatchTileCount[sPatchNum][j] == 0)

  0034a	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _sPatchNum$1$[ebp]
  00350	40		 inc	 eax
  00351	c1 e0 08	 shl	 eax, 8
  00354	03 c7		 add	 eax, edi
  00356	83 bc 81 3c 91
	03 00 00	 cmp	 DWORD PTR [ecx+eax*4+233788], 0
  0035e	0f 84 5f 01 00
	00		 je	 $LN2@HardwareTr

; 555  : 			continue;
; 556  : 		
; 557  : 		const TTerrainTexture & rTexture = m_TextureSet.GetTexture(j);

  00364	57		 push	 edi
  00365	8d 8e 7c 02 00
	00		 lea	 ecx, DWORD PTR [esi+636]
  0036b	e8 00 00 00 00	 call	 ?GetTexture@CTextureSet@@QAEAAUSTerrainTexture@@K@Z ; CTextureSet::GetTexture
  00370	89 85 ac fe ff
	ff		 mov	 DWORD PTR _rTexture$1$[ebp], eax

; 558  : 		
; 559  : 		D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);

  00376	8d 48 54	 lea	 ecx, DWORD PTR [eax+84]
  00379	51		 push	 ecx
  0037a	8d 86 88 07 00
	00		 lea	 eax, DWORD PTR [esi+1928]
  00380	50		 push	 eax
  00381	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  00387	50		 push	 eax
  00388	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 560  : 		STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);

  0038d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00393	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _matSplatColorTexTransform$[ebp]
  00399	50		 push	 eax
  0039a	6a 10		 push	 16			; 00000010H
  0039c	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 561  : 		if (isFirst)

  003a1	80 bd bb fe ff
	ff 00		 cmp	 BYTE PTR _isFirst$1$[ebp], 0
  003a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ae	74 67		 je	 SHORT $LN14@HardwareTr

; 562  : 		{
; 563  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  003b0	6a 01		 push	 1
  003b2	6a 04		 push	 4
  003b4	6a 01		 push	 1
  003b6	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 564  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  003bb	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _rTexture$1$[ebp]
  003c1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003c7	ff 70 18	 push	 DWORD PTR [eax+24]
  003ca	6a 00		 push	 0
  003cc	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 565  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  003d1	ff 33		 push	 DWORD PTR [ebx]
  003d3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003d9	6a 01		 push	 1
  003db	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 566  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  003e0	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  003e4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  003ea	50		 push	 eax
  003eb	6a 00		 push	 0
  003ed	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  003f3	6a 00		 push	 0
  003f5	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  003f8	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 567  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  003fd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00403	6a 02		 push	 2
  00405	6a 04		 push	 4
  00407	6a 01		 push	 1
  00409	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 568  : 			isFirst=false;

  0040e	c6 85 bb fe ff
	ff 00		 mov	 BYTE PTR _isFirst$1$[ebp], 0

; 569  : 		}

  00415	eb 3c		 jmp	 SHORT $LN15@HardwareTr
$LN14@HardwareTr:

; 570  : 		else
; 571  : 		{
; 572  : 			STATEMANAGER.SetTexture(0, rTexture.pd3dTexture);

  00417	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _rTexture$1$[ebp]
  0041d	ff 70 18	 push	 DWORD PTR [eax+24]
  00420	6a 00		 push	 0
  00422	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 573  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);

  00427	ff 33		 push	 DWORD PTR [ebx]
  00429	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0042f	6a 01		 push	 1
  00431	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 574  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);			

  00436	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  0043a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00440	50		 push	 eax
  00441	6a 00		 push	 0
  00443	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  00449	6a 00		 push	 0
  0044b	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0044e	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN15@HardwareTr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00453	8b 9e 94 09 00
	00		 mov	 ebx, DWORD PTR [esi+2452]
  00459	8b 86 90 09 00
	00		 mov	 eax, DWORD PTR [esi+2448]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5439 :     for (; _First != _Last; ++_First) {

  0045f	3b c3		 cmp	 eax, ebx
  00461	74 0b		 je	 SHORT $LN96@HardwareTr
$LL64@HardwareTr:

; 5440 :         if (*_First == _Val) {

  00463	39 38		 cmp	 DWORD PTR [eax], edi
  00465	74 07		 je	 SHORT $LN96@HardwareTr

; 5439 :     for (; _First != _Last; ++_First) {

  00467	83 c0 04	 add	 eax, 4
  0046a	3b c3		 cmp	 eax, ebx
  0046c	75 f5		 jne	 SHORT $LL64@HardwareTr
$LN96@HardwareTr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0046e	50		 push	 eax
  0046f	e8 00 00 00 00	 call	 ??$_Refancy@PAH$0A@@std@@YAPAHPAH@Z ; std::_Refancy<int *,0>
  00474	83 c4 04	 add	 esp, 4
  00477	3b c3		 cmp	 eax, ebx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 578  : 		if (aIterator == m_RenderedTextureNumVector.end())

  00479	75 2e		 jne	 SHORT $LN81@HardwareTr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  0047b	8b cb		 mov	 ecx, ebx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 579  : 			m_RenderedTextureNumVector.push_back(j);

  0047d	89 bd a4 fe ff
	ff		 mov	 DWORD PTR $T1[ebp], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00483	3b 8e 98 09 00
	00		 cmp	 ecx, DWORD PTR [esi+2456]
  00489	74 0b		 je	 SHORT $LN82@HardwareTr

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0048b	89 39		 mov	 DWORD PTR [ecx], edi

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  0048d	83 86 94 09 00
	00 04		 add	 DWORD PTR [esi+2452], 4

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00494	eb 13		 jmp	 SHORT $LN81@HardwareTr
$LN82@HardwareTr:

; 706  :         }
; 707  : 
; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  00496	8d 95 a4 fe ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  0049c	52		 push	 edx
  0049d	51		 push	 ecx
  0049e	8d 8e 90 09 00
	00		 lea	 ecx, DWORD PTR [esi+2448]
  004a4	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABH@?$vector@HV?$allocator@H@std@@@std@@QAEPAHQAHABH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int const &>
$LN81@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 580  : 		++m_iRenderedSplatNum;

  004a9	ff 86 88 09 00
	00		 inc	 DWORD PTR [esi+2440]
  004af	8b 86 88 09 00
	00		 mov	 eax, DWORD PTR [esi+2440]

; 581  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  004b5	3b 86 9c 09 00
	00		 cmp	 eax, DWORD PTR [esi+2460]
  004bb	7d 29		 jge	 SHORT $LN97@HardwareTr
  004bd	8b 9d b0 fe ff
	ff		 mov	 ebx, DWORD PTR tv1222[ebp]
$LN2@HardwareTr:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  004c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pTextureSet@CTerrainImpl@@1PAVCTextureSet@@A ; CTerrainImpl::ms_pTextureSet
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  004c9	83 c3 0c	 add	 ebx, 12			; 0000000cH
  004cc	47		 inc	 edi
  004cd	89 9d b0 fe ff
	ff		 mov	 DWORD PTR tv1222[ebp], ebx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\PRTerrainLib\Terrain.h

; 87   : 		DWORD					GetNumTextures()						{ return ms_pTextureSet->GetTextureCount(); }

  004d3	e8 00 00 00 00	 call	 ?GetTextureCount@CTextureSet@@QAEKXZ ; CTextureSet::GetTextureCount
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 547  : 	for (DWORD j = 1; j < pTerrain->GetNumTextures(); ++j)

  004d8	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR _pTerrain$1$[ebp]
  004de	3b f8		 cmp	 edi, eax
  004e0	0f 82 5a fe ff
	ff		 jb	 $LL4@HardwareTr
$LN97@HardwareTr:
  004e6	8b 9d 98 fe ff
	ff		 mov	 ebx, DWORD PTR _iPrevRenderedSplatNum$1$[ebp]
$LN89@HardwareTr:

; 582  : 			break;
; 583  : 		
; 584  : 	}
; 585  : 
; 586  : /*
; 587  : 	if (GetAsyncKeyState(VK_CAPITAL) & 0x8000)
; 588  : 	{
; 589  : 		TTerainSplat & rSplat = rTerrainSplatPatch.Splats[200];
; 590  : 		
; 591  : 		if (rSplat.Active)
; 592  : 		{
; 593  : 			const TTerrainTexture & rTexture = m_TextureSet.GetTexture(1);
; 594  : 			
; 595  : 			D3DXMatrixMultiply(&matSplatColorTexTransform, &m_matViewInverse, &rTexture.m_matTransform);
; 596  : 			STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matSplatColorTexTransform);
; 597  : 			
; 598  : 			STATEMANAGER.SetTexture(0, NULL);
; 599  : 			STATEMANAGER.SetTexture(1, rSplat.pd3dTexture);
; 600  : 			STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);
; 601  : 		}
; 602  : 	}
; 603  : */
; 604  : #endif
; 605  : 
; 606  : 	// 
; 607  : 	if (m_bDrawShadow)

  004ec	80 be 31 01 00
	00 00		 cmp	 BYTE PTR [esi+305], 0
  004f3	0f 84 e3 02 00
	00		 je	 $LN18@HardwareTr

; 608  : 	{
; 609  : 		STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  004f9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004ff	6a 01		 push	 1
  00501	68 89 00 00 00	 push	 137			; 00000089H
  00506	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 610  : 		
; 611  : 		STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, 0xFFFFFFFF);

  0050b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00511	6a ff		 push	 -1
  00513	6a 22		 push	 34			; 00000022H
  00515	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 612  : 		STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);

  0051a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00520	6a 01		 push	 1
  00522	6a 13		 push	 19			; 00000013H
  00524	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 613  : 		STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

  00529	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0052f	6a 03		 push	 3
  00531	6a 14		 push	 20			; 00000014H
  00533	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 614  : 				
; 615  : 		D3DXMATRIX matShadowTexTransform;
; 616  : 		D3DXMatrixMultiply(&matShadowTexTransform, &matTexTransform, &m_matStaticShadow);

  00538	8d 86 08 08 00
	00		 lea	 eax, DWORD PTR [esi+2056]
  0053e	50		 push	 eax
  0053f	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _matTexTransform$[ebp]
  00545	50		 push	 eax
  00546	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _matShadowTexTransform$2[ebp]
  0054c	50		 push	 eax
  0054d	e8 00 00 00 00	 call	 _D3DXMatrixMultiply@12

; 617  : 
; 618  : 		STATEMANAGER.SetTransform(D3DTS_TEXTURE0, &matShadowTexTransform);

  00552	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00558	8d 85 bc fe ff
	ff		 lea	 eax, DWORD PTR _matShadowTexTransform$2[ebp]
  0055e	50		 push	 eax
  0055f	6a 10		 push	 16			; 00000010H
  00561	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 619  :  		STATEMANAGER.SetTexture(0, pTerrain->GetShadowTexture());		

  00566	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _pTerrain$[ebp]
  0056c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00572	ff b0 44 a5 04
	00		 push	 DWORD PTR [eax+304452]
  00578	6a 00		 push	 0
  0057a	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 620  : 		
; 621  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0057f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00585	6a 02		 push	 2
  00587	6a 02		 push	 2
  00589	6a 00		 push	 0
  0058b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 622  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00590	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00596	6a 01		 push	 1
  00598	6a 03		 push	 3
  0059a	6a 00		 push	 0
  0059c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 623  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  005a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005a7	6a 04		 push	 4
  005a9	6a 01		 push	 1
  005ab	6a 00		 push	 0
  005ad	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 624  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  005b2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005b8	6a 02		 push	 2
  005ba	6a 05		 push	 5
  005bc	6a 00		 push	 0
  005be	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 625  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_CURRENT);

  005c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005c9	6a 01		 push	 1
  005cb	6a 06		 push	 6
  005cd	6a 00		 push	 0
  005cf	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 626  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  005d4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005da	6a 01		 push	 1
  005dc	6a 04		 push	 4
  005de	6a 00		 push	 0
  005e0	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 627  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,	D3DTADDRESS_CLAMP);

  005e5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005eb	6a 03		 push	 3
  005ed	6a 0d		 push	 13			; 0000000dH
  005ef	6a 00		 push	 0
  005f1	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 628  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,	D3DTADDRESS_CLAMP);	

  005f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005fc	6a 03		 push	 3
  005fe	6a 0e		 push	 14			; 0000000eH
  00600	6a 00		 push	 0
  00602	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 629  : 
; 630  : 		if (m_bDrawChrShadow)

  00607	80 be 32 01 00
	00 00		 cmp	 BYTE PTR [esi+306], 0
  0060e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00614	0f 84 89 00 00
	00		 je	 $LN19@HardwareTr

; 631  : 		{
; 632  : 			STATEMANAGER.SetTransform(D3DTS_TEXTURE1, &m_matDynamicShadow);

  0061a	8d 86 48 08 00
	00		 lea	 eax, DWORD PTR [esi+2120]
  00620	50		 push	 eax
  00621	6a 11		 push	 17			; 00000011H
  00623	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 633  : 
; 634  :  			STATEMANAGER.SetTexture(1, m_lpCharacterShadowMapTexture);

  00628	ff b6 d4 01 00
	00		 push	 DWORD PTR [esi+468]
  0062e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00634	6a 01		 push	 1
  00636	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 635  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  0063b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00641	6a 02		 push	 2
  00643	6a 02		 push	 2
  00645	6a 01		 push	 1
  00647	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 636  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG2, D3DTA_CURRENT);

  0064c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00652	6a 01		 push	 1
  00654	6a 03		 push	 3
  00656	6a 01		 push	 1
  00658	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 637  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  0065d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00663	6a 04		 push	 4
  00665	6a 01		 push	 1
  00667	6a 01		 push	 1
  00669	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 638  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  0066e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00674	6a 01		 push	 1
  00676	6a 04		 push	 4
  00678	6a 01		 push	 1
  0067a	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 639  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU, D3DTADDRESS_CLAMP);

  0067f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00685	6a 03		 push	 3
  00687	6a 0d		 push	 13			; 0000000dH
  00689	6a 01		 push	 1
  0068b	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 640  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV, D3DTADDRESS_CLAMP);

  00690	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00696	6a 03		 push	 3
  00698	6a 0e		 push	 14			; 0000000eH
  0069a	6a 01		 push	 1
  0069c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 641  : 		}		

  006a1	eb 09		 jmp	 SHORT $LN20@HardwareTr
$LN19@HardwareTr:

; 642  : 		else
; 643  : 		{
; 644  : 			STATEMANAGER.SetTexture(1, NULL);			

  006a3	6a 00		 push	 0
  006a5	6a 01		 push	 1
  006a7	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture
$LN20@HardwareTr:

; 645  : 		}
; 646  : 		
; 647  : 		ms_faceCount += wPrimitiveCount;

  006ac	0f b7 45 0c	 movzx	 eax, WORD PTR _wPrimitiveCount$[ebp]
  006b0	01 05 00 00 00
	00		 add	 DWORD PTR ?ms_faceCount@CGraphicBase@@1KA, eax ; CGraphicBase::ms_faceCount

; 648  : 		STATEMANAGER.DrawIndexedPrimitive(ePrimitiveType, 0, m_iPatchTerrainVertexCount, 0, wPrimitiveCount);

  006b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006bc	50		 push	 eax
  006bd	6a 00		 push	 0
  006bf	ff b6 a0 09 00
	00		 push	 DWORD PTR [esi+2464]
  006c5	6a 00		 push	 0
  006c7	ff 75 10	 push	 DWORD PTR _ePrimitiveType$[ebp]
  006ca	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive

; 649  :   		++m_iRenderedSplatNum;

  006cf	ff 86 88 09 00
	00		 inc	 DWORD PTR [esi+2440]

; 650  : 
; 651  : 		if (m_bDrawChrShadow)

  006d5	80 be 32 01 00
	00 00		 cmp	 BYTE PTR [esi+306], 0
  006dc	74 44		 je	 SHORT $LN21@HardwareTr

; 652  : 		{
; 653  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  006de	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006e4	6a 01		 push	 1
  006e6	6a 02		 push	 2
  006e8	6a 01		 push	 1
  006ea	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 654  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  006ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  006f5	6a 02		 push	 2
  006f7	6a 01		 push	 1
  006f9	6a 01		 push	 1
  006fb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 655  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00700	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00706	6a 02		 push	 2
  00708	6a 05		 push	 5
  0070a	6a 01		 push	 1
  0070c	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 656  : 			STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00711	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00717	6a 02		 push	 2
  00719	6a 04		 push	 4
  0071b	6a 01		 push	 1
  0071d	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState
$LN21@HardwareTr:

; 657  : 		}			
; 658  : 
; 659  :  		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00722	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00728	6a 02		 push	 2
  0072a	6a 02		 push	 2
  0072c	6a 00		 push	 0
  0072e	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 660  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00733	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00739	6a 01		 push	 1
  0073b	6a 03		 push	 3
  0073d	6a 00		 push	 0
  0073f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 661  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00744	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0074a	6a 04		 push	 4
  0074c	6a 01		 push	 1
  0074e	6a 00		 push	 0
  00750	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 662  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00755	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0075b	6a 02		 push	 2
  0075d	6a 05		 push	 5
  0075f	6a 00		 push	 0
  00761	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 663  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00766	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0076c	6a 02		 push	 2
  0076e	6a 04		 push	 4
  00770	6a 00		 push	 0
  00772	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 664  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  00777	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0077d	6a 01		 push	 1
  0077f	6a 0d		 push	 13			; 0000000dH
  00781	6a 00		 push	 0
  00783	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 665  : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  00788	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0078e	6a 01		 push	 1
  00790	6a 0e		 push	 14			; 0000000eH
  00792	6a 00		 push	 0
  00794	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 666  : 		
; 667  : 		
; 668  : 		STATEMANAGER.SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);

  00799	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0079f	6a 05		 push	 5
  007a1	6a 13		 push	 19			; 00000013H
  007a3	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 669  : 		STATEMANAGER.SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

  007a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007ae	6a 06		 push	 6
  007b0	6a 14		 push	 20			; 00000014H
  007b2	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 670  : 		STATEMANAGER.SetRenderState(D3DRS_FOGCOLOR, dwFogColor);

  007b7	ff b5 a8 fe ff
	ff		 push	 DWORD PTR _dwFogColor$1$[ebp]
  007bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007c3	6a 22		 push	 34			; 00000022H
  007c5	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 671  : 
; 672  : 		STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  007ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007d0	6a 00		 push	 0
  007d2	68 89 00 00 00	 push	 137			; 00000089H
  007d7	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN18@HardwareTr:

; 673  : 	}
; 674  : 	++m_iRenderedPatchNum;
; 675  : 
; 676  : 	int iCurRenderedSplatNum=m_iRenderedSplatNum-iPrevRenderedSplatNum;

  007dc	8b 86 88 09 00
	00		 mov	 eax, DWORD PTR [esi+2440]
  007e2	ff 86 8c 09 00
	00		 inc	 DWORD PTR [esi+2444]
  007e8	2b c3		 sub	 eax, ebx

; 677  : 
; 678  : 	m_iRenderedSplatNumSqSum+=iCurRenderedSplatNum*iCurRenderedSplatNum;

  007ea	0f af c0	 imul	 eax, eax
  007ed	01 86 84 09 00
	00		 add	 DWORD PTR [esi+2436], eax
$LN98@HardwareTr:
  007f3	5f		 pop	 edi
  007f4	5b		 pop	 ebx
$LN1@HardwareTr:

; 679  : 
; 680  : }

  007f5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007f8	33 cd		 xor	 ecx, ebp
  007fa	5e		 pop	 esi
  007fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00800	8b e5		 mov	 esp, ebp
  00802	5d		 pop	 ebp
  00803	c2 0c 00	 ret	 12			; 0000000cH
?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ENDP ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp
;	COMDAT ?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ
_TEXT	SEGMENT
$T1 = -40						; size = 1
tv1381 = -40						; size = 4
_far_it$ = -40						; size = 4
_fog_far$ = -36						; size = 8
tv1382 = -32						; size = 4
_near_it$ = -32						; size = 4
_fog_near$ = -28					; size = 8
_dwFogEnable$1$ = -24					; size = 4
_fFogNearDistance$ = -24				; size = 4
_fFogFarDistance$1$ = -20				; size = 4
_fLODLevel2Distance$ = -20				; size = 4
_fFogFarDistance$ = -20					; size = 4
_fFogNearDistance$1$ = -16				; size = 4
_dwB$1$ = -16						; size = 4
_fLODLevel1Distance$ = -16				; size = 4
_dwR$1$ = -12						; size = 4
_wPrimitiveCount$ = -12					; size = 2
_dwG$1$ = -8						; size = 4
_ePrimitiveType$ = -8					; size = 4
_byCUrrentLODLevel$1$ = -1				; size = 1
?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ PROC ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch, COMDAT
; _this$ = ecx

; 7    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	8b d9		 mov	 ebx, ecx
  00009	56		 push	 esi
  0000a	57		 push	 edi

; 8    : 	DWORD dwFogColor;
; 9    : 	float fFogFarDistance;
; 10   : 	float fFogNearDistance;
; 11   : 	if (mc_pEnvironmentData)

  0000b	8b 7b 3c	 mov	 edi, DWORD PTR [ebx+60]
  0000e	85 ff		 test	 edi, edi
  00010	0f 84 4c 01 00
	00		 je	 $LN11@RenderTerr
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  00016	f3 0f 10 87 2c
	01 00 00	 movss	 xmm0, DWORD PTR [edi+300]
  0001e	0f 57 c9	 xorps	 xmm1, xmm1
  00021	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00028	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00030	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00038	72 09		 jb	 SHORT $LN35@RenderTerr
  0003a	c7 45 f4 ff 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 255 ; 000000ffH
  00041	eb 31		 jmp	 SHORT $LN34@RenderTerr
$LN35@RenderTerr:
  00043	0f 2f c8	 comiss	 xmm1, xmm0
  00046	72 09		 jb	 SHORT $LN33@RenderTerr
  00048	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _dwR$1$[ebp], 0
  0004f	eb 23		 jmp	 SHORT $LN34@RenderTerr
$LN33@RenderTerr:
  00051	f3 0f 59 c3	 mulss	 xmm0, xmm3
  00055	f3 0f 58 c4	 addss	 xmm0, xmm4
  00059	e8 00 00 00 00	 call	 __ftoui3
  0005e	f3 0f 10 1d 00
	00 00 00	 movss	 xmm3, DWORD PTR __real@437f0000
  00066	0f 57 c9	 xorps	 xmm1, xmm1
  00069	f3 0f 10 25 00
	00 00 00	 movss	 xmm4, DWORD PTR __real@3f000000
  00071	89 45 f4	 mov	 DWORD PTR _dwR$1$[ebp], eax
$LN34@RenderTerr:

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00074	f3 0f 10 87 30
	01 00 00	 movss	 xmm0, DWORD PTR [edi+304]
  0007c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00083	72 09		 jb	 SHORT $LN39@RenderTerr
  00085	c7 45 f8 ff 00
	00 00		 mov	 DWORD PTR _dwG$1$[ebp], 255 ; 000000ffH
  0008c	eb 1e		 jmp	 SHORT $LN38@RenderTerr
$LN39@RenderTerr:
  0008e	0f 2f c8	 comiss	 xmm1, xmm0
  00091	72 09		 jb	 SHORT $LN37@RenderTerr
  00093	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwG$1$[ebp], 0
  0009a	eb 10		 jmp	 SHORT $LN38@RenderTerr
$LN37@RenderTerr:
  0009c	f3 0f 59 c3	 mulss	 xmm0, xmm3
  000a0	f3 0f 58 c4	 addss	 xmm0, xmm4
  000a4	e8 00 00 00 00	 call	 __ftoui3
  000a9	89 45 f8	 mov	 DWORD PTR _dwG$1$[ebp], eax
$LN38@RenderTerr:

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  000ac	f3 0f 10 87 34
	01 00 00	 movss	 xmm0, DWORD PTR [edi+308]
  000b4	0f 57 c9	 xorps	 xmm1, xmm1
  000b7	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  000be	72 09		 jb	 SHORT $LN43@RenderTerr
  000c0	c7 45 f0 ff 00
	00 00		 mov	 DWORD PTR _dwB$1$[ebp], 255 ; 000000ffH
  000c7	eb 29		 jmp	 SHORT $LN42@RenderTerr
$LN43@RenderTerr:
  000c9	0f 2f c8	 comiss	 xmm1, xmm0
  000cc	72 09		 jb	 SHORT $LN41@RenderTerr
  000ce	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _dwB$1$[ebp], 0
  000d5	eb 1b		 jmp	 SHORT $LN42@RenderTerr
$LN41@RenderTerr:
  000d7	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  000df	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  000e7	e8 00 00 00 00	 call	 __ftoui3
  000ec	89 45 f0	 mov	 DWORD PTR _dwB$1$[ebp], eax
  000ef	0f 57 c9	 xorps	 xmm1, xmm1
$LN42@RenderTerr:

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  000f2	f3 0f 10 87 38
	01 00 00	 movss	 xmm0, DWORD PTR [edi+312]
  000fa	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00101	72 07		 jb	 SHORT $LN47@RenderTerr
  00103	be ff 00 00 00	 mov	 esi, 255		; 000000ffH
  00108	eb 20		 jmp	 SHORT $LN46@RenderTerr
$LN47@RenderTerr:
  0010a	0f 2f c8	 comiss	 xmm1, xmm0
  0010d	72 04		 jb	 SHORT $LN45@RenderTerr
  0010f	33 f6		 xor	 esi, esi
  00111	eb 17		 jmp	 SHORT $LN46@RenderTerr
$LN45@RenderTerr:
  00113	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0011b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00123	e8 00 00 00 00	 call	 __ftoui3
  00128	8b f0		 mov	 esi, eax
$LN46@RenderTerr:

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0012a	c1 e6 08	 shl	 esi, 8
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 14   : 		fFogNearDistance=mc_pEnvironmentData->GetFogNearDistance();

  0012d	8b cf		 mov	 ecx, edi
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0012f	0b 75 f4	 or	 esi, DWORD PTR _dwR$1$[ebp]
  00132	c1 e6 08	 shl	 esi, 8
  00135	0b 75 f8	 or	 esi, DWORD PTR _dwG$1$[ebp]
  00138	c1 e6 08	 shl	 esi, 8
  0013b	0b 75 f0	 or	 esi, DWORD PTR _dwB$1$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 14   : 		fFogNearDistance=mc_pEnvironmentData->GetFogNearDistance();

  0013e	e8 00 00 00 00	 call	 ?GetFogNearDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogNearDistance

; 15   : 		fFogFarDistance=mc_pEnvironmentData->GetFogFarDistance();

  00143	8b 4b 3c	 mov	 ecx, DWORD PTR [ebx+60]
  00146	d9 5d e8	 fstp	 DWORD PTR _fFogNearDistance$[ebp]
  00149	e8 00 00 00 00	 call	 ?GetFogFarDistance@SEnvironmentData@@QBEMXZ ; SEnvironmentData::GetFogFarDistance

; 16   : 	}

  0014e	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fFogNearDistance$[ebp]
  00153	d9 5d ec	 fstp	 DWORD PTR _fFogFarDistance$[ebp]
  00156	f3 0f 11 45 f0	 movss	 DWORD PTR _fFogNearDistance$1$[ebp], xmm0
  0015b	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fFogFarDistance$[ebp]
  00160	eb 18		 jmp	 SHORT $LN174@RenderTerr
$LN11@RenderTerr:

; 17   : 	else
; 18   : 	{
; 19   : 		dwFogColor=0xffffffff;
; 20   : 		fFogNearDistance=5000.0f;

  00162	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@459c4000
  0016a	83 ce ff	 or	 esi, -1
  0016d	f3 0f 11 45 f0	 movss	 DWORD PTR _fFogNearDistance$1$[ebp], xmm0

; 21   : 		fFogFarDistance=10000.0f;

  00172	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@461c4000
$LN174@RenderTerr:

; 22   : 	}
; 23   : 	
; 24   : 	//////////////////////////////////////////////////////////////////////////
; 25   : 	// Render State & TextureStageState	
; 26   : 
; 27   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  0017a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00180	68 00 00 02 00	 push	 131072			; 00020000H
  00185	6a 0b		 push	 11			; 0000000bH
  00187	6a 00		 push	 0
  00189	f3 0f 11 45 ec	 movss	 DWORD PTR _fFogFarDistance$1$[ebp], xmm0
  0018e	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 28   : 	STATEMANAGER.SaveTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00199	6a 02		 push	 2
  0019b	6a 18		 push	 24			; 00000018H
  0019d	6a 00		 push	 0
  0019f	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 29   : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);

  001a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001aa	68 00 00 02 00	 push	 131072			; 00020000H
  001af	6a 0b		 push	 11			; 0000000bH
  001b1	6a 01		 push	 1
  001b3	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 30   : 	STATEMANAGER.SaveTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_COUNT2);

  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001be	6a 02		 push	 2
  001c0	6a 18		 push	 24			; 00000018H
  001c2	6a 01		 push	 1
  001c4	e8 00 00 00 00	 call	 ?SaveTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SaveTextureStageState

; 31   : 
; 32   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

  001c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001cf	6a 01		 push	 1
  001d1	6a 1b		 push	 27			; 0000001bH
  001d3	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 33   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHATESTENABLE, TRUE);

  001d8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001de	6a 01		 push	 1
  001e0	6a 0f		 push	 15			; 0000000fH
  001e2	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 34   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAREF, 0x00000000);

  001e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ed	6a 00		 push	 0
  001ef	6a 18		 push	 24			; 00000018H
  001f1	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 35   : 	STATEMANAGER.SaveRenderState(D3DRS_ALPHAFUNC, D3DCMP_GREATER);

  001f6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001fc	6a 05		 push	 5
  001fe	6a 19		 push	 25			; 00000019H
  00200	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 36   : 
; 37   : 	STATEMANAGER.SaveRenderState(D3DRS_TEXTUREFACTOR, dwFogColor);

  00205	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0020b	56		 push	 esi
  0020c	6a 3c		 push	 60			; 0000003cH
  0020e	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 38   : 
; 39   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00213	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00219	6a 02		 push	 2
  0021b	6a 02		 push	 2
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 40   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0022a	6a 01		 push	 1
  0022c	6a 03		 push	 3
  0022e	6a 00		 push	 0
  00230	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 41   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00235	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0023b	6a 04		 push	 4
  0023d	6a 01		 push	 1
  0023f	6a 00		 push	 0
  00241	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 42   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00246	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0024c	6a 02		 push	 2
  0024e	6a 05		 push	 5
  00250	6a 00		 push	 0
  00252	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 43   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  00257	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0025d	6a 02		 push	 2
  0025f	6a 04		 push	 4
  00261	6a 00		 push	 0
  00263	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 44   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSU,  D3DTADDRESS_WRAP);

  00268	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0026e	6a 01		 push	 1
  00270	6a 0d		 push	 13			; 0000000dH
  00272	6a 00		 push	 0
  00274	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 45   : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ADDRESSV,  D3DTADDRESS_WRAP);

  00279	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0027f	6a 01		 push	 1
  00281	6a 0e		 push	 14			; 0000000eH
  00283	6a 00		 push	 0
  00285	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 46   : 
; 47   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0028a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00290	6a 01		 push	 1
  00292	6a 02		 push	 2
  00294	6a 01		 push	 1
  00296	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 48   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0029b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a1	6a 02		 push	 2
  002a3	6a 01		 push	 1
  002a5	6a 01		 push	 1
  002a7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 49   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  002ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002b2	6a 02		 push	 2
  002b4	6a 05		 push	 5
  002b6	6a 01		 push	 1
  002b8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 50   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  002bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002c3	6a 02		 push	 2
  002c5	6a 04		 push	 4
  002c7	6a 01		 push	 1
  002c9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 51   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSU,  D3DTADDRESS_CLAMP);

  002ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002d4	6a 03		 push	 3
  002d6	6a 0d		 push	 13			; 0000000dH
  002d8	6a 01		 push	 1
  002da	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 52   : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ADDRESSV,  D3DTADDRESS_CLAMP);

  002df	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002e5	6a 03		 push	 3
  002e7	6a 0e		 push	 14			; 0000000eH
  002e9	6a 01		 push	 1
  002eb	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 53   : 
; 54   : #ifdef WORLD_EDITOR
; 55   : 	if (GetAsyncKeyState(VK_CAPITAL))
; 56   : 	{
; 57   : 		CSpeedTreeWrapper::ms_bSelfShadowOn = false;
; 58   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MINFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 59   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MAGFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 60   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MIPFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 61   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MINFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 62   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MAGFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 63   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MIPFILTER,	D3DTEXF_GAUSSIANCUBIC);
; 64   : 	}
; 65   : 	else
; 66   : 	{
; 67   : 		CSpeedTreeWrapper::ms_bSelfShadowOn = true;
; 68   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MINFILTER,	D3DTEXF_LINEAR);
; 69   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MAGFILTER,	D3DTEXF_LINEAR);
; 70   : 		STATEMANAGER.SetTextureStageState(0, D3DTSS_MIPFILTER,	D3DTEXF_LINEAR);
; 71   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MINFILTER,	D3DTEXF_LINEAR);
; 72   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MAGFILTER,	D3DTEXF_LINEAR);
; 73   : 		STATEMANAGER.SetTextureStageState(1, D3DTSS_MIPFILTER,	D3DTEXF_LINEAR);
; 74   : 	}
; 75   : #else
; 76   : 	CSpeedTreeWrapper::ms_bSelfShadowOn = true;
; 77   : 	STATEMANAGER.SetBestFiltering(0);

  002f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002f6	6a 00		 push	 0
  002f8	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bSelfShadowOn@CSpeedTreeWrapper@@2_NA, 1 ; CSpeedTreeWrapper::ms_bSelfShadowOn
  002ff	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 78   : 	STATEMANAGER.SetBestFiltering(1);

  00304	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0030a	6a 01		 push	 1
  0030c	e8 00 00 00 00	 call	 ?SetBestFiltering@CStateManager@@QAEXK@Z ; CStateManager::SetBestFiltering

; 79   : #endif
; 80   : 
; 81   : 	m_matWorldForCommonUse._41 = 0.0f;
; 82   : 	m_matWorldForCommonUse._42 = 0.0f;
; 83   : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &m_matWorldForCommonUse);

  00311	8d b3 48 07 00
	00		 lea	 esi, DWORD PTR [ebx+1864]
  00317	c7 83 78 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+1912], 0
  00321	56		 push	 esi
  00322	c7 83 7c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+1916], 0
  0032c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00332	68 00 01 00 00	 push	 256			; 00000100H
  00337	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 84   : 
; 85   : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE0, &m_matWorldForCommonUse);

  0033c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00342	56		 push	 esi
  00343	6a 10		 push	 16			; 00000010H
  00345	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 86   : 	STATEMANAGER.SaveTransform(D3DTS_TEXTURE1, &m_matWorldForCommonUse);

  0034a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00350	56		 push	 esi
  00351	6a 11		 push	 17			; 00000011H
  00353	e8 00 00 00 00	 call	 ?SaveTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SaveTransform

; 87   : 
; 88   : 	// Render State & TextureStageState
; 89   : 	//////////////////////////////////////////////////////////////////////////
; 90   : 
; 91   : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ | D3DFVF_NORMAL);

  00358	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0035e	6a 12		 push	 18			; 00000012H
  00360	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 92   : 
; 93   : 	m_iRenderedSplatNumSqSum = 0;
; 94   : 	m_iRenderedPatchNum = 0;
; 95   : 	m_iRenderedSplatNum = 0;
; 96   : 	m_RenderedTextureNumVector.clear();
; 97   : 
; 98   : 	std::pair<float, long> fog_far(fFogFarDistance+1600.0f, 0);

  00365	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fFogFarDistance$1$[ebp]
  0036a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@44c80000
  00372	c7 83 88 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2440], 0
  0037c	8b 83 90 09 00
	00		 mov	 eax, DWORD PTR [ebx+2448]
  00382	89 83 94 09 00
	00		 mov	 DWORD PTR [ebx+2452], eax

; 101  : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  00388	8d 45 dc	 lea	 eax, DWORD PTR _fog_far$[ebp]
  0038b	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0038c	f3 0f 11 45 dc	 movss	 DWORD PTR _fog_far$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 101  : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  00391	8d 45 d8	 lea	 eax, DWORD PTR _far_it$[ebp]
  00394	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fFogNearDistance$1$[ebp]
  00399	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@45480000
  003a1	c7 83 84 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2436], 0
  003ab	c7 83 8c 09 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+2444], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  003b5	8b bb 1c 01 00
	00		 mov	 edi, DWORD PTR [ebx+284]
  003bb	8b b3 18 01 00
	00		 mov	 esi, DWORD PTR [ebx+280]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 101  : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  003c1	57		 push	 edi
  003c2	56		 push	 esi
  003c3	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  003c4	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _fog_far$[ebp+4], 0
  003cb	f3 0f 11 45 e4	 movss	 DWORD PTR _fog_near$[ebp], xmm0
  003d0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _fog_near$[ebp+4], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 101  : 	std::vector<std::pair<float ,long> >::iterator far_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_far);

  003d7	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >

; 102  : 	std::vector<std::pair<float ,long> >::iterator near_it = std::upper_bound(m_PatchVector.begin(),m_PatchVector.end(),fog_near);

  003dc	8d 45 e4	 lea	 eax, DWORD PTR _fog_near$[ebp]
  003df	50		 push	 eax
  003e0	57		 push	 edi
  003e1	8d 45 e0	 lea	 eax, DWORD PTR _near_it$[ebp]
  003e4	56		 push	 esi
  003e5	50		 push	 eax
  003e6	e8 00 00 00 00	 call	 ??$upper_bound@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@std@@U?$pair@MJ@2@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@U?$pair@MJ@std@@@std@@@std@@@0@V10@0ABU?$pair@MJ@0@@Z ; std::upper_bound<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::pair<float,long> > > >,std::pair<float,long> >
  003eb	83 c4 20	 add	 esp, 32			; 00000020H

; 103  : 
; 104  : 	// NOTE: Word Editor  fog far        
; 105  : #ifdef WORLD_EDITOR
; 106  : 	near_it = m_PatchVector.begin();
; 107  : 	far_it = m_PatchVector.end();
; 108  : #endif
; 109  : 
; 110  : 	WORD wPrimitiveCount;
; 111  : 	D3DPRIMITIVETYPE ePrimitiveType;
; 112  : 
; 113  : 	BYTE byCUrrentLODLevel = 0;

  003ee	c6 45 ff 00	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 0

; 114  : 
; 115  : 	float fLODLevel1Distance = __GetNoFogDistance();

  003f2	8b cb		 mov	 ecx, ebx
  003f4	e8 00 00 00 00	 call	 ?__GetNoFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetNoFogDistance
  003f9	d9 5d f0	 fstp	 DWORD PTR _fLODLevel1Distance$[ebp]

; 116  : 	float fLODLevel2Distance = __GetFogDistance();

  003fc	8b cb		 mov	 ecx, ebx
  003fe	e8 00 00 00 00	 call	 ?__GetFogDistance@CMapOutdoor@@IAEMXZ ; CMapOutdoor::__GetFogDistance

; 117  : 
; 118  : 	SelectIndexBuffer(0, &wPrimitiveCount, &ePrimitiveType);

  00403	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00406	8b cb		 mov	 ecx, ebx
  00408	50		 push	 eax
  00409	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0040c	50		 push	 eax
  0040d	6a 00		 push	 0
  0040f	d9 5d ec	 fstp	 DWORD PTR _fLODLevel2Distance$[ebp]
  00412	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer

; 119  : 
; 120  : 	DWORD dwFogEnable = STATEMANAGER.GetRenderState(D3DRS_FOGENABLE);

  00417	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0041d	6a 1c		 push	 28			; 0000001cH
  0041f	e8 00 00 00 00	 call	 ?GetRenderState@CStateManager@@QAEKW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::GetRenderState

; 125  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00424	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  0042a	8b b3 18 01 00
	00		 mov	 esi, DWORD PTR [ebx+280]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 125  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  00430	6a 00		 push	 0
  00432	6a 1c		 push	 28			; 0000001cH
  00434	89 45 e8	 mov	 DWORD PTR _dwFogEnable$1$[ebp], eax
  00437	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 149  :         return _Ptr == _Right._Ptr;

  0043c	8b 7d e0	 mov	 edi, DWORD PTR _near_it$[ebp]
  0043f	3b f7		 cmp	 esi, edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 127  : 	for( ; it != near_it; ++it)

  00441	0f 84 a8 00 00
	00		 je	 $LN171@RenderTerr
$LL86@RenderTerr:

; 129  : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00447	8a 45 ff	 mov	 al, BYTE PTR _byCUrrentLODLevel$1$[ebp]
  0044a	84 c0		 test	 al, al
  0044c	75 23		 jne	 SHORT $LN165@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  0044e	56		 push	 esi
  0044f	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00454	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 129  : 		if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00457	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0045b	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  0045f	72 3c		 jb	 SHORT $LN15@RenderTerr

; 130  : 		{
; 131  : 			byCUrrentLODLevel = 1;
; 132  : 			SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  00461	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00464	c6 45 ff 01	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 1
  00468	50		 push	 eax
  00469	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0046c	50		 push	 eax
  0046d	6a 01		 push	 1

; 133  : 		}

  0046f	eb 25		 jmp	 SHORT $LN175@RenderTerr
$LN165@RenderTerr:

; 134  : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00471	3c 01		 cmp	 al, 1
  00473	75 28		 jne	 SHORT $LN15@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00475	56		 push	 esi
  00476	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0047b	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 134  : 		else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0047e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00482	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  00486	72 15		 jb	 SHORT $LN15@RenderTerr

; 135  : 		{
; 136  : 			byCUrrentLODLevel = 2;
; 137  : 			SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00488	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  0048b	c6 45 ff 02	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  0048f	50		 push	 eax
  00490	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00493	50		 push	 eax
  00494	6a 02		 push	 2
$LN175@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00496	8b cb		 mov	 ecx, ebx
  00498	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN15@RenderTerr:
  0049d	56		 push	 esi
  0049e	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  004a3	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 140  : 		__HardwareTransformPatch_RenderPatchSplat(it->second, wPrimitiveCount, ePrimitiveType);

  004a6	83 c0 04	 add	 eax, 4
  004a9	8b cb		 mov	 ecx, ebx
  004ab	89 45 e0	 mov	 DWORD PTR tv1382[ebp], eax
  004ae	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  004b1	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  004b4	ff 30		 push	 DWORD PTR [eax]
  004b6	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat

; 141  : 		if (m_iRenderedSplatNum >= m_iSplatLimit)

  004bb	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  004c1	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  004c7	7d 26		 jge	 SHORT $LN171@RenderTerr

; 142  : 			break;
; 143  : 		
; 144  :  		if (m_bDrawWireFrame)

  004c9	80 bb 30 01 00
	00 00		 cmp	 BYTE PTR [ebx+304], 0
  004d0	74 12		 je	 SHORT $LN2@RenderTerr

; 145  : 			DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  004d2	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  004d5	8b 45 e0	 mov	 eax, DWORD PTR tv1382[ebp]
  004d8	8b cb		 mov	 ecx, ebx
  004da	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  004dd	ff 30		 push	 DWORD PTR [eax]
  004df	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN2@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  004e4	83 c6 08	 add	 esi, 8

; 149  :         return _Ptr == _Right._Ptr;

  004e7	3b f7		 cmp	 esi, edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 127  : 	for( ; it != near_it; ++it)

  004e9	0f 85 58 ff ff
	ff		 jne	 $LL86@RenderTerr
$LN171@RenderTerr:

; 146  : 	}
; 147  : #endif
; 148  : 
; 149  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  004ef	ff 75 e8	 push	 DWORD PTR _dwFogEnable$1$[ebp]
  004f2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  004f8	6a 1c		 push	 28			; 0000001cH
  004fa	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 150  : 
; 151  : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  004ff	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  00505	8b 75 d8	 mov	 esi, DWORD PTR _far_it$[ebp]
  00508	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  0050e	0f 8d b4 00 00
	00		 jge	 $LN172@RenderTerr

; 153  : 		for(it = near_it; it != far_it; ++it)

  00514	3b fe		 cmp	 edi, esi
  00516	0f 84 ac 00 00
	00		 je	 $LN172@RenderTerr
  0051c	0f 1f 40 00	 npad	 4
$LL102@RenderTerr:

; 155  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00520	8a 45 ff	 mov	 al, BYTE PTR _byCUrrentLODLevel$1$[ebp]
  00523	84 c0		 test	 al, al
  00525	75 23		 jne	 SHORT $LN166@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  00527	57		 push	 edi
  00528	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0052d	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 155  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  00530	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00534	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  00538	72 3c		 jb	 SHORT $LN21@RenderTerr

; 156  : 			{
; 157  : 				byCUrrentLODLevel = 1;
; 158  : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  0053a	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  0053d	c6 45 ff 01	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 1
  00541	50		 push	 eax
  00542	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  00545	50		 push	 eax
  00546	6a 01		 push	 1

; 159  : 			}

  00548	eb 25		 jmp	 SHORT $LN176@RenderTerr
$LN166@RenderTerr:

; 160  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  0054a	3c 01		 cmp	 al, 1
  0054c	75 28		 jne	 SHORT $LN21@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  0054e	57		 push	 edi
  0054f	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  00554	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 160  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  00557	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0055b	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  0055f	72 15		 jb	 SHORT $LN21@RenderTerr

; 161  : 			{
; 162  : 				byCUrrentLODLevel = 2;
; 163  : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  00561	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  00564	c6 45 ff 02	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  00568	50		 push	 eax
  00569	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  0056c	50		 push	 eax
  0056d	6a 02		 push	 2
$LN176@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  0056f	8b cb		 mov	 ecx, ebx
  00571	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN21@RenderTerr:
  00576	57		 push	 edi
  00577	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  0057c	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 166  : 			__HardwareTransformPatch_RenderPatchSplat(it->second, wPrimitiveCount, ePrimitiveType);

  0057f	83 c0 04	 add	 eax, 4
  00582	8b cb		 mov	 ecx, ebx
  00584	89 45 d8	 mov	 DWORD PTR tv1381[ebp], eax
  00587	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0058a	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  0058d	ff 30		 push	 DWORD PTR [eax]
  0058f	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchSplat@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchSplat

; 167  : 
; 168  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  00594	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  0059a	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  005a0	7d 26		 jge	 SHORT $LN172@RenderTerr

; 169  : 				break;
; 170  : 
; 171  : 			if (m_bDrawWireFrame)

  005a2	80 bb 30 01 00
	00 00		 cmp	 BYTE PTR [ebx+304], 0
  005a9	74 12		 je	 SHORT $LN5@RenderTerr

; 172  : 				DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  005ab	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  005ae	8b 45 d8	 mov	 eax, DWORD PTR tv1381[ebp]
  005b1	8b cb		 mov	 ecx, ebx
  005b3	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  005b6	ff 30		 push	 DWORD PTR [eax]
  005b8	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN5@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  005bd	83 c7 08	 add	 edi, 8

; 149  :         return _Ptr == _Right._Ptr;

  005c0	3b fe		 cmp	 edi, esi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 153  : 		for(it = near_it; it != far_it; ++it)

  005c2	0f 85 58 ff ff
	ff		 jne	 $LL102@RenderTerr
$LN172@RenderTerr:

; 173  : 		}
; 174  : 	}
; 175  : 
; 176  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  005c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005ce	6a 00		 push	 0
  005d0	6a 1c		 push	 28			; 0000001cH
  005d2	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 177  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  005d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005dd	6a 00		 push	 0
  005df	68 89 00 00 00	 push	 137			; 00000089H
  005e4	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 178  : 
; 179  : 	STATEMANAGER.SetTexture(0, NULL);

  005e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005ef	6a 00		 push	 0
  005f1	6a 00		 push	 0
  005f3	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 180  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, FALSE);

  005f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  005fe	6a 00		 push	 0
  00600	6a 18		 push	 24			; 00000018H
  00602	6a 00		 push	 0
  00604	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 181  : 
; 182  : 	STATEMANAGER.SetTexture(1, NULL);

  00609	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0060f	6a 00		 push	 0
  00611	6a 01		 push	 1
  00613	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 183  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS, FALSE);

  00618	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0061e	6a 00		 push	 0
  00620	6a 18		 push	 24			; 00000018H
  00622	6a 01		 push	 1
  00624	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 184  : 
; 185  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);

  00629	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0062f	6a 03		 push	 3
  00631	6a 02		 push	 2
  00633	6a 00		 push	 0
  00635	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 186  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  0063a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00640	6a 02		 push	 2
  00642	6a 01		 push	 1
  00644	6a 00		 push	 0
  00646	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 187  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);

  0064b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00651	6a 01		 push	 1
  00653	6a 04		 push	 4
  00655	6a 00		 push	 0
  00657	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 188  : 
; 189  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_DISABLE);

  0065c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00662	6a 01		 push	 1
  00664	6a 01		 push	 1
  00666	6a 01		 push	 1
  00668	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 190  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE);	

  0066d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00673	6a 01		 push	 1
  00675	6a 04		 push	 4
  00677	6a 01		 push	 1
  00679	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 191  : 
; 192  : 	if (m_iRenderedSplatNum < m_iSplatLimit)

  0067e	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  00684	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  0068a	0f 8d b6 00 00
	00		 jge	 $LN173@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00690	3b b3 1c 01 00
	00		 cmp	 esi, DWORD PTR [ebx+284]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 194  : 		for(it = far_it; it != m_PatchVector.end(); ++it)

  00696	0f 84 aa 00 00
	00		 je	 $LN173@RenderTerr
  0069c	0f 1f 40 00	 npad	 4
$LL118@RenderTerr:

; 196  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  006a0	8a 45 ff	 mov	 al, BYTE PTR _byCUrrentLODLevel$1$[ebp]
  006a3	84 c0		 test	 al, al
  006a5	75 23		 jne	 SHORT $LN167@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  006a7	56		 push	 esi
  006a8	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  006ad	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 196  : 			if (byCUrrentLODLevel == 0 && fLODLevel1Distance <= it->first)

  006b0	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006b4	0f 2f 45 f0	 comiss	 xmm0, DWORD PTR _fLODLevel1Distance$[ebp]
  006b8	72 3c		 jb	 SHORT $LN27@RenderTerr

; 197  : 			{
; 198  : 				byCUrrentLODLevel = 1;
; 199  : 				SelectIndexBuffer(1, &wPrimitiveCount, &ePrimitiveType);

  006ba	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  006bd	c6 45 ff 01	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 1
  006c1	50		 push	 eax
  006c2	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  006c5	50		 push	 eax
  006c6	6a 01		 push	 1

; 200  : 			}

  006c8	eb 25		 jmp	 SHORT $LN177@RenderTerr
$LN167@RenderTerr:

; 201  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  006ca	3c 01		 cmp	 al, 1
  006cc	75 28		 jne	 SHORT $LN27@RenderTerr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  006ce	56		 push	 esi
  006cf	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  006d4	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 201  : 			else if (byCUrrentLODLevel == 1 && fLODLevel2Distance <= it->first)

  006d7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006db	0f 2f 45 ec	 comiss	 xmm0, DWORD PTR _fLODLevel2Distance$[ebp]
  006df	72 15		 jb	 SHORT $LN27@RenderTerr

; 202  : 			{
; 203  : 				byCUrrentLODLevel = 2;
; 204  : 				SelectIndexBuffer(2, &wPrimitiveCount, &ePrimitiveType);

  006e1	8d 45 f8	 lea	 eax, DWORD PTR _ePrimitiveType$[ebp]
  006e4	c6 45 ff 02	 mov	 BYTE PTR _byCUrrentLODLevel$1$[ebp], 2
  006e8	50		 push	 eax
  006e9	8d 45 f4	 lea	 eax, DWORD PTR _wPrimitiveCount$[ebp]
  006ec	50		 push	 eax
  006ed	6a 02		 push	 2
$LN177@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 256  :         return _Const_cast(_Mybase::operator->());

  006ef	8b cb		 mov	 ecx, ebx
  006f1	e8 00 00 00 00	 call	 ?SelectIndexBuffer@CMapOutdoor@@IAEXEPAGPAW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::SelectIndexBuffer
$LN27@RenderTerr:
  006f6	56		 push	 esi
  006f7	e8 00 00 00 00	 call	 ??$_Const_cast@$$CBU?$pair@MJ@std@@@std@@YAPAU?$pair@MJ@0@PBU10@@Z ; std::_Const_cast<std::pair<float,long> const >
  006fc	83 c4 04	 add	 esp, 4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 207  : 			__HardwareTransformPatch_RenderPatchNone(it->second, wPrimitiveCount, ePrimitiveType);

  006ff	8b cb		 mov	 ecx, ebx
  00701	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00704	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  00707	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  0070a	ff 37		 push	 DWORD PTR [edi]
  0070c	e8 00 00 00 00	 call	 ?__HardwareTransformPatch_RenderPatchNone@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::__HardwareTransformPatch_RenderPatchNone

; 208  : 
; 209  : 			if (m_iRenderedSplatNum >= m_iSplatLimit)

  00711	8b 83 88 09 00
	00		 mov	 eax, DWORD PTR [ebx+2440]
  00717	3b 83 9c 09 00
	00		 cmp	 eax, DWORD PTR [ebx+2460]
  0071d	7d 27		 jge	 SHORT $LN173@RenderTerr

; 210  : 				break;
; 211  : 
; 212  : 			if (m_bDrawWireFrame)

  0071f	80 bb 30 01 00
	00 00		 cmp	 BYTE PTR [ebx+304], 0
  00726	74 0f		 je	 SHORT $LN8@RenderTerr

; 213  :  				DrawWireFrame(it->second, wPrimitiveCount, ePrimitiveType);

  00728	ff 75 f8	 push	 DWORD PTR _ePrimitiveType$[ebp]
  0072b	8b cb		 mov	 ecx, ebx
  0072d	ff 75 f4	 push	 DWORD PTR _wPrimitiveCount$[ebp]
  00730	ff 37		 push	 DWORD PTR [edi]
  00732	e8 00 00 00 00	 call	 ?DrawWireFrame@CMapOutdoor@@IAEXJGW4_D3DPRIMITIVETYPE@@@Z ; CMapOutdoor::DrawWireFrame
$LN8@RenderTerr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  00737	83 c6 08	 add	 esi, 8

; 149  :         return _Ptr == _Right._Ptr;

  0073a	3b b3 1c 01 00
	00		 cmp	 esi, DWORD PTR [ebx+284]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 194  : 		for(it = far_it; it != m_PatchVector.end(); ++it)

  00740	0f 85 5a ff ff
	ff		 jne	 $LL118@RenderTerr
$LN173@RenderTerr:

; 214  : 		}
; 215  : 	}
; 216  : 
; 217  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);

  00746	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0074c	6a 02		 push	 2
  0074e	6a 02		 push	 2
  00750	6a 00		 push	 0
  00752	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 218  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_CURRENT);

  00757	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0075d	6a 01		 push	 1
  0075f	6a 03		 push	 3
  00761	6a 00		 push	 0
  00763	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 219  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);

  00768	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0076e	6a 04		 push	 4
  00770	6a 01		 push	 1
  00772	6a 00		 push	 0
  00774	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 220  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  00779	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0077f	6a 02		 push	 2
  00781	6a 05		 push	 5
  00783	6a 00		 push	 0
  00785	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 221  : 	STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  0078a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00790	6a 02		 push	 2
  00792	6a 04		 push	 4
  00794	6a 00		 push	 0
  00796	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 222  : 
; 223  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLORARG1, D3DTA_CURRENT);

  0079b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007a1	6a 01		 push	 1
  007a3	6a 02		 push	 2
  007a5	6a 01		 push	 1
  007a7	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 224  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_COLOROP,   D3DTOP_SELECTARG1);

  007ac	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007b2	6a 02		 push	 2
  007b4	6a 01		 push	 1
  007b6	6a 01		 push	 1
  007b8	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 225  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);

  007bd	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007c3	6a 02		 push	 2
  007c5	6a 05		 push	 5
  007c7	6a 01		 push	 1
  007c9	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 226  : 	STATEMANAGER.SetTextureStageState(1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1);

  007ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007d4	6a 02		 push	 2
  007d6	6a 04		 push	 4
  007d8	6a 01		 push	 1
  007da	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 227  : 
; 228  : 	STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, dwFogEnable);

  007df	ff 75 e8	 push	 DWORD PTR _dwFogEnable$1$[ebp]
  007e2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007e8	6a 1c		 push	 28			; 0000001cH
  007ea	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 229  : 	STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  007ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  007f5	6a 01		 push	 1
  007f7	68 89 00 00 00	 push	 137			; 00000089H
  007fc	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00801	8b 8b 94 09 00
	00		 mov	 ecx, DWORD PTR [ebx+2452]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  00807	8b c1		 mov	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00809	8b 93 90 09 00
	00		 mov	 edx, DWORD PTR [ebx+2448]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  0080f	2b c2		 sub	 eax, edx
  00811	c6 45 d8 00	 mov	 BYTE PTR $T1[ebp], 0
  00815	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  00818	c1 f8 02	 sar	 eax, 2
  0081b	50		 push	 eax
  0081c	51		 push	 ecx
  0081d	52		 push	 edx
  0081e	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAHU?$less@X@std@@@std@@YAXPAH0HU?$less@X@0@@Z ; std::_Sort_unchecked<int *,std::less<void> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 236  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  00823	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  00829	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\GameLib\MapOutdoorRenderHTP.cpp

; 236  : 	STATEMANAGER.RestoreRenderState(D3DRS_TEXTUREFACTOR);

  0082c	6a 3c		 push	 60			; 0000003cH
  0082e	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 237  : 
; 238  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE0);

  00833	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00839	6a 10		 push	 16			; 00000010H
  0083b	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 239  : 	STATEMANAGER.RestoreTransform(D3DTS_TEXTURE1);

  00840	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00846	6a 11		 push	 17			; 00000011H
  00848	e8 00 00 00 00	 call	 ?RestoreTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@@Z ; CStateManager::RestoreTransform

; 240  : 
; 241  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXCOORDINDEX);

  0084d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00853	6a 0b		 push	 11			; 0000000bH
  00855	6a 00		 push	 0
  00857	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 242  : 	STATEMANAGER.RestoreTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS);

  0085c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00862	6a 18		 push	 24			; 00000018H
  00864	6a 00		 push	 0
  00866	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 243  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXCOORDINDEX);

  0086b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00871	6a 0b		 push	 11			; 0000000bH
  00873	6a 01		 push	 1
  00875	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 244  : 	STATEMANAGER.RestoreTextureStageState(1, D3DTSS_TEXTURETRANSFORMFLAGS);

  0087a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00880	6a 18		 push	 24			; 00000018H
  00882	6a 01		 push	 1
  00884	e8 00 00 00 00	 call	 ?RestoreTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@@Z ; CStateManager::RestoreTextureStageState

; 245  : 
; 246  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHABLENDENABLE);

  00889	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0088f	6a 1b		 push	 27			; 0000001bH
  00891	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 247  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHATESTENABLE);

  00896	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0089c	6a 0f		 push	 15			; 0000000fH
  0089e	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 248  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAREF);

  008a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008a9	6a 18		 push	 24			; 00000018H
  008ab	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 249  : 	STATEMANAGER.RestoreRenderState(D3DRS_ALPHAFUNC);

  008b0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  008b6	6a 19		 push	 25			; 00000019H
  008b8	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
  008bd	5f		 pop	 edi
  008be	5e		 pop	 esi
  008bf	5b		 pop	 ebx

; 250  : 
; 251  : 	// Render State & TextureStageState
; 252  : 	//////////////////////////////////////////////////////////////////////////
; 253  : }

  008c0	8b e5		 mov	 esp, ebp
  008c2	5d		 pop	 ebp
  008c3	c3		 ret	 0
?__RenderTerrain_RenderHardwareTransformPatch@CMapOutdoor@@IAEXXZ ENDP ; CMapOutdoor::__RenderTerrain_RenderHardwareTransformPatch
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1705 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.h
;	COMDAT ??0D3DXMATRIX@@QAE@XZ
_TEXT	SEGMENT
??0D3DXMATRIX@@QAE@XZ PROC				; D3DXMATRIX::D3DXMATRIX, COMDAT
; _this$ = ecx

; 177  :     D3DXMATRIX() {};

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0D3DXMATRIX@@QAE@XZ ENDP				; D3DXMATRIX::D3DXMATRIX
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
