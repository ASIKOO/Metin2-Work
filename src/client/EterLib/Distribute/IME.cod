; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
PUBLIC	?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA	; CIME::_ImmUnlockIMC
PUBLIC	?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA	; CIME::_ImmLockIMCC
PUBLIC	?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA	; CIME::_ImmUnlockIMCC
PUBLIC	?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
PUBLIC	?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA	; CIME::_ShowReadingWindow
PUBLIC	?ms_bInitialized@CIME@@2_NA			; CIME::ms_bInitialized
PUBLIC	?ms_bDisableIMECompletely@CIME@@2_NA		; CIME::ms_bDisableIMECompletely
PUBLIC	?ms_bUILessMode@CIME@@2_NA			; CIME::ms_bUILessMode
PUBLIC	?ms_bImeEnabled@CIME@@2_NA			; CIME::ms_bImeEnabled
PUBLIC	?ms_bCaptureInput@CIME@@2_NA			; CIME::ms_bCaptureInput
PUBLIC	?ms_bChineseIME@CIME@@2_NA			; CIME::ms_bChineseIME
PUBLIC	?ms_bUseIMMCandidate@CIME@@2_NA			; CIME::ms_bUseIMMCandidate
PUBLIC	?ms_hWnd@CIME@@2PAUHWND__@@A			; CIME::ms_hWnd
PUBLIC	?ms_hklCurrent@CIME@@2PAUHKL__@@A		; CIME::ms_hklCurrent
PUBLIC	?ms_szKeyboardLayout@CIME@@2PADA		; CIME::ms_szKeyboardLayout
PUBLIC	?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A		; CIME::ms_stOSVI
PUBLIC	?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A		; CIME::ms_hImm32Dll
PUBLIC	?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A	; CIME::ms_hCurrentImeDll
PUBLIC	?ms_dwImeState@CIME@@2KA			; CIME::ms_dwImeState
PUBLIC	?ms_adwId@CIME@@2PAKA				; CIME::ms_adwId
PUBLIC	?ms_dwIMELevel@CIME@@2KA			; CIME::ms_dwIMELevel
PUBLIC	?ms_dwIMELevelSaved@CIME@@2KA			; CIME::ms_dwIMELevelSaved
PUBLIC	?ms_bCandidateList@CIME@@2_NA			; CIME::ms_bCandidateList
PUBLIC	?ms_dwCandidateCount@CIME@@2KA			; CIME::ms_dwCandidateCount
PUBLIC	?ms_bVerticalCandidate@CIME@@2_NA		; CIME::ms_bVerticalCandidate
PUBLIC	?ms_iCandListIndexBase@CIME@@2HA		; CIME::ms_iCandListIndexBase
PUBLIC	?ms_wszCandidate@CIME@@2PAY0BAA@_WA		; CIME::ms_wszCandidate
PUBLIC	?ms_dwCandidateSelection@CIME@@2KA		; CIME::ms_dwCandidateSelection
PUBLIC	?ms_dwCandidatePageSize@CIME@@2KA		; CIME::ms_dwCandidatePageSize
PUBLIC	?ms_bReadingInformation@CIME@@2_NA		; CIME::ms_bReadingInformation
PUBLIC	?ms_iReadingError@CIME@@2HA			; CIME::ms_iReadingError
PUBLIC	?ms_bHorizontalReading@CIME@@2_NA		; CIME::ms_bHorizontalReading
PUBLIC	?ms_wszCurrentIndicator@CIME@@2PA_WA		; CIME::ms_wszCurrentIndicator
PUBLIC	?ms_pEvent@CIME@@2PAVIIMEEventSink@@A		; CIME::ms_pEvent
PUBLIC	?m_wText@CIME@@2PA_WA				; CIME::m_wText
PUBLIC	?ms_compLen@CIME@@2HA				; CIME::ms_compLen
PUBLIC	?ms_curpos@CIME@@2HA				; CIME::ms_curpos
PUBLIC	?ms_lastpos@CIME@@2HA				; CIME::ms_lastpos
PUBLIC	?ms_ulbegin@CIME@@2HA				; CIME::ms_ulbegin
PUBLIC	?ms_ulend@CIME@@2HA				; CIME::ms_ulend
PUBLIC	?ms_uOutputCodePage@CIME@@2IA			; CIME::ms_uOutputCodePage
PUBLIC	?ms_uInputCodePage@CIME@@2IA			; CIME::ms_uInputCodePage
PUBLIC	?s_aszIndicator@@3PAY02_WA			; s_aszIndicator
PUBLIC	?gs_codePage@@3KA				; gs_codePage
PUBLIC	?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A	; CTsfUiLessMode::m_tm
PUBLIC	?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwUIElementSinkCookie
PUBLIC	?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA		; CTsfUiLessMode::m_dwAlpnSinkCookie
PUBLIC	?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwOpenModeSinkCookie
PUBLIC	?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA	; CTsfUiLessMode::m_dwConvModeSinkCookie
PUBLIC	?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
PUBLIC	?m_nCandidateRefCount@CTsfUiLessMode@@1HA	; CTsfUiLessMode::m_nCandidateRefCount
_BSS	SEGMENT
?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMC
?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA DD 01H DUP (?)	; CIME::_ImmUnlockIMC
?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmLockIMCC
?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA DD 01H DUP (?) ; CIME::_ImmUnlockIMCC
?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA DD 01H DUP (?) ; CIME::_GetReadingString
?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA DD 01H DUP (?) ; CIME::_ShowReadingWindow
?ms_bInitialized@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bInitialized
	ALIGN	4

?ms_bDisableIMECompletely@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bDisableIMECompletely
	ALIGN	4

?ms_bUILessMode@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUILessMode
	ALIGN	4

?ms_bImeEnabled@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bImeEnabled
	ALIGN	4

?ms_bCaptureInput@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCaptureInput
	ALIGN	4

?ms_bChineseIME@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bChineseIME
	ALIGN	4

?ms_bUseIMMCandidate@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bUseIMMCandidate
	ALIGN	4

?ms_hWnd@CIME@@2PAUHWND__@@A DD 01H DUP (?)		; CIME::ms_hWnd
?ms_hklCurrent@CIME@@2PAUHKL__@@A DD 01H DUP (?)	; CIME::ms_hklCurrent
?ms_szKeyboardLayout@CIME@@2PADA DB 0aH DUP (?)		; CIME::ms_szKeyboardLayout
	ALIGN	4

?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A DB 094H DUP (?)	; CIME::ms_stOSVI
?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?)	; CIME::ms_hImm32Dll
?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A DD 01H DUP (?) ; CIME::ms_hCurrentImeDll
?ms_dwImeState@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwImeState
?ms_adwId@CIME@@2PAKA DD 02H DUP (?)			; CIME::ms_adwId
?ms_dwIMELevel@CIME@@2KA DD 01H DUP (?)			; CIME::ms_dwIMELevel
?ms_dwIMELevelSaved@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwIMELevelSaved
?ms_bCandidateList@CIME@@2_NA DB 01H DUP (?)		; CIME::ms_bCandidateList
	ALIGN	4

?ms_dwCandidateCount@CIME@@2KA DD 01H DUP (?)		; CIME::ms_dwCandidateCount
?ms_bVerticalCandidate@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bVerticalCandidate
	ALIGN	4

?ms_iCandListIndexBase@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iCandListIndexBase
?ms_wszCandidate@CIME@@2PAY0BAA@_WA DW 0a00H DUP (?)	; CIME::ms_wszCandidate
?ms_dwCandidateSelection@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidateSelection
?ms_dwCandidatePageSize@CIME@@2KA DD 01H DUP (?)	; CIME::ms_dwCandidatePageSize
?ms_bReadingInformation@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bReadingInformation
	ALIGN	4

?ms_iReadingError@CIME@@2HA DD 01H DUP (?)		; CIME::ms_iReadingError
?ms_bHorizontalReading@CIME@@2_NA DB 01H DUP (?)	; CIME::ms_bHorizontalReading
	ALIGN	4

?ms_wszCurrentIndicator@CIME@@2PA_WA DD 01H DUP (?)	; CIME::ms_wszCurrentIndicator
?ms_pEvent@CIME@@2PAVIIMEEventSink@@A DD 01H DUP (?)	; CIME::ms_pEvent
?m_wText@CIME@@2PA_WA DW 0400H DUP (?)			; CIME::m_wText
?ms_compLen@CIME@@2HA DD 01H DUP (?)			; CIME::ms_compLen
?ms_curpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_curpos
?ms_lastpos@CIME@@2HA DD 01H DUP (?)			; CIME::ms_lastpos
?ms_ulbegin@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulbegin
?ms_ulend@CIME@@2HA DD 01H DUP (?)			; CIME::ms_ulend
?ms_uOutputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uOutputCodePage
?ms_uInputCodePage@CIME@@2IA DD 01H DUP (?)		; CIME::ms_uInputCodePage
?gs_codePage@@3KA DD 01H DUP (?)			; gs_codePage
?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A DD 01H DUP (?) ; CTsfUiLessMode::m_tm
?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A DD 01H DUP (?) ; CTsfUiLessMode::m_TsfSink
?m_nCandidateRefCount@CTsfUiLessMode@@1HA DD 01H DUP (?) ; CTsfUiLessMode::m_nCandidateRefCount
_BSS	ENDS
_DATA	SEGMENT
?s_aszIndicator@@3PAY02_WA DB 'E', 00H, 'n', 00H, 00H, 00H ; s_aszIndicator
	DB	080H, '{', 00H, 00H
	ORG $+2
	DB	'A~', 00H, 00H
	ORG $+2
	DB	00H, 0acH, 00H, 00H
	ORG $+2
	DB	'B0', 00H, 00H
	ORG $+2
	ORG $+2
?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwUIElementSinkCookie
?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH	; CTsfUiLessMode::m_dwAlpnSinkCookie
?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwOpenModeSinkCookie
?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA DD 0ffffffffH ; CTsfUiLessMode::m_dwConvModeSinkCookie
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CIME@@QAE@XZ					; CIME::CIME
PUBLIC	??1CIME@@UAE@XZ					; CIME::~CIME
PUBLIC	?Initialize@CIME@@QAE_NPAUHWND__@@@Z		; CIME::Initialize
PUBLIC	?Uninitialize@CIME@@QAEXXZ			; CIME::Uninitialize
PUBLIC	?Clear@CIME@@SAXXZ				; CIME::Clear
PUBLIC	?SetMax@CIME@@QAEXH@Z				; CIME::SetMax
PUBLIC	?SetUserMax@CIME@@QAEXH@Z			; CIME::SetUserMax
PUBLIC	?SetText@CIME@@QAEXPBDH@Z			; CIME::SetText
PUBLIC	?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CIME::GetText
PUBLIC	?GetCodePageText@CIME@@QAEPBDXZ			; CIME::GetCodePageText
PUBLIC	?GetCodePage@CIME@@QAEHXZ			; CIME::GetCodePage
PUBLIC	?GetCandidateCount@CIME@@QAEHXZ			; CIME::GetCandidateCount
PUBLIC	?GetCandidatePageCount@CIME@@QAEHXZ		; CIME::GetCandidatePageCount
PUBLIC	?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetCandidate
PUBLIC	?GetCandidateSelection@CIME@@QAEHXZ		; CIME::GetCandidateSelection
PUBLIC	?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CIME::GetReading
PUBLIC	?GetReadingError@CIME@@QAEHXZ			; CIME::GetReadingError
PUBLIC	?SetInputMode@CIME@@QAEXK@Z			; CIME::SetInputMode
PUBLIC	?GetInputMode@CIME@@QAEKXZ			; CIME::GetInputMode
PUBLIC	?IsIMEEnabled@CIME@@QAE_NXZ			; CIME::IsIMEEnabled
PUBLIC	?EnableIME@CIME@@QAEX_N@Z			; CIME::EnableIME
PUBLIC	?DisableIME@CIME@@QAEXXZ			; CIME::DisableIME
PUBLIC	?EnableCaptureInput@CIME@@QAEXXZ		; CIME::EnableCaptureInput
PUBLIC	?DisableCaptureInput@CIME@@QAEXXZ		; CIME::DisableCaptureInput
PUBLIC	?IsCaptureEnabled@CIME@@QAE_NXZ			; CIME::IsCaptureEnabled
PUBLIC	?SetNumberMode@CIME@@QAEXXZ			; CIME::SetNumberMode
PUBLIC	?SetStringMode@CIME@@QAEXXZ			; CIME::SetStringMode
PUBLIC	?__IsWritable@CIME@@QAE_N_W@Z			; CIME::__IsWritable
PUBLIC	?AddExceptKey@CIME@@QAEX_W@Z			; CIME::AddExceptKey
PUBLIC	?ClearExceptKey@CIME@@QAEXXZ			; CIME::ClearExceptKey
PUBLIC	?PasteTextFromClipBoard@CIME@@QAEXXZ		; CIME::PasteTextFromClipBoard
PUBLIC	?EnablePaste@CIME@@QAEX_N@Z			; CIME::EnablePaste
PUBLIC	?PasteString@CIME@@QAEXPBD@Z			; CIME::PasteString
PUBLIC	?FinalizeString@CIME@@SAX_N@Z			; CIME::FinalizeString
PUBLIC	?UseDefaultIME@CIME@@QAEXXZ			; CIME::UseDefaultIME
PUBLIC	?GetCurPos@CIME@@SAHXZ				; CIME::GetCurPos
PUBLIC	?GetCompLen@CIME@@SAHXZ				; CIME::GetCompLen
PUBLIC	?GetULBegin@CIME@@SAHXZ				; CIME::GetULBegin
PUBLIC	?GetULEnd@CIME@@SAHXZ				; CIME::GetULEnd
PUBLIC	?CloseCandidateList@CIME@@SAXXZ			; CIME::CloseCandidateList
PUBLIC	?CloseReadingInformation@CIME@@SAXXZ		; CIME::CloseReadingInformation
PUBLIC	?ChangeInputLanguage@CIME@@SAXXZ		; CIME::ChangeInputLanguage
PUBLIC	?ChangeInputLanguageWorker@CIME@@SAXXZ		; CIME::ChangeInputLanguageWorker
PUBLIC	?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMInputLanguage
PUBLIC	?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMStartComposition
PUBLIC	?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMComposition
PUBLIC	?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z	; CIME::WMEndComposition
PUBLIC	?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMNotify
PUBLIC	?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z		; CIME::WMChar
PUBLIC	?IncCurPos@CIME@@IAEXXZ				; CIME::IncCurPos
PUBLIC	?DecCurPos@CIME@@IAEXXZ				; CIME::DecCurPos
PUBLIC	?SetCurPos@CIME@@IAEXH@Z			; CIME::SetCurPos
PUBLIC	?DelCurPos@CIME@@IAEXXZ				; CIME::DelCurPos
PUBLIC	?CheckInputLocale@CIME@@KAXXZ			; CIME::CheckInputLocale
PUBLIC	?CheckToggleState@CIME@@KAXXZ			; CIME::CheckToggleState
PUBLIC	?SetSupportLevel@CIME@@KAXK@Z			; CIME::SetSupportLevel
PUBLIC	?InsertString@CIME@@IAEXPA_WH@Z			; CIME::InsertString
PUBLIC	?OnChar@CIME@@IAEX_W@Z				; CIME::OnChar
PUBLIC	?GetCodePageFromLang@CIME@@IAEIG@Z		; CIME::GetCodePageFromLang
PUBLIC	?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ResultProcess
PUBLIC	?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
PUBLIC	?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CompositionProcess
PUBLIC	?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::AttributeProcess
PUBLIC	?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z	; CIME::CandidateProcess
PUBLIC	?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z		; CIME::ReadingProcess
PUBLIC	?IsMax@CIME@@IAE_NPB_WH@Z			; CIME::IsMax
PUBLIC	?GetImeId@CIME@@IAEKI@Z				; CIME::GetImeId
PUBLIC	?GetReadingWindowOrientation@CIME@@IAE_NXZ	; CIME::GetReadingWindowOrientation
PUBLIC	?SetupImeApi@CIME@@KAXXZ			; CIME::SetupImeApi
PUBLIC	?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
PUBLIC	?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
PUBLIC	??_GCIME@@UAEPAXI@Z				; CIME::`scalar deleting destructor'
PUBLIC	??0CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::CUIElementSink
PUBLIC	??1CUIElementSink@CTsfUiLessMode@@QAE@XZ	; CTsfUiLessMode::CUIElementSink::~CUIElementSink
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::AddRef
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ	; CTsfUiLessMode::CUIElementSink::Release
PUBLIC	?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ; CTsfUiLessMode::CUIElementSink::BeginUIElement
PUBLIC	?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
PUBLIC	?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ; CTsfUiLessMode::CUIElementSink::EndUIElement
PUBLIC	?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ; CTsfUiLessMode::CUIElementSink::OnActivated
PUBLIC	?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ; CTsfUiLessMode::CUIElementSink::OnChange
PUBLIC	?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString
PUBLIC	?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings
PUBLIC	?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
PUBLIC	?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
PUBLIC	?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
PUBLIC	?SetupSinks@CTsfUiLessMode@@SAHXZ		; CTsfUiLessMode::SetupSinks
PUBLIC	?ReleaseSinks@CTsfUiLessMode@@SAXXZ		; CTsfUiLessMode::ReleaseSinks
PUBLIC	?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ	; CTsfUiLessMode::CurrentInputLocaleIsIme
PUBLIC	?UpdateImeState@CTsfUiLessMode@@SAXH@Z		; CTsfUiLessMode::UpdateImeState
PUBLIC	?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z	; CTsfUiLessMode::EnableUiUpdates
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>
PUBLIC	??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
PUBLIC	??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ; std::_Destroy_range<std::allocator<wchar_t> >
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
PUBLIC	??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z	; std::_Copy_memmove<wchar_t *,wchar_t *>
PUBLIC	??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z		; std::_Refancy<wchar_t *,0>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z		; std::_Zero_range<wchar_t *>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
PUBLIC	?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
PUBLIC	?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
PUBLIC	?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
PUBLIC	??_7CIME@@6B@					; CIME::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
PUBLIC	__GUID_aa80e801_2021_11d2_93e0_0060b067b86e
PUBLIC	??_C@_0L@LPOFADGE@?2imm32?4dll@			; `string'
PUBLIC	??_C@_0L@JGAMEFKO@ImmLockIMC@			; `string'
PUBLIC	??_C@_0N@PDIACEGP@ImmUnlockIMC@			; `string'
PUBLIC	??_C@_0M@OKKMJOGM@ImmLockIMCC@			; `string'
PUBLIC	??_C@_0O@GKKOACL@ImmUnlockIMCC@			; `string'
PUBLIC	??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@	; `string'
PUBLIC	??_C@_05JKJMOPAK@?$EA?$CF04d@			; `string'
PUBLIC	??_C@_05EFEJGKEJ@?$EA9999@			; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_0N@FFMHCBAD@TINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@JMLDIBIB@CINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@FHDFFBN@MSTCIPHA?4IME@			; `string'
PUBLIC	??_C@_0N@JFHOELJF@PINTLGNT?4IME@		; `string'
PUBLIC	??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@		; `string'
PUBLIC	??_C@_01KICIPPFI@?2@				; `string'
PUBLIC	??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ ; `string'
PUBLIC	??_C@_07DEJAPC@MSTCIPH@				; `string'
PUBLIC	??_C@_08LMKCILHO@TINTLGNT@			; `string'
PUBLIC	??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@		; `string'
PUBLIC	??_C@_0N@EMABPIGL@QQPINYIN?4IME@		; `string'
PUBLIC	??_C@_0M@IPABOCGB@SOGOUPY?4IME@			; `string'
PUBLIC	??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@		; `string'
PUBLIC	??_C@_0BB@EOIFCLLM@GetReadingString@		; `string'
PUBLIC	??_C@_0BC@MEELNKEC@ShowReadingWindow@		; `string'
PUBLIC	__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
PUBLIC	__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
PUBLIC	__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
PUBLIC	__GUID_743abd5f_f26d_48df_8cc5_238492419b64
PUBLIC	__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
PUBLIC	__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
PUBLIC	__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R0?AUIUnknown@@@8				; IUnknown `RTTI Type Descriptor'
PUBLIC	??_R3IUnknown@@8				; IUnknown::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IUnknown@@8				; IUnknown::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CIME@@6B@					; CIME::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCIME@@@8				; CIME `RTTI Type Descriptor'
PUBLIC	??_R3CIME@@8					; CIME::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CIME@@8					; CIME::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CIME@@8				; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfCompartmentEventSink@@@8		; ITfCompartmentEventSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfCompartmentEventSink@@8			; ITfCompartmentEventSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfCompartmentEventSink@@8	; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfInputProcessorProfileActivationSink@@8	; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AUITfUIElementSink@@@8			; ITfUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ITfUIElementSink@@8			; ITfUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ITfUIElementSink@@8		; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCUIElementSink@CTsfUiLessMode@@@8	; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
PUBLIC	??_R3CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CUIElementSink@CTsfUiLessMode@@8		; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8	; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
PUBLIC	??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R17?0A@EA@ITfCompartmentEventSink@@8		; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R17?0A@EC@IUnknown@@8			; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
PUBLIC	??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	_iswdigit:PROC
EXTRN	_towlower:PROC
EXTRN	__stricmp:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GlobalUnlock@4:PROC
EXTRN	__imp__GlobalLock@4:PROC
EXTRN	__imp__lstrlenW@4:PROC
EXTRN	__imp__GetKeyboardLayoutNameA@4:PROC
EXTRN	__imp__GetKeyboardLayout@4:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__OpenClipboard@4:PROC
EXTRN	__imp__CloseClipboard@0:PROC
EXTRN	__imp__GetClipboardData@4:PROC
EXTRN	__imp__CharNextW@4:PROC
EXTRN	__imp__MultiByteToWideChar@24:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__CompareStringA@24:PROC
EXTRN	__imp__GetLocaleInfoA@16:PROC
EXTRN	_GetFileVersionInfoSizeA@8:PROC
EXTRN	_GetFileVersionInfoA@16:PROC
EXTRN	_VerQueryValueA@16:PROC
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	_ImmGetIMEFileNameA@12:PROC
EXTRN	_ImmIsIME@4:PROC
EXTRN	_ImmGetContext@4:PROC
EXTRN	_ImmReleaseContext@8:PROC
EXTRN	_ImmAssociateContext@8:PROC
EXTRN	_ImmGetCompositionStringW@16:PROC
EXTRN	_ImmSetCompositionStringW@24:PROC
EXTRN	_ImmGetCandidateListW@16:PROC
EXTRN	_ImmGetConversionStatus@12:PROC
EXTRN	_ImmSetConversionStatus@12:PROC
EXTRN	_ImmGetOpenStatus@4:PROC
EXTRN	_ImmNotifyIME@16:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitializeEx@8:PROC
EXTRN	__imp__CoCreateInstance@20:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??_ECIME@@UAEPAXI@Z:PROC			; CIME::`vector deleting destructor'
EXTRN	?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z:PROC ; GetTextTagOutputString
EXTRN	?GetTextTagOutputLen@@YAHPB_WH@Z:PROC		; GetTextTagOutputLen
EXTRN	?FindColorTagEndPosition@@YAHPB_WH@Z:PROC	; FindColorTagEndPosition
EXTRN	?FindColorTagStartPosition@@YAHPB_WH@Z:PROC	; FindColorTagStartPosition
EXTRN	?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z:PROC ; GetTextTagInternalPosFromRenderPos
EXTRN	?MIN@@YAHHH@Z:PROC				; MIN
EXTRN	__imp__SysFreeString@4:PROC
EXTRN	__imp__VariantClear@4:PROC
EXTRN	?GetDefaultCodePage@@YAKXZ:PROC			; GetDefaultCodePage
EXTRN	?ReadToken@@YAHPBD@Z:PROC			; ReadToken
EXTRN	?FindToken@@YAPBDPBD0@Z:PROC			; FindToken
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IUnknown:BYTE
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	_CLSID_TF_ThreadMgr:BYTE
EXTRN	_CLSID_TF_InputProcessorProfiles:BYTE
EXTRN	_GUID_COMPARTMENT_KEYBOARD_OPENCLOSE:BYTE
EXTRN	_GUID_TFCAT_TIP_KEYBOARD:BYTE
EXTRN	_IID_ITfCompartmentEventSink:BYTE
EXTRN	_IID_ITfCompartmentMgr:BYTE
EXTRN	_IID_ITfSource:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A DB 0cH DUP (?) ; CIME::ms_wstrReading
	ALIGN	8

?g_disableCicero@@3VCDisableCicero@@A DQ 01H DUP (?)	; g_disableCicero
_BSS	ENDS
;	COMDAT ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
_BSS	SEGMENT
?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA DB 010H DUP (?) ; `CIME::GetCodePageText'::`2'::szCodePage
_BSS	ENDS
;	COMDAT ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA
_BSS	SEGMENT
?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA DB 01H DUP (?) ; `CIME::FinalizeString'::`2'::s_bProcessing
_BSS	ENDS
;	COMDAT ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A
_BSS	SEGMENT
?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::GetImeId'::`2'::hklPrev
_BSS	ENDS
;	COMDAT ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A
_BSS	SEGMENT
?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A DD 01H DUP (?) ; `CIME::CheckInputLocale'::`2'::s_hklPrev
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; ??ms_wstrReading$initializer$@CIME@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R17?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (8,-1,0,66)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R17?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	01H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R13?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EC@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EC@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,66)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R2CUIElementSink@CTsfUiLessMode@@8 DD FLAT:??_R1A@?0A@EA@CUIElementSink@CTsfUiLessMode@@8 ; CTsfUiLessMode::CUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8
	DD	FLAT:??_R1A@?0A@EC@IUnknown@@8
	DD	FLAT:??_R13?0A@EA@ITfInputProcessorProfileActivationSink@@8
	DD	FLAT:??_R13?0A@EC@IUnknown@@8
	DD	FLAT:??_R17?0A@EA@ITfCompartmentEventSink@@8
	DD	FLAT:??_R17?0A@EC@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	SEGMENT
??_R3CUIElementSink@CTsfUiLessMode@@8 DD 00H		; CTsfUiLessMode::CUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	07H
	DD	FLAT:??_R2CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
data$rs	SEGMENT
??_R0?AVCUIElementSink@CTsfUiLessMode@@@8 DD FLAT:??_7type_info@@6B@ ; CTsfUiLessMode::CUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCUIElementSink@CTsfUiLessMode@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
rdata$r	SEGMENT
??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD 00H ; CTsfUiLessMode::CUIElementSink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCUIElementSink@CTsfUiLessMode@@@8
	DD	FLAT:??_R3CUIElementSink@CTsfUiLessMode@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfUIElementSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfUIElementSink@@8 DD FLAT:??_R0?AUITfUIElementSink@@@8 ; ITfUIElementSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfUIElementSink@@8
rdata$r	SEGMENT
??_R2ITfUIElementSink@@8 DD FLAT:??_R1A@?0A@EA@ITfUIElementSink@@8 ; ITfUIElementSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfUIElementSink@@8
rdata$r	SEGMENT
??_R3ITfUIElementSink@@8 DD 00H				; ITfUIElementSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfUIElementSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfUIElementSink@@@8
data$rs	SEGMENT
??_R0?AUITfUIElementSink@@@8 DD FLAT:??_7type_info@@6B@	; ITfUIElementSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfUIElementSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R0?AUITfInputProcessorProfileActivationSink@@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R2ITfInputProcessorProfileActivationSink@@8 DD FLAT:??_R1A@?0A@EA@ITfInputProcessorProfileActivationSink@@8 ; ITfInputProcessorProfileActivationSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfInputProcessorProfileActivationSink@@8
rdata$r	SEGMENT
??_R3ITfInputProcessorProfileActivationSink@@8 DD 00H	; ITfInputProcessorProfileActivationSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfInputProcessorProfileActivationSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfInputProcessorProfileActivationSink@@@8
data$rs	SEGMENT
??_R0?AUITfInputProcessorProfileActivationSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfInputProcessorProfileActivationSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfInputProcessorProfileActivationSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ITfCompartmentEventSink@@8 DD FLAT:??_R0?AUITfCompartmentEventSink@@@8 ; ITfCompartmentEventSink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R2ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R2ITfCompartmentEventSink@@8 DD FLAT:??_R1A@?0A@EA@ITfCompartmentEventSink@@8 ; ITfCompartmentEventSink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R3ITfCompartmentEventSink@@8
rdata$r	SEGMENT
??_R3ITfCompartmentEventSink@@8 DD 00H			; ITfCompartmentEventSink::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ITfCompartmentEventSink@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUITfCompartmentEventSink@@@8
data$rs	SEGMENT
??_R0?AUITfCompartmentEventSink@@@8 DD FLAT:??_7type_info@@6B@ ; ITfCompartmentEventSink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUITfCompartmentEventSink@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CIME@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CIME@@8 DD FLAT:??_R0?AVCIME@@@8		; CIME::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R2CIME@@8
rdata$r	SEGMENT
??_R2CIME@@8 DD	FLAT:??_R1A@?0A@EA@CIME@@8		; CIME::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CIME@@8
rdata$r	SEGMENT
??_R3CIME@@8 DD	00H					; CIME::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CIME@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCIME@@@8
data$rs	SEGMENT
??_R0?AVCIME@@@8 DD FLAT:??_7type_info@@6B@		; CIME `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCIME@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CIME@@6B@
rdata$r	SEGMENT
??_R4CIME@@6B@ DD 00H					; CIME::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCIME@@@8
	DD	FLAT:??_R3CIME@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IUnknown@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IUnknown@@8 DD FLAT:??_R0?AUIUnknown@@@8	; IUnknown::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R2IUnknown@@8
rdata$r	SEGMENT
??_R2IUnknown@@8 DD FLAT:??_R1A@?0A@EA@IUnknown@@8	; IUnknown::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3IUnknown@@8
rdata$r	SEGMENT
??_R3IUnknown@@8 DD 00H					; IUnknown::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2IUnknown@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUIUnknown@@@8
data$rs	SEGMENT
??_R0?AUIUnknown@@@8 DD FLAT:??_7type_info@@6B@		; IUnknown `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUIUnknown@@', 00H
data$rs	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
_DATA	SEGMENT
?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A DD 0ccf05dd8H ; `CTsfUiLessMode::GetCompartments'::`2'::_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION
	DW	04a87H
	DW	011d7H
	DB	0a6H
	DB	0e2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
_DATA	ENDS
;	COMDAT __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74c_0f28_11d8_a82a_00065b84435c DD 071c6e74cH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
CONST	SEGMENT
__GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca DD 01f02b6c5H
	DW	07842H
	DW	04ee6H
	DB	08aH
	DB	0bH
	DB	09aH
	DB	024H
	DB	018H
	DB	03aH
	DB	095H
	DB	0caH
CONST	ENDS
;	COMDAT __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea135_19df_11d7_a6d2_00065b84435c DD 0ea1ea135H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
_DATA	SEGMENT
?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A DD 037b2c25H ; `CTsfUiLessMode::CUIElementSink::OnActivated'::`2'::TF_PROFILE_DAYI
	DW	0480cH
	DW	04d7fH
	DB	0b0H
	DB	027H
	DB	0d6H
	DB	0caH
	DB	06bH
	DB	069H
	DB	078H
	DB	08aH
_DATA	ENDS
;	COMDAT __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea138_19df_11d7_a6d2_00065b84435c DD 0ea1ea138H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea139_19df_11d7_a6d2_00065b84435c DD 0ea1ea139H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_743abd5f_f26d_48df_8cc5_238492419b64
CONST	SEGMENT
__GUID_743abd5f_f26d_48df_8cc5_238492419b64 DD 0743abd5fH
	DW	0f26dH
	DW	048dfH
	DB	08cH
	DB	0c5H
	DB	023H
	DB	084H
	DB	092H
	DB	041H
	DB	09bH
	DB	064H
CONST	ENDS
;	COMDAT __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
CONST	SEGMENT
__GUID_71c6e74e_0f28_11d8_a82a_00065b84435c DD 071c6e74eH
	DW	0f28H
	DW	011d8H
	DB	0a8H
	DB	02aH
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
CONST	SEGMENT
__GUID_ea1ea136_19df_11d7_a6d2_00065b84435c DD 0ea1ea136H
	DW	019dfH
	DW	011d7H
	DB	0a6H
	DB	0d2H
	DB	00H
	DB	06H
	DB	05bH
	DB	084H
	DB	043H
	DB	05cH
CONST	ENDS
;	COMDAT __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
CONST	SEGMENT
__GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7 DD 04ea48a35H
	DW	060aeH
	DW	0446fH
	DB	08fH
	DB	0d6H
	DB	0e6H
	DB	0a8H
	DB	0d8H
	DB	024H
	DB	059H
	DB	0f7H
CONST	ENDS
;	COMDAT __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
CONST	SEGMENT
__GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c DD 03e90ade3H
	DW	07594H
	DW	04cb0H
	DB	0bbH
	DB	058H
	DB	069H
	DB	062H
	DB	08fH
	DB	05fH
	DB	045H
	DB	08cH
CONST	ENDS
;	COMDAT ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA
_DATA	SEGMENT
?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA DD 0ffffH ; `CIME::CheckInputLocale'::`2'::s_uPrevCodePage
_DATA	ENDS
;	COMDAT ??_C@_0BC@MEELNKEC@ShowReadingWindow@
CONST	SEGMENT
??_C@_0BC@MEELNKEC@ShowReadingWindow@ DB 'ShowReadingWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EOIFCLLM@GetReadingString@
CONST	SEGMENT
??_C@_0BB@EOIFCLLM@GetReadingString@ DB 'GetReadingString', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
CONST	SEGMENT
??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@ DB 'GOOGLEPINYIN2.IME', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
CONST	SEGMENT
??_C@_0M@IPABOCGB@SOGOUPY?4IME@ DB 'SOGOUPY.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
CONST	SEGMENT
??_C@_0N@EMABPIGL@QQPINYIN?4IME@ DB 'QQPINYIN.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
CONST	SEGMENT
??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@ DB 'Keyboard Mapping', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMKCILHO@TINTLGNT@
CONST	SEGMENT
??_C@_08LMKCILHO@TINTLGNT@ DB 'TINTLGNT', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DEJAPC@MSTCIPH@
CONST	SEGMENT
??_C@_07DEJAPC@MSTCIPH@ DB 'MSTCIPH', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
CONST	SEGMENT
??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@ DB 'software\micro'
	DB	'soft\windows\currentversion\', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KICIPPFI@?2@
CONST	SEGMENT
??_C@_01KICIPPFI@?2@ DB '\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
CONST	SEGMENT
??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@ DB 'MSSCIPYA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JFHOELJF@PINTLGNT?4IME@ DB 'PINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
CONST	SEGMENT
??_C@_0N@FHDFFBN@MSTCIPHA?4IME@ DB 'MSTCIPHA.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@JMLDIBIB@CINTLGNT?4IME@ DB 'CINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
CONST	SEGMENT
??_C@_0N@FFMHCBAD@TINTLGNT?4IME@ DB 'TINTLGNT.IME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05EFEJGKEJ@?$EA9999@
CONST	SEGMENT
??_C@_05EFEJGKEJ@?$EA9999@ DB '@9999', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05JKJMOPAK@?$EA?$CF04d@
CONST	SEGMENT
??_C@_05JKJMOPAK@?$EA?$CF04d@ DB '@%04d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
CONST	SEGMENT
??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@ DB 'ImmDisableTextFrameSer'
	DB	'vice', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GKKOACL@ImmUnlockIMCC@
CONST	SEGMENT
??_C@_0O@GKKOACL@ImmUnlockIMCC@ DB 'ImmUnlockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OKKMJOGM@ImmLockIMCC@
CONST	SEGMENT
??_C@_0M@OKKMJOGM@ImmLockIMCC@ DB 'ImmLockIMCC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PDIACEGP@ImmUnlockIMC@
CONST	SEGMENT
??_C@_0N@PDIACEGP@ImmUnlockIMC@ DB 'ImmUnlockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JGAMEFKO@ImmLockIMC@
CONST	SEGMENT
??_C@_0L@JGAMEFKO@ImmLockIMC@ DB 'ImmLockIMC', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LPOFADGE@?2imm32?4dll@
CONST	SEGMENT
??_C@_0L@LPOFADGE@?2imm32?4dll@ DB '\imm32.dll', 00H	; `string'
CONST	ENDS
;	COMDAT __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
CONST	SEGMENT
__GUID_aa80e801_2021_11d2_93e0_0060b067b86e DD 0aa80e801H
	DW	02021H
	DW	011d2H
	DB	093H
	DB	0e0H
	DB	00H
	DB	060H
	DB	0b0H
	DB	067H
	DB	0b8H
	DB	06eH
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
	DD	FLAT:?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
	DD	FLAT:?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
CONST	ENDS
;	COMDAT ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
CONST	SEGMENT
??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ DD FLAT:??_R4CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@ ; CTsfUiLessMode::CUIElementSink::`vftable'
	DD	FLAT:?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
	DD	FLAT:?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
	DD	FLAT:?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
	DD	FLAT:?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
	DD	FLAT:?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
CONST	ENDS
;	COMDAT ??_7CIME@@6B@
CONST	SEGMENT
??_7CIME@@6B@ DD FLAT:??_R4CIME@@6B@			; CIME::`vftable'
	DD	FLAT:??_ECIME@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Fg_disableCicero@@YAXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??__Fg_disableCicero@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Fg_disableCicero@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDisableCicero@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0
__ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsMax@CIME@@IAE_NPB_WH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0
__ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0
__ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?PasteTextFromClipBoard@CIME@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
?g_disableCicero$initializer$@@3P6AXXZA DD FLAT:??__Eg_disableCicero@@YAXXZ ; g_disableCicero$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W7AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}', COMDAT
  00000	83 6c 24 04 08	 sub	 DWORD PTR [esp+4], 8
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W7AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{8}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::Release
?Release@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::Release`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ
_TEXT	SEGMENT
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ PROC	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ; CTsfUiLessMode::CUIElementSink::AddRef
?AddRef@CUIElementSink@CTsfUiLessMode@@W3AGKXZ ENDP	; [thunk]:CTsfUiLessMode::CUIElementSink::AddRef`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z PROC ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}', COMDAT
  00000	83 6c 24 04 04	 sub	 DWORD PTR [esp+4], 4
  00005	e9 00 00 00 00	 jmp	 ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ; CTsfUiLessMode::CUIElementSink::QueryInterface
?QueryInterface@CUIElementSink@CTsfUiLessMode@@W3AGJABU_GUID@@PAPAX@Z ENDP ; [thunk]:CTsfUiLessMode::CUIElementSink::QueryInterface`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4367 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);
; 1690 :     const auto _ULast = _Get_unwrapped(_Last);
; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00007	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000a	57		 push	 edi
  0000b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>

; 1694 :         return _Dest + (_ULast - _UFirst);

  00013	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	03 7d 10	 add	 edi, DWORD PTR __Dest$[ebp]
  0001c	8b c7		 mov	 eax, edi
  0001e	5f		 pop	 edi

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z PROC		; std::_Zero_range<wchar_t *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1856 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1857 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ENDP		; std::_Zero_range<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00003	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00009	2b ca		 sub	 ecx, edx
  0000b	51		 push	 ecx
  0000c	6a 00		 push	 0
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memset

; 1856 :     return _Last;

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1857 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z PROC		; std::_Refancy<wchar_t *,0>, COMDAT

; 261  : _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 262  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 263  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ENDP		; std::_Refancy<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z PROC	; std::_Copy_memmove<wchar_t *,wchar_t *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	56		 push	 esi

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 75 10	 mov	 esi, DWORD PTR __Dest$[ebp]
  0000a	57		 push	 edi
  0000b	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 4367 : }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ENDP	; std::_Copy_memmove<wchar_t *,wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	56		 push	 esi
  0000a	8d 34 41	 lea	 esi, DWORD PTR [ecx+eax*2]
  0000d	56		 push	 esi
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Zero_range@PA_W@std@@YAPA_WQA_W0@Z ; std::_Zero_range<wchar_t *>
  00014	83 c4 08	 add	 esp, 8

; 1868 :         return _First + _Count;

  00017	8b c6		 mov	 eax, esi
  00019	5e		 pop	 esi

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z PROC ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);
; 1690 :     const auto _ULast = _Get_unwrapped(_Last);
; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00004	8b 5d 10	 mov	 ebx, DWORD PTR __Dest$[ebp]
  00007	57		 push	 edi
  00008	8b 7d 0c	 mov	 edi, DWORD PTR __Last$[ebp]
  0000b	53		 push	 ebx
  0000c	57		 push	 edi
  0000d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>

; 1694 :         return _Dest + (_ULast - _UFirst);

  00015	2b 7d 08	 sub	 edi, DWORD PTR __First$[ebp]
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001b	d1 ff		 sar	 edi, 1
  0001d	8d 04 7b	 lea	 eax, DWORD PTR [ebx+edi*2]
  00020	5f		 pop	 edi
  00021	5b		 pop	 ebx

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ENDP ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1863 :     // value-initialize _Count objects to raw _First, using _Al
; 1864 :     using _Ptrty = typename _Alloc::value_type*;
; 1865 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1866 :         auto _PFirst = _Unfancy(_First);
; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR __Count$[ebp]
  0000a	03 f1		 add	 esi, ecx
  0000c	56		 push	 esi
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00013	83 c4 08	 add	 esp, 8

; 1868 :         return _First + _Count;

  00016	8b c6		 mov	 eax, esi
  00018	5e		 pop	 esi

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
tv347 = -4						; size = 4
__Newvec$1$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1183 :         if (_Newsize > max_size()) {

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00012	0f 87 99 00 00
	00		 ja	 $LN35@Resize_rea

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00018	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00020	2b 0e		 sub	 ecx, DWORD PTR [esi]

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00022	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00025	2b 1e		 sub	 ebx, DWORD PTR [esi]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00027	d1 f9		 sar	 ecx, 1

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00029	8b d1		 mov	 edx, ecx

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0002b	d1 fb		 sar	 ebx, 1

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002d	d1 ea		 shr	 edx, 1
  0002f	2b c2		 sub	 eax, edx
  00031	3b c8		 cmp	 ecx, eax
  00033	76 65		 jbe	 SHORT $LN10@Resize_rea

; 1621 :             return _Max; // geometric growth would overflow

  00035	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
$LN18@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 65   :     return _Count * _Ty_size;

  0003a	03 c0		 add	 eax, eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003c	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  0003d	89 45 fc	 mov	 DWORD PTR tv347[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00040	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00045	8b cf		 mov	 ecx, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00047	89 45 08	 mov	 DWORD PTR __Newvec$1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0004a	2b cb		 sub	 ecx, ebx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  0004c	56		 push	 esi
  0004d	51		 push	 ecx

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1193 : 
; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  0004e	8d 0c 58	 lea	 ecx, DWORD PTR [eax+ebx*2]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00057	8b 5d 08	 mov	 ebx, DWORD PTR __Newvec$1$[ebp]
  0005a	56		 push	 esi
  0005b	53		 push	 ebx
  0005c	ff 76 04	 push	 DWORD PTR [esi+4]
  0005f	ff 36		 push	 DWORD PTR [esi]
  00061	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00066	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00068	83 c4 20	 add	 esp, 32			; 00000020H

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  0006b	85 c9		 test	 ecx, ecx
  0006d	74 12		 je	 SHORT $LN29@Resize_rea

; 1677 :             _Destroy(_Myfirst, _Mylast);
; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0006f	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00072	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00074	83 e0 fe	 and	 eax, -2			; fffffffeH
  00077	50		 push	 eax
  00078	51		 push	 ecx
  00079	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0007e	83 c4 08	 add	 esp, 8
$LN29@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00081	8d 04 7b	 lea	 eax, DWORD PTR [ebx+edi*2]
  00084	89 1e		 mov	 DWORD PTR [esi], ebx
  00086	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  00089	8b 45 fc	 mov	 eax, DWORD PTR tv347[ebp]
  0008c	03 c3		 add	 eax, ebx
  0008e	5f		 pop	 edi
  0008f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00092	5e		 pop	 esi
  00093	5b		 pop	 ebx

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);
; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1204 :         _RERAISE;
; 1205 :         _CATCH_END
; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1208 :     }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c2 08 00	 ret	 8
$LN10@Resize_rea:

; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0009a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0009d	3b c7		 cmp	 eax, edi
  0009f	73 04		 jae	 SHORT $LN11@Resize_rea

; 1627 :             return _Newsize; // geometric growth would be insufficient

  000a1	8b c7		 mov	 eax, edi
  000a3	eb 95		 jmp	 SHORT $LN18@Resize_rea
$LN11@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  000a5	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000aa	76 8e		 jbe	 SHORT $LN18@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000ac	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN35@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1184 :             _Xlength();

  000b1	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN33@Resize_rea:
  000b6	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldsize$1$ = -4					; size = 4
__Newvec$1$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 1183 :         if (_Newsize > max_size()) {

  00007	8b 7d 08	 mov	 edi, DWORD PTR __Newsize$[ebp]
  0000a	8b f1		 mov	 esi, ecx
  0000c	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  00012	0f 87 86 00 00
	00		 ja	 $LN30@Resize_rea

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00018	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;
; 1188 :         pointer& _Myfirst = _My_data._Myfirst;
; 1189 :         pointer& _Mylast  = _My_data._Mylast;
; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  00020	2b 0e		 sub	 ecx, DWORD PTR [esi]
  00022	89 4d fc	 mov	 DWORD PTR __Oldsize$1$[ebp], ecx

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00025	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  00028	2b 0e		 sub	 ecx, DWORD PTR [esi]

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002a	8b d1		 mov	 edx, ecx
  0002c	d1 ea		 shr	 edx, 1
  0002e	2b c2		 sub	 eax, edx
  00030	3b c8		 cmp	 ecx, eax
  00032	76 07		 jbe	 SHORT $LN10@Resize_rea

; 1621 :             return _Max; // geometric growth would overflow

  00034	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00039	eb 08		 jmp	 SHORT $LN11@Resize_rea
$LN10@Resize_rea:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0003b	8d 1c 0a	 lea	 ebx, DWORD PTR [edx+ecx]

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0003e	3b df		 cmp	 ebx, edi
  00040	0f 42 df	 cmovb	 ebx, edi
$LN11@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00043	53		 push	 ebx
  00044	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00049	8b 55 fc	 mov	 edx, DWORD PTR __Oldsize$1$[ebp]
  0004c	8b cf		 mov	 ecx, edi
  0004e	2b ca		 sub	 ecx, edx
  00050	89 45 08	 mov	 DWORD PTR __Newvec$1$[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00053	56		 push	 esi
  00054	51		 push	 ecx

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);
; 1193 : 
; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);
; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  00055	8d 0c 10	 lea	 ecx, DWORD PTR [eax+edx]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0005e	56		 push	 esi
  0005f	ff 75 08	 push	 DWORD PTR __Newvec$1$[ebp]
  00062	ff 76 04	 push	 DWORD PTR [esi+4]
  00065	ff 36		 push	 DWORD PTR [esi]
  00067	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  0006c	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0006e	83 c4 20	 add	 esp, 32			; 00000020H

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00071	85 c9		 test	 ecx, ecx
  00073	74 0f		 je	 SHORT $LN24@Resize_rea

; 1677 :             _Destroy(_Myfirst, _Mylast);
; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00075	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00078	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007a	50		 push	 eax
  0007b	51		 push	 ecx
  0007c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00081	83 c4 08	 add	 esp, 8
$LN24@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00084	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$1$[ebp]
  00087	89 0e		 mov	 DWORD PTR [esi], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00089	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0008c	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  0008f	8d 04 19	 lea	 eax, DWORD PTR [ecx+ebx]
  00092	5f		 pop	 edi
  00093	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);
; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);
; 1204 :         _RERAISE;
; 1205 :         _CATCH_END
; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 1208 :     }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
$LN30@Resize_rea:

; 1184 :             _Xlength();

  0009e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN28@Resize_rea:
  000a3	cc		 int	 3
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z PROC ; std::_Destroy_range<std::allocator<wchar_t> >, COMDAT

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_range@V?$allocator@_W@std@@@std@@YAXPA_WQA_WAAV?$allocator@_W@0@@Z ENDP ; std::_Destroy_range<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z
_TEXT	SEGMENT
tv435 = -12						; size = 4
__Newsize$1$ = -8					; size = 4
tv434 = -4						; size = 4
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;
; 729  :         pointer& _Myfirst = _My_data._Myfirst;
; 730  :         pointer& _Mylast  = _My_data._Mylast;
; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00007	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	57		 push	 edi
  0000e	8b 16		 mov	 edx, DWORD PTR [esi]
  00010	2b da		 sub	 ebx, edx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00012	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00015	2b c2		 sub	 eax, edx
  00017	d1 fb		 sar	 ebx, 1
  00019	d1 f8		 sar	 eax, 1

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  0001b	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00020	0f 84 c1 00 00
	00		 je	 $LN39@Emplace_re

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00026	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  00029	8d 78 01	 lea	 edi, DWORD PTR [eax+1]

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0002c	2b ca		 sub	 ecx, edx

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  0002e	89 7d f8	 mov	 DWORD PTR __Newsize$1$[ebp], edi

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00031	d1 f9		 sar	 ecx, 1

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00033	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00038	8b d1		 mov	 edx, ecx
  0003a	d1 ea		 shr	 edx, 1
  0003c	2b c2		 sub	 eax, edx
  0003e	3b c8		 cmp	 ecx, eax
  00040	76 38		 jbe	 SHORT $LN12@Emplace_re

; 1621 :             return _Max; // geometric growth would overflow

  00042	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
$LN20@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 65   :     return _Count * _Ty_size;

  00047	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0004a	50		 push	 eax

; 65   :     return _Count * _Ty_size;

  0004b	89 45 f4	 mov	 DWORD PTR tv435[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0004e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00056	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00058	8d 04 5f	 lea	 eax, DWORD PTR [edi+ebx*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0005b	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0005e	8b 5d 08	 mov	 ebx, DWORD PTR __Whereptr$[ebp]
  00061	89 45 fc	 mov	 DWORD PTR tv434[ebp], eax
  00064	66 8b 09	 mov	 cx, WORD PTR [ecx]
  00067	66 89 08	 mov	 WORD PTR [eax], cx
  0006a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0006d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0006f	3b da		 cmp	 ebx, edx
  00071	75 1b		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00073	8b 5d fc	 mov	 ebx, DWORD PTR tv434[ebp]

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00076	8b c7		 mov	 eax, edi

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
; 754  :         } else { // provide basic guarantee

  00078	eb 2b		 jmp	 SHORT $LN5@Emplace_re
$LN12@Emplace_re:

; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007a	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0007d	8b cf		 mov	 ecx, edi
  0007f	3b c7		 cmp	 eax, edi
  00081	0f 43 c8	 cmovae	 ecx, eax
  00084	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH
  0008a	77 60		 ja	 SHORT $LN40@Emplace_re
  0008c	eb b9		 jmp	 SHORT $LN20@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0008e	56		 push	 esi
  0008f	57		 push	 edi
  00090	53		 push	 ebx
  00091	51		 push	 ecx
  00092	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >
  00097	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0009a	8b cb		 mov	 ecx, ebx

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  0009c	8b 5d fc	 mov	 ebx, DWORD PTR tv434[ebp]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0009f	83 c4 10	 add	 esp, 16			; 00000010H

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000a2	8d 43 02	 lea	 eax, DWORD PTR [ebx+2]
$LN5@Emplace_re:
  000a5	56		 push	 esi
  000a6	50		 push	 eax
  000a7	52		 push	 edx
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PA_WV?$allocator@_W@std@@@std@@YAPA_WQA_W0PA_WAAV?$allocator@_W@0@@Z ; std::_Uninitialized_move<wchar_t *,std::allocator<wchar_t> >

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  000ae	8b 0e		 mov	 ecx, DWORD PTR [esi]

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);
; 756  :             _Constructed_first = _Newvec;
; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  000b0	83 c4 10	 add	 esp, 16			; 00000010H

; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  000b3	85 c9		 test	 ecx, ecx
  000b5	74 12		 je	 SHORT $LN33@Emplace_re

; 1677 :             _Destroy(_Myfirst, _Mylast);
; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b7	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  000ba	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000bc	83 e0 fe	 and	 eax, -2			; fffffffeH
  000bf	50		 push	 eax
  000c0	51		 push	 ecx
  000c1	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000c6	83 c4 08	 add	 esp, 8
$LN33@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1682 :         _Mylast  = _Newvec + _Newsize;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR __Newsize$1$[ebp]
  000cc	89 3e		 mov	 DWORD PTR [esi], edi
  000ce	8d 0c 47	 lea	 ecx, DWORD PTR [edi+eax*2]

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000d1	8b c3		 mov	 eax, ebx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  000d3	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR tv435[ebp]
  000d9	03 cf		 add	 ecx, edi

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000db	5f		 pop	 edi

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000dc	89 4e 08	 mov	 DWORD PTR [esi+8], ecx

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);
; 761  :         _Al.deallocate(_Newvec, _Newcapacity);
; 762  :         _RERAISE;
; 763  :         _CATCH_END
; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 766  :         return _Newvec + _Whereoff;

  000df	5e		 pop	 esi
  000e0	5b		 pop	 ebx

; 767  :     }

  000e1	8b e5		 mov	 esp, ebp
  000e3	5d		 pop	 ebp
  000e4	c2 08 00	 ret	 8
$LN39@Emplace_re:

; 738  :             _Xlength();

  000e7	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN40@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000ec	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN37@Emplace_re:
  000f1	cc		 int	 3
??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?_strtoul@@YAKPBDPAPADH@Z
_TEXT	SEGMENT
_psz$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?_strtoul@@YAKPBDPAPADH@Z PROC				; _strtoul, COMDAT

; 1405 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1406 : 	if ( !psz )

  00004	8b 75 08	 mov	 esi, DWORD PTR _psz$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	75 05		 jne	 SHORT $LN6@strtoul

; 1407 : 		return 0;

  0000b	33 c0		 xor	 eax, eax
  0000d	5e		 pop	 esi

; 1436 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
$LN6@strtoul:
  00010	53		 push	 ebx

; 1408 : 
; 1409 : 	ULONG ulRet = 0;
; 1410 : 	if ( psz[0] == '0' && ( psz[1] == 'x' || psz[1] == 'X' ) )

  00011	8a 1e		 mov	 bl, BYTE PTR [esi]
  00013	33 d2		 xor	 edx, edx
  00015	80 fb 30	 cmp	 bl, 48			; 00000030H
  00018	75 54		 jne	 SHORT $LN18@strtoul
  0001a	8a 46 01	 mov	 al, BYTE PTR [esi+1]
  0001d	3c 78		 cmp	 al, 120			; 00000078H
  0001f	74 04		 je	 SHORT $LN9@strtoul
  00021	3c 58		 cmp	 al, 88			; 00000058H
  00023	75 4d		 jne	 SHORT $LL4@strtoul
$LN9@strtoul:

; 1411 : 	{
; 1412 : 		psz += 2;
; 1413 : 		ULONG ul = 0;
; 1414 : 		while ( *psz )

  00025	8a 4e 02	 mov	 cl, BYTE PTR [esi+2]
  00028	83 c6 02	 add	 esi, 2
  0002b	84 c9		 test	 cl, cl
  0002d	74 5d		 je	 SHORT $LN26@strtoul
  0002f	90		 npad	 1
$LL2@strtoul:

; 1415 : 		{
; 1416 : 			if ( '0' <= *psz && *psz <= '9' )

  00030	8d 41 d0	 lea	 eax, DWORD PTR [ecx-48]
  00033	3c 09		 cmp	 al, 9
  00035	77 08		 ja	 SHORT $LN10@strtoul

; 1417 : 				ul = *psz - '0';

  00037	0f be c1	 movsx	 eax, cl
  0003a	83 e8 30	 sub	 eax, 48			; 00000030H
  0003d	eb 1c		 jmp	 SHORT $LN15@strtoul
$LN10@strtoul:

; 1418 : 			else if ( 'A' <= *psz && *psz <= 'F' )

  0003f	8d 41 bf	 lea	 eax, DWORD PTR [ecx-65]
  00042	3c 05		 cmp	 al, 5
  00044	77 08		 ja	 SHORT $LN12@strtoul

; 1419 : 				ul = *psz - 'A' + 10;

  00046	0f be c1	 movsx	 eax, cl
  00049	83 e8 37	 sub	 eax, 55			; 00000037H
  0004c	eb 0d		 jmp	 SHORT $LN15@strtoul
$LN12@strtoul:

; 1420 : 			else if ( 'a' <= *psz && *psz <= 'f' )

  0004e	8d 41 9f	 lea	 eax, DWORD PTR [ecx-97]
  00051	3c 05		 cmp	 al, 5
  00053	77 37		 ja	 SHORT $LN26@strtoul

; 1421 : 				ul = *psz - 'a' + 10;

  00055	0f be c1	 movsx	 eax, cl
  00058	83 e8 57	 sub	 eax, 87			; 00000057H
$LN15@strtoul:

; 1422 : 			else
; 1423 : 				break;
; 1424 : 			ulRet = ulRet * 16 + ul;
; 1425 : 			psz++;

  0005b	8a 4e 01	 mov	 cl, BYTE PTR [esi+1]
  0005e	46		 inc	 esi
  0005f	c1 e2 04	 shl	 edx, 4
  00062	03 d0		 add	 edx, eax
  00064	84 c9		 test	 cl, cl
  00066	75 c8		 jne	 SHORT $LL2@strtoul

; 1433 : 		}
; 1434 : 	}
; 1435 : 	return ulRet;

  00068	5b		 pop	 ebx
  00069	8b c2		 mov	 eax, edx
  0006b	5e		 pop	 esi

; 1436 : }

  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN18@strtoul:

; 1426 : 		}
; 1427 : 	}
; 1428 : 	else {
; 1429 : 		while ( *psz && ( '0' <= *psz && *psz <= '9' ) )

  0006e	84 db		 test	 bl, bl
  00070	74 1a		 je	 SHORT $LN26@strtoul
$LL4@strtoul:
  00072	8d 43 d0	 lea	 eax, DWORD PTR [ebx-48]
  00075	3c 09		 cmp	 al, 9
  00077	77 13		 ja	 SHORT $LN26@strtoul

; 1430 : 		{
; 1431 : 			ulRet = ulRet * 10 + ( *psz - '0' );
; 1432 : 			psz++;

  00079	46		 inc	 esi
  0007a	0f be c3	 movsx	 eax, bl
  0007d	8d 14 92	 lea	 edx, DWORD PTR [edx+edx*4]
  00080	8d 52 e8	 lea	 edx, DWORD PTR [edx-24]
  00083	8a 1e		 mov	 bl, BYTE PTR [esi]
  00085	8d 14 50	 lea	 edx, DWORD PTR [eax+edx*2]
  00088	84 db		 test	 bl, bl
  0008a	75 e6		 jne	 SHORT $LL4@strtoul
$LN26@strtoul:

; 1433 : 		}
; 1434 : 	}
; 1435 : 	return ulRet;

  0008c	5b		 pop	 ebx
  0008d	8b c2		 mov	 eax, edx
  0008f	5e		 pop	 esi

; 1436 : }

  00090	5d		 pop	 ebp
  00091	c3		 ret	 0
?_strtoul@@YAKPBDPAPADH@Z ENDP				; _strtoul
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>, COMDAT
; _this$ = ecx

; 1140 :     void assign(_Iter _First, _Iter _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1140 :     void assign(_Iter _First, _Iter _Last) {

  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  0000a	8b f0		 mov	 esi, eax
  0000c	2b 75 08	 sub	 esi, DWORD PTR __First$[ebp]
  0000f	d1 fe		 sar	 esi, 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1107 :             const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);

  00011	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00014	8b 17		 mov	 edx, DWORD PTR [edi]
  00016	2b ca		 sub	 ecx, edx
  00018	d1 f9		 sar	 ecx, 1

; 1108 :             if (_Newsize > _Oldcapacity) {

  0001a	3b f1		 cmp	 esi, ecx
  0001c	76 74		 jbe	 SHORT $LN28@assign

; 1285 :         if (_Newsize > max_size()) {

  0001e	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00024	0f 87 84 00 00
	00		 ja	 $LN34@assign
  0002a	53		 push	 ebx

; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0002b	8b d9		 mov	 ebx, ecx
  0002d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00032	d1 eb		 shr	 ebx, 1
  00034	2b c3		 sub	 eax, ebx
  00036	3b c8		 cmp	 ecx, eax
  00038	76 07		 jbe	 SHORT $LN13@assign

; 1621 :             return _Max; // geometric growth would overflow

  0003a	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0003f	eb 07		 jmp	 SHORT $LN14@assign
$LN13@assign:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00041	03 d9		 add	 ebx, ecx

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00043	3b de		 cmp	 ebx, esi
  00045	0f 42 de	 cmovb	 ebx, esi
$LN14@assign:

; 1291 :         if (_Myfirst) { // destroy and deallocate old array

  00048	85 d2		 test	 edx, edx
  0004a	74 21		 je	 SHORT $LN10@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0004c	8d 04 09	 lea	 eax, DWORD PTR [ecx+ecx]
  0004f	50		 push	 eax
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1295 :             _Myfirst = pointer();

  00056	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1296 :             _Mylast  = pointer();

  0005f	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0

; 1297 :             _Myend   = pointer();

  00066	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
$LN10@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 60   :         if (_Count > _Max_possible) {

  0006d	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  00073	77 3e		 ja	 SHORT $LN35@assign

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00075	8d 34 1b	 lea	 esi, DWORD PTR [ebx+ebx]

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00078	56		 push	 esi
  00079	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0007e	8b d0		 mov	 edx, eax
  00080	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1646 :         _Myend             = _Newvec + _Newcapacity;

  00083	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00086	89 17		 mov	 DWORD PTR [edi], edx
  00088	89 57 04	 mov	 DWORD PTR [edi+4], edx
  0008b	8d 0c 16	 lea	 ecx, DWORD PTR [esi+edx]
  0008e	89 4f 08	 mov	 DWORD PTR [edi+8], ecx
  00091	5b		 pop	 ebx
$LN28@assign:

; 1112 :             _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));

  00092	52		 push	 edx
  00093	50		 push	 eax
  00094	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00097	e8 00 00 00 00	 call	 ??$_Copy_memmove@PA_WPA_W@std@@YAPA_WPA_W00@Z ; std::_Copy_memmove<wchar_t *,wchar_t *>
  0009c	50		 push	 eax
  0009d	e8 00 00 00 00	 call	 ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ; std::_Refancy<wchar_t *,0>
  000a2	83 c4 10	 add	 esp, 16			; 00000010H
  000a5	89 47 04	 mov	 DWORD PTR [edi+4], eax
  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi

; 1143 :     }

  000aa	5d		 pop	 ebp
  000ab	c2 08 00	 ret	 8
$LN34@assign:

; 1286 :             _Xlength();

  000ae	e8 00 00 00 00	 call	 ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
$LN35@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000b3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN32@assign:
  000b8	cc		 int	 3
??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1705 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00003	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00005	85 c9		 test	 ecx, ecx
  00007	74 23		 je	 SHORT $LN4@vector

; 1695 :             _Destroy(_Myfirst, _Mylast);
; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00009	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0000c	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	50		 push	 eax
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00015	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0001b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1699 :             _Mylast  = pointer();

  0001e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1700 :             _Myend   = pointer();

  00025	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  0002c	5e		 pop	 esi

; 673  :         _Tidy();
; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0002d	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__Fg_disableCicero@@YAXXZ
text$yd	SEGMENT
__$EHRec$ = -12						; size = 12
??__Fg_disableCicero@@YAXXZ PROC			; `dynamic atexit destructor for 'g_disableCicero'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??__Fg_disableCicero@@YAXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 244  : 		if ( m_ptim )

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A

; 221  : 	{

  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 244  : 		if ( m_ptim )

  0002f	85 c9		 test	 ecx, ecx
  00031	74 10		 je	 SHORT $LN7@dynamic

; 245  : 		{
; 246  : 			m_ptim->Release();

  00033	8b 01		 mov	 eax, DWORD PTR [ecx]
  00035	51		 push	 ecx
  00036	ff 50 08	 call	 DWORD PTR [eax+8]

; 247  : 			m_ptim = NULL;

  00039	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A, 0
$LN7@dynamic:

; 248  : 		}
; 249  : 		if ( m_bComInit )

  00043	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  0004a	74 06		 je	 SHORT $LN10@dynamic

; 250  : 			CoUninitialize();

  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN10@dynamic:

; 251  : 		m_bComInit = false;

  00052	c6 05 04 00 00
	00 00		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??__Fg_disableCicero@@YAXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Fg_disableCicero@@YAXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Fg_disableCicero@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_disableCicero''
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__Eg_disableCicero@@YAXXZ
text$di	SEGMENT
??__Eg_disableCicero@@YAXXZ PROC			; `dynamic initializer for 'g_disableCicero'', COMDAT

; 272  : static CDisableCicero g_disableCicero;

  00000	68 00 00 00 00	 push	 OFFSET ??__Fg_disableCicero@@YAXXZ ; `dynamic atexit destructor for 'g_disableCicero''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__Eg_disableCicero@@YAXXZ ENDP			; `dynamic initializer for 'g_disableCicero''
text$di	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z
_TEXT	SEGMENT
_srcTm$ = -4						; size = 4
_bEnable$ = 8						; size = 1
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z PROC		; CTsfUiLessMode::EnableUiUpdates, COMDAT

; 2006 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2007 : 	if ( m_tm == NULL ||
; 2008 : 		 ( bEnable && m_dwUIElementSinkCookie != TF_INVALID_COOKIE )  ||

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000a	85 c9		 test	 ecx, ecx
  0000c	74 7e		 je	 SHORT $LN3@EnableUiUp
  0000e	53		 push	 ebx
  0000f	8a 5d 08	 mov	 bl, BYTE PTR _bEnable$[ebp]
  00012	84 db		 test	 bl, bl
  00014	74 0b		 je	 SHORT $LN9@EnableUiUp
  00016	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0001d	75 6c		 jne	 SHORT $LN10@EnableUiUp
  0001f	eb 09		 jmp	 SHORT $LN2@EnableUiUp
$LN9@EnableUiUp:
  00021	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00028	74 61		 je	 SHORT $LN10@EnableUiUp
$LN2@EnableUiUp:

; 2009 : 		 ( !bEnable && m_dwUIElementSinkCookie == TF_INVALID_COOKIE ) )
; 2010 : 	{
; 2011 : 		return;
; 2012 : 	}
; 2013 : 	ITfSource *srcTm = NULL;
; 2014 : 	HRESULT hr = E_FAIL;
; 2015 : 	if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  0002a	8d 55 fc	 lea	 edx, DWORD PTR _srcTm$[ebp]
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _srcTm$[ebp], 0
  00034	8b 01		 mov	 eax, DWORD PTR [ecx]
  00036	52		 push	 edx
  00037	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0003c	51		 push	 ecx
  0003d	ff 10		 call	 DWORD PTR [eax]
  0003f	85 c0		 test	 eax, eax
  00041	78 48		 js	 SHORT $LN10@EnableUiUp

; 2016 : 	{
; 2017 : 		if ( bEnable )

  00043	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	84 db		 test	 bl, bl
  0004a	74 22		 je	 SHORT $LN6@EnableUiUp

; 2018 : 		{
; 2019 : 			hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie);

  0004c	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00051	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00057	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  0005c	50		 push	 eax
  0005d	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 2024 : 			m_dwUIElementSinkCookie = TF_INVALID_COOKIE;
; 2025 : 		}
; 2026 : 		srcTm->Release();

  00060	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  00063	50		 push	 eax
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	ff 51 08	 call	 DWORD PTR [ecx+8]
  00069	5b		 pop	 ebx

; 2027 : 	}
; 2028 : }

  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
$LN6@EnableUiUp:

; 2020 : 		}
; 2021 : 		else
; 2022 : 		{
; 2023 : 			hr = srcTm->UnadviseSink(m_dwUIElementSinkCookie);

  0006e	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00074	50		 push	 eax
  00075	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2024 : 			m_dwUIElementSinkCookie = TF_INVALID_COOKIE;
; 2025 : 		}
; 2026 : 		srcTm->Release();

  00078	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$[ebp]
  0007b	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwUIElementSinkCookie
  00085	50		 push	 eax
  00086	8b 08		 mov	 ecx, DWORD PTR [eax]
  00088	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN10@EnableUiUp:
  0008b	5b		 pop	 ebx
$LN3@EnableUiUp:

; 2027 : 	}
; 2028 : }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ENDP		; CTsfUiLessMode::EnableUiUpdates
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UpdateImeState@CTsfUiLessMode@@SAXH@Z
_TEXT	SEGMENT
_valConvMode$1 = -44					; size = 16
_valOpenMode$2 = -28					; size = 16
_pcm$ = -12						; size = 4
_pTfConvMode$ = -8					; size = 4
_pTfOpenMode$ = -4					; size = 4
_bResetCompartmentEventSink$ = 8			; size = 4
?UpdateImeState@CTsfUiLessMode@@SAXH@Z PROC		; CTsfUiLessMode::UpdateImeState, COMDAT

; 1791 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 1792 : 	ITfCompartmentMgr* pcm;
; 1793 : 	ITfCompartment* pTfOpenMode = NULL;
; 1794 : 	ITfCompartment* pTfConvMode = NULL;
; 1795 : 	if ( GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode ) )

  00006	8d 45 f8	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pTfOpenMode$[ebp], 0
  00010	50		 push	 eax
  00011	8d 45 fc	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00014	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTfConvMode$[ebp], 0
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR _pcm$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8e 00 00
	00		 je	 $LN2@UpdateImeS

; 1796 : 	{
; 1797 : 		VARIANT valOpenMode;
; 1798 : 		VARIANT valConvMode;
; 1799 : 		pTfOpenMode->GetValue( &valOpenMode );

  00030	53		 push	 ebx
  00031	57		 push	 edi
  00032	8b 7d fc	 mov	 edi, DWORD PTR _pTfOpenMode$[ebp]
  00035	8d 4d e4	 lea	 ecx, DWORD PTR _valOpenMode$2[ebp]
  00038	51		 push	 ecx
  00039	57		 push	 edi
  0003a	8b 07		 mov	 eax, DWORD PTR [edi]
  0003c	ff 50 10	 call	 DWORD PTR [eax+16]

; 1800 : 		pTfConvMode->GetValue( &valConvMode );

  0003f	8b 5d f8	 mov	 ebx, DWORD PTR _pTfConvMode$[ebp]
  00042	8d 4d d4	 lea	 ecx, DWORD PTR _valConvMode$1[ebp]
  00045	51		 push	 ecx
  00046	53		 push	 ebx
  00047	8b 03		 mov	 eax, DWORD PTR [ebx]
  00049	ff 50 10	 call	 DWORD PTR [eax+16]

; 1801 : 		if ( valOpenMode.vt == VT_I4 )

  0004c	66 83 7d e4 03	 cmp	 WORD PTR _valOpenMode$2[ebp], 3
  00051	75 2e		 jne	 SHORT $LN5@UpdateImeS

; 1802 : 		{
; 1803 : 			if ( CIME::ms_bChineseIME )

  00053	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  0005a	74 18		 je	 SHORT $LN4@UpdateImeS

; 1804 : 			{
; 1805 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 && valConvMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  0005c	83 7d ec 00	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], 0
  00060	74 0b		 je	 SHORT $LN8@UpdateImeS
  00062	83 7d dc 00	 cmp	 DWORD PTR _valConvMode$1[ebp+8], 0
  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	75 0f		 jne	 SHORT $LN9@UpdateImeS
$LN8@UpdateImeS:
  0006d	b8 02 00 00 00	 mov	 eax, 2

; 1806 : 			}

  00072	eb 08		 jmp	 SHORT $LN9@UpdateImeS
$LN4@UpdateImeS:

; 1807 : 			else
; 1808 : 			{
; 1809 : 				CIME::ms_dwImeState = valOpenMode.lVal != 0 ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  00074	33 c0		 xor	 eax, eax
  00076	39 45 ec	 cmp	 DWORD PTR _valOpenMode$2[ebp+8], eax
  00079	0f 95 c0	 setne	 al
$LN9@UpdateImeS:

; 1810 : 			}
; 1811 : 		}
; 1812 : 		VariantClear( &valOpenMode );

  0007c	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
$LN5@UpdateImeS:
  00081	8d 45 e4	 lea	 eax, DWORD PTR _valOpenMode$2[ebp]
  00084	50		 push	 eax
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1813 : 		VariantClear( &valConvMode );

  0008b	8d 45 d4	 lea	 eax, DWORD PTR _valConvMode$1[ebp]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VariantClear@4

; 1814 : 
; 1815 : 		if ( bResetCompartmentEventSink )

  00095	83 7d 08 00	 cmp	 DWORD PTR _bResetCompartmentEventSink$[ebp], 0
  00099	74 0c		 je	 SHORT $LN6@UpdateImeS

; 1816 : 		{
; 1817 : 			SetupCompartmentSinks( FALSE, pTfOpenMode, pTfConvMode );	// Reset compartment sinks

  0009b	53		 push	 ebx
  0009c	57		 push	 edi
  0009d	6a 00		 push	 0
  0009f	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@UpdateImeS:

; 1818 : 		}
; 1819 : 		pTfOpenMode->Release();

  000a7	8b 07		 mov	 eax, DWORD PTR [edi]
  000a9	57		 push	 edi
  000aa	ff 50 08	 call	 DWORD PTR [eax+8]

; 1820 : 		pTfConvMode->Release();

  000ad	8b 03		 mov	 eax, DWORD PTR [ebx]
  000af	53		 push	 ebx
  000b0	ff 50 08	 call	 DWORD PTR [eax+8]

; 1821 : 		pcm->Release();

  000b3	8b 45 f4	 mov	 eax, DWORD PTR _pcm$[ebp]
  000b6	50		 push	 eax
  000b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b9	ff 51 08	 call	 DWORD PTR [ecx+8]
  000bc	5f		 pop	 edi
  000bd	5b		 pop	 ebx
$LN2@UpdateImeS:

; 1822 : 	}
; 1823 : }

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
?UpdateImeState@CTsfUiLessMode@@SAXH@Z ENDP		; CTsfUiLessMode::UpdateImeState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_pProfiles$ = -84					; size = 4
_pProfileMgr$1 = -80					; size = 4
_tip$2 = -76						; size = 72
__$ArrayPad$ = -4					; size = 4
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ PROC	; CTsfUiLessMode::CurrentInputLocaleIsIme, COMDAT

; 1977 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi

; 1978 : 	BOOL ret = FALSE;
; 1979 : 	HRESULT hr;
; 1980 : 
; 1981 : 	ITfInputProcessorProfiles *pProfiles;
; 1982 : 	hr = CoCreateInstance(CLSID_TF_InputProcessorProfiles, NULL, CLSCTX_INPROC_SERVER, __uuidof(ITfInputProcessorProfiles), (LPVOID*)&pProfiles);

  00011	8d 45 ac	 lea	 eax, DWORD PTR _pProfiles$[ebp]
  00014	33 f6		 xor	 esi, esi
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET __GUID_1f02b6c5_7842_4ee6_8a0b_9a24183a95ca
  0001c	6a 01		 push	 1
  0001e	56		 push	 esi
  0001f	68 00 00 00 00	 push	 OFFSET _CLSID_TF_InputProcessorProfiles
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 1983 : 	if (SUCCEEDED(hr))

  0002a	85 c0		 test	 eax, eax
  0002c	78 43		 js	 SHORT $LN6@CurrentInp

; 1984 : 	{
; 1985 : 		ITfInputProcessorProfileMgr *pProfileMgr;
; 1986 : 		hr = pProfiles->QueryInterface(__uuidof(ITfInputProcessorProfileMgr), (LPVOID*)&pProfileMgr);

  0002e	8b 45 ac	 mov	 eax, DWORD PTR _pProfiles$[ebp]
  00031	8d 55 b0	 lea	 edx, DWORD PTR _pProfileMgr$1[ebp]
  00034	52		 push	 edx
  00035	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74c_0f28_11d8_a82a_00065b84435c
  0003a	50		 push	 eax
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	ff 11		 call	 DWORD PTR [ecx]

; 1987 : 		if (SUCCEEDED(hr))

  0003f	85 c0		 test	 eax, eax
  00041	78 25		 js	 SHORT $LN3@CurrentInp

; 1988 : 		{
; 1989 : 			TF_INPUTPROCESSORPROFILE tip;
; 1990 : 			hr = pProfileMgr->GetActiveProfile( GUID_TFCAT_TIP_KEYBOARD, &tip );

  00043	8b 45 b0	 mov	 eax, DWORD PTR _pProfileMgr$1[ebp]
  00046	8d 55 b4	 lea	 edx, DWORD PTR _tip$2[ebp]
  00049	52		 push	 edx
  0004a	68 00 00 00 00	 push	 OFFSET _GUID_TFCAT_TIP_KEYBOARD
  0004f	50		 push	 eax
  00050	8b 08		 mov	 ecx, DWORD PTR [eax]
  00052	ff 51 28	 call	 DWORD PTR [ecx+40]

; 1991 : 			if (SUCCEEDED(hr))

  00055	85 c0		 test	 eax, eax
  00057	78 06		 js	 SHORT $LN4@CurrentInp

; 1992 : 			{
; 1993 : 				ret = ( tip.dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) != 0;

  00059	8b 75 b4	 mov	 esi, DWORD PTR _tip$2[ebp]
  0005c	83 e6 01	 and	 esi, 1
$LN4@CurrentInp:

; 1994 : 			}
; 1995 : 			pProfileMgr->Release();

  0005f	8b 45 b0	 mov	 eax, DWORD PTR _pProfileMgr$1[ebp]
  00062	50		 push	 eax
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@CurrentInp:

; 1996 : 		}
; 1997 : 		pProfiles->Release();

  00068	8b 4d ac	 mov	 ecx, DWORD PTR _pProfiles$[ebp]
  0006b	51		 push	 ecx
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	ff 52 08	 call	 DWORD PTR [edx+8]
$LN6@CurrentInp:

; 1998 : 	}
; 1999 : 	return ret;
; 2000 : }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	8b c6		 mov	 eax, esi
  00076	33 cd		 xor	 ecx, ebp
  00078	5e		 pop	 esi
  00079	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ENDP	; CTsfUiLessMode::CurrentInputLocaleIsIme
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ReleaseSinks@CTsfUiLessMode@@SAXXZ
_TEXT	SEGMENT
_source$ = -4						; size = 4
?ReleaseSinks@CTsfUiLessMode@@SAXXZ PROC		; CTsfUiLessMode::ReleaseSinks, COMDAT

; 1611 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1612 : 	HRESULT hr;
; 1613 : 	ITfSource *source;
; 1614 : 
; 1615 : 	// Remove all sinks
; 1616 : 	if ( m_tm && SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfSource), (void **)&source)))

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000a	85 c9		 test	 ecx, ecx
  0000c	0f 84 86 00 00
	00		 je	 $LN4@ReleaseSin
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	8d 55 fc	 lea	 edx, DWORD PTR _source$[ebp]
  00017	52		 push	 edx
  00018	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0001d	51		 push	 ecx
  0001e	ff 10		 call	 DWORD PTR [eax]
  00020	85 c0		 test	 eax, eax
  00022	78 74		 js	 SHORT $LN4@ReleaseSin

; 1617 : 	{
; 1618 :         hr = source->UnadviseSink(m_dwUIElementSinkCookie);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00027	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0002d	50		 push	 eax
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1619 : 		hr = source->UnadviseSink(m_dwAlpnSinkCookie);

  00033	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  0003c	50		 push	 eax
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1620 :         source->Release();

  00042	8b 45 fc	 mov	 eax, DWORD PTR _source$[ebp]
  00045	50		 push	 eax
  00046	8b 08		 mov	 ecx, DWORD PTR [eax]
  00048	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1621 : 		SetupCompartmentSinks(TRUE);	// Remove all compartment sinks

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 01		 push	 1
  00051	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks

; 1622 : 		m_tm->Deactivate();

  00056	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	50		 push	 eax
  00061	ff 51 10	 call	 DWORD PTR [ecx+16]

; 1623 : 		SAFE_RELEASE(m_tm);

  00064	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 10		 je	 SHORT $LN3@ReleaseSin
  0006e	8b 01		 mov	 eax, DWORD PTR [ecx]
  00070	51		 push	 ecx
  00071	ff 50 08	 call	 DWORD PTR [eax+8]
  00074	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A, 0 ; CTsfUiLessMode::m_tm
$LN3@ReleaseSin:

; 1624 : 		SAFE_RELEASE(m_TsfSink);

  0007e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00084	85 c9		 test	 ecx, ecx
  00086	74 10		 je	 SHORT $LN4@ReleaseSin
  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	51		 push	 ecx
  0008b	ff 50 08	 call	 DWORD PTR [eax+8]
  0008e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, 0 ; CTsfUiLessMode::m_TsfSink
$LN4@ReleaseSin:

; 1625 : 	}	
; 1626 : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
?ReleaseSinks@CTsfUiLessMode@@SAXXZ ENDP		; CTsfUiLessMode::ReleaseSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupSinks@CTsfUiLessMode@@SAHXZ
_TEXT	SEGMENT
_cid$ = -8						; size = 4
_srcTm$1 = -4						; size = 4
$T2 = -4						; size = 4
?SetupSinks@CTsfUiLessMode@@SAHXZ PROC			; CTsfUiLessMode::SetupSinks, COMDAT

; 1563 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1564 : 	// ITfThreadMgrEx is available on Vista or later.
; 1565 : 	HRESULT hr;
; 1566 :     hr = CoCreateInstance(CLSID_TF_ThreadMgr, 

  00006	68 00 00 00 00	 push	 OFFSET ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000b	68 00 00 00 00	 push	 OFFSET __GUID_3e90ade3_7594_4cb0_bb58_69628f5f458c
  00010	6a 01		 push	 1
  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20

; 1567 :                           NULL, 
; 1568 :                           CLSCTX_INPROC_SERVER, 
; 1569 :                           __uuidof(ITfThreadMgrEx), 
; 1570 :                           (void**)&m_tm);
; 1571 : 
; 1572 :     if (hr != S_OK)

  0001f	85 c0		 test	 eax, eax
  00021	0f 85 d6 00 00
	00		 jne	 $LN15@SetupSinks

; 1573 :     {
; 1574 :         return FALSE;
; 1575 :     }
; 1576 : 
; 1577 :     // ready to start interacting
; 1578 : 	TfClientId cid;	// not used
; 1579 :     if (FAILED(m_tm->ActivateEx(&cid, TF_TMAE_UIELEMENTENABLEDONLY)))

  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0002c	8d 55 f8	 lea	 edx, DWORD PTR _cid$[ebp]
  0002f	6a 04		 push	 4
  00031	52		 push	 edx
  00032	50		 push	 eax
  00033	8b 08		 mov	 ecx, DWORD PTR [eax]
  00035	ff 51 38	 call	 DWORD PTR [ecx+56]
  00038	85 c0		 test	 eax, eax
  0003a	0f 88 bd 00 00
	00		 js	 $LN15@SetupSinks

; 1582 :     }
; 1583 : 
; 1584 : 	// Setup sinks
; 1585 : 	BOOL bRc = FALSE;

  00040	56		 push	 esi

; 1586 :     m_TsfSink = new CUIElementSink();

  00041	6a 10		 push	 16			; 00000010H
  00043	33 f6		 xor	 esi, esi
  00045	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00050	85 c0		 test	 eax, eax
  00052	0f 84 98 00 00
	00		 je	 $LN10@SetupSinks
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::CUIElementSink
  0005f	a3 00 00 00 00	 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, eax ; CTsfUiLessMode::m_TsfSink
  00064	85 c0		 test	 eax, eax

; 1587 : 	if (m_TsfSink)

  00066	0f 84 8a 00 00
	00		 je	 $LN5@SetupSinks

; 1588 : 	{
; 1589 : 		ITfSource *srcTm;
; 1590 : 		if (SUCCEEDED(hr = m_tm->QueryInterface(__uuidof(ITfSource), (void **)&srcTm)))

  0006c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  00071	8d 55 fc	 lea	 edx, DWORD PTR _srcTm$1[ebp]
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET __GUID_4ea48a35_60ae_446f_8fd6_e6a8d82459f7
  0007a	50		 push	 eax
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	ff 11		 call	 DWORD PTR [ecx]
  0007f	85 c0		 test	 eax, eax
  00081	78 73		 js	 SHORT $LN5@SetupSinks

; 1591 : 		{
; 1592 : 			// Sink for reading window change
; 1593 : 			if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfUIElementSink), (ITfUIElementSink*)m_TsfSink, &m_dwUIElementSinkCookie)))

  00083	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$1[ebp]
  00086	68 00 00 00 00	 push	 OFFSET ?m_dwUIElementSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwUIElementSinkCookie
  0008b	ff 35 00 00 00
	00		 push	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00091	8b 08		 mov	 ecx, DWORD PTR [eax]
  00093	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  00098	50		 push	 eax
  00099	ff 51 0c	 call	 DWORD PTR [ecx+12]
  0009c	85 c0		 test	 eax, eax
  0009e	78 40		 js	 SHORT $LN8@SetupSinks

; 1594 : 			{
; 1595 : 				// Sink for input locale change
; 1596 : 				if (SUCCEEDED(hr = srcTm->AdviseSink(__uuidof(ITfInputProcessorProfileActivationSink), (ITfInputProcessorProfileActivationSink*)m_TsfSink, &m_dwAlpnSinkCookie)))

  000a0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  000a5	85 c0		 test	 eax, eax
  000a7	74 05		 je	 SHORT $LN12@SetupSinks
  000a9	8d 50 04	 lea	 edx, DWORD PTR [eax+4]
  000ac	eb 02		 jmp	 SHORT $LN13@SetupSinks
$LN12@SetupSinks:
  000ae	33 d2		 xor	 edx, edx
$LN13@SetupSinks:
  000b0	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$1[ebp]
  000b3	68 00 00 00 00	 push	 OFFSET ?m_dwAlpnSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwAlpnSinkCookie
  000b8	52		 push	 edx
  000b9	68 00 00 00 00	 push	 OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  000be	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c0	50		 push	 eax
  000c1	ff 51 0c	 call	 DWORD PTR [ecx+12]
  000c4	85 c0		 test	 eax, eax
  000c6	78 18		 js	 SHORT $LN8@SetupSinks

; 1597 : 				{
; 1598 : 					if (SetupCompartmentSinks())	// Setup compartment sinks for the first time

  000c8	6a 00		 push	 0
  000ca	6a 00		 push	 0
  000cc	6a 00		 push	 0
  000ce	e8 00 00 00 00	 call	 ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ; CTsfUiLessMode::SetupCompartmentSinks
  000d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000d6	b9 01 00 00 00	 mov	 ecx, 1
  000db	85 c0		 test	 eax, eax
  000dd	0f 45 f1	 cmovne	 esi, ecx
$LN8@SetupSinks:

; 1599 : 					{
; 1600 : 						bRc = TRUE;
; 1601 : 					}
; 1602 : 				}
; 1603 : 			}
; 1604 : 			srcTm->Release();

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _srcTm$1[ebp]
  000e3	50		 push	 eax
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	ff 51 08	 call	 DWORD PTR [ecx+8]

; 1605 : 		}
; 1606 : 	}
; 1607 : 	return bRc;

  000e9	8b c6		 mov	 eax, esi
  000eb	5e		 pop	 esi

; 1608 : }

  000ec	8b e5		 mov	 esp, ebp
  000ee	5d		 pop	 ebp
  000ef	c3		 ret	 0
$LN10@SetupSinks:

; 1586 :     m_TsfSink = new CUIElementSink();

  000f0	89 35 00 00 00
	00		 mov	 DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A, esi ; CTsfUiLessMode::m_TsfSink
$LN5@SetupSinks:

; 1605 : 		}
; 1606 : 	}
; 1607 : 	return bRc;

  000f6	8b c6		 mov	 eax, esi
  000f8	5e		 pop	 esi

; 1608 : }

  000f9	8b e5		 mov	 esp, ebp
  000fb	5d		 pop	 ebp
  000fc	c3		 ret	 0
$LN15@SetupSinks:

; 1580 :     {
; 1581 :         return FALSE;

  000fd	33 c0		 xor	 eax, eax

; 1608 : }

  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
?SetupSinks@CTsfUiLessMode@@SAHXZ ENDP			; CTsfUiLessMode::SetupSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z
_TEXT	SEGMENT
_bRc$1$ = -16						; size = 4
_pcm$ = -12						; size = 4
_srcOpenMode$ = -8					; size = 4
_bLocalCompartments$1$ = -1				; size = 1
_bRemoveOnly$ = 8					; size = 4
_srcConvMode$1 = 12					; size = 4
_pTfOpenMode$ = 12					; size = 4
_pTfConvMode$ = 16					; size = 4
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z PROC ; CTsfUiLessMode::SetupCompartmentSinks, COMDAT

; 2064 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2065 : 	bool bLocalCompartments = false;
; 2066 : 	ITfCompartmentMgr* pcm = NULL;
; 2067 : 	BOOL bRc = FALSE;
; 2068 : 	HRESULT hr = E_FAIL;
; 2069 : 
; 2070 : 	if ( !pTfOpenMode && !pTfConvMode )

  00008	8b 75 0c	 mov	 esi, DWORD PTR _pTfOpenMode$[ebp]
  0000b	57		 push	 edi
  0000c	33 ff		 xor	 edi, edi
  0000e	c6 45 ff 00	 mov	 BYTE PTR _bLocalCompartments$1$[ebp], 0
  00012	89 7d f4	 mov	 DWORD PTR _pcm$[ebp], edi
  00015	89 7d f0	 mov	 DWORD PTR _bRc$1$[ebp], edi
  00018	85 f6		 test	 esi, esi
  0001a	75 2f		 jne	 SHORT $LN19@SetupCompa
  0001c	39 7d 10	 cmp	 DWORD PTR _pTfConvMode$[ebp], edi
  0001f	0f 85 3c 01 00
	00		 jne	 $LN4@SetupCompa

; 2071 : 	{
; 2072 : 		bLocalCompartments = true;
; 2073 : 		GetCompartments( &pcm, &pTfOpenMode, &pTfConvMode );

  00025	8d 45 10	 lea	 eax, DWORD PTR _pTfConvMode$[ebp]
  00028	c6 45 ff 01	 mov	 BYTE PTR _bLocalCompartments$1$[ebp], 1
  0002c	50		 push	 eax
  0002d	8d 45 0c	 lea	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR _pcm$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ; CTsfUiLessMode::GetCompartments

; 2074 : 	}
; 2075 : 	if ( !( pTfOpenMode && pTfConvMode ) )

  0003a	8b 75 0c	 mov	 esi, DWORD PTR _pTfOpenMode$[ebp]
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 f6		 test	 esi, esi
  00042	0f 84 19 01 00
	00		 je	 $LN4@SetupCompa
  00048	8b 7d f4	 mov	 edi, DWORD PTR _pcm$[ebp]
$LN19@SetupCompa:
  0004b	8b 5d 10	 mov	 ebx, DWORD PTR _pTfConvMode$[ebp]
  0004e	85 db		 test	 ebx, ebx
  00050	0f 84 0b 01 00
	00		 je	 $LN4@SetupCompa

; 2076 : 	{
; 2077 : 		// Invalid parameters or GetCompartments() has failed.
; 2078 : 		return FALSE;
; 2079 : 	}
; 2080 : 	ITfSource *srcOpenMode = NULL;
; 2081 : 	if (SUCCEEDED(hr = pTfOpenMode->QueryInterface( IID_ITfSource, (void**)&srcOpenMode )))

  00056	8d 4d f8	 lea	 ecx, DWORD PTR _srcOpenMode$[ebp]
  00059	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _srcOpenMode$[ebp], 0
  00060	8b 06		 mov	 eax, DWORD PTR [esi]
  00062	51		 push	 ecx
  00063	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  00068	56		 push	 esi
  00069	ff 10		 call	 DWORD PTR [eax]
  0006b	85 c0		 test	 eax, eax
  0006d	0f 88 cc 00 00
	00		 js	 $LN5@SetupCompa

; 2082 : 	{
; 2083 : 		// Remove existing sink for open mode
; 2084 : 		if ( m_dwOpenModeSinkCookie != TF_INVALID_COOKIE )

  00073	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  00079	83 fa ff	 cmp	 edx, -1
  0007c	74 14		 je	 SHORT $LN6@SetupCompa

; 2085 : 		{
; 2086 : 			srcOpenMode->UnadviseSink( m_dwOpenModeSinkCookie );

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  00081	52		 push	 edx
  00082	50		 push	 eax
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2087 : 			m_dwOpenModeSinkCookie = TF_INVALID_COOKIE;

  00088	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwOpenModeSinkCookie
$LN6@SetupCompa:

; 2088 : 		}
; 2089 : 		// Setup sink for open mode (toggle state) change
; 2090 : 		if ( bRemoveOnly || SUCCEEDED(hr = srcOpenMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwOpenModeSinkCookie )))

  00092	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  00096	75 28		 jne	 SHORT $LN8@SetupCompa
  00098	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  0009d	85 c0		 test	 eax, eax
  0009f	74 05		 je	 SHORT $LN15@SetupCompa
  000a1	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
  000a4	eb 02		 jmp	 SHORT $LN16@SetupCompa
$LN15@SetupCompa:
  000a6	33 d2		 xor	 edx, edx
$LN16@SetupCompa:
  000a8	8b 45 f8	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  000ab	68 00 00 00 00	 push	 OFFSET ?m_dwOpenModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwOpenModeSinkCookie
  000b0	52		 push	 edx
  000b1	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	50		 push	 eax
  000b9	ff 51 0c	 call	 DWORD PTR [ecx+12]
  000bc	85 c0		 test	 eax, eax
  000be	78 76		 js	 SHORT $LN9@SetupCompa
$LN8@SetupCompa:

; 2091 : 		{
; 2092 : 			ITfSource *srcConvMode = NULL;
; 2093 : 			if (SUCCEEDED(hr = pTfConvMode->QueryInterface( IID_ITfSource, (void**)&srcConvMode )))

  000c0	8d 4d 0c	 lea	 ecx, DWORD PTR _srcConvMode$1[ebp]
  000c3	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _srcConvMode$1[ebp], 0
  000ca	8b 03		 mov	 eax, DWORD PTR [ebx]
  000cc	51		 push	 ecx
  000cd	68 00 00 00 00	 push	 OFFSET _IID_ITfSource
  000d2	53		 push	 ebx
  000d3	ff 10		 call	 DWORD PTR [eax]
  000d5	85 c0		 test	 eax, eax
  000d7	78 5d		 js	 SHORT $LN9@SetupCompa

; 2094 : 			{
; 2095 : 				// Remove existing sink for open mode
; 2096 : 				if ( m_dwConvModeSinkCookie != TF_INVALID_COOKIE )

  000d9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  000df	83 fa ff	 cmp	 edx, -1
  000e2	74 14		 je	 SHORT $LN10@SetupCompa

; 2097 : 				{
; 2098 : 					srcConvMode->UnadviseSink( m_dwConvModeSinkCookie );

  000e4	8b 45 0c	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  000e7	52		 push	 edx
  000e8	50		 push	 eax
  000e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000eb	ff 51 10	 call	 DWORD PTR [ecx+16]

; 2099 : 					m_dwConvModeSinkCookie = TF_INVALID_COOKIE;

  000ee	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA, -1 ; CTsfUiLessMode::m_dwConvModeSinkCookie
$LN10@SetupCompa:

; 2100 : 				}
; 2101 : 				// Setup sink for open mode (toggle state) change
; 2102 : 				if ( bRemoveOnly || SUCCEEDED(hr = srcConvMode->AdviseSink( IID_ITfCompartmentEventSink, (ITfCompartmentEventSink*)m_TsfSink, &m_dwConvModeSinkCookie )))

  000f8	83 7d 08 00	 cmp	 DWORD PTR _bRemoveOnly$[ebp], 0
  000fc	75 28		 jne	 SHORT $LN12@SetupCompa
  000fe	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_TsfSink@CTsfUiLessMode@@1PAVCUIElementSink@1@A ; CTsfUiLessMode::m_TsfSink
  00103	85 c0		 test	 eax, eax
  00105	74 05		 je	 SHORT $LN17@SetupCompa
  00107	8d 50 08	 lea	 edx, DWORD PTR [eax+8]
  0010a	eb 02		 jmp	 SHORT $LN18@SetupCompa
$LN17@SetupCompa:
  0010c	33 d2		 xor	 edx, edx
$LN18@SetupCompa:
  0010e	8b 45 0c	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  00111	68 00 00 00 00	 push	 OFFSET ?m_dwConvModeSinkCookie@CTsfUiLessMode@@1KA ; CTsfUiLessMode::m_dwConvModeSinkCookie
  00116	52		 push	 edx
  00117	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentEventSink
  0011c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011e	50		 push	 eax
  0011f	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00122	85 c0		 test	 eax, eax
  00124	78 07		 js	 SHORT $LN11@SetupCompa
$LN12@SetupCompa:

; 2103 : 				{
; 2104 : 					bRc = TRUE;

  00126	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _bRc$1$[ebp], 1
$LN11@SetupCompa:

; 2105 : 				}
; 2106 : 				srcConvMode->Release();

  0012d	8b 45 0c	 mov	 eax, DWORD PTR _srcConvMode$1[ebp]
  00130	50		 push	 eax
  00131	8b 08		 mov	 ecx, DWORD PTR [eax]
  00133	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN9@SetupCompa:

; 2107 : 			}
; 2108 : 		}
; 2109 : 		srcOpenMode->Release();

  00136	8b 45 f8	 mov	 eax, DWORD PTR _srcOpenMode$[ebp]
  00139	50		 push	 eax
  0013a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013c	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN5@SetupCompa:

; 2110 : 	}
; 2111 : 	if ( bLocalCompartments )

  0013f	80 7d ff 00	 cmp	 BYTE PTR _bLocalCompartments$1$[ebp], 0
  00143	74 12		 je	 SHORT $LN13@SetupCompa

; 2112 : 	{
; 2113 : 		pTfOpenMode->Release();

  00145	8b 06		 mov	 eax, DWORD PTR [esi]
  00147	56		 push	 esi
  00148	ff 50 08	 call	 DWORD PTR [eax+8]

; 2114 : 		pTfConvMode->Release();

  0014b	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  0014d	53		 push	 ebx
  0014e	ff 51 08	 call	 DWORD PTR [ecx+8]

; 2115 : 		pcm->Release();

  00151	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00153	57		 push	 edi
  00154	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN13@SetupCompa:

; 2116 : 	}
; 2117 : 	return bRc;

  00157	8b 45 f0	 mov	 eax, DWORD PTR _bRc$1$[ebp]
  0015a	5f		 pop	 edi

; 2118 : }

  0015b	5e		 pop	 esi
  0015c	5b		 pop	 ebx
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	c3		 ret	 0
$LN4@SetupCompa:
  00161	5f		 pop	 edi
  00162	5e		 pop	 esi
  00163	33 c0		 xor	 eax, eax
  00165	5b		 pop	 ebx
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c3		 ret	 0
?SetupCompartmentSinks@CTsfUiLessMode@@KAHHPAUITfCompartment@@0@Z ENDP ; CTsfUiLessMode::SetupCompartmentSinks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z
_TEXT	SEGMENT
_pTfConvMode$ = -12					; size = 4
_pTfOpenMode$ = -8					; size = 4
_pcm$ = -4						; size = 4
_ppcm$ = 8						; size = 4
_ppTfOpenMode$ = 12					; size = 4
_ppTfConvMode$ = 16					; size = 4
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z PROC ; CTsfUiLessMode::GetCompartments, COMDAT

; 2033 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 2034 : 	ITfCompartmentMgr* pcm = NULL;
; 2035 : 	ITfCompartment* pTfOpenMode = NULL;
; 2036 : 	ITfCompartment* pTfConvMode = NULL;
; 2037 : 
; 2038 : 	static GUID _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION = { 0xCCF05DD8, 0x4A87, 0x11D7, 0xA6, 0xE2, 0x00, 0x06, 0x5B, 0x84, 0x43, 0x5C };
; 2039 : 
; 2040 : 	HRESULT hr;
; 2041 : 	if (SUCCEEDED(hr = m_tm->QueryInterface( IID_ITfCompartmentMgr, (void**)&pcm )))

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000b	8d 55 fc	 lea	 edx, DWORD PTR _pcm$[ebp]
  0000e	52		 push	 edx
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcm$[ebp], 0
  00016	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pTfOpenMode$[ebp], 0
  0001d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _pTfConvMode$[ebp], 0
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	68 00 00 00 00	 push	 OFFSET _IID_ITfCompartmentMgr
  0002b	50		 push	 eax
  0002c	ff 11		 call	 DWORD PTR [ecx]
  0002e	85 c0		 test	 eax, eax
  00030	78 5f		 js	 SHORT $LN2@GetCompart

; 2042 : 	{
; 2043 : 		if (SUCCEEDED(hr = pcm->GetCompartment( GUID_COMPARTMENT_KEYBOARD_OPENCLOSE, &pTfOpenMode )))

  00032	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  00035	8d 55 f8	 lea	 edx, DWORD PTR _pTfOpenMode$[ebp]
  00038	52		 push	 edx
  00039	68 00 00 00 00	 push	 OFFSET _GUID_COMPARTMENT_KEYBOARD_OPENCLOSE
  0003e	50		 push	 eax
  0003f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00041	ff 51 0c	 call	 DWORD PTR [ecx+12]
  00044	85 c0		 test	 eax, eax
  00046	78 40		 js	 SHORT $LN3@GetCompart

; 2044 : 		{
; 2045 : 			if (SUCCEEDED(hr = pcm->GetCompartment( _GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION, &pTfConvMode )))

  00048	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  0004b	8d 55 f4	 lea	 edx, DWORD PTR _pTfConvMode$[ebp]
  0004e	52		 push	 edx
  0004f	68 00 00 00 00	 push	 OFFSET ?_GUID_COMPARTMENT_KEYBOARD_INPUTMODE_CONVERSION@?1??GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z@4U_GUID@@A
  00054	50		 push	 eax
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	ff 51 0c	 call	 DWORD PTR [ecx+12]
  0005a	85 c0		 test	 eax, eax
  0005c	78 21		 js	 SHORT $LN4@GetCompart

; 2046 : 			{
; 2047 : 				*ppcm = pcm;

  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _ppcm$[ebp]
  00061	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  00064	89 01		 mov	 DWORD PTR [ecx], eax

; 2048 : 				*ppTfOpenMode = pTfOpenMode;

  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _ppTfOpenMode$[ebp]
  00069	8b 45 f8	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  0006c	89 01		 mov	 DWORD PTR [ecx], eax

; 2049 : 				*ppTfConvMode = pTfConvMode;

  0006e	8b 4d 10	 mov	 ecx, DWORD PTR _ppTfConvMode$[ebp]
  00071	8b 45 f4	 mov	 eax, DWORD PTR _pTfConvMode$[ebp]
  00074	89 01		 mov	 DWORD PTR [ecx], eax

; 2050 : 				return TRUE;

  00076	b8 01 00 00 00	 mov	 eax, 1

; 2057 : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN4@GetCompart:

; 2051 : 			}
; 2052 : 			pTfOpenMode->Release();

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _pTfOpenMode$[ebp]
  00082	50		 push	 eax
  00083	8b 08		 mov	 ecx, DWORD PTR [eax]
  00085	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@GetCompart:

; 2053 : 		}
; 2054 : 		pcm->Release();

  00088	8b 45 fc	 mov	 eax, DWORD PTR _pcm$[ebp]
  0008b	50		 push	 eax
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN2@GetCompart:

; 2055 : 	}
; 2056 : 	return FALSE;

  00091	33 c0		 xor	 eax, eax

; 2057 : }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
?GetCompartments@CTsfUiLessMode@@KAHPAPAUITfCompartmentMgr@@PAPAUITfCompartment@@1@Z ENDP ; CTsfUiLessMode::GetCompartments
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z
_TEXT	SEGMENT
_puiem$ = -8						; size = 4
_pElement$ = -4						; size = 4
_dwUIElementId$ = 8					; size = 4
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z PROC ; CTsfUiLessMode::GetUIElement, COMDAT

; 1963 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1964 :     ITfUIElementMgr *puiem;
; 1965 :     ITfUIElement *pElement = NULL;
; 1966 : 
; 1967 :     if (SUCCEEDED(m_tm->QueryInterface(__uuidof(ITfUIElementMgr), (void **)&puiem)))

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_tm@CTsfUiLessMode@@1PAUITfThreadMgrEx@@A ; CTsfUiLessMode::m_tm
  0000b	8d 55 f8	 lea	 edx, DWORD PTR _puiem$[ebp]
  0000e	52		 push	 edx
  0000f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pElement$[ebp], 0
  00016	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea135_19df_11d7_a6d2_00065b84435c
  0001b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001d	50		 push	 eax
  0001e	ff 11		 call	 DWORD PTR [ecx]
  00020	85 c0		 test	 eax, eax
  00022	78 19		 js	 SHORT $LN4@GetUIEleme

; 1968 :     {
; 1969 :         puiem->GetUIElement(dwUIElementId, &pElement);

  00024	8b 45 f8	 mov	 eax, DWORD PTR _puiem$[ebp]
  00027	8d 55 fc	 lea	 edx, DWORD PTR _pElement$[ebp]
  0002a	52		 push	 edx
  0002b	ff 75 08	 push	 DWORD PTR _dwUIElementId$[ebp]
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	50		 push	 eax
  00031	ff 51 18	 call	 DWORD PTR [ecx+24]

; 1970 :         puiem->Release();

  00034	8b 45 f8	 mov	 eax, DWORD PTR _puiem$[ebp]
  00037	50		 push	 eax
  00038	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003a	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN4@GetUIEleme:

; 1971 :     }
; 1972 : 
; 1973 :     return pElement;
; 1974 : }

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _pElement$[ebp]
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ENDP ; CTsfUiLessMode::GetUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z
_TEXT	SEGMENT
_bstr$ = -28						; size = 4
_uCurrentPage$ = -24					; size = 4
_uIndex$ = -20						; size = 4
_IndexList$1$ = -16					; size = 4
tv309 = -12						; size = 4
_uCount$ = -8						; size = 4
_uPageCnt$ = -4						; size = 4
_pcandidate$ = 8					; size = 4
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z PROC ; CTsfUiLessMode::MakeCandidateStrings, COMDAT

; 1903 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 1904 : 	UINT uIndex = 0;
; 1905 : 	UINT uCount = 0;
; 1906 : 	UINT uCurrentPage = 0;
; 1907 : 	UINT *IndexList = NULL;
; 1908 : 	UINT uPageCnt = 0;
; 1909 : 	DWORD dwPageStart = 0;
; 1910 : 	DWORD dwPageSize = 0;
; 1911 : 	BSTR bstr;
; 1912 : 
; 1913 : 	pcandidate->GetSelection(&uIndex);

  00009	8b 7d 08	 mov	 edi, DWORD PTR _pcandidate$[ebp]
  0000c	8d 4d ec	 lea	 ecx, DWORD PTR _uIndex$[ebp]
  0000f	33 c0		 xor	 eax, eax
  00011	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _uIndex$[ebp], 0
  00018	89 45 f0	 mov	 DWORD PTR _IndexList$1$[ebp], eax
  0001b	33 f6		 xor	 esi, esi
  0001d	89 45 fc	 mov	 DWORD PTR _uPageCnt$[ebp], eax
  00020	33 db		 xor	 ebx, ebx
  00022	8b 07		 mov	 eax, DWORD PTR [edi]
  00024	51		 push	 ecx
  00025	57		 push	 edi
  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _uCount$[ebp], 0
  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _uCurrentPage$[ebp], 0
  00034	ff 50 28	 call	 DWORD PTR [eax+40]

; 1914 : 	pcandidate->GetCount(&uCount);

  00037	8b 07		 mov	 eax, DWORD PTR [edi]
  00039	8d 4d f8	 lea	 ecx, DWORD PTR _uCount$[ebp]
  0003c	51		 push	 ecx
  0003d	57		 push	 edi
  0003e	ff 50 24	 call	 DWORD PTR [eax+36]

; 1915 : 	pcandidate->GetCurrentPage(&uCurrentPage);

  00041	8b 07		 mov	 eax, DWORD PTR [edi]
  00043	8d 4d e8	 lea	 ecx, DWORD PTR _uCurrentPage$[ebp]
  00046	51		 push	 ecx
  00047	57		 push	 edi
  00048	ff 50 38	 call	 DWORD PTR [eax+56]

; 1916 : 	CIME::ms_dwCandidateSelection = (DWORD)uIndex;

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _uIndex$[ebp]

; 1917 : 	CIME::ms_dwCandidateCount = (DWORD)uCount;
; 1918 : 	CIME::ms_bCandidateList = true;
; 1919 : 
; 1920 : 	pcandidate->GetPageIndex(NULL, 0, &uPageCnt);

  0004e	8d 4d fc	 lea	 ecx, DWORD PTR _uPageCnt$[ebp]
  00051	51		 push	 ecx
  00052	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection
  00057	8b 45 f8	 mov	 eax, DWORD PTR _uCount$[ebp]
  0005a	53		 push	 ebx
  0005b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount
  00060	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList
  00067	8b 07		 mov	 eax, DWORD PTR [edi]
  00069	53		 push	 ebx
  0006a	57		 push	 edi
  0006b	ff 50 30	 call	 DWORD PTR [eax+48]

; 1921 : 	if(uPageCnt > 0)

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  00071	85 c0		 test	 eax, eax
  00073	74 46		 je	 SHORT $LN15@MakeCandid

; 1922 : 	{
; 1923 : 		IndexList = (UINT *) malloc(sizeof(UINT)*uPageCnt);

  00075	c1 e0 02	 shl	 eax, 2
  00078	50		 push	 eax
  00079	e8 00 00 00 00	 call	 _malloc
  0007e	83 c4 04	 add	 esp, 4
  00081	89 45 f0	 mov	 DWORD PTR _IndexList$1$[ebp], eax

; 1924 : 		if(IndexList)

  00084	85 c0		 test	 eax, eax
  00086	74 33		 je	 SHORT $LN15@MakeCandid

; 1925 : 		{
; 1926 : 			pcandidate->GetPageIndex(IndexList, uPageCnt, &uPageCnt);

  00088	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0008a	8d 55 fc	 lea	 edx, DWORD PTR _uPageCnt$[ebp]
  0008d	52		 push	 edx
  0008e	ff 75 fc	 push	 DWORD PTR _uPageCnt$[ebp]
  00091	50		 push	 eax
  00092	57		 push	 edi
  00093	ff 51 30	 call	 DWORD PTR [ecx+48]

; 1927 : 			dwPageStart = IndexList[uCurrentPage];

  00096	8b 4d e8	 mov	 ecx, DWORD PTR _uCurrentPage$[ebp]
  00099	8b 45 f0	 mov	 eax, DWORD PTR _IndexList$1$[ebp]
  0009c	8b 34 88	 mov	 esi, DWORD PTR [eax+ecx*4]
  0009f	8d 1c 88	 lea	 ebx, DWORD PTR [eax+ecx*4]

; 1928 : 			dwPageSize = (uCurrentPage < uPageCnt-1) ? 

  000a2	8b 45 fc	 mov	 eax, DWORD PTR _uPageCnt$[ebp]
  000a5	48		 dec	 eax
  000a6	3b c8		 cmp	 ecx, eax
  000a8	73 0c		 jae	 SHORT $LN14@MakeCandid
  000aa	8b 5b 04	 mov	 ebx, DWORD PTR [ebx+4]
  000ad	39 5d f8	 cmp	 DWORD PTR _uCount$[ebp], ebx
  000b0	0f 42 5d f8	 cmovb	 ebx, DWORD PTR _uCount$[ebp]
  000b4	eb 03		 jmp	 SHORT $LN30@MakeCandid
$LN14@MakeCandid:
  000b6	8b 5d f8	 mov	 ebx, DWORD PTR _uCount$[ebp]
$LN30@MakeCandid:

; 1929 : 				min(uCount, IndexList[uCurrentPage+1]) - dwPageStart:
; 1930 : 				uCount - dwPageStart;
; 1931 : 		}
; 1932 : 	}
; 1933 : 
; 1934 : 	CIME::ms_dwCandidatePageSize = min(dwPageSize, CIME::MAX_CANDLIST);

  000b9	2b de		 sub	 ebx, esi
$LN15@MakeCandid:
  000bb	bf 0a 00 00 00	 mov	 edi, 10			; 0000000aH

; 1935 : 	CIME::ms_dwCandidateSelection = CIME::ms_dwCandidateSelection - dwPageStart;
; 1936 : 
; 1937 : 	memset(&CIME::ms_wszCandidate, 0, sizeof(CIME::ms_wszCandidate));

  000c0	68 00 14 00 00	 push	 5120			; 00001400H
  000c5	3b df		 cmp	 ebx, edi
  000c7	6a 00		 push	 0
  000c9	0f 42 fb	 cmovb	 edi, ebx
  000cc	29 35 00 00 00
	00		 sub	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, esi ; CIME::ms_dwCandidateSelection
  000d2	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  000d7	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, edi ; CIME::ms_dwCandidatePageSize
  000dd	e8 00 00 00 00	 call	 _memset
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1938 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  000e5	33 db		 xor	 ebx, ebx
  000e7	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  000ed	73 61		 jae	 SHORT $LN29@MakeCandid

; 1929 : 				min(uCount, IndexList[uCurrentPage+1]) - dwPageStart:
; 1930 : 				uCount - dwPageStart;
; 1931 : 		}
; 1932 : 	}
; 1933 : 
; 1934 : 	CIME::ms_dwCandidatePageSize = min(dwPageSize, CIME::MAX_CANDLIST);

  000ef	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv309[ebp], OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
$LL4@MakeCandid:

; 1938 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  000f6	3b df		 cmp	 ebx, edi
  000f8	73 56		 jae	 SHORT $LN29@MakeCandid

; 1939 : 	{
; 1940 : 		if (SUCCEEDED(pcandidate->GetString( i, &bstr )))

  000fa	8b 4d 08	 mov	 ecx, DWORD PTR _pcandidate$[ebp]
  000fd	8d 55 e4	 lea	 edx, DWORD PTR _bstr$[ebp]
  00100	52		 push	 edx
  00101	56		 push	 esi
  00102	51		 push	 ecx
  00103	8b 01		 mov	 eax, DWORD PTR [ecx]
  00105	ff 50 2c	 call	 DWORD PTR [eax+44]
  00108	85 c0		 test	 eax, eax
  0010a	78 2b		 js	 SHORT $LN2@MakeCandid

; 1941 : 		{
; 1942 : 			if(bstr)

  0010c	8b 7d e4	 mov	 edi, DWORD PTR _bstr$[ebp]
  0010f	85 ff		 test	 edi, edi
  00111	74 24		 je	 SHORT $LN2@MakeCandid

; 1943 : 			{
; 1944 : 				wcscpy( CIME::ms_wszCandidate[j], bstr );

  00113	8b 55 f4	 mov	 edx, DWORD PTR tv309[ebp]
  00116	8b c7		 mov	 eax, edi
  00118	2b d7		 sub	 edx, edi
  0011a	66 0f 1f 44 00
	00		 npad	 6
$LL16@MakeCandid:
  00120	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  00123	8d 40 02	 lea	 eax, DWORD PTR [eax+2]
  00126	66 89 4c 02 fe	 mov	 WORD PTR [edx+eax-2], cx
  0012b	66 85 c9	 test	 cx, cx
  0012e	75 f0		 jne	 SHORT $LL16@MakeCandid

; 1945 : 				SysFreeString(bstr);

  00130	57		 push	 edi
  00131	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN2@MakeCandid:

; 1938 : 	for (UINT i = dwPageStart, j = 0; (DWORD)i < CIME::ms_dwCandidateCount && j < CIME::ms_dwCandidatePageSize; i++, j++)

  00137	81 45 f4 00 02
	00 00		 add	 DWORD PTR tv309[ebp], 512 ; 00000200H
  0013e	46		 inc	 esi
  0013f	43		 inc	 ebx
  00140	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  00146	73 08		 jae	 SHORT $LN29@MakeCandid
  00148	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  0014e	eb a6		 jmp	 SHORT $LL4@MakeCandid
$LN29@MakeCandid:

; 1946 : 			}
; 1947 : 		}
; 1948 : 	}
; 1949 : 	//OutputDebugStringW( L"\n" );
; 1950 : 
; 1951 : 	if (GETPRIMLANG() == LANG_KOREAN)

  00150	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00155	83 c9 ff	 or	 ecx, -1
  00158	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0015d	83 f8 12	 cmp	 eax, 18			; 00000012H
  00160	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection

; 1952 : 	{
; 1953 : 		CIME::ms_dwCandidateSelection = (DWORD)-1;
; 1954 : 	}
; 1955 : 
; 1956 : 	if(IndexList)

  00165	5f		 pop	 edi
  00166	0f 44 c1	 cmove	 eax, ecx
  00169	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection
  0016e	8b 45 f0	 mov	 eax, DWORD PTR _IndexList$1$[ebp]
  00171	5e		 pop	 esi
  00172	5b		 pop	 ebx
  00173	85 c0		 test	 eax, eax
  00175	74 09		 je	 SHORT $LN10@MakeCandid

; 1957 : 	{
; 1958 : 		free(IndexList);

  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _free
  0017d	83 c4 04	 add	 esp, 4
$LN10@MakeCandid:

; 1959 : 	}
; 1960 : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c3		 ret	 0
?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ENDP ; CTsfUiLessMode::MakeCandidateStrings
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z
_TEXT	SEGMENT
_dwFlags$ = -24						; size = 4
_cchMax$ = -20						; size = 4
_i$1$ = -16						; size = 4
_pszSource$1$ = -12					; size = 4
_fVertical$ = -8					; size = 4
_uErrorIndex$ = -4					; size = 4
_bstr$ = 8						; size = 4
_preading$ = 8						; size = 4
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z PROC ; CTsfUiLessMode::MakeReadingInformationString, COMDAT

; 1851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00006	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1858 : 	preading->GetUpdatedFlags(&dwFlags);

  0000c	8d 4d e8	 lea	 ecx, DWORD PTR _dwFlags$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000f	8b c2		 mov	 eax, edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1853 : 	UINT uErrorIndex = 0;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _uErrorIndex$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00018	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1851 : {

  0001e	56		 push	 esi

; 1858 : 	preading->GetUpdatedFlags(&dwFlags);

  0001f	8b 75 08	 mov	 esi, DWORD PTR _preading$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  00022	d1 f8		 sar	 eax, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1858 : 	preading->GetUpdatedFlags(&dwFlags);

  00024	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00025	0f 45 15 00 00
	00 00		 cmovne	 edx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  0002c	89 15 04 00 00
	00		 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4, edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1858 : 	preading->GetUpdatedFlags(&dwFlags);

  00032	8b 06		 mov	 eax, DWORD PTR [esi]
  00034	56		 push	 esi
  00035	ff 50 1c	 call	 DWORD PTR [eax+28]

; 1859 : 	preading->GetMaxReadingStringLength(&cchMax);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	8d 4d ec	 lea	 ecx, DWORD PTR _cchMax$[ebp]
  0003d	51		 push	 ecx
  0003e	56		 push	 esi
  0003f	ff 50 28	 call	 DWORD PTR [eax+40]

; 1860 : 	preading->GetErrorIndex(&uErrorIndex);	// errorIndex is zero-based

  00042	8b 06		 mov	 eax, DWORD PTR [esi]
  00044	8d 4d fc	 lea	 ecx, DWORD PTR _uErrorIndex$[ebp]
  00047	51		 push	 ecx
  00048	56		 push	 esi
  00049	ff 50 2c	 call	 DWORD PTR [eax+44]

; 1861 : 	preading->IsVerticalOrderPreferred(&fVertical);

  0004c	8b 06		 mov	 eax, DWORD PTR [esi]
  0004e	8d 4d f8	 lea	 ecx, DWORD PTR _fVertical$[ebp]
  00051	51		 push	 ecx
  00052	56		 push	 esi
  00053	ff 50 30	 call	 DWORD PTR [eax+48]

; 1862 : 	CIME::ms_iReadingError = (int)uErrorIndex;
; 1863 : 	CIME::ms_bHorizontalReading = !fVertical;

  00056	83 7d f8 00	 cmp	 DWORD PTR _fVertical$[ebp], 0

; 1864 : 	CIME::ms_bReadingInformation = true;
; 1865 : 	BSTR bstr;
; 1866 : 	if (SUCCEEDED(preading->GetString(&bstr)))

  0005a	8d 4d 08	 lea	 ecx, DWORD PTR _bstr$[ebp]
  0005d	8b 45 fc	 mov	 eax, DWORD PTR _uErrorIndex$[ebp]
  00060	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iReadingError@CIME@@2HA, eax ; CIME::ms_iReadingError
  00065	0f 94 05 00 00
	00 00		 sete	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA ; CIME::ms_bHorizontalReading
  0006c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation
  00073	8b 06		 mov	 eax, DWORD PTR [esi]
  00075	51		 push	 ecx
  00076	56		 push	 esi
  00077	ff 50 24	 call	 DWORD PTR [eax+36]
  0007a	85 c0		 test	 eax, eax
  0007c	0f 88 bb 00 00
	00		 js	 $LN6@MakeReadin

; 1867 : 	{
; 1868 : 		if (bstr)

  00082	8b 45 08	 mov	 eax, DWORD PTR _bstr$[ebp]
  00085	85 c0		 test	 eax, eax
  00087	0f 84 b0 00 00
	00		 je	 $LN6@MakeReadin

; 1869 : 		{
; 1870 : 			CIME::ms_wstrReading.assign( (wchar_t *) bstr, (wchar_t *) bstr+lstrlenW(bstr) );

  0008d	50		 push	 eax
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4
  00094	8b 4d 08	 mov	 ecx, DWORD PTR _bstr$[ebp]
  00097	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0009a	50		 push	 eax
  0009b	51		 push	 ecx
  0009c	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  000a1	e8 00 00 00 00	 call	 ??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>

; 1872 : 			if ( fVertical )

  000a6	83 7d f8 00	 cmp	 DWORD PTR _fVertical$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  000b0	89 4d f4	 mov	 DWORD PTR _pszSource$1$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1872 : 			if ( fVertical )

  000b3	74 7f		 je	 SHORT $LN3@MakeReadin

; 1873 : 			{
; 1874 : 				CIME::ms_dwCandidatePageSize = CIME::MAX_CANDLIST;
; 1875 : 				// ms_iReadingError is used only in horizontal window, and has to be -1 if there's no error.
; 1876 : 				CIME::ms_dwCandidateSelection = CIME::ms_iReadingError ? CIME::ms_iReadingError - 1 : (DWORD)-1;

  000b5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError
  000ba	c7 05 00 00 00
	00 0a 00 00 00	 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, 10 ; CIME::ms_dwCandidatePageSize, 0000000aH
  000c4	85 c0		 test	 eax, eax
  000c6	74 03		 je	 SHORT $LN10@MakeReadin
  000c8	48		 dec	 eax
  000c9	eb 03		 jmp	 SHORT $LN11@MakeReadin
$LN10@MakeReadin:
  000cb	83 c8 ff	 or	 eax, -1
$LN11@MakeReadin:

; 1877 : 				CIME::ms_dwCandidateCount = cchMax;

  000ce	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1878 : 				// for vertical reading window, copy each character to g_szCandidate array.
; 1879 : 				for ( UINT i = 0; i < cchMax; i++ )

  000d3	33 d2		 xor	 edx, edx
  000d5	8b 45 ec	 mov	 eax, DWORD PTR _cchMax$[ebp]
  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, eax ; CIME::ms_dwCandidateCount
  000dd	89 55 f0	 mov	 DWORD PTR _i$1$[ebp], edx
  000e0	85 c0		 test	 eax, eax
  000e2	74 50		 je	 SHORT $LN3@MakeReadin

; 1877 : 				CIME::ms_dwCandidateCount = cchMax;

  000e4	53		 push	 ebx
  000e5	be 00 00 00 00	 mov	 esi, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  000ea	57		 push	 edi
  000eb	0f 1f 44 00 00	 npad	 5
$LL4@MakeReadin:

; 1880 : 				{
; 1881 : 					LPWSTR pszDest = CIME::ms_wszCandidate[i];
; 1882 : 					if ( *pszSource )

  000f0	66 83 39 00	 cmp	 WORD PTR [ecx], 0
  000f4	8b c6		 mov	 eax, esi
  000f6	74 26		 je	 SHORT $LN8@MakeReadin

; 1883 : 					{
; 1884 : 						LPWSTR pszNextSrc = CharNextW(pszSource);

  000f8	51		 push	 ecx
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CharNextW@4
  000ff	8b f8		 mov	 edi, eax

; 1885 : 						SIZE_T size = (LPSTR)pszNextSrc - (LPSTR)pszSource;

  00101	8b 45 f4	 mov	 eax, DWORD PTR _pszSource$1$[ebp]
  00104	8b df		 mov	 ebx, edi
  00106	2b d8		 sub	 ebx, eax

; 1886 : 						CopyMemory( pszDest, pszSource, size );

  00108	53		 push	 ebx
  00109	50		 push	 eax
  0010a	56		 push	 esi
  0010b	e8 00 00 00 00	 call	 _memcpy
  00110	8b 55 f0	 mov	 edx, DWORD PTR _i$1$[ebp]

; 1887 : 						pszSource = pszNextSrc;
; 1888 : 						pszDest += size;

  00113	8d 04 5e	 lea	 eax, DWORD PTR [esi+ebx*2]
  00116	8b cf		 mov	 ecx, edi
  00118	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011b	89 4d f4	 mov	 DWORD PTR _pszSource$1$[ebp], ecx
$LN8@MakeReadin:

; 1889 : 					}
; 1890 : 					*pszDest = 0;

  0011e	33 ff		 xor	 edi, edi
  00120	42		 inc	 edx
  00121	66 89 38	 mov	 WORD PTR [eax], di
  00124	81 c6 00 02 00
	00		 add	 esi, 512		; 00000200H
  0012a	89 55 f0	 mov	 DWORD PTR _i$1$[ebp], edx
  0012d	3b 55 ec	 cmp	 edx, DWORD PTR _cchMax$[ebp]
  00130	72 be		 jb	 SHORT $LL4@MakeReadin
  00132	5f		 pop	 edi
  00133	5b		 pop	 ebx
$LN3@MakeReadin:

; 1891 : 				}
; 1892 : 			}
; 1893 : 			//else
; 1894 : 			//{
; 1895 : 			//	CIME::ms_wszCandidate[0][0] = L' ';	// hack to make rendering happen
; 1896 : 			//}
; 1897 : 			SysFreeString(bstr);

  00134	ff 75 08	 push	 DWORD PTR _bstr$[ebp]
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SysFreeString@4
$LN6@MakeReadin:
  0013d	5e		 pop	 esi

; 1898 : 		}
; 1899 : 	}
; 1900 : }

  0013e	8b e5		 mov	 esp, ebp
  00140	5d		 pop	 ebp
  00141	c3		 ret	 0
?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ENDP ; CTsfUiLessMode::MakeReadingInformationString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_rguid$ = 12						; size = 4
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z PROC ; CTsfUiLessMode::CUIElementSink::OnChange, COMDAT

; 1846 : 	UpdateImeState();

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00007	83 c4 04	 add	 esp, 4

; 1847 :     return S_OK;

  0000a	33 c0		 xor	 eax, eax

; 1848 : }

  0000c	c2 08 00	 ret	 8
?OnChange@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnChange
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_dwProfileType$ = 12					; size = 4
_langid$ = 16						; size = 2
_clsid$ = 20						; size = 4
_catid$ = 24						; size = 4
_guidProfile$ = 28					; size = 4
_hkl$ = 32						; size = 4
_dwFlags$ = 36						; size = 4
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z PROC ; CTsfUiLessMode::CUIElementSink::OnActivated, COMDAT

; 1827 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00003	8b 55 1c	 mov	 edx, DWORD PTR _guidProfile$[ebp]
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET ?TF_PROFILE_DAYI@?1??OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z@4U4@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1827 : {

  0000b	56		 push	 esi
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0000c	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
$LL15@OnActivate:
  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	3b 02		 cmp	 eax, DWORD PTR [edx]
  00015	75 0f		 jne	 SHORT $LN14@OnActivate
  00017	83 c1 04	 add	 ecx, 4
  0001a	83 c2 04	 add	 edx, 4
  0001d	83 ee 04	 sub	 esi, 4
  00020	73 ef		 jae	 SHORT $LL15@OnActivate
  00022	33 c0		 xor	 eax, eax
  00024	eb 05		 jmp	 SHORT $LN16@OnActivate
$LN14@OnActivate:
  00026	b8 01 00 00 00	 mov	 eax, 1
$LN16@OnActivate:
  0002b	8b 4d 18	 mov	 ecx, DWORD PTR _catid$[ebp]
  0002e	ba 00 00 00 00	 mov	 edx, OFFSET _GUID_TFCAT_TIP_KEYBOARD
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1829 : 	CIME::ms_iCandListIndexBase = IsEqualGUID( TF_PROFILE_DAYI, guidProfile ) ? 0 : 1;   

  00033	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00038	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0003d	0f 1f 00	 npad	 3
$LL18@OnActivate:
  00040	8b 01		 mov	 eax, DWORD PTR [ecx]
  00042	3b 02		 cmp	 eax, DWORD PTR [edx]
  00044	75 71		 jne	 SHORT $LN20@OnActivate
  00046	83 c1 04	 add	 ecx, 4
  00049	83 c2 04	 add	 edx, 4
  0004c	83 ee 04	 sub	 esi, 4
  0004f	73 ef		 jae	 SHORT $LL18@OnActivate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1830 : 	if ( IsEqualIID( catid, GUID_TFCAT_TIP_KEYBOARD ) && ( dwFlags & TF_IPSINK_FLAG_ACTIVE ) )

  00051	f6 45 24 01	 test	 BYTE PTR _dwFlags$[ebp], 1
  00055	74 60		 je	 SHORT $LN20@OnActivate

; 1831 : 	{
; 1832 : 		CIME::ms_bChineseIME = ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR ) && langid == LANG_CHT;

  00057	8b 45 0c	 mov	 eax, DWORD PTR _dwProfileType$[ebp]
  0005a	83 e0 01	 and	 eax, 1
  0005d	74 28		 je	 SHORT $LN6@OnActivate
  0005f	b9 04 04 00 00	 mov	 ecx, 1028		; 00000404H
  00064	66 39 4d 10	 cmp	 WORD PTR _langid$[ebp], cx
  00068	75 1d		 jne	 SHORT $LN6@OnActivate

; 1834 : 		{
; 1835 : 			UpdateImeState(TRUE);

  0006a	6a 01		 push	 1
  0006c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 1 ; CIME::ms_bChineseIME
  00073	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00078	83 c4 04	 add	 esp, 4

; 1839 : 		CIME::ChangeInputLanguage();

  0007b	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 1840 : 	}
; 1841 :     return S_OK;
; 1842 : }

  00080	33 c0		 xor	 eax, eax
  00082	5e		 pop	 esi
  00083	5d		 pop	 ebp
  00084	c2 20 00	 ret	 32			; 00000020H
$LN6@OnActivate:

; 1833 : 		if ( dwProfileType & TF_PROFILETYPE_INPUTPROCESSOR )

  00087	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  0008e	85 c0		 test	 eax, eax
  00090	74 16		 je	 SHORT $LN3@OnActivate

; 1834 : 		{
; 1835 : 			UpdateImeState(TRUE);

  00092	6a 01		 push	 1
  00094	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  00099	83 c4 04	 add	 esp, 4

; 1839 : 		CIME::ChangeInputLanguage();

  0009c	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 1840 : 	}
; 1841 :     return S_OK;
; 1842 : }

  000a1	33 c0		 xor	 eax, eax
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp
  000a5	c2 20 00	 ret	 32			; 00000020H
$LN3@OnActivate:

; 1836 : 		}
; 1837 : 		else
; 1838 : 			CIME::ms_dwImeState = IMEUI_STATE_OFF;

  000a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState

; 1839 : 		CIME::ChangeInputLanguage();

  000b2	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage
$LN20@OnActivate:

; 1840 : 	}
; 1841 :     return S_OK;
; 1842 : }

  000b7	33 c0		 xor	 eax, eax
  000b9	5e		 pop	 esi
  000ba	5d		 pop	 ebp
  000bb	c2 20 00	 ret	 32			; 00000020H
?OnActivated@CUIElementSink@CTsfUiLessMode@@UAGJKGABU_GUID@@00PAUHKL__@@K@Z ENDP ; CTsfUiLessMode::CUIElementSink::OnActivated
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_preading$ = 12						; size = 4
_dwUIElementId$ = 12					; size = 4
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::EndUIElement, COMDAT

; 1759 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1760 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00005	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00008	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1761 :     if (!pElement)

  00012	85 f6		 test	 esi, esi
  00014	75 0c		 jne	 SHORT $LN2@EndUIEleme

; 1762 :         return E_INVALIDARG;

  00016	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001b	5e		 pop	 esi

; 1788 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN2@EndUIEleme:

; 1763 : 
; 1764 : 	//BSTR bstrDesc;
; 1765 : 	//OutputDebugStringW(L"ENDUI: ");
; 1766 : 	//pElement->GetDescription(&bstrDesc);
; 1767 : 	//OutputDebugStringW(bstrDesc);
; 1768 : 	//OutputDebugStringW(L"\n");
; 1769 : 
; 1770 : 	ITfReadingInformationUIElement   *preading = NULL;
; 1771 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00022	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00025	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  0002c	8b 06		 mov	 eax, DWORD PTR [esi]
  0002e	51		 push	 ecx
  0002f	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00034	56		 push	 esi
  00035	ff 10		 call	 DWORD PTR [eax]
  00037	85 c0		 test	 eax, eax
  00039	78 0e		 js	 SHORT $LN3@EndUIEleme

; 1772 :     {
; 1773 : 		CIME::CloseReadingInformation();

  0003b	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation

; 1774 :         preading->Release();

  00040	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]
  00043	50		 push	 eax
  00044	8b 08		 mov	 ecx, DWORD PTR [eax]
  00046	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN3@EndUIEleme:

; 1775 :     }
; 1776 : 
; 1777 : 	ITfCandidateListUIElement   *pcandidate = NULL;
; 1778 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  00049	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  0004c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00053	8b 06		 mov	 eax, DWORD PTR [esi]
  00055	51		 push	 ecx
  00056	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  0005b	56		 push	 esi
  0005c	ff 10		 call	 DWORD PTR [eax]
  0005e	85 c0		 test	 eax, eax
  00060	78 17		 js	 SHORT $LN4@EndUIEleme

; 1779 : 	{
; 1780 : 		m_nCandidateRefCount--;

  00062	83 2d 00 00 00
	00 01		 sub	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA, 1 ; CTsfUiLessMode::m_nCandidateRefCount

; 1781 : 		if (m_nCandidateRefCount == 0)

  00069	75 05		 jne	 SHORT $LN5@EndUIEleme

; 1782 : 			CIME::CloseCandidateList();

  0006b	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
$LN5@EndUIEleme:

; 1783 : 		pcandidate->Release();

  00070	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
  00073	50		 push	 eax
  00074	8b 08		 mov	 ecx, DWORD PTR [eax]
  00076	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN4@EndUIEleme:

; 1784 : 	}
; 1785 : 
; 1786 :     pElement->Release();

  00079	8b 06		 mov	 eax, DWORD PTR [esi]
  0007b	56		 push	 esi
  0007c	ff 50 08	 call	 DWORD PTR [eax+8]

; 1787 :     return S_OK;

  0007f	33 c0		 xor	 eax, eax
  00081	5e		 pop	 esi

; 1788 : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
?EndUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::EndUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z
_TEXT	SEGMENT
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_preading$ = 12						; size = 4
_dwUIElementId$ = 12					; size = 4
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z PROC ; CTsfUiLessMode::CUIElementSink::UpdateUIElement, COMDAT

; 1725 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1726 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00005	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00008	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1727 :     if (!pElement)

  00012	85 f6		 test	 esi, esi
  00014	75 0c		 jne	 SHORT $LN2@UpdateUIEl

; 1728 :         return E_INVALIDARG;

  00016	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001b	5e		 pop	 esi

; 1756 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 08 00	 ret	 8
$LN2@UpdateUIEl:

; 1729 : 
; 1730 :     ITfReadingInformationUIElement   *preading = NULL;
; 1731 :     ITfCandidateListUIElement		*pcandidate = NULL;
; 1732 : 
; 1733 : 	//BSTR bstrDesc;
; 1734 : 	//pElement->GetDescription(&bstrDesc);
; 1735 : 	//OutputDebugStringW(L"UPDATEUI: ");
; 1736 : 	//OutputDebugStringW(bstrDesc);
; 1737 : 	//OutputDebugStringW(L"\n");
; 1738 : 
; 1739 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00022	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00025	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  0002c	51		 push	 ecx
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00034	8b 06		 mov	 eax, DWORD PTR [esi]
  00036	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  0003b	56		 push	 esi
  0003c	ff 10		 call	 DWORD PTR [eax]
  0003e	85 c0		 test	 eax, eax
  00040	78 1f		 js	 SHORT $LN3@UpdateUIEl

; 1740 :     {
; 1741 : 		MakeReadingInformationString(preading);

  00042	ff 75 0c	 push	 DWORD PTR _preading$[ebp]
  00045	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString

; 1742 : 		if(CIME::ms_pEvent)

  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00050	83 c4 04	 add	 esp, 4
  00053	85 c9		 test	 ecx, ecx
  00055	74 05		 je	 SHORT $LN5@UpdateUIEl

; 1743 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00057	8b 01		 mov	 eax, DWORD PTR [ecx]
  00059	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@UpdateUIEl:

; 1744 :         preading->Release();

  0005c	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]

; 1745 :     }

  0005f	eb 2f		 jmp	 SHORT $LN9@UpdateUIEl
$LN3@UpdateUIEl:

; 1746 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  00061	8b 06		 mov	 eax, DWORD PTR [esi]
  00063	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  00066	51		 push	 ecx
  00067	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  0006c	56		 push	 esi
  0006d	ff 10		 call	 DWORD PTR [eax]
  0006f	85 c0		 test	 eax, eax
  00071	78 23		 js	 SHORT $LN6@UpdateUIEl

; 1747 : 	{
; 1748 : 		MakeCandidateStrings(pcandidate);

  00073	ff 75 fc	 push	 DWORD PTR _pcandidate$[ebp]
  00076	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings

; 1749 : 		if(CIME::ms_pEvent)

  0007b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00081	83 c4 04	 add	 esp, 4
  00084	85 c9		 test	 ecx, ecx
  00086	74 05		 je	 SHORT $LN7@UpdateUIEl

; 1750 : 			CIME::ms_pEvent->OnOpenCandidateList();

  00088	8b 01		 mov	 eax, DWORD PTR [ecx]
  0008a	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@UpdateUIEl:

; 1751 : 		pcandidate->Release();

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
$LN9@UpdateUIEl:

; 1752 :     }
; 1753 : 
; 1754 :     pElement->Release();

  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	50		 push	 eax
  00093	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN6@UpdateUIEl:
  00096	8b 06		 mov	 eax, DWORD PTR [esi]
  00098	56		 push	 esi
  00099	ff 50 08	 call	 DWORD PTR [eax+8]

; 1755 :     return S_OK;

  0009c	33 c0		 xor	 eax, eax
  0009e	5e		 pop	 esi

; 1756 : }

  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 08 00	 ret	 8
?UpdateUIElement@CUIElementSink@CTsfUiLessMode@@UAGJK@Z ENDP ; CTsfUiLessMode::CUIElementSink::UpdateUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z
_TEXT	SEGMENT
_pcandidate$ = -4					; size = 4
_this$ = 8						; size = 4
_preading$ = 12						; size = 4
_dwUIElementId$ = 12					; size = 4
_pbShow$ = 16						; size = 4
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z PROC ; CTsfUiLessMode::CUIElementSink::BeginUIElement, COMDAT

; 1689 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1690 :     ITfUIElement *pElement = GetUIElement(dwUIElementId);

  00005	ff 75 0c	 push	 DWORD PTR _dwUIElementId$[ebp]
  00008	e8 00 00 00 00	 call	 ?GetUIElement@CTsfUiLessMode@@KAPAUITfUIElement@@K@Z ; CTsfUiLessMode::GetUIElement
  0000d	8b f0		 mov	 esi, eax
  0000f	83 c4 04	 add	 esp, 4

; 1691 :     if (!pElement)

  00012	85 f6		 test	 esi, esi
  00014	75 0c		 jne	 SHORT $LN2@BeginUIEle

; 1692 :         return E_INVALIDARG;

  00016	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  0001b	5e		 pop	 esi

; 1722 : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 0c 00	 ret	 12			; 0000000cH
$LN2@BeginUIEle:

; 1693 : 
; 1694 :     ITfReadingInformationUIElement   *preading = NULL;
; 1695 : 	ITfCandidateListUIElement		*pcandidate = NULL;
; 1696 : 	*pbShow = FALSE;

  00022	8b 45 10	 mov	 eax, DWORD PTR _pbShow$[ebp]

; 1697 : 
; 1698 : 	//BSTR bstrDesc;
; 1699 : 	//OutputDebugStringW(L"BEGINUI: ");
; 1700 : 	//pElement->GetDescription(&bstrDesc);
; 1701 : 	//OutputDebugStringW(bstrDesc);
; 1702 : 	//OutputDebugStringW(L"\n");
; 1703 : 
; 1704 : 	if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfReadingInformationUIElement), (void **)&preading)))

  00025	8d 4d 0c	 lea	 ecx, DWORD PTR _preading$[ebp]
  00028	51		 push	 ecx
  00029	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _preading$[ebp], 0
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pcandidate$[ebp], 0
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0003d	8b 06		 mov	 eax, DWORD PTR [esi]
  0003f	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea139_19df_11d7_a6d2_00065b84435c
  00044	56		 push	 esi
  00045	ff 10		 call	 DWORD PTR [eax]
  00047	85 c0		 test	 eax, eax
  00049	78 1f		 js	 SHORT $LN3@BeginUIEle

; 1705 :     {
; 1706 : 		MakeReadingInformationString(preading);

  0004b	ff 75 0c	 push	 DWORD PTR _preading$[ebp]
  0004e	e8 00 00 00 00	 call	 ?MakeReadingInformationString@CTsfUiLessMode@@KAXPAUITfReadingInformationUIElement@@@Z ; CTsfUiLessMode::MakeReadingInformationString

; 1707 : 		if(CIME::ms_pEvent)

  00053	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00059	83 c4 04	 add	 esp, 4
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 05		 je	 SHORT $LN5@BeginUIEle

; 1708 : 			CIME::ms_pEvent->OnOpenReadingWnd();

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	ff 50 14	 call	 DWORD PTR [eax+20]
$LN5@BeginUIEle:

; 1709 :         preading->Release();

  00065	8b 45 0c	 mov	 eax, DWORD PTR _preading$[ebp]

; 1710 :     }

  00068	eb 35		 jmp	 SHORT $LN9@BeginUIEle
$LN3@BeginUIEle:

; 1711 : 	else if (SUCCEEDED(pElement->QueryInterface(__uuidof(ITfCandidateListUIElement), (void **)&pcandidate)))

  0006a	8b 06		 mov	 eax, DWORD PTR [esi]
  0006c	8d 4d fc	 lea	 ecx, DWORD PTR _pcandidate$[ebp]
  0006f	51		 push	 ecx
  00070	68 00 00 00 00	 push	 OFFSET __GUID_ea1ea138_19df_11d7_a6d2_00065b84435c
  00075	56		 push	 esi
  00076	ff 10		 call	 DWORD PTR [eax]
  00078	85 c0		 test	 eax, eax
  0007a	78 29		 js	 SHORT $LN6@BeginUIEle

; 1712 : 	{
; 1713 : 		m_nCandidateRefCount++;
; 1714 : 		MakeCandidateStrings(pcandidate);

  0007c	ff 75 fc	 push	 DWORD PTR _pcandidate$[ebp]
  0007f	ff 05 00 00 00
	00		 inc	 DWORD PTR ?m_nCandidateRefCount@CTsfUiLessMode@@1HA ; CTsfUiLessMode::m_nCandidateRefCount
  00085	e8 00 00 00 00	 call	 ?MakeCandidateStrings@CTsfUiLessMode@@KAXPAUITfCandidateListUIElement@@@Z ; CTsfUiLessMode::MakeCandidateStrings

; 1715 : 		if(CIME::ms_pEvent)

  0008a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00090	83 c4 04	 add	 esp, 4
  00093	85 c9		 test	 ecx, ecx
  00095	74 05		 je	 SHORT $LN7@BeginUIEle

; 1716 : 			CIME::ms_pEvent->OnOpenCandidateList();

  00097	8b 01		 mov	 eax, DWORD PTR [ecx]
  00099	ff 50 0c	 call	 DWORD PTR [eax+12]
$LN7@BeginUIEle:

; 1717 : 		pcandidate->Release();

  0009c	8b 45 fc	 mov	 eax, DWORD PTR _pcandidate$[ebp]
$LN9@BeginUIEle:

; 1718 :     }
; 1719 : 
; 1720 :     pElement->Release();

  0009f	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a1	50		 push	 eax
  000a2	ff 51 08	 call	 DWORD PTR [ecx+8]
$LN6@BeginUIEle:
  000a5	8b 06		 mov	 eax, DWORD PTR [esi]
  000a7	56		 push	 esi
  000a8	ff 50 08	 call	 DWORD PTR [eax+8]

; 1721 :     return S_OK;

  000ab	33 c0		 xor	 eax, eax
  000ad	5e		 pop	 esi

; 1722 : }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 0c 00	 ret	 12			; 0000000cH
?BeginUIElement@CUIElementSink@CTsfUiLessMode@@UAGJKPAH@Z ENDP ; CTsfUiLessMode::CUIElementSink::BeginUIElement
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::Release, COMDAT

; 1677 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1678 :     LONG cr = --_cRef;

  00004	8b 75 08	 mov	 esi, DWORD PTR _this$[ebp]
  00007	57		 push	 edi
  00008	83 46 0c ff	 add	 DWORD PTR [esi+12], -1
  0000c	8b 7e 0c	 mov	 edi, DWORD PTR [esi+12]

; 1679 : 
; 1680 :     if (_cRef == 0)

  0000f	75 12		 jne	 SHORT $LN9@Release
  00011	8b ce		 mov	 ecx, esi
  00013	e8 00 00 00 00	 call	 ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ; CTsfUiLessMode::CUIElementSink::~CUIElementSink
  00018	6a 10		 push	 16			; 00000010H
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
$LN9@Release:

; 1681 :     {
; 1682 :         delete this;
; 1683 :     }
; 1684 : 
; 1685 :     return cr;
; 1686 : }

  00023	8b c7		 mov	 eax, edi
  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?Release@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::Release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ PROC	; CTsfUiLessMode::CUIElementSink::AddRef, COMDAT

; 1672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1673 :     return ++_cRef;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00006	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00009	40		 inc	 eax
  0000a	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1674 : }

  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?AddRef@CUIElementSink@CTsfUiLessMode@@UAGKXZ ENDP	; CTsfUiLessMode::CUIElementSink::AddRef
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_riid$ = 12						; size = 4
_ppvObj$ = 16						; size = 4
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z PROC ; CTsfUiLessMode::CUIElementSink::QueryInterface, COMDAT

; 1639 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	8b 5d 10	 mov	 ebx, DWORD PTR _ppvObj$[ebp]

; 1640 :     if (ppvObj == NULL)

  00007	85 db		 test	 ebx, ebx
  00009	75 0a		 jne	 SHORT $LN2@QueryInter

; 1641 :         return E_INVALIDARG;

  0000b	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00010	5b		 pop	 ebx

; 1669 : }

  00011	5d		 pop	 ebp
  00012	c2 0c 00	 ret	 12			; 0000000cH
$LN2@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00015	8b 55 0c	 mov	 edx, DWORD PTR _riid$[ebp]
  00018	8b ca		 mov	 ecx, edx
  0001a	56		 push	 esi
  0001b	57		 push	 edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1643 :     *ppvObj = NULL;

  0001c	c7 03 00 00 00
	00		 mov	 DWORD PTR [ebx], 0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00022	be 00 00 00 00	 mov	 esi, OFFSET _IID_IUnknown
  00027	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
  0002c	0f 1f 40 00	 npad	 4
$LL25@QueryInter:
  00030	8b 01		 mov	 eax, DWORD PTR [ecx]
  00032	3b 06		 cmp	 eax, DWORD PTR [esi]
  00034	75 12		 jne	 SHORT $LN3@QueryInter
  00036	83 c1 04	 add	 ecx, 4
  00039	83 c6 04	 add	 esi, 4
  0003c	83 ef 04	 sub	 edi, 4
  0003f	73 ef		 jae	 SHORT $LL25@QueryInter
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1647 :         *ppvObj = reinterpret_cast<IUnknown *>(this);

  00041	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00044	8b ca		 mov	 ecx, edx

; 1648 : 	}

  00046	eb 77		 jmp	 SHORT $LN9@QueryInter
$LN3@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00048	8b ca		 mov	 ecx, edx
  0004a	be 00 00 00 00	 mov	 esi, OFFSET __GUID_ea1ea136_19df_11d7_a6d2_00065b84435c
  0004f	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LL27@QueryInter:
  00054	8b 01		 mov	 eax, DWORD PTR [ecx]
  00056	3b 06		 cmp	 eax, DWORD PTR [esi]
  00058	75 12		 jne	 SHORT $LN5@QueryInter
  0005a	83 c1 04	 add	 ecx, 4
  0005d	83 c6 04	 add	 esi, 4
  00060	83 ef 04	 sub	 edi, 4
  00063	73 ef		 jae	 SHORT $LL27@QueryInter
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1651 :         *ppvObj = (ITfUIElementSink *)this;

  00065	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00068	8b ca		 mov	 ecx, edx

; 1652 :     }

  0006a	eb 53		 jmp	 SHORT $LN9@QueryInter
$LN5@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  0006c	8b ca		 mov	 ecx, edx
  0006e	be 00 00 00 00	 mov	 esi, OFFSET __GUID_71c6e74e_0f28_11d8_a82a_00065b84435c
  00073	bf 0c 00 00 00	 mov	 edi, 12			; 0000000cH
$LL29@QueryInter:
  00078	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007a	3b 06		 cmp	 eax, DWORD PTR [esi]
  0007c	75 13		 jne	 SHORT $LN7@QueryInter
  0007e	83 c1 04	 add	 ecx, 4
  00081	83 c6 04	 add	 esi, 4
  00084	83 ef 04	 sub	 edi, 4
  00087	73 ef		 jae	 SHORT $LL29@QueryInter
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1655 : 		*ppvObj = (ITfInputProcessorProfileActivationSink*)this;

  00089	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  0008c	8d 42 04	 lea	 eax, DWORD PTR [edx+4]

; 1656 : 	}

  0008f	eb 26		 jmp	 SHORT $LN34@QueryInter
$LN7@QueryInter:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

  00091	b9 00 00 00 00	 mov	 ecx, OFFSET __GUID_743abd5f_f26d_48df_8cc5_238492419b64
  00096	be 0c 00 00 00	 mov	 esi, 12			; 0000000cH
  0009b	0f 1f 44 00 00	 npad	 5
$LL31@QueryInter:
  000a0	8b 02		 mov	 eax, DWORD PTR [edx]
  000a2	3b 01		 cmp	 eax, DWORD PTR [ecx]
  000a4	75 2e		 jne	 SHORT $LN10@QueryInter
  000a6	83 c2 04	 add	 edx, 4
  000a9	83 c1 04	 add	 ecx, 4
  000ac	83 ee 04	 sub	 esi, 4
  000af	73 ef		 jae	 SHORT $LL31@QueryInter
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1659 : 		*ppvObj = (ITfCompartmentEventSink*)this;

  000b1	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  000b4	8d 42 08	 lea	 eax, DWORD PTR [edx+8]
$LN34@QueryInter:

; 1660 : 	}
; 1661 : 
; 1662 :     if (*ppvObj)

  000b7	8b ca		 mov	 ecx, edx
  000b9	f7 d9		 neg	 ecx
  000bb	1b c9		 sbb	 ecx, ecx
  000bd	23 c8		 and	 ecx, eax
$LN9@QueryInter:
  000bf	89 0b		 mov	 DWORD PTR [ebx], ecx
  000c1	85 c9		 test	 ecx, ecx
  000c3	74 0f		 je	 SHORT $LN10@QueryInter

; 1663 :     {
; 1664 :         AddRef();

  000c5	8b 02		 mov	 eax, DWORD PTR [edx]
  000c7	52		 push	 edx
  000c8	ff 50 04	 call	 DWORD PTR [eax+4]
  000cb	5f		 pop	 edi
  000cc	5e		 pop	 esi

; 1665 :         return S_OK;

  000cd	33 c0		 xor	 eax, eax
  000cf	5b		 pop	 ebx

; 1669 : }

  000d0	5d		 pop	 ebp
  000d1	c2 0c 00	 ret	 12			; 0000000cH
$LN10@QueryInter:
  000d4	5f		 pop	 edi
  000d5	5e		 pop	 esi

; 1666 :     }
; 1667 : 
; 1668 :     return E_NOINTERFACE;

  000d6	b8 02 40 00 80	 mov	 eax, -2147467262	; 80004002H
  000db	5b		 pop	 ebx

; 1669 : }

  000dc	5d		 pop	 ebp
  000dd	c2 0c 00	 ret	 12			; 0000000cH
?QueryInterface@CUIElementSink@CTsfUiLessMode@@UAGJABU_GUID@@PAPAX@Z ENDP ; CTsfUiLessMode::CUIElementSink::QueryInterface
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??1CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::~CUIElementSink, COMDAT
; _this$ = ecx

; 1635 : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@
  00006	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0000d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@

; 1636 : }

  00014	c3		 ret	 0
??1CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::~CUIElementSink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??0CUIElementSink@CTsfUiLessMode@@QAE@XZ
_TEXT	SEGMENT
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ PROC		; CTsfUiLessMode::CUIElementSink::CUIElementSink, COMDAT
; _this$ = ecx

; 1629 : {

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfUIElementSink@@@

; 1630 :     _cRef = 1;
; 1631 : }

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfInputProcessorProfileActivationSink@@@
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], OFFSET ??_7CUIElementSink@CTsfUiLessMode@@6BITfCompartmentEventSink@@@
  00016	c7 41 0c 01 00
	00 00		 mov	 DWORD PTR [ecx+12], 1
  0001d	c3		 ret	 0
??0CUIElementSink@CTsfUiLessMode@@QAE@XZ ENDP		; CTsfUiLessMode::CUIElementSink::CUIElementSink
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CIME::ms_wstrReading'', COMDAT

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  00006	85 c9		 test	 ecx, ecx
  00008	74 32		 je	 SHORT $LN6@ms_wstrRea

; 1695 :             _Destroy(_Myfirst, _Mylast);
; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0000a	a1 08 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+8
  0000f	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	83 e0 fe	 and	 eax, -2			; fffffffeH
  00014	50		 push	 eax
  00015	51		 push	 ecx
  00016	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001b	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A, 0

; 1699 :             _Mylast  = pointer();

  00028	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4, 0

; 1700 :             _Myend   = pointer();

  00032	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+8, 0
$LN6@ms_wstrRea:
  0003c	c3		 ret	 0
??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ PROC ; `dynamic initializer for 'CIME::ms_wstrReading'', COMDAT

; 120  : std::vector<wchar_t>	CIME::ms_wstrReading;

  00000	68 00 00 00 00	 push	 OFFSET ??__F?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ; `dynamic atexit destructor for 'CIME::ms_wstrReading''
  00005	e8 00 00 00 00	 call	 _atexit
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
??__E?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A@@YAXXZ ENDP ; `dynamic initializer for 'CIME::ms_wstrReading''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCIME@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCIME@@UAEPAXI@Z PROC				; CIME::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CIME@@UAE@XZ		; CIME::~CIME
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 24 08 00 00	 push	 2084			; 00000824H
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCIME@@UAEPAXI@Z ENDP				; CIME::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength, COMDAT

; 1705 :         _Xlength_error("vector too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@_WV?$allocator@_W@std@@@std@@CAXXZ ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
$T1 = 11						; size = 1
?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z PROC ; std::vector<wchar_t,std::allocator<wchar_t> >::resize, COMDAT
; _this$ = ecx

; 1240 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]

; 1240 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {

  00009	57		 push	 edi

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0000a	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0000d	8b 3e		 mov	 edi, DWORD PTR [esi]
  0000f	2b d7		 sub	 edx, edi
  00011	d1 fa		 sar	 edx, 1

; 1216 :         if (_Newsize < _Oldsize) { // trim

  00013	3b ca		 cmp	 ecx, edx
  00015	73 0c		 jae	 SHORT $LN4@resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00017	8d 04 4f	 lea	 eax, DWORD PTR [edi+ecx*2]
  0001a	5f		 pop	 edi

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  0001b	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0001e	5e		 pop	 esi
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
$LN4@resize:

; 1224 :         if (_Newsize > _Oldsize) { // append

  00023	76 2f		 jbe	 SHORT $LN5@resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00025	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00028	2b c7		 sub	 eax, edi
  0002a	d1 f8		 sar	 eax, 1

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  0002c	3b c8		 cmp	 ecx, eax
  0002e	76 12		 jbe	 SHORT $LN6@resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00030	8d 45 0b	 lea	 eax, DWORD PTR $T1[ebp]
  00033	50		 push	 eax
  00034	51		 push	 ecx
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@_WV?$allocator@_W@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Resize_reallocate<std::_Value_init_tag>
  0003c	5f		 pop	 edi

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  0003d	5e		 pop	 esi
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
$LN6@resize:

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00042	56		 push	 esi

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  00043	2b ca		 sub	 ecx, edx

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00045	51		 push	 ecx
  00046	ff 76 04	 push	 DWORD PTR [esi+4]
  00049	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@_W@std@@@std@@YAPA_WPA_WIAAV?$allocator@_W@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<wchar_t> >
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1241 :         // trim or append value-initialized elements, provide strong guarantee
; 1242 :         _Resize(_Newsize, _Value_init_tag{});
; 1243 :     }

  00051	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN5@resize:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ENDP ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetupImeApi@CIME@@KAXXZ
_TEXT	SEGMENT
_szImeFile$ = -268					; size = 261
__$ArrayPad$ = -4					; size = 4
?SetupImeApi@CIME@@KAXXZ PROC				; CIME::SetupImeApi, COMDAT

; 1374 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1375 :     char szImeFile[MAX_PATH + 1];
; 1376 : 
; 1377 : 	_GetReadingString = NULL;
; 1378 :     _ShowReadingWindow = NULL;
; 1379 : 	ms_bUseIMMCandidate = false;
; 1380 : 
; 1381 : 	if(ImmGetIMEFileNameA(ms_hklCurrent, szImeFile, COUNTOF(szImeFile) - 1) == 0)

  00013	68 04 01 00 00	 push	 260			; 00000104H
  00018	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  00028	50		 push	 eax
  00029	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0002f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, 0 ; CIME::_ShowReadingWindow
  00039	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 0 ; CIME::ms_bUseIMMCandidate
  00040	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  00045	85 c0		 test	 eax, eax
  00047	0f 84 dd 00 00
	00		 je	 $LN9@SetupImeAp

; 1382 : 		return;
; 1383 : 	if(stricmp(szImeFile, CHS_IMEFILENAME_QQPINYIN) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_SOGOUPY) == 0 || stricmp(szImeFile, CHS_IMEFILENAME_GOOGLEPINYIN2) == 0)

  0004d	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0N@EMABPIGL@QQPINYIN?4IME@
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 __stricmp
  0005e	83 c4 08	 add	 esp, 8
  00061	85 c0		 test	 eax, eax
  00063	74 30		 je	 SHORT $LN4@SetupImeAp
  00065	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@IPABOCGB@SOGOUPY?4IME@
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 __stricmp
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	74 18		 je	 SHORT $LN4@SetupImeAp
  0007d	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KLAKFCEJ@GOOGLEPINYIN2?4IME@
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 __stricmp
  0008e	83 c4 08	 add	 esp, 8
  00091	85 c0		 test	 eax, eax
  00093	75 07		 jne	 SHORT $LN3@SetupImeAp
$LN4@SetupImeAp:

; 1384 : 		ms_bUseIMMCandidate = true;

  00095	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, 1 ; CIME::ms_bUseIMMCandidate
$LN3@SetupImeAp:

; 1385 : 	if (ms_bUILessMode)

  0009c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  000a3	0f 85 81 00 00
	00		 jne	 $LN9@SetupImeAp

; 1386 : 		return;
; 1387 : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000ae	85 c0		 test	 eax, eax
  000b0	74 11		 je	 SHORT $LN6@SetupImeAp
  000b2	50		 push	 eax
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  000b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN6@SetupImeAp:

; 1388 : 	ms_hCurrentImeDll = LoadLibraryA(szImeFile);

  000c3	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szImeFile$[ebp]
  000c9	50		 push	 eax
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000d0	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hCurrentImeDll

; 1389 : 
; 1390 : 	if (ms_hCurrentImeDll) {

  000d5	85 c0		 test	 eax, eax
  000d7	74 51		 je	 SHORT $LN9@SetupImeAp

; 1391 : 		_GetReadingString = (UINT (WINAPI*)(HIMC, UINT, LPWSTR, PINT, BOOL*, PUINT)) (GetProcAddress(ms_hCurrentImeDll, "GetReadingString"));

  000d9	56		 push	 esi
  000da	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@EOIFCLLM@GetReadingString@
  000e5	50		 push	 eax
  000e6	ff d6		 call	 esi

; 1392 : 		_ShowReadingWindow =(BOOL (WINAPI*)(HIMC, BOOL)) (GetProcAddress(ms_hCurrentImeDll, "ShowReadingWindow"));

  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@MEELNKEC@ShowReadingWindow@
  000ed	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  000f3	a3 00 00 00 00	 mov	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, eax ; CIME::_GetReadingString
  000f8	ff d6		 call	 esi
  000fa	a3 00 00 00 00	 mov	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA, eax ; CIME::_ShowReadingWindow

; 1393 : 
; 1394 : 		if(_ShowReadingWindow) {

  000ff	85 c0		 test	 eax, eax
  00101	74 26		 je	 SHORT $LN11@SetupImeAp

; 1395 : 			HIMC hImc = ImmGetContext(ms_hWnd);

  00103	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00109	e8 00 00 00 00	 call	 _ImmGetContext@4
  0010e	8b f0		 mov	 esi, eax

; 1396 : 			if(hImc) {

  00110	85 f6		 test	 esi, esi
  00112	74 15		 je	 SHORT $LN11@SetupImeAp

; 1397 : 				_ShowReadingWindow(hImc, false);

  00114	6a 00		 push	 0
  00116	56		 push	 esi
  00117	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ShowReadingWindow@CIME@@1P6GHPAUHIMC__@@H@ZA ; CIME::_ShowReadingWindow

; 1398 : 				ImmReleaseContext(ms_hWnd, hImc);

  0011d	56		 push	 esi
  0011e	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00124	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN11@SetupImeAp:
  00129	5e		 pop	 esi
$LN9@SetupImeAp:

; 1399 : 			}
; 1400 : 		}
; 1401 : 	}
; 1402 : }

  0012a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012d	33 cd		 xor	 ecx, ebp
  0012f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c3		 ret	 0
?SetupImeApi@CIME@@KAXXZ ENDP				; CIME::SetupImeApi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReadingWindowOrientation@CIME@@IAE_NXZ
_TEXT	SEGMENT
_dwType$1 = -284					; size = 4
_dwMapping$2 = -280					; size = 4
_dwSize$3 = -276					; size = 4
_hKey$4 = -272						; size = 4
_bHorizontalReading$1$ = -265				; size = 1
_szRegPath$5 = -264					; size = 260
__$ArrayPad$ = -4					; size = 4
?GetReadingWindowOrientation@CIME@@IAE_NXZ PROC		; CIME::GetReadingWindowOrientation, COMDAT
; _this$ = ecx

; 1340 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1341 :     bool bHorizontalReading = (ms_hklCurrent == _CHS_HKL) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_adwId[0] == 0);

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  00018	53		 push	 ebx
  00019	3d 04 08 0e e0	 cmp	 eax, -535951356		; e00e0804H
  0001e	0f 84 aa 01 00
	00		 je	 $LN10@GetReading
  00024	3d 04 04 09 e0	 cmp	 eax, -536280060		; e0090404H
  00029	0f 84 9f 01 00
	00		 je	 $LN10@GetReading
  0002f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  00035	85 db		 test	 ebx, ebx
  00037	0f 84 91 01 00
	00		 je	 $LN10@GetReading
  0003d	32 c9		 xor	 cl, cl

; 1342 :     if(!bHorizontalReading && (GETLANG() == LANG_CHT))

  0003f	ba 04 04 00 00	 mov	 edx, 1028		; 00000404H
  00044	88 8d f7 fe ff
	ff		 mov	 BYTE PTR _bHorizontalReading$1$[ebp], cl
  0004a	66 3b c2	 cmp	 ax, dx
  0004d	0f 85 6a 01 00
	00		 jne	 $LN16@GetReading

; 1343 :     {
; 1344 :         char szRegPath[MAX_PATH];
; 1345 :         HKEY hKey;
; 1346 :         DWORD dwVer = ms_adwId[0] & 0xFFFF0000;
; 1347 :         strcpy(szRegPath, "software\\microsoft\\windows\\currentversion\\");

  00053	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@
  0005a	66 a1 28 00 00
	00		 mov	 ax, WORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+40
  00060	81 e3 00 00 ff
	ff		 and	 ebx, -65536		; ffff0000H
  00066	66 89 85 20 ff
	ff ff		 mov	 WORD PTR _szRegPath$5[ebp+40], ax

; 1348 :         strcat(szRegPath, (dwVer >= MAKEIMEVERSION(5, 1)) ? "MSTCIPH" : "TINTLGNT");

  0006d	81 fb 00 00 01
	05		 cmp	 ebx, 83951616		; 05010000H
  00073	a0 2a 00 00 00	 mov	 al, BYTE PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+42
  00078	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_07DEJAPC@MSTCIPH@
  0007d	0f 11 85 f8 fe
	ff ff		 movups	 XMMWORD PTR _szRegPath$5[ebp], xmm0
  00084	88 85 22 ff ff
	ff		 mov	 BYTE PTR _szRegPath$5[ebp+42], al
  0008a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LMKCILHO@TINTLGNT@
  0008f	0f 10 05 10 00
	00 00		 movups	 xmm0, XMMWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+16
  00096	56		 push	 esi
  00097	0f 42 d0	 cmovb	 edx, eax
  0009a	0f 11 85 08 ff
	ff ff		 movups	 XMMWORD PTR _szRegPath$5[ebp+16], xmm0
  000a1	8b f2		 mov	 esi, edx
  000a3	f3 0f 7e 05 20
	00 00 00	 movq	 xmm0, QWORD PTR ??_C@_0CL@PCFEMFCF@software?2microsoft?2windows?2curr@+32
  000ab	57		 push	 edi
  000ac	66 0f d6 85 18
	ff ff ff	 movq	 QWORD PTR _szRegPath$5[ebp+32], xmm0
$LL13@GetReading:
  000b4	8a 02		 mov	 al, BYTE PTR [edx]
  000b6	42		 inc	 edx
  000b7	84 c0		 test	 al, al
  000b9	75 f9		 jne	 SHORT $LL13@GetReading
  000bb	8d bd f8 fe ff
	ff		 lea	 edi, DWORD PTR _szRegPath$5[ebp]
  000c1	2b d6		 sub	 edx, esi
  000c3	4f		 dec	 edi
$LL14@GetReading:
  000c4	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000c7	47		 inc	 edi
  000c8	84 c0		 test	 al, al
  000ca	75 f8		 jne	 SHORT $LL14@GetReading
  000cc	8b ca		 mov	 ecx, edx

; 1349 :         LONG lRc = RegOpenKeyExA(HKEY_CURRENT_USER, szRegPath, 0, KEY_READ, &hKey);

  000ce	8d 85 f0 fe ff
	ff		 lea	 eax, DWORD PTR _hKey$4[ebp]
  000d4	c1 e9 02	 shr	 ecx, 2
  000d7	f3 a5		 rep movsd
  000d9	50		 push	 eax
  000da	68 19 00 02 00	 push	 131097			; 00020019H
  000df	6a 00		 push	 0
  000e1	8b ca		 mov	 ecx, edx
  000e3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _szRegPath$5[ebp]
  000e9	83 e1 03	 and	 ecx, 3
  000ec	50		 push	 eax
  000ed	f3 a4		 rep movsb
  000ef	68 01 00 00 80	 push	 -2147483647		; 80000001H
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegOpenKeyExA@20
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi

; 1350 :         if (lRc == ERROR_SUCCESS)

  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 a4 00 00
	00		 jne	 $LN15@GetReading

; 1351 :         {
; 1352 :             DWORD dwSize = sizeof(DWORD), dwMapping, dwType;
; 1353 :             lRc = RegQueryValueExA(hKey, "Keyboard Mapping", NULL, &dwType, (PBYTE)&dwMapping, &dwSize);

  00104	8d 85 ec fe ff
	ff		 lea	 eax, DWORD PTR _dwSize$3[ebp]
  0010a	c7 85 ec fe ff
	ff 04 00 00 00	 mov	 DWORD PTR _dwSize$3[ebp], 4
  00114	50		 push	 eax
  00115	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR _dwMapping$2[ebp]
  0011b	50		 push	 eax
  0011c	8d 85 e4 fe ff
	ff		 lea	 eax, DWORD PTR _dwType$1[ebp]
  00122	50		 push	 eax
  00123	6a 00		 push	 0
  00125	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@KFOMJFEN@Keyboard?5Mapping@
  0012a	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  00130	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24

; 1354 :             if (lRc == ERROR_SUCCESS)

  00136	85 c0		 test	 eax, eax
  00138	75 4b		 jne	 SHORT $LN19@GetReading

; 1355 :             {
; 1356 :                 if ((dwVer <= MAKEIMEVERSION(5, 0) && 
; 1357 :                        ((BYTE)dwMapping == 0x22 || (BYTE)dwMapping == 0x23))
; 1358 :                      ||

  0013a	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _dwMapping$2[ebp]
  00140	81 fb 00 00 00
	05		 cmp	 ebx, 83886080		; 05000000H
  00146	77 08		 ja	 SHORT $LN7@GetReading
  00148	3c 22		 cmp	 al, 34			; 00000022H
  0014a	74 1a		 je	 SHORT $LN6@GetReading
  0014c	3c 23		 cmp	 al, 35			; 00000023H
  0014e	74 16		 je	 SHORT $LN6@GetReading
$LN7@GetReading:
  00150	81 fb 00 00 01
	05		 cmp	 ebx, 83951616		; 05010000H
  00156	74 08		 je	 SHORT $LN8@GetReading
  00158	81 fb 00 00 02
	05		 cmp	 ebx, 84017152		; 05020000H
  0015e	75 25		 jne	 SHORT $LN19@GetReading
$LN8@GetReading:
  00160	2c 22		 sub	 al, 34			; 00000022H
  00162	3c 02		 cmp	 al, 2
  00164	77 1f		 ja	 SHORT $LN19@GetReading
$LN6@GetReading:

; 1359 :                      ((dwVer == MAKEIMEVERSION(5, 1) || dwVer == MAKEIMEVERSION(5, 2)) &&
; 1360 :                        (BYTE)dwMapping >= 0x22 && (BYTE)dwMapping <= 0x24)
; 1361 :                   )
; 1362 :                 {
; 1363 :                     bHorizontalReading = true;
; 1364 :                 }
; 1365 :             }
; 1366 :             RegCloseKey(hKey);

  00166	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  0016c	b3 01		 mov	 bl, 1
  0016e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 : 	return bHorizontalReading;

  00174	8a c3		 mov	 al, bl
  00176	5b		 pop	 ebx

; 1371 : }

  00177	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017a	33 cd		 xor	 ecx, ebp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	8b e5		 mov	 esp, ebp
  00183	5d		 pop	 ebp
  00184	c3		 ret	 0
$LN19@GetReading:

; 1359 :                      ((dwVer == MAKEIMEVERSION(5, 1) || dwVer == MAKEIMEVERSION(5, 2)) &&
; 1360 :                        (BYTE)dwMapping >= 0x22 && (BYTE)dwMapping <= 0x24)
; 1361 :                   )
; 1362 :                 {
; 1363 :                     bHorizontalReading = true;
; 1364 :                 }
; 1365 :             }
; 1366 :             RegCloseKey(hKey);

  00185	ff b5 f0 fe ff
	ff		 push	 DWORD PTR _hKey$4[ebp]
  0018b	8a 9d f7 fe ff
	ff		 mov	 bl, BYTE PTR _bHorizontalReading$1$[ebp]
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegCloseKey@4

; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 : 	return bHorizontalReading;

  00197	8a c3		 mov	 al, bl
  00199	5b		 pop	 ebx

; 1371 : }

  0019a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0019d	33 cd		 xor	 ecx, ebp
  0019f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a4	8b e5		 mov	 esp, ebp
  001a6	5d		 pop	 ebp
  001a7	c3		 ret	 0
$LN15@GetReading:

; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 : 	return bHorizontalReading;

  001a8	8a 85 f7 fe ff
	ff		 mov	 al, BYTE PTR _bHorizontalReading$1$[ebp]
  001ae	5b		 pop	 ebx

; 1371 : }

  001af	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b2	33 cd		 xor	 ecx, ebp
  001b4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b9	8b e5		 mov	 esp, ebp
  001bb	5d		 pop	 ebp
  001bc	c3		 ret	 0
$LN16@GetReading:

; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 : 	return bHorizontalReading;

  001bd	8a c1		 mov	 al, cl
  001bf	5b		 pop	 ebx

; 1371 : }

  001c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	33 cd		 xor	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
$LN10@GetReading:
  001ce	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d1	b0 01		 mov	 al, 1
  001d3	33 cd		 xor	 ecx, ebp
  001d5	5b		 pop	 ebx
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c3		 ret	 0
?GetReadingWindowOrientation@CIME@@IAE_NXZ ENDP		; CIME::GetReadingWindowOrientation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetImeId@CIME@@IAEKI@Z
_TEXT	SEGMENT
_cbVerData$1 = -1044					; size = 4
_lpVerData$2 = -1040					; size = 4
_lpVerBuffer$1$ = -1036					; size = 4
_dwVerHandle$ = -1032					; size = 4
_szTmp$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_uIndex$ = 8						; size = 4
?GetImeId@CIME@@IAEKI@Z PROC				; CIME::GetImeId, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 14 04 00
	00		 sub	 esp, 1044		; 00000414H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 1252 : 	static HKL hklPrev = 0;
; 1253 :     char szTmp[1024];
; 1254 : 
; 1255 : 	if (uIndex >= COUNTOF(ms_adwId))

  00016	8b 7d 08	 mov	 edi, DWORD PTR _uIndex$[ebp]
  00019	83 ff 02	 cmp	 edi, 2
  0001c	0f 83 2b 02 00
	00		 jae	 $LN17@GetImeId

; 1256 : 		return 0;
; 1257 : 	HKL hkl = ms_hklCurrent;

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent

; 1258 : 	if(hklPrev == hkl)

  00028	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A, ecx
  0002e	0f 84 67 02 00
	00		 je	 $LN18@GetImeId

; 1259 : 		return ms_adwId[uIndex];
; 1260 : 	hklPrev = hkl;
; 1261 : 
; 1262 : 	DWORD dwLang = ((DWORD)hkl & 0xffff);
; 1263 : 
; 1264 : 	if ( ms_bUILessMode && GETLANG() == LANG_CHT ) {

  00034	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  0003b	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  00040	89 0d 00 00 00
	00		 mov	 DWORD PTR ?hklPrev@?1??GetImeId@CIME@@IAEKI@Z@4PAUHKL__@@A, ecx
  00046	74 23		 je	 SHORT $LN4@GetImeId
  00048	66 3b c8	 cmp	 cx, ax
  0004b	75 1e		 jne	 SHORT $LN4@GetImeId

; 1265 : 		// In case of Vista, artifitial value is returned so that it's not considered as older IME.
; 1266 : 		ms_adwId[0] = IMEID_CHT_VER_VISTA;

  0004d	c7 05 00 00 00
	00 04 04 00 07	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 117441540 ; 07000404H

; 1267 : 		ms_adwId[1] = 0;
; 1268 : 		return ms_adwId[0];

  00057	b8 04 04 00 07	 mov	 eax, 117441540		; 07000404H
  0005c	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 0
  00066	e9 e4 01 00 00	 jmp	 $LN1@GetImeId
$LN4@GetImeId:

; 1269 : 	}
; 1270 : 
; 1271 : 	if (!((ms_hklCurrent == _CHT_HKL_NEW_PHONETIC) || (ms_hklCurrent == _CHT_HKL_NEW_CHANG_JIE) || (ms_hklCurrent == _CHT_HKL_NEW_QUICK) || (ms_hklCurrent == _CHT_HKL_HK_CANTONESE) || (ms_hklCurrent == _CHS_HKL))) {

  0006b	81 f9 04 04 08
	e0		 cmp	 ecx, -536345596		; e0080404H
  00071	74 24		 je	 SHORT $LN5@GetImeId
  00073	81 f9 04 04 09
	e0		 cmp	 ecx, -536280060		; e0090404H
  00079	74 1c		 je	 SHORT $LN5@GetImeId
  0007b	81 f9 04 04 0a
	e0		 cmp	 ecx, -536214524		; e00a0404H
  00081	74 14		 je	 SHORT $LN5@GetImeId
  00083	81 f9 04 04 0b
	e0		 cmp	 ecx, -536148988		; e00b0404H
  00089	74 0c		 je	 SHORT $LN5@GetImeId
  0008b	81 f9 04 08 0e
	e0		 cmp	 ecx, -535951356		; e00e0804H
  00091	0f 85 a2 01 00
	00		 jne	 $LN12@GetImeId
$LN5@GetImeId:

; 1272 : 		ms_adwId[0] = ms_adwId[1] = 0;
; 1273 :         return 0;
; 1274 : 	}
; 1275 : 
; 1276 : 	if (!ImmGetIMEFileNameA(ms_hklCurrent, szTmp, (sizeof(szTmp) / sizeof(szTmp[0])) - 1)) {

  00097	68 ff 03 00 00	 push	 1023			; 000003ffH
  0009c	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000a2	50		 push	 eax
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 _ImmGetIMEFileNameA@12
  000a9	85 c0		 test	 eax, eax
  000ab	0f 84 88 01 00
	00		 je	 $LN12@GetImeId

; 1277 : 		ms_adwId[0] = ms_adwId[1] = 0;
; 1278 :         return 0;
; 1279 : 	}
; 1280 : 
; 1281 :     if (!_GetReadingString)

  000b1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  000b8	0f 85 a0 00 00
	00		 jne	 $LN8@GetImeId

; 1282 : 	{
; 1283 :         if ((CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME1, -1) != CSTR_EQUAL) &&
; 1284 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME2, -1) != CSTR_EQUAL) &&
; 1285 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHT_IMEFILENAME3, -1) != CSTR_EQUAL) &&
; 1286 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME1, -1) != CSTR_EQUAL) &&

  000be	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CompareStringA@24
  000c4	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000ca	6a ff		 push	 -1
  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FFMHCBAD@TINTLGNT?4IME@
  000d1	6a ff		 push	 -1
  000d3	50		 push	 eax
  000d4	6a 01		 push	 1
  000d6	68 09 04 00 00	 push	 1033			; 00000409H
  000db	ff d6		 call	 esi
  000dd	83 f8 02	 cmp	 eax, 2
  000e0	74 7c		 je	 SHORT $LN8@GetImeId
  000e2	6a ff		 push	 -1
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JMLDIBIB@CINTLGNT?4IME@
  000e9	6a ff		 push	 -1
  000eb	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  000f1	50		 push	 eax
  000f2	6a 01		 push	 1
  000f4	68 09 04 00 00	 push	 1033			; 00000409H
  000f9	ff d6		 call	 esi
  000fb	83 f8 02	 cmp	 eax, 2
  000fe	74 5e		 je	 SHORT $LN8@GetImeId
  00100	6a ff		 push	 -1
  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0N@FHDFFBN@MSTCIPHA?4IME@
  00107	6a ff		 push	 -1
  00109	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0010f	50		 push	 eax
  00110	6a 01		 push	 1
  00112	68 09 04 00 00	 push	 1033			; 00000409H
  00117	ff d6		 call	 esi
  00119	83 f8 02	 cmp	 eax, 2
  0011c	74 40		 je	 SHORT $LN8@GetImeId
  0011e	6a ff		 push	 -1
  00120	68 00 00 00 00	 push	 OFFSET ??_C@_0N@JFHOELJF@PINTLGNT?4IME@
  00125	6a ff		 push	 -1
  00127	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0012d	50		 push	 eax
  0012e	6a 01		 push	 1
  00130	68 09 04 00 00	 push	 1033			; 00000409H
  00135	ff d6		 call	 esi
  00137	83 f8 02	 cmp	 eax, 2
  0013a	74 22		 je	 SHORT $LN8@GetImeId
  0013c	6a ff		 push	 -1
  0013e	68 00 00 00 00	 push	 OFFSET ??_C@_0N@ONOBNHOE@MSSCIPYA?4IME@
  00143	6a ff		 push	 -1
  00145	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0014b	50		 push	 eax
  0014c	6a 01		 push	 1
  0014e	68 09 04 00 00	 push	 1033			; 00000409H
  00153	ff d6		 call	 esi
  00155	83 f8 02	 cmp	 eax, 2
  00158	0f 85 db 00 00
	00		 jne	 $LN12@GetImeId
$LN8@GetImeId:

; 1287 :             (CompareStringA(LCID_INVARIANT, NORM_IGNORECASE, szTmp, -1, CHS_IMEFILENAME2, -1) != CSTR_EQUAL))
; 1288 : 		{
; 1289 : 			ms_adwId[0] = ms_adwId[1] = 0;
; 1290 : 	        return 0;
; 1291 :         }
; 1292 :     }
; 1293 : 
; 1294 :     DWORD   dwVerHandle;
; 1295 :     DWORD   dwVerSize = GetFileVersionInfoSize(szTmp, &dwVerHandle);

  0015e	8d 85 f8 fb ff
	ff		 lea	 eax, DWORD PTR _dwVerHandle$[ebp]
  00164	50		 push	 eax
  00165	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _GetFileVersionInfoSizeA@8

; 1296 : 	LANGID	langId = LOWORD(ms_hklCurrent);

  00171	0f b7 35 00 00
	00 00		 movzx	 esi, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  00178	8b d8		 mov	 ebx, eax

; 1297 : 
; 1298 :     if (dwVerSize)

  0017a	85 db		 test	 ebx, ebx
  0017c	0f 84 b7 00 00
	00		 je	 $LN12@GetImeId

; 1299 : 	{
; 1300 :         LPVOID lpVerBuffer = alloca(dwVerSize);

  00182	e8 00 00 00 00	 call	 __alloca_probe_16
  00187	8b c4		 mov	 eax, esp

; 1301 : 
; 1302 :         if (GetFileVersionInfo(szTmp, dwVerHandle, dwVerSize, lpVerBuffer))

  00189	50		 push	 eax
  0018a	53		 push	 ebx
  0018b	ff b5 f8 fb ff
	ff		 push	 DWORD PTR _dwVerHandle$[ebp]
  00191	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _lpVerBuffer$1$[ebp], eax
  00197	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _szTmp$[ebp]
  0019d	50		 push	 eax
  0019e	e8 00 00 00 00	 call	 _GetFileVersionInfoA@16
  001a3	85 c0		 test	 eax, eax
  001a5	0f 84 8e 00 00
	00		 je	 $LN12@GetImeId

; 1303 : 		{
; 1304 : 			LPVOID  lpVerData;
; 1305 : 			UINT    cbVerData;
; 1306 : 
; 1307 :             if(VerQueryValue(lpVerBuffer, "\\", &lpVerData, &cbVerData))

  001ab	8d 85 ec fb ff
	ff		 lea	 eax, DWORD PTR _cbVerData$1[ebp]
  001b1	50		 push	 eax
  001b2	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _lpVerData$2[ebp]
  001b8	50		 push	 eax
  001b9	68 00 00 00 00	 push	 OFFSET ??_C@_01KICIPPFI@?2@
  001be	ff b5 f4 fb ff
	ff		 push	 DWORD PTR _lpVerBuffer$1$[ebp]
  001c4	e8 00 00 00 00	 call	 _VerQueryValueA@16
  001c9	85 c0		 test	 eax, eax
  001cb	74 6c		 je	 SHORT $LN12@GetImeId

; 1308 : 			{
; 1309 :                 DWORD dwVer = ((VS_FIXEDFILEINFO*) lpVerData)->dwFileVersionMS;

  001cd	8b 95 f0 fb ff
	ff		 mov	 edx, DWORD PTR _lpVerData$2[ebp]
  001d3	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 1310 :                 dwVer = (dwVer & 0x00ff0000) << 8 | (dwVer & 0x000000ff) << 16;

  001d6	0f b6 c8	 movzx	 ecx, al
  001d9	25 00 00 ff ff	 and	 eax, -65536		; ffff0000H
  001de	c1 e1 08	 shl	 ecx, 8
  001e1	0b c8		 or	 ecx, eax
  001e3	c1 e1 08	 shl	 ecx, 8

; 1311 : 
; 1312 :                 if (_GetReadingString
; 1313 :                     ||
; 1314 :                     (langId == LANG_CHT &&
; 1315 :                         (dwVer == MAKEIMEVERSION(4, 2) || 
; 1316 :                         dwVer == MAKEIMEVERSION(4, 3) || 
; 1317 :                         dwVer == MAKEIMEVERSION(4, 4) || 
; 1318 :                         dwVer == MAKEIMEVERSION(5, 0) ||
; 1319 :                         dwVer == MAKEIMEVERSION(5, 1) ||
; 1320 :                         dwVer == MAKEIMEVERSION(5, 2) ||
; 1321 :                         dwVer == MAKEIMEVERSION(6, 0)))
; 1322 :                     ||

  001e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA, 0 ; CIME::_GetReadingString
  001ed	0f 85 97 00 00
	00		 jne	 $LN15@GetImeId
  001f3	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  001f8	66 3b f0	 cmp	 si, ax
  001fb	75 6b		 jne	 SHORT $LN14@GetImeId
  001fd	81 f9 00 00 02
	04		 cmp	 ecx, 67239936		; 04020000H
  00203	0f 84 81 00 00
	00		 je	 $LN15@GetImeId
  00209	81 f9 00 00 03
	04		 cmp	 ecx, 67305472		; 04030000H
  0020f	74 79		 je	 SHORT $LN15@GetImeId
  00211	81 f9 00 00 04
	04		 cmp	 ecx, 67371008		; 04040000H
  00217	74 71		 je	 SHORT $LN15@GetImeId
  00219	81 f9 00 00 00
	05		 cmp	 ecx, 83886080		; 05000000H
  0021f	74 69		 je	 SHORT $LN15@GetImeId
  00221	81 f9 00 00 01
	05		 cmp	 ecx, 83951616		; 05010000H
  00227	74 61		 je	 SHORT $LN15@GetImeId
  00229	81 f9 00 00 02
	05		 cmp	 ecx, 84017152		; 05020000H
  0022f	74 59		 je	 SHORT $LN15@GetImeId
  00231	81 f9 00 00 00
	06		 cmp	 ecx, 100663296		; 06000000H
  00237	74 51		 je	 SHORT $LN15@GetImeId
$LN12@GetImeId:

; 1330 : 					return ms_adwId[uIndex];
; 1331 :                 }
; 1332 :             }
; 1333 :         }
; 1334 :     }
; 1335 : 	ms_adwId[0] = ms_adwId[1] = 0;

  00239	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 0
  00243	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 0
$LN17@GetImeId:

; 1336 : 	return ms_adwId[0];
; 1337 : }

  0024d	33 c0		 xor	 eax, eax
$LN1@GetImeId:
  0024f	8d a5 e0 fb ff
	ff		 lea	 esp, DWORD PTR [ebp-1056]
  00255	5f		 pop	 edi
  00256	5e		 pop	 esi
  00257	5b		 pop	 ebx
  00258	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025b	33 cd		 xor	 ecx, ebp
  0025d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00262	8b e5		 mov	 esp, ebp
  00264	5d		 pop	 ebp
  00265	c2 04 00	 ret	 4
$LN14@GetImeId:

; 1311 : 
; 1312 :                 if (_GetReadingString
; 1313 :                     ||
; 1314 :                     (langId == LANG_CHT &&
; 1315 :                         (dwVer == MAKEIMEVERSION(4, 2) || 
; 1316 :                         dwVer == MAKEIMEVERSION(4, 3) || 
; 1317 :                         dwVer == MAKEIMEVERSION(4, 4) || 
; 1318 :                         dwVer == MAKEIMEVERSION(5, 0) ||
; 1319 :                         dwVer == MAKEIMEVERSION(5, 1) ||
; 1320 :                         dwVer == MAKEIMEVERSION(5, 2) ||
; 1321 :                         dwVer == MAKEIMEVERSION(6, 0)))
; 1322 :                     ||

  00268	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  0026d	66 3b f0	 cmp	 si, ax
  00270	75 c7		 jne	 SHORT $LN12@GetImeId
  00272	81 f9 00 00 01
	04		 cmp	 ecx, 67174400		; 04010000H
  00278	74 10		 je	 SHORT $LN15@GetImeId
  0027a	81 f9 00 00 02
	04		 cmp	 ecx, 67239936		; 04020000H
  00280	74 08		 je	 SHORT $LN15@GetImeId
  00282	81 f9 00 00 03
	05		 cmp	 ecx, 84082688		; 05030000H
  00288	75 af		 jne	 SHORT $LN12@GetImeId
$LN15@GetImeId:

; 1323 :                     (langId == LANG_CHS &&
; 1324 :                         (dwVer == MAKEIMEVERSION(4, 1) ||
; 1325 :                         dwVer == MAKEIMEVERSION(4, 2) ||
; 1326 :                         dwVer == MAKEIMEVERSION(5, 3))))
; 1327 : 				{
; 1328 :                     ms_adwId[0] = dwVer | langId;

  0028a	8b c6		 mov	 eax, esi
  0028c	0b c1		 or	 eax, ecx
  0028e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA, eax

; 1329 :                     ms_adwId[1] = ((VS_FIXEDFILEINFO*)lpVerData)->dwFileVersionLS;

  00293	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00296	a3 04 00 00 00	 mov	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, eax
$LN18@GetImeId:

; 1336 : 	return ms_adwId[0];
; 1337 : }

  0029b	8b 04 bd 00 00
	00 00		 mov	 eax, DWORD PTR ?ms_adwId@CIME@@2PAKA[edi*4]
  002a2	eb ab		 jmp	 SHORT $LN1@GetImeId
?GetImeId@CIME@@IAEKI@Z ENDP				; CIME::GetImeId
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsMax@CIME@@IAE_NPB_WH@Z
_TEXT	SEGMENT
_wInput$GSCopy$1$ = -68					; size = 4
_str$2 = -64						; size = 24
_input$3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_wInput$ = 8						; size = 4
_len$ = 12						; size = 4
?IsMax@CIME@@IAE_NPB_WH@Z PROC				; CIME::IsMax, COMDAT
; _this$ = ecx

; 1229 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	53		 push	 ebx
  0001f	56		 push	 esi
  00020	57		 push	 edi
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	8b d9		 mov	 ebx, ecx
  0002d	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]

; 1230 : 	if (ms_lastpos + len > IMESTR_MAXLEN)

  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00036	8b 45 08	 mov	 eax, DWORD PTR _wInput$[ebp]
  00039	89 45 bc	 mov	 DWORD PTR _wInput$GSCopy$1$[ebp], eax
  0003c	8d 04 39	 lea	 eax, DWORD PTR [ecx+edi]
  0003f	3d 00 04 00 00	 cmp	 eax, 1024		; 00000400H
  00044	0f 8f ed 00 00
	00		 jg	 $LN23@IsMax

; 1231 : 		return true;
; 1232 : 
; 1233 : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  0004a	6a 00		 push	 0
  0004c	6a 00		 push	 0
  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	51		 push	 ecx
  00053	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00058	6a 00		 push	 0
  0005a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1234 : 	int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, wInput, len, 0, 0, NULL, NULL);

  00066	6a 00		 push	 0
  00068	6a 00		 push	 0
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	57		 push	 edi
  0006f	ff 75 bc	 push	 DWORD PTR _wInput$GSCopy$1$[ebp]
  00072	8b f0		 mov	 esi, eax
  00074	6a 00		 push	 0
  00076	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 1235 : 	//return textLen + inputLen > m_max;
; 1236 : 
; 1237 : 	if (textLen + inputLen > m_max)

  00082	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00085	03 c6		 add	 eax, esi
  00087	3b c1		 cmp	 eax, ecx
  00089	0f 8f a8 00 00
	00		 jg	 $LN23@IsMax

; 1239 : 	else if (m_userMax != 0 && m_max != m_userMax)

  0008f	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  00092	85 c0		 test	 eax, eax
  00094	0f 84 99 00 00
	00		 je	 $LN5@IsMax
  0009a	3b c8		 cmp	 ecx, eax
  0009c	0f 84 91 00 00
	00		 je	 $LN5@IsMax

; 1240 : 	{
; 1241 : 		std::wstring str = GetTextTagOutputString(m_wText, ms_lastpos);

  000a2	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000a8	8d 45 c0	 lea	 eax, DWORD PTR _str$2[ebp]
  000ab	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString

; 1242 : 		std::wstring input = GetTextTagOutputString(wInput, len);

  000b6	57		 push	 edi
  000b7	ff 75 bc	 push	 DWORD PTR _wInput$GSCopy$1$[ebp]
  000ba	8d 45 d8	 lea	 eax, DWORD PTR _input$3[ebp]
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c4	50		 push	 eax
  000c5	e8 00 00 00 00	 call	 ?GetTextTagOutputString@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WH@Z ; GetTextTagOutputString

; 1243 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  000ca	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WideCharToMultiByte@32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2218 :         const value_type* _Result = _Bx._Buf;

  000d0	8d 45 c0	 lea	 eax, DWORD PTR _str$2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1242 : 		std::wstring input = GetTextTagOutputString(wInput, len);

  000d3	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  000d6	83 7d d4 08	 cmp	 DWORD PTR _str$2[ebp+20], 8

; 2219 :         if (_Large_string_engaged()) {

  000da	0f 43 45 c0	 cmovae	 eax, DWORD PTR _str$2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1243 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  000de	6a 00		 push	 0
  000e0	6a 00		 push	 0
  000e2	6a 00		 push	 0
  000e4	6a 00		 push	 0
  000e6	ff 75 d0	 push	 DWORD PTR _str$2[ebp+16]
  000e9	50		 push	 eax
  000ea	6a 00		 push	 0
  000ec	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  000f2	ff d7		 call	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  000f4	83 7d ec 08	 cmp	 DWORD PTR _input$3[ebp+20], 8

; 2218 :         const value_type* _Result = _Bx._Buf;

  000f8	8d 4d d8	 lea	 ecx, DWORD PTR _input$3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1244 : 		int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, input.c_str(), input.length(), 0, 0, NULL, NULL);

  000fb	6a 00		 push	 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2219 :         if (_Large_string_engaged()) {

  000fd	0f 43 4d d8	 cmovae	 ecx, DWORD PTR _input$3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1243 : 		int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, str.c_str(), str.length(), 0, 0, NULL, NULL);

  00101	8b f0		 mov	 esi, eax

; 1244 : 		int inputLen = WideCharToMultiByte(ms_uOutputCodePage, 0, input.c_str(), input.length(), 0, 0, NULL, NULL);

  00103	6a 00		 push	 0
  00105	6a 00		 push	 0
  00107	6a 00		 push	 0
  00109	ff 75 e8	 push	 DWORD PTR _input$3[ebp+16]
  0010c	51		 push	 ecx
  0010d	6a 00		 push	 0
  0010f	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00115	ff d7		 call	 edi

; 1245 : 		return textLen + inputLen > m_userMax;

  00117	03 c6		 add	 eax, esi
  00119	8d 4d d8	 lea	 ecx, DWORD PTR _input$3[ebp]
  0011c	3b 43 0c	 cmp	 eax, DWORD PTR [ebx+12]
  0011f	0f 9f c3	 setg	 bl
  00122	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00127	8d 4d c0	 lea	 ecx, DWORD PTR _str$2[ebp]
  0012a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0012f	8a c3		 mov	 al, bl
  00131	eb 06		 jmp	 SHORT $LN1@IsMax
$LN5@IsMax:

; 1246 : 	}
; 1247 : 	return false;

  00133	32 c0		 xor	 al, al
  00135	eb 02		 jmp	 SHORT $LN1@IsMax
$LN23@IsMax:

; 1238 : 		return true;

  00137	b0 01		 mov	 al, 1
$LN1@IsMax:

; 1248 : }

  00139	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00143	59		 pop	 ecx
  00144	5f		 pop	 edi
  00145	5e		 pop	 esi
  00146	5b		 pop	 ebx
  00147	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014a	33 cd		 xor	 ecx, ebp
  0014c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsMax@CIME@@IAE_NPB_WH@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _str$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IsMax@CIME@@IAE_NPB_WH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsMax@CIME@@IAE_NPB_WH@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsMax@CIME@@IAE_NPB_WH@Z ENDP				; CIME::IsMax
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_this$1$ = -184						; size = 4
_hImc$GSCopy$1$ = -180					; size = 4
_lpIC$1$ = -176						; size = 4
_nTcharSize$1$ = -172					; size = 4
_wstrLen$1$ = -172					; size = 4
_dwErr$ = -168						; size = 4
_tempLen$1$ = -164					; size = 4
_uMaxUiLen$1 = -164					; size = 4
_bUnicodeIme$1$ = -157					; size = 1
_temp$1$ = -156						; size = 4
_bVertical$2 = -156					; size = 4
_osi$3 = -152						; size = 148
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ReadingProcess, COMDAT
; _this$ = ecx

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec b8 00 00
	00		 sub	 esp, 184		; 000000b8H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1085 :     if (!ms_adwId[0])

  00013	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA, 0
  0001a	53		 push	 ebx
  0001b	8b 5d 08	 mov	 ebx, DWORD PTR _hImc$[ebp]
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	89 8d 48 ff ff
	ff		 mov	 DWORD PTR _this$1$[ebp], ecx
  00026	89 9d 4c ff ff
	ff		 mov	 DWORD PTR _hImc$GSCopy$1$[ebp], ebx
  0002c	0f 84 5b 03 00
	00		 je	 $LN29@ReadingPro

; 1086 : 	{
; 1087 : 		return;
; 1088 :     }
; 1089 : 
; 1090 :     DWORD dwErr = 0;
; 1091 : 
; 1092 :     if (_GetReadingString)

  00032	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString
  00037	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _dwErr$[ebp], 0
  00041	85 c0		 test	 eax, eax
  00043	0f 84 8d 00 00
	00		 je	 $LN5@ReadingPro

; 1093 : 	{
; 1094 :         UINT uMaxUiLen;
; 1095 :         BOOL bVertical;
; 1096 :         // Obtain the reading string size
; 1097 :         int wstrLen = _GetReadingString(hImc, 0, NULL, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  00049	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR _uMaxUiLen$1[ebp]
  0004f	51		 push	 ecx
  00050	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR _bVertical$2[ebp]
  00056	51		 push	 ecx
  00057	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR _dwErr$[ebp]
  0005d	51		 push	 ecx
  0005e	6a 00		 push	 0
  00060	6a 00		 push	 0
  00062	53		 push	 ebx
  00063	ff d0		 call	 eax
  00065	89 85 54 ff ff
	ff		 mov	 DWORD PTR _wstrLen$1$[ebp], eax

; 1098 : 
; 1099 : 		if(wstrLen == 0) {

  0006b	85 c0		 test	 eax, eax
  0006d	75 1a		 jne	 SHORT $LN7@ReadingPro

; 1100 : 			ms_wstrReading.resize(0);

  0006f	50		 push	 eax
  00070	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00075	e8 00 00 00 00	 call	 ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize

; 1105 : 		}
; 1106 : 
; 1107 : 		ms_bHorizontalReading = (bVertical == 0);

  0007a	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _bVertical$2[ebp], 0
  00081	0f 94 c0	 sete	 al

; 1108 : 
; 1109 :     } else {

  00084	e9 cd 00 00 00	 jmp	 $LN6@ReadingPro
$LN7@ReadingPro:

; 1101 : 		} else {
; 1102 : 			wchar_t *wstr = (wchar_t*)alloca(sizeof(wchar_t) * wstrLen);

  00089	8d 3c 00	 lea	 edi, DWORD PTR [eax+eax]
  0008c	8b c7		 mov	 eax, edi
  0008e	e8 00 00 00 00	 call	 __alloca_probe_16
  00093	8b f4		 mov	 esi, esp

; 1103 :             _GetReadingString(hImc, wstrLen, wstr, (PINT)&dwErr, &bVertical, &uMaxUiLen);

  00095	8d 85 5c ff ff
	ff		 lea	 eax, DWORD PTR _uMaxUiLen$1[ebp]
  0009b	50		 push	 eax
  0009c	8d 85 64 ff ff
	ff		 lea	 eax, DWORD PTR _bVertical$2[ebp]
  000a2	50		 push	 eax
  000a3	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR _dwErr$[ebp]
  000a9	50		 push	 eax
  000aa	56		 push	 esi
  000ab	ff b5 54 ff ff
	ff		 push	 DWORD PTR _wstrLen$1$[ebp]
  000b1	53		 push	 ebx
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR ?_GetReadingString@CIME@@1P6GIPAUHIMC__@@IPA_WPAH2PAI@ZA ; CIME::_GetReadingString

; 1104 : 			ms_wstrReading.assign(wstr, wstr+wstrLen);

  000b8	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  000bb	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  000c0	50		 push	 eax
  000c1	56		 push	 esi
  000c2	e8 00 00 00 00	 call	 ??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>

; 1105 : 		}
; 1106 : 
; 1107 : 		ms_bHorizontalReading = (bVertical == 0);

  000c7	83 bd 64 ff ff
	ff 00		 cmp	 DWORD PTR _bVertical$2[ebp], 0
  000ce	0f 94 c0	 sete	 al

; 1108 : 
; 1109 :     } else {

  000d1	e9 80 00 00 00	 jmp	 $LN6@ReadingPro
$LN5@ReadingPro:

; 1110 : 
; 1111 :         // IMEs that doesn't implement Reading String API
; 1112 : 		wchar_t* temp = NULL;
; 1113 : 		DWORD tempLen = 0;
; 1114 : 	    bool bUnicodeIme = false;
; 1115 : 		INPUTCONTEXT *lpIC = _ImmLockIMC(hImc);

  000d6	53		 push	 ebx
  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA ; CIME::_ImmLockIMC
  000dd	8b d8		 mov	 ebx, eax
  000df	89 9d 50 ff ff
	ff		 mov	 DWORD PTR _lpIC$1$[ebp], ebx

; 1116 : 
; 1117 : 		if (lpIC == NULL)

  000e5	85 db		 test	 ebx, ebx
  000e7	74 3e		 je	 SHORT $LN37@ReadingPro

; 1118 : 		{
; 1119 : 			temp = NULL;
; 1120 : 			tempLen = 0;
; 1121 : 		}
; 1122 : 		else
; 1123 : 		{
; 1124 : 			LPBYTE p = 0;
; 1125 : 			switch(ms_adwId[0])

  000e9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  000ef	81 f9 04 04 04
	04		 cmp	 ecx, 67372036		; 04040404H
  000f5	0f 87 7c 01 00
	00		 ja	 $LN32@ReadingPro
  000fb	0f 84 4b 01 00
	00		 je	 $LN11@ReadingPro
  00101	81 f9 04 08 02
	04		 cmp	 ecx, 67241988		; 04020804H
  00107	0f 87 33 01 00
	00		 ja	 $LN33@ReadingPro
  0010d	0f 84 c6 00 00
	00		 je	 $LN21@ReadingPro
  00113	81 f9 04 08 01
	04		 cmp	 ecx, 67176452		; 04010804H
  00119	74 75		 je	 SHORT $LN19@ReadingPro
  0011b	81 f9 04 04 02
	04		 cmp	 ecx, 67240964		; 04020404H
  00121	0f 84 25 01 00
	00		 je	 $LN11@ReadingPro
$LN37@ReadingPro:

; 1202 : 			ms_wstrReading.resize(0);

  00127	6a 00		 push	 0
  00129	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  0012e	e8 00 00 00 00	 call	 ?resize@?$vector@_WV?$allocator@_W@std@@@std@@QAEXI@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::resize
$LN27@ReadingPro:

; 1211 : 			}
; 1212 : 		}
; 1213 : 
; 1214 : 		_ImmUnlockIMCC(lpIC->hPrivate);

  00133	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA ; CIME::_ImmUnlockIMCC

; 1215 : 		_ImmUnlockIMC(hImc);

  0013f	ff b5 4c ff ff
	ff		 push	 DWORD PTR _hImc$GSCopy$1$[ebp]
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA ; CIME::_ImmUnlockIMC

; 1216 : 
; 1217 : 		ms_bHorizontalReading = GetReadingWindowOrientation();

  0014b	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR _this$1$[ebp]
  00151	e8 00 00 00 00	 call	 ?GetReadingWindowOrientation@CIME@@IAE_NXZ ; CIME::GetReadingWindowOrientation
$LN6@ReadingPro:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00156	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bHorizontalReading@CIME@@2_NA, al ; CIME::ms_bHorizontalReading
  0015b	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4
  00160	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1219 : 	if (ms_wstrReading.size()) {

  00166	a9 fe ff ff ff	 test	 eax, -2			; fffffffeH
  0016b	0f 84 17 02 00
	00		 je	 $LN28@ReadingPro

; 1220 : 		ms_bReadingInformation = true;
; 1221 : 		if(ms_pEvent)

  00171	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00177	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 1 ; CIME::ms_bReadingInformation
  0017e	85 c9		 test	 ecx, ecx
  00180	0f 84 07 02 00
	00		 je	 $LN29@ReadingPro

; 1222 : 			ms_pEvent->OnOpenReadingWnd();

  00186	8b 01		 mov	 eax, DWORD PTR [ecx]
  00188	ff 50 14	 call	 DWORD PTR [eax+20]

; 1223 : 	} else {

  0018b	e9 fd 01 00 00	 jmp	 $LN29@ReadingPro
$LN19@ReadingPro:

; 1160 : 					break;
; 1161 : 
; 1162 : 				// the code tested only with Win 98 SE (MSPY 1.5/ ver 4.1.0.21)
; 1163 : 				case IMEID_CHS_VER41:
; 1164 : 					{
; 1165 : 						int nOffset;
; 1166 : 						nOffset = (ms_adwId[1] >= 0x00000002) ? 8 : 7;

  00190	83 3d 04 00 00
	00 02		 cmp	 DWORD PTR ?ms_adwId@CIME@@2PAKA+4, 2

; 1167 : 
; 1168 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + nOffset * 4);

  00197	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  0019d	1b f6		 sbb	 esi, esi
  0019f	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  001a5	8b 74 b0 20	 mov	 esi, DWORD PTR [eax+esi*4+32]

; 1169 : 						if(!p) break;

  001a9	85 f6		 test	 esi, esi
  001ab	0f 84 76 ff ff
	ff		 je	 $LN37@ReadingPro

; 1170 : 						tempLen = *(DWORD *)(p + 7*4 + 16*2*4);
; 1171 : 						dwErr = *(DWORD *)(p + 8*4 + 16*2*4);

  001b1	8b 86 a0 00 00
	00		 mov	 eax, DWORD PTR [esi+160]
  001b7	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]

; 1172 : 						dwErr = min(dwErr, tempLen);
; 1173 : 						temp = (wchar_t *)(p + 6*4 + 16*2*1);

  001bd	83 c6 38	 add	 esi, 56			; 00000038H
  001c0	3b c1		 cmp	 eax, ecx

; 1174 : 						bUnicodeIme = true;

  001c2	c6 85 63 ff ff
	ff 01		 mov	 BYTE PTR _bUnicodeIme$1$[ebp], 1
  001c9	8b d1		 mov	 edx, ecx
  001cb	0f 42 d0	 cmovb	 edx, eax

; 1175 : 					}
; 1176 : 					break;

  001ce	8a 85 63 ff ff
	ff		 mov	 al, BYTE PTR _bUnicodeIme$1$[ebp]
  001d4	e9 25 01 00 00	 jmp	 $LN38@ReadingPro
$LN21@ReadingPro:

; 1177 : 
; 1178 : 				case IMEID_CHS_VER42: // 4.2.x.x // SCIME98 or MSPY2 (w/Office2k, Win2k, WinME, etc)
; 1179 : 					{
; 1180 : 						OSVERSIONINFOA osi;
; 1181 : 						osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
; 1182 : 						GetVersionExA(&osi);

  001d9	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _osi$3[ebp]
  001df	c7 85 68 ff ff
	ff 94 00 00 00	 mov	 DWORD PTR _osi$3[ebp], 148 ; 00000094H
  001e9	50		 push	 eax
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 1183 : 
; 1184 : 						int nTcharSize = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? sizeof(wchar_t) : sizeof(char);
; 1185 : 						p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 1*4 + 1*4 + 6*4);

  001f0	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  001f6	33 c0		 xor	 eax, eax
  001f8	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR _osi$3[ebp+16], 2
  001ff	0f 94 c0	 sete	 al
  00202	40		 inc	 eax
  00203	89 85 54 ff ff
	ff		 mov	 DWORD PTR _nTcharSize$1$[ebp], eax
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  0020f	8b 78 20	 mov	 edi, DWORD PTR [eax+32]

; 1186 : 						if(!p) break;

  00212	85 ff		 test	 edi, edi
  00214	0f 84 0d ff ff
	ff		 je	 $LN37@ReadingPro

; 1187 : 						tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize);

  0021a	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR _nTcharSize$1$[ebp]

; 1188 : 						dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * nTcharSize + 1*4);
; 1189 : 						temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  00220	8d 77 40	 lea	 esi, DWORD PTR [edi+64]
  00223	8d 42 04	 lea	 eax, DWORD PTR [edx+4]
  00226	03 c0		 add	 eax, eax

; 1190 : 						bUnicodeIme = (osi.dwPlatformId == VER_PLATFORM_WIN32_NT) ? true : false;

  00228	83 bd 78 ff ff
	ff 02		 cmp	 DWORD PTR _osi$3[ebp+16], 2
  0022f	8b 0c c7	 mov	 ecx, DWORD PTR [edi+eax*8]
  00232	0f 94 c0	 sete	 al
  00235	03 d2		 add	 edx, edx
  00237	8b 54 d7 44	 mov	 edx, DWORD PTR [edi+edx*8+68]

; 1191 : 					}
; 1192 : 					break;

  0023b	e9 be 00 00 00	 jmp	 $LN38@ReadingPro
$LN33@ReadingPro:

; 1118 : 		{
; 1119 : 			temp = NULL;
; 1120 : 			tempLen = 0;
; 1121 : 		}
; 1122 : 		else
; 1123 : 		{
; 1124 : 			LPBYTE p = 0;
; 1125 : 			switch(ms_adwId[0])

  00240	81 f9 04 04 03
	04		 cmp	 ecx, 67306500		; 04030404H
  00246	0f 85 db fe ff
	ff		 jne	 $LN37@ReadingPro
$LN11@ReadingPro:

; 1126 : 			{
; 1127 : 				case IMEID_CHT_VER42: // New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98
; 1128 : 				case IMEID_CHT_VER43: // New(Phonetic/ChanJie)IME98a : 4.3.x.x // WinMe, Win2k
; 1129 : 				case IMEID_CHT_VER44: // New ChanJie IME98b          : 4.4.x.x // WinXP
; 1130 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 24);

  0024c	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  00252	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  00258	8b 50 18	 mov	 edx, DWORD PTR [eax+24]

; 1131 : 					if (!p) break;

  0025b	85 d2		 test	 edx, edx
  0025d	0f 84 c4 fe ff
	ff		 je	 $LN37@ReadingPro

; 1132 : 					tempLen = *(DWORD *)(p + 7 * 4 + 32 * 4);

  00263	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]

; 1133 : 					dwErr = *(DWORD *)(p + 8 * 4 + 32 * 4);
; 1134 : 					temp = (wchar_t *)(p + 56);

  00269	8d 72 38	 lea	 esi, DWORD PTR [edx+56]

; 1135 : 					bUnicodeIme = true;

  0026c	8b 92 a0 00 00
	00		 mov	 edx, DWORD PTR [edx+160]

; 1136 : 					break;

  00272	e9 85 00 00 00	 jmp	 $LN39@ReadingPro
$LN32@ReadingPro:

; 1118 : 		{
; 1119 : 			temp = NULL;
; 1120 : 			tempLen = 0;
; 1121 : 		}
; 1122 : 		else
; 1123 : 		{
; 1124 : 			LPBYTE p = 0;
; 1125 : 			switch(ms_adwId[0])

  00277	81 f9 04 04 02
	05		 cmp	 ecx, 84018180		; 05020404H
  0027d	77 46		 ja	 SHORT $LN34@ReadingPro
  0027f	74 50		 je	 SHORT $LN16@ReadingPro
  00281	81 f9 04 04 00
	05		 cmp	 ecx, 83887108		; 05000404H
  00287	74 0d		 je	 SHORT $LN13@ReadingPro
  00289	81 f9 04 04 01
	05		 cmp	 ecx, 83952644		; 05010404H
  0028f	74 40		 je	 SHORT $LN16@ReadingPro
  00291	e9 91 fe ff ff	 jmp	 $LN37@ReadingPro
$LN13@ReadingPro:

; 1137 : 
; 1138 : 				case IMEID_CHT_VER50: // 5.0.x.x // WinME
; 1139 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 3 * 4);

  00296	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  0029c	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  002a2	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]

; 1140 : 					if(!p) break;

  002a5	85 d2		 test	 edx, edx
  002a7	0f 84 7a fe ff
	ff		 je	 $LN37@ReadingPro

; 1141 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4 + 4*2);

  002ad	8b 52 20	 mov	 edx, DWORD PTR [edx+32]

; 1142 : 					if(!p) break;

  002b0	85 d2		 test	 edx, edx
  002b2	0f 84 6f fe ff
	ff		 je	 $LN37@ReadingPro

; 1143 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16);

  002b8	8b 4a 50	 mov	 ecx, DWORD PTR [edx+80]

; 1144 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 + 1*4);
; 1145 : 					temp = (wchar_t *)(p + 1*4 + (16*2+2*4) + 5*4);

  002bb	8d 72 40	 lea	 esi, DWORD PTR [edx+64]

; 1146 : 					bUnicodeIme = false;

  002be	8b 52 54	 mov	 edx, DWORD PTR [edx+84]
  002c1	32 c0		 xor	 al, al

; 1147 : 					break;

  002c3	eb 39		 jmp	 SHORT $LN38@ReadingPro
$LN34@ReadingPro:

; 1118 : 		{
; 1119 : 			temp = NULL;
; 1120 : 			tempLen = 0;
; 1121 : 		}
; 1122 : 		else
; 1123 : 		{
; 1124 : 			LPBYTE p = 0;
; 1125 : 			switch(ms_adwId[0])

  002c5	81 f9 04 08 03
	05		 cmp	 ecx, 84084740		; 05030804H
  002cb	0f 85 56 fe ff
	ff		 jne	 $LN37@ReadingPro
$LN16@ReadingPro:

; 1148 : 
; 1149 : 				case IMEID_CHT_VER51: // 5.1.x.x // IME2002(w/OfficeXP)
; 1150 : 				case IMEID_CHT_VER52: // 5.2.x.x // (w/whistler)
; 1151 : 				case IMEID_CHS_VER53: // 5.3.x.x // SCIME2k or MSPY3 (w/OfficeXP and Whistler)
; 1152 : 					p = *(LPBYTE *)((LPBYTE)_ImmLockIMCC(lpIC->hPrivate) + 4);

  002d1	ff b3 24 01 00
	00		 push	 DWORD PTR [ebx+292]
  002d7	ff 15 00 00 00
	00		 call	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA ; CIME::_ImmLockIMCC
  002dd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]

; 1153 : 					if(!p) break;

  002e0	85 d2		 test	 edx, edx
  002e2	0f 84 3f fe ff
	ff		 je	 $LN37@ReadingPro

; 1154 : 					p = *(LPBYTE *)((LPBYTE)p + 1*4 + 5*4);

  002e8	8b 52 18	 mov	 edx, DWORD PTR [edx+24]

; 1155 : 					if(!p) break;

  002eb	85 d2		 test	 edx, edx
  002ed	0f 84 34 fe ff
	ff		 je	 $LN37@ReadingPro

; 1156 : 					tempLen = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2);

  002f3	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]

; 1157 : 					dwErr = *(DWORD *)(p + 1*4 + (16*2+2*4) + 5*4 + 16 * 2 + 1*4);
; 1158 : 					temp  = (wchar_t *) (p + 1*4 + (16*2+2*4) + 5*4);

  002f6	8d 72 40	 lea	 esi, DWORD PTR [edx+64]

; 1159 : 					bUnicodeIme = true;

  002f9	8b 52 64	 mov	 edx, DWORD PTR [edx+100]
$LN39@ReadingPro:

; 1193 : 
; 1194 : 				default:
; 1195 : 					temp = NULL;
; 1196 : 					tempLen = 0;
; 1197 : 					break;
; 1198 : 			}
; 1199 : 		}
; 1200 : 
; 1201 : 		if(tempLen == 0) {

  002fc	b0 01		 mov	 al, 1
$LN38@ReadingPro:
  002fe	89 8d 5c ff ff
	ff		 mov	 DWORD PTR _tempLen$1$[ebp], ecx
  00304	89 b5 64 ff ff
	ff		 mov	 DWORD PTR _temp$1$[ebp], esi
  0030a	89 95 58 ff ff
	ff		 mov	 DWORD PTR _dwErr$[ebp], edx
  00310	85 c9		 test	 ecx, ecx
  00312	0f 84 0f fe ff
	ff		 je	 $LN37@ReadingPro

; 1203 : 		} else {
; 1204 : 			if(bUnicodeIme) {

  00318	84 c0		 test	 al, al
  0031a	74 14		 je	 SHORT $LN26@ReadingPro

; 1205 : 				ms_wstrReading.assign(temp, temp+tempLen);

  0031c	8d 04 4e	 lea	 eax, DWORD PTR [esi+ecx*2]
  0031f	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00324	50		 push	 eax
  00325	56		 push	 esi
  00326	e8 00 00 00 00	 call	 ??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>

; 1206 : 			} else {

  0032b	e9 03 fe ff ff	 jmp	 $LN27@ReadingPro
$LN26@ReadingPro:

; 1207 : 				int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, NULL, 0); 

  00330	6a 00		 push	 0
  00332	6a 00		 push	 0
  00334	51		 push	 ecx
  00335	56		 push	 esi
  00336	6a 00		 push	 0
  00338	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0033e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24
  00344	8b f0		 mov	 esi, eax

; 1208 : 				wchar_t* wstr = (wchar_t*)alloca(sizeof(wchar_t)*wstrLen);

  00346	8d 1c 36	 lea	 ebx, DWORD PTR [esi+esi]
  00349	8b c3		 mov	 eax, ebx
  0034b	e8 00 00 00 00	 call	 __alloca_probe_16
  00350	8b fc		 mov	 edi, esp

; 1209 : 				MultiByteToWideChar(ms_uInputCodePage, 0, (char*)temp, tempLen, wstr, wstrLen); 

  00352	56		 push	 esi
  00353	57		 push	 edi
  00354	ff b5 5c ff ff
	ff		 push	 DWORD PTR _tempLen$1$[ebp]
  0035a	ff b5 64 ff ff
	ff		 push	 DWORD PTR _temp$1$[ebp]
  00360	6a 00		 push	 0
  00362	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00368	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 1210 : 				ms_wstrReading.assign(wstr, wstr+wstrLen);

  0036e	8d 04 3b	 lea	 eax, DWORD PTR [ebx+edi]
  00371	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A ; CIME::ms_wstrReading
  00376	50		 push	 eax
  00377	57		 push	 edi
  00378	e8 00 00 00 00	 call	 ??$assign@PA_W$0A@@?$vector@_WV?$allocator@_W@std@@@std@@QAEXPA_W0@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::assign<wchar_t *,0>
  0037d	8b 9d 50 ff ff
	ff		 mov	 ebx, DWORD PTR _lpIC$1$[ebp]
  00383	e9 ab fd ff ff	 jmp	 $LN27@ReadingPro
$LN28@ReadingPro:

; 1224 : 		CloseReadingInformation();

  00388	e8 00 00 00 00	 call	 ?CloseReadingInformation@CIME@@SAXXZ ; CIME::CloseReadingInformation
$LN29@ReadingPro:

; 1225 : 	}
; 1226 : }

  0038d	8d a5 3c ff ff
	ff		 lea	 esp, DWORD PTR [ebp-196]
  00393	5f		 pop	 edi
  00394	5e		 pop	 esi
  00395	5b		 pop	 ebx
  00396	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00399	33 cd		 xor	 ecx, ebp
  0039b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  003a0	8b e5		 mov	 esp, ebp
  003a2	5d		 pop	 ebp
  003a3	c2 04 00	 ret	 4
?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ReadingProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_abyCandidate$ = -36					; size = 12
_this$1$ = -24						; size = 4
tv606 = -20						; size = 4
tv607 = -16						; size = 4
_j$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv605 = 8						; size = 4
_cChars$1$ = 8						; size = 4
_hImc$ = 8						; size = 4
$T2 = 11						; size = 1
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::CandidateProcess, COMDAT
; _this$ = ecx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e8	 mov	 DWORD PTR _this$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0002b	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp], 0
  00032	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp+4], 0
  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _abyCandidate$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1028 : 	DWORD dwCandidateLen = ImmGetCandidateListW(hImc, 0, NULL, 0);

  00040	8b 7d 08	 mov	 edi, DWORD PTR _hImc$[ebp]
  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	57		 push	 edi
  0004a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00051	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16
  00056	8b f0		 mov	 esi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1224 :         if (_Newsize > _Oldsize) { // append

  00058	85 f6		 test	 esi, esi
  0005a	0f 84 b7 01 00
	00		 je	 $LN43@CandidateP

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate
; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00060	8d 45 0b	 lea	 eax, DWORD PTR $T2[ebp]
  00063	50		 push	 eax
  00064	56		 push	 esi
  00065	8d 4d dc	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00068	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1034 : 		dwCandidateLen = ImmGetCandidateListW(hImc, 0, lpCandidateList, dwCandidateLen);

  0006d	8b 5d dc	 mov	 ebx, DWORD PTR _abyCandidate$[ebp]
  00070	56		 push	 esi
  00071	53		 push	 ebx
  00072	6a 00		 push	 0
  00074	57		 push	 edi
  00075	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 1 ; CIME::ms_bCandidateList
  0007c	e8 00 00 00 00	 call	 _ImmGetCandidateListW@16

; 1035 : 
; 1036 : 		ms_dwCandidateSelection	= lpCandidateList->dwSelection;

  00081	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]

; 1037 : 		ms_dwCandidateCount		= lpCandidateList->dwCount;
; 1038 : 
; 1039 : 		int iStartOfPage = 0;

  00084	33 ff		 xor	 edi, edi
  00086	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection

; 1040 : 
; 1041 : 		if( GETLANG() == LANG_CHS ) {

  0008b	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  00090	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  00093	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, ecx ; CIME::ms_dwCandidateCount
  00099	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, ax
  000a0	75 53		 jne	 SHORT $LN9@CandidateP

; 1042 : 			// MSPY (CHS IME) has variable number of candidates in candidate window find where current page starts, and the size of current page
; 1043 : 			const int maxCandChar = 18 * (3 - sizeof(TCHAR));
; 1044 : 			UINT cChars = 0;

  000a2	33 c0		 xor	 eax, eax

; 1045 : 			UINT i;
; 1046 : 			for (i = 0; i < ms_dwCandidateCount; i++)

  000a4	33 f6		 xor	 esi, esi
  000a6	89 45 08	 mov	 DWORD PTR _cChars$1$[ebp], eax
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 3e		 je	 SHORT $LN59@CandidateP

; 1042 : 			// MSPY (CHS IME) has variable number of candidates in candidate window find where current page starts, and the size of current page
; 1043 : 			const int maxCandChar = 18 * (3 - sizeof(TCHAR));
; 1044 : 			UINT cChars = 0;

  000ad	8d 43 18	 lea	 eax, DWORD PTR [ebx+24]
  000b0	89 45 f0	 mov	 DWORD PTR tv607[ebp], eax
$LL4@CandidateP:

; 1047 : 			{
; 1048 : 				UINT uLen = lstrlenW((LPWSTR)((DWORD)lpCandidateList + lpCandidateList->dwOffset[i])) + (3 - sizeof(WCHAR));

  000b3	8b 00		 mov	 eax, DWORD PTR [eax]
  000b5	03 c3		 add	 eax, ebx
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__lstrlenW@4

; 1049 : 				if (uLen + cChars > maxCandChar)

  000be	8b 4d 08	 mov	 ecx, DWORD PTR _cChars$1$[ebp]
  000c1	40		 inc	 eax
  000c2	03 c8		 add	 ecx, eax
  000c4	89 4d 08	 mov	 DWORD PTR _cChars$1$[ebp], ecx
  000c7	83 f9 24	 cmp	 ecx, 36			; 00000024H
  000ca	76 0d		 jbe	 SHORT $LN2@CandidateP

; 1050 : 				{
; 1051 : 					if (i > ms_dwCandidateSelection)

  000cc	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  000d2	77 17		 ja	 SHORT $LN59@CandidateP

; 1052 : 					{
; 1053 : 						break;
; 1054 : 					}
; 1055 : 					iStartOfPage = i;

  000d4	8b fe		 mov	 edi, esi

; 1056 : 					cChars = uLen;

  000d6	89 45 08	 mov	 DWORD PTR _cChars$1$[ebp], eax
$LN2@CandidateP:

; 1045 : 			UINT i;
; 1046 : 			for (i = 0; i < ms_dwCandidateCount; i++)

  000d9	8b 45 f0	 mov	 eax, DWORD PTR tv607[ebp]
  000dc	46		 inc	 esi
  000dd	83 c0 04	 add	 eax, 4
  000e0	89 45 f0	 mov	 DWORD PTR tv607[ebp], eax
  000e3	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount
  000e9	72 c8		 jb	 SHORT $LL4@CandidateP
$LN59@CandidateP:

; 1057 : 				}
; 1058 : 				else
; 1059 : 				{
; 1060 : 					cChars += uLen;
; 1061 : 				}
; 1062 : 			}
; 1063 : 			ms_dwCandidatePageSize	= i - iStartOfPage;

  000eb	2b f7		 sub	 esi, edi
  000ed	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, esi ; CIME::ms_dwCandidatePageSize

; 1064 : 		} else {

  000f3	eb 33		 jmp	 SHORT $LN18@CandidateP
$LN9@CandidateP:

; 1065 : 			ms_dwCandidatePageSize	= MIN( lpCandidateList->dwPageSize, MAX_CANDLIST );

  000f5	6a 0a		 push	 10			; 0000000aH
  000f7	ff 73 14	 push	 DWORD PTR [ebx+20]
  000fa	e8 00 00 00 00	 call	 ?MIN@@YAHHH@Z		; MIN
  000ff	83 c4 08	 add	 esp, 8
  00102	8b f0		 mov	 esi, eax

; 1066 : 			iStartOfPage = ms_bUILessMode ? lpCandidateList->dwPageStart : (ms_dwCandidateSelection / (MAX_CANDLIST - 1)) * (MAX_CANDLIST - 1);

  00104	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  0010b	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA, esi ; CIME::ms_dwCandidatePageSize
  00111	74 05		 je	 SHORT $LN17@CandidateP
  00113	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00116	eb 10		 jmp	 SHORT $LN18@CandidateP
$LN17@CandidateP:
  00118	b8 39 8e e3 38	 mov	 eax, 954437177		; 38e38e39H
  0011d	f7 25 00 00 00
	00		 mul	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  00123	d1 ea		 shr	 edx, 1
  00125	8d 3c d2	 lea	 edi, DWORD PTR [edx+edx*8]
$LN18@CandidateP:

; 1067 : 		}
; 1068 : 
; 1069 : 		ms_dwCandidateSelection = ( GETLANG() == LANG_CHS && !GetImeId() ) ? (DWORD)-1 : ms_dwCandidateSelection - iStartOfPage;

  00128	b8 04 08 00 00	 mov	 eax, 2052		; 00000804H
  0012d	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, ax
  00134	75 19		 jne	 SHORT $LN19@CandidateP
  00136	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  00139	6a 00		 push	 0
  0013b	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  00140	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize
  00146	85 c0		 test	 eax, eax
  00148	75 05		 jne	 SHORT $LN19@CandidateP
  0014a	83 c8 ff	 or	 eax, -1
  0014d	eb 07		 jmp	 SHORT $LN20@CandidateP
$LN19@CandidateP:
  0014f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection
  00154	2b c7		 sub	 eax, edi
$LN20@CandidateP:

; 1070 : 
; 1071 : 		//printf( "SEL: %d, START: %d, PAGED: %d\n", ms_dwCandidateSelection, iStartOfPage, ms_dwCandidatePageSize );
; 1072 : 	    memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00156	68 00 14 00 00	 push	 5120			; 00001400H
  0015b	6a 00		 push	 0
  0015d	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00162	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, eax ; CIME::ms_dwCandidateSelection
  00167	e8 00 00 00 00	 call	 _memset

; 1073 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  0016c	33 c0		 xor	 eax, eax
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	89 45 f0	 mov	 DWORD PTR _j$1$[ebp], eax
  00174	3b 7b 08	 cmp	 edi, DWORD PTR [ebx+8]
  00177	73 5a		 jae	 SHORT $LN6@CandidateP

; 1070 : 
; 1071 : 		//printf( "SEL: %d, START: %d, PAGED: %d\n", ms_dwCandidateSelection, iStartOfPage, ms_dwCandidatePageSize );
; 1072 : 	    memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00179	8d 4b 18	 lea	 ecx, DWORD PTR [ebx+24]
  0017c	ba 00 00 00 00	 mov	 edx, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  00181	8d 0c b9	 lea	 ecx, DWORD PTR [ecx+edi*4]
  00184	89 55 ec	 mov	 DWORD PTR tv606[ebp], edx
  00187	89 4d 08	 mov	 DWORD PTR tv605[ebp], ecx
  0018a	66 0f 1f 44 00
	00		 npad	 6
$LL7@CandidateP:

; 1073 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  00190	3b c6		 cmp	 eax, esi
  00192	73 3f		 jae	 SHORT $LN6@CandidateP

; 1074 : 			wcscpy( ms_wszCandidate[j], (LPWSTR)( (DWORD)lpCandidateList + lpCandidateList->dwOffset[i] ) );

  00194	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00196	03 cb		 add	 ecx, ebx
  00198	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL21@CandidateP:
  001a0	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  001a3	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  001a6	66 89 02	 mov	 WORD PTR [edx], ax
  001a9	8d 52 02	 lea	 edx, DWORD PTR [edx+2]
  001ac	66 85 c0	 test	 ax, ax
  001af	75 ef		 jne	 SHORT $LL21@CandidateP

; 1073 : 	    for(UINT i = iStartOfPage, j = 0; (DWORD)i < lpCandidateList->dwCount && j < ms_dwCandidatePageSize; i++, j++) {

  001b1	8b 4d 08	 mov	 ecx, DWORD PTR tv605[ebp]
  001b4	47		 inc	 edi
  001b5	8b 45 f0	 mov	 eax, DWORD PTR _j$1$[ebp]
  001b8	83 c1 04	 add	 ecx, 4
  001bb	8b 55 ec	 mov	 edx, DWORD PTR tv606[ebp]
  001be	40		 inc	 eax
  001bf	81 c2 00 02 00
	00		 add	 edx, 512		; 00000200H
  001c5	89 4d 08	 mov	 DWORD PTR tv605[ebp], ecx
  001c8	89 45 f0	 mov	 DWORD PTR _j$1$[ebp], eax
  001cb	89 55 ec	 mov	 DWORD PTR tv606[ebp], edx
  001ce	3b 7b 08	 cmp	 edi, DWORD PTR [ebx+8]
  001d1	72 bd		 jb	 SHORT $LL7@CandidateP
$LN6@CandidateP:

; 1075 : 	    }
; 1076 : 
; 1077 : 		// don't display selection in candidate list in case of Korean and old Chinese IME.
; 1078 : 		if ( GETPRIMLANG() == LANG_KOREAN || GETLANG() == LANG_CHT && !GetImeId() )

  001d3	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  001da	8b c1		 mov	 eax, ecx
  001dc	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001e1	83 f8 12	 cmp	 eax, 18			; 00000012H
  001e4	74 18		 je	 SHORT $LN15@CandidateP
  001e6	b8 04 04 00 00	 mov	 eax, 1028		; 00000404H
  001eb	66 3b c8	 cmp	 cx, ax
  001ee	75 18		 jne	 SHORT $LN14@CandidateP
  001f0	8b 4d e8	 mov	 ecx, DWORD PTR _this$1$[ebp]
  001f3	6a 00		 push	 0
  001f5	e8 00 00 00 00	 call	 ?GetImeId@CIME@@IAEKI@Z	; CIME::GetImeId
  001fa	85 c0		 test	 eax, eax
  001fc	75 0a		 jne	 SHORT $LN14@CandidateP
$LN15@CandidateP:

; 1079 : 			ms_dwCandidateSelection = (DWORD) -1;

  001fe	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA, -1 ; CIME::ms_dwCandidateSelection
$LN14@CandidateP:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00208	8b 45 e4	 mov	 eax, DWORD PTR _abyCandidate$[ebp+8]
  0020b	2b c3		 sub	 eax, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0020d	50		 push	 eax
  0020e	53		 push	 ebx
  0020f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00214	83 c4 08	 add	 esp, 8
$LN43@CandidateP:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 1081 : }

  00217	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0021a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00221	59		 pop	 ecx
  00222	5f		 pop	 edi
  00223	5e		 pop	 esi
  00224	5b		 pop	 ebx
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _abyCandidate$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::CandidateProcess
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_attribute$ = -1028					; size = 1024
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::AttributeProcess, COMDAT
; _this$ = ecx

; 1013 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hImc$[ebp]

; 1014 : 	BYTE	attribute[IMESTR_MAXLEN];
; 1015 : 	LONG	attributeLen = ImmGetCompositionStringW(hImc, GCS_COMPATTR, &attribute, sizeof(attribute)) / sizeof(BYTE);

  00016	8d 8d fc fb ff
	ff		 lea	 ecx, DWORD PTR _attribute$[ebp]
  0001c	56		 push	 esi
  0001d	68 00 04 00 00	 push	 1024			; 00000400H
  00022	51		 push	 ecx
  00023	6a 10		 push	 16			; 00000010H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0002b	8b f0		 mov	 esi, eax

; 1016 : 
; 1017 : 	int start,end;
; 1018 : 	for(start=0; start<attributeLen; ++start) if(attribute[start]==ATTR_TARGET_CONVERTED || attribute[start]==ATTR_TARGET_NOTCONVERTED) break;

  0002d	33 c9		 xor	 ecx, ecx
  0002f	85 f6		 test	 esi, esi
  00031	7e 16		 jle	 SHORT $LN24@AttributeP
$LL4@AttributeP:
  00033	8a 94 0d fc fb
	ff ff		 mov	 dl, BYTE PTR _attribute$[ebp+ecx]
  0003a	80 fa 01	 cmp	 dl, 1
  0003d	74 0a		 je	 SHORT $LN24@AttributeP
  0003f	80 fa 03	 cmp	 dl, 3
  00042	74 05		 je	 SHORT $LN24@AttributeP
  00044	41		 inc	 ecx
  00045	3b ce		 cmp	 ecx, esi
  00047	7c ea		 jl	 SHORT $LL4@AttributeP
$LN24@AttributeP:

; 1019 : 	for(end=start; end<attributeLen; ++end) if(attribute[end]!=attribute[start]) break;

  00049	8b c1		 mov	 eax, ecx
  0004b	3b ce		 cmp	 ecx, esi
  0004d	7d 15		 jge	 SHORT $LN23@AttributeP
  0004f	8a 94 0d fc fb
	ff ff		 mov	 dl, BYTE PTR _attribute$[ebp+ecx]
$LL7@AttributeP:
  00056	38 94 05 fc fb
	ff ff		 cmp	 BYTE PTR _attribute$[ebp+eax], dl
  0005d	75 05		 jne	 SHORT $LN23@AttributeP
  0005f	40		 inc	 eax
  00060	3b c6		 cmp	 eax, esi
  00062	7c f2		 jl	 SHORT $LL7@AttributeP
$LN23@AttributeP:

; 1020 : 
; 1021 : 	ms_ulbegin = start;
; 1022 : 	ms_ulend = end;
; 1023 : }

  00064	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, ecx ; CIME::ms_ulbegin
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006d	33 cd		 xor	 ecx, ebp
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, eax ; CIME::ms_ulend
  00074	5e		 pop	 esi
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::AttributeProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_hImc$ = 8						; size = 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z PROC	; CIME::CompositionProcess, COMDAT
; _this$ = ecx

; 952  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 953  : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  00007	68 00 08 00 00	 push	 2048			; 00000800H
  0000c	8d 77 22	 lea	 esi, DWORD PTR [edi+34]
  0000f	56		 push	 esi
  00010	6a 08		 push	 8
  00012	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00015	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0001a	d1 e8		 shr	 eax, 1

; 954  : 
; 955  : 	//OutputDebugStringW( L"Composition: " );
; 956  : 	//OutputDebugStringW( m_wszComposition );
; 957  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 958  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 959  : 	//	pbyData += i;
; 960  : 	//	WCHAR tszName[32];
; 961  : 
; 962  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 963  : 	//	OutputDebugStringW( tszName );
; 964  : 	//}
; 965  : 	//OutputDebugStringW( L"\n" );
; 966  : 
; 967  : 	if (IsMax(m_wszComposition, ms_compLen))

  0001c	8b cf		 mov	 ecx, edi
  0001e	50		 push	 eax
  0001f	56		 push	 esi
  00020	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen
  00025	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	84 c0		 test	 al, al
  0002e	74 18		 je	 SHORT $LN2@Compositio

; 968  : 	{
; 969  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00030	6a 00		 push	 0
  00032	6a 04		 push	 4
  00034	6a 15		 push	 21			; 00000015H
  00036	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00039	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 970  : 		ms_compLen = 0;

  0003e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
$LN2@Compositio:

; 971  : 	}
; 972  : }

  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP	; CIME::CompositionProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_hImc$ = 8						; size = 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z PROC ; CIME::CompositionProcessBuilding, COMDAT
; _this$ = ecx

; 975  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 976  : 	int textLen = WideCharToMultiByte(ms_uOutputCodePage, 0, m_wText, ms_lastpos, 0, 0, NULL, NULL);

  00004	6a 00		 push	 0
  00006	6a 00		 push	 0
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00012	8b f1		 mov	 esi, ecx
  00014	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00019	6a 00		 push	 0
  0001b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 977  : 
; 978  : 	if (textLen >= m_max)

  00027	3b 46 08	 cmp	 eax, DWORD PTR [esi+8]
  0002a	7c 1d		 jl	 SHORT $LN2@Compositio

; 979  : 	{
; 980  : 		ImmNotifyIME(hImc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  0002c	6a 00		 push	 0
  0002e	6a 04		 push	 4
  00030	6a 15		 push	 21			; 00000015H
  00032	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00035	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 986  : 
; 987  : 	//OutputDebugStringW( L"Composition: " );
; 988  : 	//OutputDebugStringW( m_wszComposition );
; 989  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 990  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 991  : 	//	pbyData += i;
; 992  : 	//	WCHAR tszName[32];
; 993  : 
; 994  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 995  : 	//	OutputDebugStringW( tszName );
; 996  : 	//}
; 997  : 	//OutputDebugStringW( L"\n" );
; 998  : }

  0003a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
  00044	5e		 pop	 esi
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
$LN2@Compositio:

; 981  : 		ms_compLen = 0;
; 982  : 		return;
; 983  : 	}
; 984  : 	
; 985  : 	ms_compLen = ImmGetCompositionStringW(hImc, GCS_COMPSTR, m_wszComposition, sizeof(m_wszComposition))/sizeof(wchar_t);

  00049	68 00 08 00 00	 push	 2048			; 00000800H
  0004e	8d 46 22	 lea	 eax, DWORD PTR [esi+34]
  00051	50		 push	 eax
  00052	6a 08		 push	 8
  00054	ff 75 08	 push	 DWORD PTR _hImc$[ebp]
  00057	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  0005c	d1 e8		 shr	 eax, 1

; 986  : 
; 987  : 	//OutputDebugStringW( L"Composition: " );
; 988  : 	//OutputDebugStringW( m_wszComposition );
; 989  : 	//for( int i=0; i < (int) ms_compLen * 2; i++ ) {
; 990  : 	//	LPBYTE pbyData = (LPBYTE) m_wszComposition;
; 991  : 	//	pbyData += i;
; 992  : 	//	WCHAR tszName[32];
; 993  : 
; 994  : 	//	swprintf_s( tszName, L"%02X ", (unsigned int) *pbyData );
; 995  : 	//	OutputDebugStringW( tszName );
; 996  : 	//}
; 997  : 	//OutputDebugStringW( L"\n" );
; 998  : }

  0005e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, eax ; CIME::ms_compLen
  00063	5e		 pop	 esi
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ENDP ; CIME::CompositionProcessBuilding
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z
_TEXT	SEGMENT
_temp$ = -2052						; size = 2048
__$ArrayPad$ = -4					; size = 4
_hImc$ = 8						; size = 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z PROC		; CIME::ResultProcess, COMDAT
; _this$ = ecx

; 1001 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _hImc$[ebp]
  00016	56		 push	 esi

; 1002 : 	wchar_t temp[IMESTR_MAXLEN];
; 1003 : 
; 1004 : 	int len = ImmGetCompositionStringW(hImc, GCS_RESULTSTR, temp, sizeof(temp))/sizeof(wchar_t);

  00017	68 00 08 00 00	 push	 2048			; 00000800H
  0001c	8b f1		 mov	 esi, ecx
  0001e	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00024	51		 push	 ecx
  00025	68 00 08 00 00	 push	 2048			; 00000800H
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 _ImmGetCompositionStringW@16
  00030	d1 e8		 shr	 eax, 1

; 1005 : 
; 1006 : 	if (len <= 0)

  00032	74 0f		 je	 SHORT $LN1@ResultProc

; 1007 : 		return;
; 1008 : 
; 1009 : 	InsertString(temp, len);

  00034	50		 push	 eax
  00035	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  0003b	8b ce		 mov	 ecx, esi
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@ResultProc:

; 1010 : }

  00043	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00046	33 cd		 xor	 ecx, ebp
  00048	5e		 pop	 esi
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ENDP		; CIME::ResultProcess
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageFromLang@CIME@@IAEIG@Z
_TEXT	SEGMENT
_langid$ = 8						; size = 2
?GetCodePageFromLang@CIME@@IAEIG@Z PROC			; CIME::GetCodePageFromLang, COMDAT
; _this$ = ecx

; 878  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 879  : 	unsigned pri_langid = PRIMARYLANGID(langid);

  00003	0f b7 4d 08	 movzx	 ecx, WORD PTR _langid$[ebp]
  00007	8b c1		 mov	 eax, ecx
  00009	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH

; 880  : 	switch (pri_langid)

  0000e	48		 dec	 eax
  0000f	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00012	0f 87 93 00 00
	00		 ja	 $LN21@GetCodePag
  00018	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN23@GetCodePag[eax]
  0001f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@GetCodePag[eax*4]
$LN6@GetCodePag:

; 881  : 	{
; 882  : 		case LANG_JAPANESE:
; 883  : 			//setlocale(LC_ALL, ".932");
; 884  : 			return 932;

  00026	b8 a4 03 00 00	 mov	 eax, 932		; 000003a4H

; 948  : 	}
; 949  : }

  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
$LN7@GetCodePag:

; 885  : 		case LANG_KOREAN:
; 886  : 			//setlocale(LC_ALL, ".949");
; 887  : 			return 949;

  0002f	b8 b5 03 00 00	 mov	 eax, 949		; 000003b5H

; 948  : 	}
; 949  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN8@GetCodePag:

; 888  : 		case LANG_CHINESE:
; 889  : 			{
; 890  : 				switch (SUBLANGID(langid))

  00038	c1 e9 0a	 shr	 ecx, 10			; 0000000aH
  0003b	49		 dec	 ecx
  0003c	83 f9 04	 cmp	 ecx, 4
  0003f	77 10		 ja	 SHORT $LN4@GetCodePag
  00041	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN25@GetCodePag[ecx*4]
$LN10@GetCodePag:

; 891  : 				{
; 892  : 					case SUBLANG_CHINESE_SIMPLIFIED:
; 893  : 					case SUBLANG_CHINESE_SINGAPORE:
; 894  : 						//setlocale(LC_ALL, ".936");
; 895  : 						return 936;
; 896  : 					case SUBLANG_CHINESE_TRADITIONAL:
; 897  : 					case SUBLANG_CHINESE_MACAU:
; 898  : 					case SUBLANG_CHINESE_HONGKONG:
; 899  : 						//setlocale(LC_ALL, ".950");
; 900  : 						return 950;

  00048	b8 b6 03 00 00	 mov	 eax, 950		; 000003b6H

; 948  : 	}
; 949  : }

  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
$LN4@GetCodePag:

; 901  : 				}
; 902  : 			}
; 903  : 			//setlocale(LC_ALL, ".936");
; 904  : 			return 936;

  00051	b8 a8 03 00 00	 mov	 eax, 936		; 000003a8H

; 948  : 	}
; 949  : }

  00056	5d		 pop	 ebp
  00057	c2 04 00	 ret	 4
$LN11@GetCodePag:

; 905  : 		case LANG_ARABIC:
; 906  : 			return 1256;

  0005a	b8 e8 04 00 00	 mov	 eax, 1256		; 000004e8H

; 948  : 	}
; 949  : }

  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
$LN12@GetCodePag:

; 907  : 		case LANG_GREEK:
; 908  : 			//setlocale(LC_ALL, ".1253");
; 909  : 			return 1253;

  00063	b8 e5 04 00 00	 mov	 eax, 1253		; 000004e5H

; 948  : 	}
; 949  : }

  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
$LN13@GetCodePag:

; 910  : 		case LANG_TURKISH:
; 911  : 			//setlocale(LC_ALL, ".1254");
; 912  : 			return 1254;

  0006c	b8 e6 04 00 00	 mov	 eax, 1254		; 000004e6H

; 948  : 	}
; 949  : }

  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
$LN14@GetCodePag:

; 913  : 		case LANG_HEBREW:
; 914  : 			//setlocale(LC_ALL, ".1255");
; 915  : 			return 1255;

  00075	b8 e7 04 00 00	 mov	 eax, 1255		; 000004e7H

; 948  : 	}
; 949  : }

  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
$LN15@GetCodePag:

; 916  : 		case LANG_ESTONIAN:
; 917  : 		case LANG_LATVIAN:
; 918  : 		case LANG_LITHUANIAN:
; 919  : 			//setlocale(LC_ALL, ".1257");
; 920  : 			return 1257;

  0007e	b8 e9 04 00 00	 mov	 eax, 1257		; 000004e9H

; 948  : 	}
; 949  : }

  00083	5d		 pop	 ebp
  00084	c2 04 00	 ret	 4
$LN16@GetCodePag:

; 921  : 		case LANG_VIETNAMESE:
; 922  : 			return 1258;

  00087	b8 ea 04 00 00	 mov	 eax, 1258		; 000004eaH

; 948  : 	}
; 949  : }

  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN17@GetCodePag:

; 923  : 		case LANG_THAI:
; 924  : 			//setlocale(LC_ALL, ".874");
; 925  : 			return 874;

  00090	b8 6a 03 00 00	 mov	 eax, 874		; 0000036aH

; 948  : 	}
; 949  : }

  00095	5d		 pop	 ebp
  00096	c2 04 00	 ret	 4
$LN18@GetCodePag:

; 926  : 		case LANG_CZECH:
; 927  : 		case LANG_HUNGARIAN:
; 928  : 		case LANG_POLISH:
; 929  : 		case LANG_CROATIAN:
; 930  : 		case LANG_MACEDONIAN:
; 931  : 		case LANG_ROMANIAN:
; 932  : 		case LANG_SLOVAK:
; 933  : 		case LANG_SLOVENIAN:
; 934  : 			//setlocale(LC_ALL, ".1250");
; 935  : 			return 1250;

  00099	b8 e2 04 00 00	 mov	 eax, 1250		; 000004e2H

; 948  : 	}
; 949  : }

  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
$LN19@GetCodePag:

; 936  : 		case LANG_RUSSIAN:
; 937  : 		case LANG_BELARUSIAN:
; 938  : 		case LANG_BULGARIAN:
; 939  : 		case LANG_UKRAINIAN:
; 940  : 			return 1251;

  000a2	b8 e3 04 00 00	 mov	 eax, 1251		; 000004e3H

; 948  : 	}
; 949  : }

  000a7	5d		 pop	 ebp
  000a8	c2 04 00	 ret	 4
$LN21@GetCodePag:

; 941  : 		case LANG_GERMAN:
; 942  : 			//_wsetlocale(LC_ALL, ".1252");
; 943  : 			return 1252;
; 944  : 		default:
; 945  : 			//TraceError("UNKNOWN IME[%d]\n", langid);
; 946  : 			//setlocale(LC_ALL, ".949");
; 947  : 			return 1252;

  000ab	b8 e4 04 00 00	 mov	 eax, 1252		; 000004e4H

; 948  : 	}
; 949  : }

  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
$LN24@GetCodePag:
  000b4	00 00 00 00	 DD	 $LN11@GetCodePag
  000b8	00 00 00 00	 DD	 $LN19@GetCodePag
  000bc	00 00 00 00	 DD	 $LN8@GetCodePag
  000c0	00 00 00 00	 DD	 $LN18@GetCodePag
  000c4	00 00 00 00	 DD	 $LN21@GetCodePag
  000c8	00 00 00 00	 DD	 $LN12@GetCodePag
  000cc	00 00 00 00	 DD	 $LN14@GetCodePag
  000d0	00 00 00 00	 DD	 $LN6@GetCodePag
  000d4	00 00 00 00	 DD	 $LN7@GetCodePag
  000d8	00 00 00 00	 DD	 $LN17@GetCodePag
  000dc	00 00 00 00	 DD	 $LN13@GetCodePag
  000e0	00 00 00 00	 DD	 $LN15@GetCodePag
  000e4	00 00 00 00	 DD	 $LN16@GetCodePag
  000e8	00 00 00 00	 DD	 $LN21@GetCodePag
$LN23@GetCodePag:
  000ec	00		 DB	 0
  000ed	01		 DB	 1
  000ee	0d		 DB	 13			; 0000000dH
  000ef	02		 DB	 2
  000f0	03		 DB	 3
  000f1	0d		 DB	 13			; 0000000dH
  000f2	04		 DB	 4
  000f3	05		 DB	 5
  000f4	0d		 DB	 13			; 0000000dH
  000f5	0d		 DB	 13			; 0000000dH
  000f6	0d		 DB	 13			; 0000000dH
  000f7	0d		 DB	 13			; 0000000dH
  000f8	06		 DB	 6
  000f9	03		 DB	 3
  000fa	0d		 DB	 13			; 0000000dH
  000fb	0d		 DB	 13			; 0000000dH
  000fc	07		 DB	 7
  000fd	08		 DB	 8
  000fe	0d		 DB	 13			; 0000000dH
  000ff	0d		 DB	 13			; 0000000dH
  00100	03		 DB	 3
  00101	0d		 DB	 13			; 0000000dH
  00102	0d		 DB	 13			; 0000000dH
  00103	03		 DB	 3
  00104	01		 DB	 1
  00105	03		 DB	 3
  00106	03		 DB	 3
  00107	0d		 DB	 13			; 0000000dH
  00108	0d		 DB	 13			; 0000000dH
  00109	09		 DB	 9
  0010a	0a		 DB	 10			; 0000000aH
  0010b	0d		 DB	 13			; 0000000dH
  0010c	0d		 DB	 13			; 0000000dH
  0010d	01		 DB	 1
  0010e	01		 DB	 1
  0010f	03		 DB	 3
  00110	0b		 DB	 11			; 0000000bH
  00111	0b		 DB	 11			; 0000000bH
  00112	0b		 DB	 11			; 0000000bH
  00113	0d		 DB	 13			; 0000000dH
  00114	0d		 DB	 13			; 0000000dH
  00115	0c		 DB	 12			; 0000000cH
  00116	0d		 DB	 13			; 0000000dH
  00117	0d		 DB	 13			; 0000000dH
  00118	0d		 DB	 13			; 0000000dH
  00119	0d		 DB	 13			; 0000000dH
  0011a	03		 DB	 3
  0011b	90		 npad	 1
$LN25@GetCodePag:
  0011c	00 00 00 00	 DD	 $LN10@GetCodePag
  00120	00 00 00 00	 DD	 $LN4@GetCodePag
  00124	00 00 00 00	 DD	 $LN10@GetCodePag
  00128	00 00 00 00	 DD	 $LN4@GetCodePag
  0012c	00 00 00 00	 DD	 $LN10@GetCodePag
?GetCodePageFromLang@CIME@@IAEIG@Z ENDP			; CIME::GetCodePageFromLang
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?OnChar@CIME@@IAEX_W@Z
_TEXT	SEGMENT
_c$ = 8							; size = 2
?OnChar@CIME@@IAEX_W@Z PROC				; CIME::OnChar, COMDAT
; _this$ = ecx

; 866  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 867  : 	if (m_bOnlyNumberMode)

  00006	83 7e 10 00	 cmp	 DWORD PTR [esi+16], 0
  0000a	74 0f		 je	 SHORT $LN3@OnChar

; 868  : 		if (!iswdigit(c))

  0000c	ff 75 08	 push	 DWORD PTR _c$[ebp]
  0000f	e8 00 00 00 00	 call	 _iswdigit
  00014	83 c4 04	 add	 esp, 4
  00017	85 c0		 test	 eax, eax
  00019	74 1b		 je	 SHORT $LN1@OnChar
$LN3@OnChar:

; 869  : 			return;
; 870  : 
; 871  : 	if (!__IsWritable(c))

  0001b	ff 75 08	 push	 DWORD PTR _c$[ebp]
  0001e	8b ce		 mov	 ecx, esi
  00020	e8 00 00 00 00	 call	 ?__IsWritable@CIME@@QAE_N_W@Z ; CIME::__IsWritable
  00025	84 c0		 test	 al, al
  00027	74 0d		 je	 SHORT $LN1@OnChar

; 872  : 		return;
; 873  : 
; 874  : 	InsertString(&c, 1);

  00029	6a 01		 push	 1
  0002b	8d 45 08	 lea	 eax, DWORD PTR _c$[ebp]
  0002e	8b ce		 mov	 ecx, esi
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString
$LN1@OnChar:
  00036	5e		 pop	 esi

; 875  : }

  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
?OnChar@CIME@@IAEX_W@Z ENDP				; CIME::OnChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?InsertString@CIME@@IAEXPA_WH@Z
_TEXT	SEGMENT
_wString$ = 8						; size = 4
_iSize$ = 12						; size = 4
?InsertString@CIME@@IAEXPA_WH@Z PROC			; CIME::InsertString, COMDAT
; _this$ = ecx

; 852  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 853  : 	if (IsMax(wString, iSize))

  00004	8b 5d 0c	 mov	 ebx, DWORD PTR _iSize$[ebp]
  00007	53		 push	 ebx
  00008	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsMax@CIME@@IAE_NPB_WH@Z ; CIME::IsMax
  00010	84 c0		 test	 al, al
  00012	75 5d		 jne	 SHORT $LN1@InsertStri

; 854  : 		return;
; 855  : 
; 856  : 	if (ms_curpos < ms_lastpos)

  00014	56		 push	 esi
  00015	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0001b	57		 push	 edi
  0001c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00022	3b f7		 cmp	 esi, edi
  00024	7d 22		 jge	 SHORT $LN3@InsertStri

; 857  : 		memmove(m_wText+ms_curpos+iSize, m_wText+ms_curpos, sizeof(wchar_t)*(ms_lastpos-ms_curpos));

  00026	8b c7		 mov	 eax, edi
  00028	2b c6		 sub	 eax, esi
  0002a	03 c0		 add	 eax, eax
  0002c	50		 push	 eax
  0002d	8d 04 75 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[esi*2]
  00034	50		 push	 eax
  00035	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00038	8d 04 45 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _memmove
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@InsertStri:

; 858  : 
; 859  : 	memcpy(m_wText+ms_curpos, wString, sizeof(wchar_t)*iSize);

  00048	8d 04 1b	 lea	 eax, DWORD PTR [ebx+ebx]
  0004b	50		 push	 eax
  0004c	ff 75 08	 push	 DWORD PTR _wString$[ebp]
  0004f	8d 04 75 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[esi*2]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _memcpy
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 860  : 
; 861  : 	ms_curpos += iSize;

  0005f	03 f3		 add	 esi, ebx

; 862  : 	ms_lastpos += iSize;

  00061	03 fb		 add	 edi, ebx
  00063	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  00069	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, edi ; CIME::ms_lastpos
  0006f	5f		 pop	 edi
  00070	5e		 pop	 esi
$LN1@InsertStri:
  00071	5b		 pop	 ebx

; 863  : }

  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
?InsertString@CIME@@IAEXPA_WH@Z ENDP			; CIME::InsertString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetSupportLevel@CIME@@KAXK@Z
_TEXT	SEGMENT
_dwImeLevel$ = 8					; size = 4
?SetSupportLevel@CIME@@KAXK@Z PROC			; CIME::SetSupportLevel, COMDAT

; 764  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 765  : 	if ( dwImeLevel < 2 || 3 < dwImeLevel )

  00003	8b 55 08	 mov	 edx, DWORD PTR _dwImeLevel$[ebp]
  00006	8d 42 fe	 lea	 eax, DWORD PTR [edx-2]
  00009	83 f8 01	 cmp	 eax, 1
  0000c	77 28		 ja	 SHORT $LN3@SetSupport

; 766  : 		return;
; 767  : 	if ( GETPRIMLANG() == LANG_KOREAN )

  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent

; 768  : 	{
; 769  : 		dwImeLevel = 3;
; 770  : 	}
; 771  : 	ms_dwIMELevel = dwImeLevel;

  00013	b9 03 00 00 00	 mov	 ecx, 3
  00018	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  0001d	83 f8 12	 cmp	 eax, 18			; 00000012H
  00020	0f 45 ca	 cmovne	 ecx, edx
  00023	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_dwIMELevel@CIME@@2KA, ecx ; CIME::ms_dwIMELevel

; 772  : 	// cancel current composition string.
; 773  : 	FinalizeString();

  00029	c7 45 08 00 00
	00 00		 mov	 DWORD PTR _dwImeLevel$[ebp], 0

; 774  : 	//SetCompStringColor();
; 775  : }

  00030	5d		 pop	 ebp

; 772  : 	// cancel current composition string.
; 773  : 	FinalizeString();

  00031	e9 00 00 00 00	 jmp	 ?FinalizeString@CIME@@SAX_N@Z ; CIME::FinalizeString
$LN3@SetSupport:

; 774  : 	//SetCompStringColor();
; 775  : }

  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?SetSupportLevel@CIME@@KAXK@Z ENDP			; CIME::SetSupportLevel
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CheckToggleState@CIME@@KAXXZ
_TEXT	SEGMENT
_dwSentMode$1 = -8					; size = 4
_dwConvMode$2 = -4					; size = 4
?CheckToggleState@CIME@@KAXXZ PROC			; CIME::CheckToggleState, COMDAT

; 1520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1521 : 	CheckInputLocale();

  00006	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 1522 : 
; 1523 : 	// In Vista, we have to use TSF since few IMM functions don't work as expected.
; 1524 : 	// WARNING: Because of timing, g_dwState and g_bChineseIME may not be updated 
; 1525 : 	// immediately after the change on IME states by user.
; 1526 : 	if ( ms_bUILessMode )

  0000b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00012	0f 85 b2 00 00
	00		 jne	 $LN4@CheckToggl

; 1527 : 		return;
; 1528 : 
; 1529 : 	/* Check Toggle State */ 
; 1530 : 	bool bIme = ImmIsIME( ms_hklCurrent ) != 0

  00018	53		 push	 ebx
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0001f	e8 00 00 00 00	 call	 _ImmIsIME@4
  00024	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  0002a	85 c0		 test	 eax, eax
  0002c	74 12		 je	 SHORT $LN8@CheckToggl
  0002e	8b c1		 mov	 eax, ecx
  00030	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00035	3d 00 00 00 e0	 cmp	 eax, -536870912		; e0000000H
  0003a	75 04		 jne	 SHORT $LN8@CheckToggl
  0003c	b3 01		 mov	 bl, 1
  0003e	eb 02		 jmp	 SHORT $LN9@CheckToggl
$LN8@CheckToggl:
  00040	32 db		 xor	 bl, bl
$LN9@CheckToggl:

; 1531 : 		&& ( ( 0xF0000000 & (DWORD)ms_hklCurrent ) == 0xE0000000 ); // Hack to detect IME correctly. When IME is running as TIP, ImmIsIME() returns true for CHT US keyboard.
; 1532 : 	ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && bIme;

  00042	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  00048	83 f9 04	 cmp	 ecx, 4
  0004b	75 08		 jne	 SHORT $LN10@CheckToggl
  0004d	84 db		 test	 bl, bl
  0004f	74 04		 je	 SHORT $LN10@CheckToggl
  00051	b0 01		 mov	 al, 1
  00053	eb 02		 jmp	 SHORT $LN11@CheckToggl
$LN10@CheckToggl:
  00055	32 c0		 xor	 al, al
$LN11@CheckToggl:
  00057	56		 push	 esi

; 1533 : 
; 1534 : 	HIMC himc;
; 1535 : 	if (NULL != (himc = ImmGetContext(ms_hWnd))) {

  00058	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0005e	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME
  00063	e8 00 00 00 00	 call	 _ImmGetContext@4
  00068	8b f0		 mov	 esi, eax
  0006a	85 f6		 test	 esi, esi
  0006c	74 50		 je	 SHORT $LN3@CheckToggl

; 1536 : 		if (ms_bChineseIME) {

  0006e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, 0 ; CIME::ms_bChineseIME
  00075	74 19		 je	 SHORT $LN5@CheckToggl

; 1537 : 			DWORD dwConvMode, dwSentMode;
; 1538 : 			ImmGetConversionStatus(himc, &dwConvMode, &dwSentMode);

  00077	8d 45 f8	 lea	 eax, DWORD PTR _dwSentMode$1[ebp]
  0007a	50		 push	 eax
  0007b	8d 45 fc	 lea	 eax, DWORD PTR _dwConvMode$2[ebp]
  0007e	50		 push	 eax
  0007f	56		 push	 esi
  00080	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 1539 : 			ms_dwImeState = ( dwConvMode & IME_CMODE_NATIVE ) ? IMEUI_STATE_ON : IMEUI_STATE_ENGLISH;

  00085	8b 45 fc	 mov	 eax, DWORD PTR _dwConvMode$2[ebp]
  00088	f7 d0		 not	 eax
  0008a	83 e0 01	 and	 eax, 1
  0008d	40		 inc	 eax

; 1540 : 		}

  0008e	eb 17		 jmp	 SHORT $LN13@CheckToggl
$LN5@CheckToggl:

; 1541 : 		else
; 1542 : 		{
; 1543 : 			ms_dwImeState = ( bIme && ImmGetOpenStatus( himc ) != 0 ) ? IMEUI_STATE_ON : IMEUI_STATE_OFF;

  00090	84 db		 test	 bl, bl
  00092	74 11		 je	 SHORT $LN12@CheckToggl
  00094	56		 push	 esi
  00095	e8 00 00 00 00	 call	 _ImmGetOpenStatus@4
  0009a	85 c0		 test	 eax, eax
  0009c	74 07		 je	 SHORT $LN12@CheckToggl
  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	eb 02		 jmp	 SHORT $LN13@CheckToggl
$LN12@CheckToggl:
  000a5	33 c0		 xor	 eax, eax
$LN13@CheckToggl:

; 1544 : 		}
; 1545 : 		ImmReleaseContext(ms_hWnd, himc);

  000a7	56		 push	 esi
  000a8	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  000ae	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, eax ; CIME::ms_dwImeState
  000b3	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  000b8	5e		 pop	 esi
  000b9	5b		 pop	 ebx

; 1549 : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
$LN3@CheckToggl:
  000be	5e		 pop	 esi

; 1546 : 	}
; 1547 : 	else
; 1548 : 		ms_dwImeState = IMEUI_STATE_OFF;

  000bf	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwImeState@CIME@@2KA, 0 ; CIME::ms_dwImeState
  000c9	5b		 pop	 ebx
$LN4@CheckToggl:

; 1549 : }

  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
?CheckToggleState@CIME@@KAXXZ ENDP			; CIME::CheckToggleState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CheckInputLocale@CIME@@KAXXZ
_TEXT	SEGMENT
_szCodePage$ = -24					; size = 8
_szLang$1 = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
?CheckInputLocale@CIME@@KAXXZ PROC			; CIME::CheckInputLocale, COMDAT

; 1439 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 1440 : 	static UINT s_uPrevCodePage = 0xFFFF;
; 1441 : 	static HKL	s_hklPrev = NULL;
; 1442 : 
; 1443 : 	ms_hklCurrent = GetKeyboardLayout( 0 );

  00010	6a 00		 push	 0
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayout@4
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, eax ; CIME::ms_hklCurrent

; 1444 : 	if ( s_hklPrev == ms_hklCurrent )

  0001d	39 05 00 00 00
	00		 cmp	 DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A, eax
  00023	0f 84 23 01 00
	00		 je	 $LN16@CheckInput

; 1445 : 		return;
; 1446 : 	s_hklPrev = ms_hklCurrent;
; 1447 : 
; 1448 : 	char szCodePage[8];
; 1449 : 	int iRc = GetLocaleInfoA( MAKELCID( GETLANG(), SORT_DEFAULT ), LOCALE_IDEFAULTANSICODEPAGE, szCodePage, COUNTOF( szCodePage ) ); iRc;

  00029	6a 08		 push	 8
  0002b	8d 4d e8	 lea	 ecx, DWORD PTR _szCodePage$[ebp]
  0002e	a3 00 00 00 00	 mov	 DWORD PTR ?s_hklPrev@?1??CheckInputLocale@CIME@@KAXXZ@4PAUHKL__@@A, eax
  00033	51		 push	 ecx
  00034	68 04 10 00 00	 push	 4100			; 00001004H
  00039	0f b7 c0	 movzx	 eax, ax
  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16

; 1450 : 	ms_uInputCodePage = _strtoul( szCodePage, NULL, 0 );

  00043	6a 00		 push	 0
  00045	8d 45 e8	 lea	 eax, DWORD PTR _szCodePage$[ebp]
  00048	6a 00		 push	 0
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 ?_strtoul@@YAKPBDPAPADH@Z ; _strtoul
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA, eax ; CIME::ms_uInputCodePage
  00058	39 05 00 00 00
	00		 cmp	 DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA, eax

; 1451 : 	if ( s_uPrevCodePage == ms_uInputCodePage )

  0005e	0f 84 e8 00 00
	00		 je	 $LN16@CheckInput

; 1452 : 		return;
; 1453 : 	s_uPrevCodePage = ms_uInputCodePage;
; 1454 : 
; 1455 : 	GetKeyboardLayoutName(ms_szKeyboardLayout);

  00064	68 00 00 00 00	 push	 OFFSET ?ms_szKeyboardLayout@CIME@@2PADA ; CIME::ms_szKeyboardLayout
  00069	a3 00 00 00 00	 mov	 DWORD PTR ?s_uPrevCodePage@?1??CheckInputLocale@CIME@@KAXXZ@4IA, eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetKeyboardLayoutNameA@4

; 1456 : 
; 1457 :     switch (GETPRIMLANG()) 

  00074	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  0007b	8b c1		 mov	 eax, ecx
  0007d	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00082	83 e8 04	 sub	 eax, 4
  00085	74 31		 je	 SHORT $LN10@CheckInput
  00087	83 e8 0d	 sub	 eax, 13			; 0000000dH
  0008a	74 19		 je	 SHORT $LN9@CheckInput
  0008c	83 e8 01	 sub	 eax, 1
  0008f	75 5f		 jne	 SHORT $LN13@CheckInput

; 1458 : 	{
; 1459 : 		case LANG_KOREAN:
; 1460 : 			ms_bVerticalCandidate = false;

  00091	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, al ; CIME::ms_bVerticalCandidate

; 1478 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHS];
; 1479 : 					break;
; 1480 : 
; 1481 : 				case SUBLANG_CHINESE_TRADITIONAL:
; 1482 : 				case SUBLANG_CHINESE_HONGKONG:
; 1483 : 				case SUBLANG_CHINESE_MACAU:
; 1484 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHT];
; 1485 : 					break;
; 1486 : 
; 1487 : 				default:	// unsupported sub-language
; 1488 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1489 : 					break;
; 1490 : 			}
; 1491 : 			break;
; 1492 : 
; 1493 : 		default:
; 1494 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1495 : 			break;
; 1496 :     }
; 1497 : 
; 1498 :     if (ms_wszCurrentIndicator == s_aszIndicator[INDICATOR_NON_IME])

  00096	c7 05 00 00 00
	00 12 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+18 ; CIME::ms_wszCurrentIndicator
  000a0	e9 8c 00 00 00	 jmp	 $LN15@CheckInput
$LN9@CheckInput:

; 1461 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_KOREAN];
; 1462 : 			break;
; 1463 : 
; 1464 : 		case LANG_JAPANESE:
; 1465 : 			ms_bVerticalCandidate = true;

  000a5	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate

; 1478 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHS];
; 1479 : 					break;
; 1480 : 
; 1481 : 				case SUBLANG_CHINESE_TRADITIONAL:
; 1482 : 				case SUBLANG_CHINESE_HONGKONG:
; 1483 : 				case SUBLANG_CHINESE_MACAU:
; 1484 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHT];
; 1485 : 					break;
; 1486 : 
; 1487 : 				default:	// unsupported sub-language
; 1488 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1489 : 					break;
; 1490 : 			}
; 1491 : 			break;
; 1492 : 
; 1493 : 		default:
; 1494 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1495 : 			break;
; 1496 :     }
; 1497 : 
; 1498 :     if (ms_wszCurrentIndicator == s_aszIndicator[INDICATOR_NON_IME])

  000ac	c7 05 00 00 00
	00 18 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+24 ; CIME::ms_wszCurrentIndicator
  000b6	eb 79		 jmp	 SHORT $LN15@CheckInput
$LN10@CheckInput:

; 1466 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_JAPANESE];
; 1467 : 			break;
; 1468 : 
; 1469 : 		case LANG_CHINESE:
; 1470 : 			ms_bVerticalCandidate = true;
; 1471 : 
; 1472 : 			switch(GETSUBLANG()) 

  000b8	8b c1		 mov	 eax, ecx
  000ba	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 1 ; CIME::ms_bVerticalCandidate
  000c1	c1 e8 0a	 shr	 eax, 10			; 0000000aH
  000c4	48		 dec	 eax
  000c5	83 f8 04	 cmp	 eax, 4
  000c8	77 26		 ja	 SHORT $LN13@CheckInput
  000ca	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN18@CheckInput[eax*4]
$LN11@CheckInput:

; 1473 : 			{
; 1474 : 				case SUBLANG_CHINESE_SIMPLIFIED:
; 1475 : 				case SUBLANG_CHINESE_SINGAPORE:
; 1476 : 					//ms_bVerticalCandidate = (GetImeId() == 0);
; 1477 : 					ms_bVerticalCandidate = false;

  000d1	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bVerticalCandidate@CIME@@2_NA, 0 ; CIME::ms_bVerticalCandidate

; 1478 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHS];
; 1479 : 					break;
; 1480 : 
; 1481 : 				case SUBLANG_CHINESE_TRADITIONAL:
; 1482 : 				case SUBLANG_CHINESE_HONGKONG:
; 1483 : 				case SUBLANG_CHINESE_MACAU:
; 1484 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_CHT];
; 1485 : 					break;
; 1486 : 
; 1487 : 				default:	// unsupported sub-language
; 1488 : 					ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1489 : 					break;
; 1490 : 			}
; 1491 : 			break;
; 1492 : 
; 1493 : 		default:
; 1494 : 			ms_wszCurrentIndicator = s_aszIndicator[INDICATOR_NON_IME];
; 1495 : 			break;
; 1496 :     }
; 1497 : 
; 1498 :     if (ms_wszCurrentIndicator == s_aszIndicator[INDICATOR_NON_IME])

  000d8	c7 05 00 00 00
	00 06 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+6 ; CIME::ms_wszCurrentIndicator
  000e2	eb 4d		 jmp	 SHORT $LN15@CheckInput
$LN12@CheckInput:
  000e4	c7 05 00 00 00
	00 0c 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA+12 ; CIME::ms_wszCurrentIndicator
  000ee	eb 41		 jmp	 SHORT $LN15@CheckInput
$LN13@CheckInput:

; 1499 :     {
; 1500 :         char szLang[10];
; 1501 :         GetLocaleInfoA(MAKELCID(GETLANG(), SORT_DEFAULT), LOCALE_SABBREVLANGNAME, szLang, sizeof(szLang));

  000f0	6a 0a		 push	 10			; 0000000aH
  000f2	8d 45 f0	 lea	 eax, DWORD PTR _szLang$1[ebp]
  000f5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA, OFFSET ?s_aszIndicator@@3PAY02_WA ; CIME::ms_wszCurrentIndicator, s_aszIndicator
  000ff	50		 push	 eax
  00100	6a 03		 push	 3
  00102	51		 push	 ecx
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLocaleInfoA@16

; 1502 :         ms_wszCurrentIndicator[0] = szLang[0];

  00109	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  0010e	66 0f be 4d f0	 movsx	 cx, BYTE PTR _szLang$1[ebp]
  00113	66 89 08	 mov	 WORD PTR [eax], cx

; 1503 :         ms_wszCurrentIndicator[1] = towlower(szLang[1]);

  00116	66 0f be 45 f1	 movsx	 ax, BYTE PTR _szLang$1[ebp+1]
  0011b	0f b7 c0	 movzx	 eax, ax
  0011e	50		 push	 eax
  0011f	e8 00 00 00 00	 call	 _towlower
  00124	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wszCurrentIndicator@CIME@@2PA_WA ; CIME::ms_wszCurrentIndicator
  0012a	83 c4 04	 add	 esp, 4
  0012d	66 89 41 02	 mov	 WORD PTR [ecx+2], ax
$LN15@CheckInput:

; 1504 :     }
; 1505 : 
; 1506 : 	//       
; 1507 : 	//   .
; 1508 : 	if(ms_uOutputCodePage != 1256) {

  00131	81 3d 00 00 00
	00 e8 04 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 1256 ; CIME::ms_uOutputCodePage, 000004e8H
  0013b	74 0f		 je	 SHORT $LN16@CheckInput

; 1509 : 		ms_uOutputCodePage = ms_uInputCodePage;

  0013d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00142	a3 00 00 00 00	 mov	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, eax ; CIME::ms_uOutputCodePage

; 1510 : 		Clear();

  00147	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear
$LN16@CheckInput:

; 1511 : 	}
; 1512 : 
; 1513 : 	//for ( int i = 0; i < 256; i++ )
; 1514 : 	//{
; 1515 : 	//	LeadByteTable[i] = (BYTE)IsDBCSLeadByteEx( g_uCodePage, (BYTE)i );
; 1516 : 	//}
; 1517 : }

  0014c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014f	33 cd		 xor	 ecx, ebp
  00151	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00156	8b e5		 mov	 esp, ebp
  00158	5d		 pop	 ebp
  00159	c3		 ret	 0
  0015a	66 90		 npad	 2
$LN18@CheckInput:
  0015c	00 00 00 00	 DD	 $LN12@CheckInput
  00160	00 00 00 00	 DD	 $LN11@CheckInput
  00164	00 00 00 00	 DD	 $LN12@CheckInput
  00168	00 00 00 00	 DD	 $LN11@CheckInput
  0016c	00 00 00 00	 DD	 $LN12@CheckInput
?CheckInputLocale@CIME@@KAXXZ ENDP			; CIME::CheckInputLocale
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DelCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?DelCurPos@CIME@@IAEXXZ PROC				; CIME::DelCurPos, COMDAT
; _this$ = ecx

; 830  : 	if (ms_curpos < ms_lastpos)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7d 5c		 jge	 SHORT $LN2@DelCurPos

; 831  : 	{
; 832  : 		int eraseCount = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos) + 1;

  0000f	56		 push	 esi
  00010	2b c1		 sub	 eax, ecx
  00012	57		 push	 edi
  00013	50		 push	 eax
  00014	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition

; 833  : 		wcscpy(m_wText + ms_curpos, m_wText + ms_curpos + eraseCount);

  00021	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00027	83 c4 08	 add	 esp, 8
  0002a	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0002d	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  00030	8d 0c 4d 00 00
	00 00		 lea	 ecx, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  00037	8d 14 36	 lea	 edx, DWORD PTR [esi+esi]
  0003a	2b d1		 sub	 edx, ecx
  0003c	8d 92 00 00 00
	00		 lea	 edx, DWORD PTR ?m_wText@CIME@@2PA_WA[edx]
$LL4@DelCurPos:
  00042	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  00045	8d 49 02	 lea	 ecx, DWORD PTR [ecx+2]
  00048	66 89 44 0a fe	 mov	 WORD PTR [edx+ecx-2], ax
  0004d	66 85 c0	 test	 ax, ax
  00050	75 f0		 jne	 SHORT $LL4@DelCurPos

; 834  : 		ms_lastpos -= eraseCount;

  00052	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00057	2b c7		 sub	 eax, edi

; 835  : 		ms_curpos = min(ms_lastpos, ms_curpos);

  00059	3b c6		 cmp	 eax, esi
  0005b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, eax ; CIME::ms_lastpos
  00060	5f		 pop	 edi
  00061	0f 4c f0	 cmovl	 esi, eax
  00064	89 35 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, esi ; CIME::ms_curpos
  0006a	5e		 pop	 esi
$LN2@DelCurPos:

; 836  : 	}
; 837  : }

  0006b	c3		 ret	 0
?DelCurPos@CIME@@IAEXXZ ENDP				; CIME::DelCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetCurPos@CIME@@IAEXH@Z
_TEXT	SEGMENT
_offset$ = 8						; size = 4
?SetCurPos@CIME@@IAEXH@Z PROC				; CIME::SetCurPos, COMDAT
; _this$ = ecx

; 814  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 815  : 	if (offset < 0 || offset > ms_lastpos)

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _offset$[ebp]
  0000c	85 f6		 test	 esi, esi
  0000e	78 37		 js	 SHORT $LN4@SetCurPos
  00010	3b f0		 cmp	 esi, eax
  00012	7f 33		 jg	 SHORT $LN4@SetCurPos

; 816  : 	{
; 817  : 		ms_curpos = ms_lastpos;
; 818  : 		return;
; 819  : 	}
; 820  : 	else
; 821  : 	{
; 822  : 		// offset    .   .
; 823  : 		//ms_curpos = min(ms_lastpos, offset);
; 824  : 		ms_curpos = min(ms_lastpos, GetTextTagInternalPosFromRenderPos(m_wText, ms_lastpos, offset));

  00014	56		 push	 esi
  00015	50		 push	 eax
  00016	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0001b	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  00020	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH
  00029	3b c8		 cmp	 ecx, eax
  0002b	7d 0b		 jge	 SHORT $LN6@SetCurPos
  0002d	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, ecx ; CIME::ms_curpos
  00033	5e		 pop	 esi

; 825  : 	}
; 826  : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@SetCurPos:

; 816  : 	{
; 817  : 		ms_curpos = ms_lastpos;
; 818  : 		return;
; 819  : 	}
; 820  : 	else
; 821  : 	{
; 822  : 		// offset    .   .
; 823  : 		//ms_curpos = min(ms_lastpos, offset);
; 824  : 		ms_curpos = min(ms_lastpos, GetTextTagInternalPosFromRenderPos(m_wText, ms_lastpos, offset));

  00038	56		 push	 esi
  00039	51		 push	 ecx
  0003a	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0003f	e8 00 00 00 00	 call	 ?GetTextTagInternalPosFromRenderPos@@YAHPB_WHH@Z ; GetTextTagInternalPosFromRenderPos
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SetCurPos:

; 825  : 	}
; 826  : }

  00047	a3 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, eax ; CIME::ms_curpos
  0004c	5e		 pop	 esi
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
?SetCurPos@CIME@@IAEXH@Z ENDP				; CIME::SetCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DecCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?DecCurPos@CIME@@IAEXXZ PROC				; CIME::DecCurPos, COMDAT
; _this$ = ecx

; 794  : 	if (ms_curpos > 0)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00005	85 c0		 test	 eax, eax
  00007	7e 3f		 jle	 SHORT $LN4@DecCurPos

; 795  : 	{
; 796  : 		int pos = FindColorTagStartPosition(m_wText + ms_curpos - 1, ms_curpos);

  00009	50		 push	 eax
  0000a	8d 04 45 fe ff
	ff ff		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[eax*2-2]
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?FindColorTagStartPosition@@YAHPB_WH@Z ; FindColorTagStartPosition
  00017	83 c4 08	 add	 esp, 8

; 797  : 		
; 798  : 		if (pos > 0)

  0001a	85 c0		 test	 eax, eax
  0001c	7e 24		 jle	 SHORT $LN3@DecCurPos

; 799  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos - (pos + 1)));

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00024	33 d2		 xor	 edx, edx
  00026	2b c8		 sub	 ecx, eax
  00028	83 c1 ff	 add	 ecx, -1
  0002b	0f 49 d1	 cmovns	 edx, ecx
  0002e	39 15 00 00 00
	00		 cmp	 DWORD PTR ?ms_lastpos@CIME@@2HA, edx ; CIME::ms_lastpos
  00034	0f 4c 15 00 00
	00 00		 cmovl	 edx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0003b	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, edx ; CIME::ms_curpos

; 802  : 		//--ms_curpos;
; 803  : 	}
; 804  : }

  00041	c3		 ret	 0
$LN3@DecCurPos:

; 800  : 		else
; 801  : 			--ms_curpos;

  00042	ff 0d 00 00 00
	00		 dec	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
$LN4@DecCurPos:

; 802  : 		//--ms_curpos;
; 803  : 	}
; 804  : }

  00048	c3		 ret	 0
?DecCurPos@CIME@@IAEXXZ ENDP				; CIME::DecCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IncCurPos@CIME@@IAEXXZ
_TEXT	SEGMENT
?IncCurPos@CIME@@IAEXXZ PROC				; CIME::IncCurPos, COMDAT
; _this$ = ecx

; 780  : 	if (ms_curpos < ms_lastpos)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  0000b	3b c8		 cmp	 ecx, eax
  0000d	7d 41		 jge	 SHORT $LN4@IncCurPos

; 781  : 	{
; 782  : 		int pos = FindColorTagEndPosition(m_wText + ms_curpos, ms_lastpos - ms_curpos);

  0000f	2b c1		 sub	 eax, ecx
  00011	50		 push	 eax
  00012	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ?FindColorTagEndPosition@@YAHPB_WH@Z ; FindColorTagEndPosition
  0001f	83 c4 08	 add	 esp, 8

; 783  : 
; 784  : 		if (pos > 0)

  00022	85 c0		 test	 eax, eax
  00024	7e 24		 jle	 SHORT $LN3@IncCurPos

; 785  : 			ms_curpos = min(ms_lastpos, max(0, ms_curpos + (pos + 1)));

  00026	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  0002c	41		 inc	 ecx
  0002d	03 c1		 add	 eax, ecx
  0002f	33 c9		 xor	 ecx, ecx
  00031	85 c0		 test	 eax, eax
  00033	0f 49 c8	 cmovns	 ecx, eax
  00036	39 0d 00 00 00
	00		 cmp	 DWORD PTR ?ms_lastpos@CIME@@2HA, ecx ; CIME::ms_lastpos
  0003c	0f 4c 0d 00 00
	00 00		 cmovl	 ecx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00043	89 0d 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, ecx ; CIME::ms_curpos

; 788  : 		//++ms_curpos;
; 789  : 	}
; 790  : }

  00049	c3		 ret	 0
$LN3@IncCurPos:

; 786  : 		else
; 787  : 			++ms_curpos;

  0004a	ff 05 00 00 00
	00		 inc	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
$LN4@IncCurPos:

; 788  : 		//++ms_curpos;
; 789  : 	}
; 790  : }

  00050	c3		 ret	 0
?IncCurPos@CIME@@IAEXXZ ENDP				; CIME::IncCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_c$ = -25						; size = 1
_w$1 = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z PROC			; CIME::WMChar, COMDAT
; _this$ = ecx

; 2264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2265 : 	unsigned char c = unsigned char(wParam & 0xff);

  00010	8b 55 10	 mov	 edx, DWORD PTR _wParam$[ebp]
  00013	88 55 e7	 mov	 BYTE PTR _c$[ebp], dl
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	80 fa 08	 cmp	 dl, 8

; 2266 : 
; 2267 : 	switch (c) 

  0001c	74 57		 je	 SHORT $LN4@WMChar

; 2276 : 		}
; 2277 : 		if(ms_pEvent)
; 2278 : 			ms_pEvent->OnUpdate();
; 2279 : 		return 0;
; 2280 : 		break;
; 2281 : 
; 2282 : 	default:
; 2283 : 		if(ms_pEvent) {

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00024	85 c9		 test	 ecx, ecx
  00026	74 0e		 je	 SHORT $LN10@WMChar

; 2284 : 			if (ms_pEvent->OnWM_CHAR(wParam, lParam))

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  0002d	52		 push	 edx
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	ff d0		 call	 eax
  00032	84 c0		 test	 al, al
  00034	75 6c		 jne	 SHORT $LN19@WMChar
$LN10@WMChar:

; 2285 : 				break;
; 2286 : 		}
; 2287 : 		if(ms_bCaptureInput == false)

  00036	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0003d	74 63		 je	 SHORT $LN19@WMChar

; 2288 : 			return 0;
; 2289 : 		wchar_t w[10];
; 2290 : 		MultiByteToWideChar(ms_uInputCodePage, 0, (char*)&c, 1, w, 1);

  0003f	6a 01		 push	 1
  00041	8d 45 e8	 lea	 eax, DWORD PTR _w$1[ebp]
  00044	50		 push	 eax
  00045	6a 01		 push	 1
  00047	8d 45 e7	 lea	 eax, DWORD PTR _c$[ebp]
  0004a	50		 push	 eax
  0004b	6a 00		 push	 0
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 2291 : 
; 2292 : 		OnChar(w[0]);

  00059	ff 75 e8	 push	 DWORD PTR _w$1[ebp]
  0005c	8b ce		 mov	 ecx, esi
  0005e	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar

; 2293 : 		if (w[0] == L'|')

  00063	66 83 7d e8 7c	 cmp	 WORD PTR _w$1[ebp], 124	; 0000007cH
  00068	75 29		 jne	 SHORT $LN6@WMChar

; 2294 : 			OnChar(w[0]);

  0006a	6a 7c		 push	 124			; 0000007cH
  0006c	8b ce		 mov	 ecx, esi
  0006e	e8 00 00 00 00	 call	 ?OnChar@CIME@@IAEX_W@Z	; CIME::OnChar
  00073	eb 1e		 jmp	 SHORT $LN6@WMChar
$LN4@WMChar:

; 2268 : 	{
; 2269 : 	case 8:
; 2270 : 		if(ms_bCaptureInput == false)

  00075	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0007c	74 24		 je	 SHORT $LN19@WMChar

; 2271 : 			return 0;
; 2272 : 		if (ms_curpos > 0)

  0007e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos
  00085	7e 0c		 jle	 SHORT $LN6@WMChar

; 2273 : 		{
; 2274 : 			DecCurPos();

  00087	e8 00 00 00 00	 call	 ?DecCurPos@CIME@@IAEXXZ	; CIME::DecCurPos

; 2275 : 			DelCurPos();

  0008c	8b ce		 mov	 ecx, esi
  0008e	e8 00 00 00 00	 call	 ?DelCurPos@CIME@@IAEXXZ	; CIME::DelCurPos
$LN6@WMChar:

; 2295 : 		if(ms_pEvent)
; 2296 : 			ms_pEvent->OnUpdate();
; 2297 : 		break;
; 2298 : 	}
; 2299 : 
; 2300 : 	return 0;
; 2301 : }

  00093	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00099	85 c9		 test	 ecx, ecx
  0009b	74 05		 je	 SHORT $LN19@WMChar
  0009d	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009f	ff 50 04	 call	 DWORD PTR [eax+4]
$LN19@WMChar:
  000a2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 c0		 xor	 eax, eax
  000a7	33 cd		 xor	 ecx, ebp
  000a9	5e		 pop	 esi
  000aa	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000af	8b e5		 mov	 esp, ebp
  000b1	5d		 pop	 ebp
  000b2	c2 10 00	 ret	 16			; 00000010H
?WMChar@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP			; CIME::WMChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_result$1$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_uiMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMNotify, COMDAT
; _this$ = ecx

; 2184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 2185 : 	LRESULT		result = 0;

  00005	33 db		 xor	 ebx, ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	89 5d fc	 mov	 DWORD PTR _result$1$[ebp], ebx

; 2186 : 
; 2187 : 	if(ms_bCaptureInput == false)

  0000d	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, bl ; CIME::ms_bCaptureInput
  00013	75 0a		 jne	 SHORT $LN6@WMNotify

; 2188 : 		return 0;

  00015	5e		 pop	 esi
  00016	33 c0		 xor	 eax, eax

; 2261 : }

  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 10 00	 ret	 16			; 00000010H
$LN6@WMNotify:

; 2189 : 	switch (wParam) {

  0001f	8b 4d 10	 mov	 ecx, DWORD PTR _wParam$[ebp]
  00022	57		 push	 edi
  00023	8d 41 fd	 lea	 eax, DWORD PTR [ecx-3]
  00026	83 f8 0b	 cmp	 eax, 11			; 0000000bH
  00029	0f 87 18 01 00
	00		 ja	 $LN2@WMNotify
  0002f	0f b6 80 00 00
	00 00		 movzx	 eax, BYTE PTR $LN33@WMNotify[eax]
  00036	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN34@WMNotify[eax*4]
$LN7@WMNotify:

; 2190 : 
; 2191 : 	case IMN_OPENCANDIDATE:
; 2192 : 	case IMN_CHANGECANDIDATE: {
; 2193 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  0003d	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  00043	74 0c		 je	 SHORT $LN8@WMNotify
  00045	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, bl ; CIME::ms_bUseIMMCandidate
  0004b	0f 84 f6 00 00
	00		 je	 $LN2@WMNotify
$LN8@WMNotify:

; 2194 : 			break;
; 2195 : 		HIMC hImc = ImmGetContext(hWnd);

  00051	8b 5d 08	 mov	 ebx, DWORD PTR _hWnd$[ebp]
  00054	53		 push	 ebx
  00055	e8 00 00 00 00	 call	 _ImmGetContext@4
  0005a	8b f8		 mov	 edi, eax

; 2196 : 		if (hImc == NULL)

  0005c	85 ff		 test	 edi, edi
  0005e	0f 84 e1 00 00
	00		 je	 $LN36@WMNotify

; 2197 : 			break;
; 2198 : 		CandidateProcess(hImc);

  00064	57		 push	 edi
  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?CandidateProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CandidateProcess

; 2199 : 		if (!m_bUseDefaultIME) {

  0006c	80 7e 21 00	 cmp	 BYTE PTR [esi+33], 0
  00070	75 1e		 jne	 SHORT $LN10@WMNotify

; 2200 : 			if(ms_pEvent)

  00072	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00078	85 c9		 test	 ecx, ecx
  0007a	74 27		 je	 SHORT $LN11@WMNotify

; 2201 : 				ms_pEvent->OnOpenCandidateList();

  0007c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007e	ff 50 0c	 call	 DWORD PTR [eax+12]

; 2204 : 		ImmReleaseContext(hWnd, hImc);

  00081	57		 push	 edi
  00082	53		 push	 ebx
  00083	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2205 : 		break;

  00088	8b 5d fc	 mov	 ebx, DWORD PTR _result$1$[ebp]
  0008b	e9 b7 00 00 00	 jmp	 $LN2@WMNotify
$LN10@WMNotify:

; 2202 : 		} else
; 2203 : 			result = ::DefWindowProc(hWnd, uiMsg, wParam, lParam);

  00090	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  00093	ff 75 10	 push	 DWORD PTR _wParam$[ebp]
  00096	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  00099	53		 push	 ebx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000a0	89 45 fc	 mov	 DWORD PTR _result$1$[ebp], eax
$LN11@WMNotify:

; 2204 : 		ImmReleaseContext(hWnd, hImc);

  000a3	57		 push	 edi
  000a4	53		 push	 ebx
  000a5	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2205 : 		break;

  000aa	8b 5d fc	 mov	 ebx, DWORD PTR _result$1$[ebp]
  000ad	e9 95 00 00 00	 jmp	 $LN2@WMNotify
$LN13@WMNotify:

; 2206 : 		}
; 2207 : 	case IMN_CLOSECANDIDATE:
; 2208 : 		if (ms_bUILessMode && !ms_bUseIMMCandidate)

  000b2	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000b8	74 0c		 je	 SHORT $LN14@WMNotify
  000ba	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUseIMMCandidate@CIME@@2_NA, bl ; CIME::ms_bUseIMMCandidate
  000c0	0f 84 81 00 00
	00		 je	 $LN2@WMNotify
$LN14@WMNotify:

; 2209 : 			break;
; 2210 : 		if (!m_bUseDefaultIME)

  000c6	38 5e 21	 cmp	 BYTE PTR [esi+33], bl
  000c9	75 07		 jne	 SHORT $LN15@WMNotify

; 2211 : 			CloseCandidateList();

  000cb	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList
  000d0	eb 75		 jmp	 SHORT $LN2@WMNotify
$LN15@WMNotify:

; 2212 : 		else
; 2213 : 			result = DefWindowProc(hWnd, uiMsg, wParam, lParam);

  000d2	ff 75 14	 push	 DWORD PTR _lParam$[ebp]
  000d5	51		 push	 ecx
  000d6	ff 75 0c	 push	 DWORD PTR _uiMsg$[ebp]
  000d9	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DefWindowProcA@16
  000e2	8b d8		 mov	 ebx, eax

; 2214 : 		break;

  000e4	eb 61		 jmp	 SHORT $LN2@WMNotify
$LN17@WMNotify:

; 2215 : 
; 2216 : 	case IMN_SETCONVERSIONMODE:
; 2217 : 	case IMN_SETOPENSTATUS:
; 2218 : 		if (ms_bUILessMode)

  000e6	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000ec	75 59		 jne	 SHORT $LN2@WMNotify

; 2219 : 			break;
; 2220 : 		CheckToggleState();

  000ee	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 2221 : 		break;

  000f3	eb 52		 jmp	 SHORT $LN2@WMNotify
$LN19@WMNotify:

; 2222 : 
; 2223 : 	case IMN_PRIVATE: {
; 2224 : 		if (ms_bUILessMode)

  000f5	38 1d 00 00 00
	00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, bl ; CIME::ms_bUILessMode
  000fb	75 4a		 jne	 SHORT $LN2@WMNotify

; 2225 : 			break;
; 2226 : 		HIMC hImc = ImmGetContext(hWnd);

  000fd	8b 5d 08	 mov	 ebx, DWORD PTR _hWnd$[ebp]
  00100	53		 push	 ebx
  00101	e8 00 00 00 00	 call	 _ImmGetContext@4
  00106	8b f8		 mov	 edi, eax

; 2227 : 		if (hImc == NULL)

  00108	85 ff		 test	 edi, edi
  0010a	74 39		 je	 SHORT $LN36@WMNotify

; 2228 : 			break;
; 2229 :         ReadingProcess(hImc);

  0010c	57		 push	 edi
  0010d	8b ce		 mov	 ecx, esi
  0010f	e8 00 00 00 00	 call	 ?ReadingProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ReadingProcess

; 2230 : 
; 2231 : 		// Trap some messages to hide reading window
; 2232 :         switch(ms_adwId[0])

  00114	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_adwId@CIME@@2PAKA
  0011a	81 f9 04 04 00
	05		 cmp	 ecx, 83887108		; 05000404H
  00120	77 5c		 ja	 SHORT $LN30@WMNotify
  00122	74 7e		 je	 SHORT $LN25@WMNotify
  00124	81 f9 04 08 02
	04		 cmp	 ecx, 67241988		; 04020804H
  0012a	77 35		 ja	 SHORT $LN31@WMNotify
  0012c	74 43		 je	 SHORT $LN22@WMNotify
  0012e	81 f9 04 08 01
	04		 cmp	 ecx, 67176452		; 04010804H
  00134	74 3b		 je	 SHORT $LN22@WMNotify
  00136	81 f9 04 04 02
	04		 cmp	 ecx, 67240964		; 04020404H
  0013c	74 33		 je	 SHORT $LN22@WMNotify
$LN26@WMNotify:

; 2250 :                 break;
; 2251 :         }
; 2252 : 		ImmReleaseContext(hWnd, hImc);

  0013e	57		 push	 edi
  0013f	53		 push	 ebx
  00140	e8 00 00 00 00	 call	 _ImmReleaseContext@8
$LN36@WMNotify:

; 2253 : 		break;
; 2254 : 		}
; 2255 : 	}
; 2256 : 
; 2257 : 	if(ms_pEvent)

  00145	33 db		 xor	 ebx, ebx
$LN2@WMNotify:
  00147	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0014d	85 c9		 test	 ecx, ecx
  0014f	74 05		 je	 SHORT $LN28@WMNotify

; 2258 : 		ms_pEvent->OnUpdate();

  00151	8b 01		 mov	 eax, DWORD PTR [ecx]
  00153	ff 50 04	 call	 DWORD PTR [eax+4]
$LN28@WMNotify:

; 2259 : 
; 2260 : 	return result;

  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	8b c3		 mov	 eax, ebx

; 2261 : }

  0015a	5b		 pop	 ebx
  0015b	8b e5		 mov	 esp, ebp
  0015d	5d		 pop	 ebp
  0015e	c2 10 00	 ret	 16			; 00000010H
$LN31@WMNotify:

; 2230 : 
; 2231 : 		// Trap some messages to hide reading window
; 2232 :         switch(ms_adwId[0])

  00161	81 f9 04 04 03
	04		 cmp	 ecx, 67306500		; 04030404H
  00167	74 08		 je	 SHORT $LN22@WMNotify
  00169	81 f9 04 04 04
	04		 cmp	 ecx, 67372036		; 04040404H
  0016f	75 cd		 jne	 SHORT $LN26@WMNotify
$LN22@WMNotify:

; 2233 :         {
; 2234 :             case IMEID_CHT_VER42:
; 2235 :             case IMEID_CHT_VER43:
; 2236 :             case IMEID_CHT_VER44:
; 2237 :             case IMEID_CHS_VER41:
; 2238 :             case IMEID_CHS_VER42:
; 2239 : 				if ((lParam == 1)||(lParam == 2))

  00171	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  00174	83 f8 01	 cmp	 eax, 1
  00177	74 45		 je	 SHORT $LN27@WMNotify
  00179	83 f8 02	 cmp	 eax, 2
  0017c	eb 3e		 jmp	 SHORT $LN38@WMNotify
$LN30@WMNotify:

; 2230 : 
; 2231 : 		// Trap some messages to hide reading window
; 2232 :         switch(ms_adwId[0])

  0017e	81 f9 04 08 03
	05		 cmp	 ecx, 84084740		; 05030804H
  00184	77 14		 ja	 SHORT $LN32@WMNotify
  00186	74 1a		 je	 SHORT $LN25@WMNotify
  00188	81 f9 04 04 01
	05		 cmp	 ecx, 83952644		; 05010404H
  0018e	74 12		 je	 SHORT $LN25@WMNotify
  00190	81 f9 04 04 02
	05		 cmp	 ecx, 84018180		; 05020404H
  00196	74 0a		 je	 SHORT $LN25@WMNotify
  00198	eb a4		 jmp	 SHORT $LN26@WMNotify
$LN32@WMNotify:
  0019a	81 f9 04 04 00
	06		 cmp	 ecx, 100664324		; 06000404H
  001a0	75 9c		 jne	 SHORT $LN26@WMNotify
$LN25@WMNotify:

; 2240 : 					return true;
; 2241 :                 break;
; 2242 : 
; 2243 :             case IMEID_CHT_VER50:
; 2244 :             case IMEID_CHT_VER51:
; 2245 :             case IMEID_CHT_VER52:
; 2246 :             case IMEID_CHT_VER60:
; 2247 :             case IMEID_CHS_VER53:
; 2248 :                 if ((lParam == 16)||(lParam == 17)||(lParam == 26)||(lParam == 27)||(lParam == 28))

  001a2	8b 45 14	 mov	 eax, DWORD PTR _lParam$[ebp]
  001a5	83 f8 10	 cmp	 eax, 16			; 00000010H
  001a8	74 14		 je	 SHORT $LN27@WMNotify
  001aa	83 f8 11	 cmp	 eax, 17			; 00000011H
  001ad	74 0f		 je	 SHORT $LN27@WMNotify
  001af	83 f8 1a	 cmp	 eax, 26			; 0000001aH
  001b2	74 0a		 je	 SHORT $LN27@WMNotify
  001b4	83 f8 1b	 cmp	 eax, 27			; 0000001bH
  001b7	74 05		 je	 SHORT $LN27@WMNotify
  001b9	83 f8 1c	 cmp	 eax, 28			; 0000001cH
$LN38@WMNotify:

; 2249 : 					return true;

  001bc	75 80		 jne	 SHORT $LN26@WMNotify
$LN27@WMNotify:
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
  001c0	b8 01 00 00 00	 mov	 eax, 1

; 2261 : }

  001c5	5b		 pop	 ebx
  001c6	8b e5		 mov	 esp, ebp
  001c8	5d		 pop	 ebp
  001c9	c2 10 00	 ret	 16			; 00000010H
$LN34@WMNotify:
  001cc	00 00 00 00	 DD	 $LN7@WMNotify
  001d0	00 00 00 00	 DD	 $LN13@WMNotify
  001d4	00 00 00 00	 DD	 $LN17@WMNotify
  001d8	00 00 00 00	 DD	 $LN19@WMNotify
  001dc	00 00 00 00	 DD	 $LN2@WMNotify
$LN33@WMNotify:
  001e0	00		 DB	 0
  001e1	01		 DB	 1
  001e2	00		 DB	 0
  001e3	02		 DB	 2
  001e4	04		 DB	 4
  001e5	02		 DB	 2
  001e6	04		 DB	 4
  001e7	04		 DB	 4
  001e8	04		 DB	 4
  001e9	04		 DB	 4
  001ea	04		 DB	 4
  001eb	03		 DB	 3
?WMNotify@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMNotify
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMEndComposition, COMDAT
; _this$ = ecx

; 2173 : 	ms_compLen = 0;
; 2174 : 	ms_ulbegin = 0;
; 2175 : 	ms_ulend = 0;
; 2176 : 
; 2177 : 	if(ms_pEvent)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen
  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin
  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend
  00024	85 c9		 test	 ecx, ecx
  00026	74 05		 je	 SHORT $LN4@WMEndCompo

; 2178 : 		ms_pEvent->OnUpdate();

  00028	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002a	ff 50 04	 call	 DWORD PTR [eax+4]
$LN4@WMEndCompo:

; 2179 : 
; 2180 : 	return 0L;
; 2181 : }

  0002d	33 c0		 xor	 eax, eax
  0002f	c2 10 00	 ret	 16			; 00000010H
?WMEndComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMEndComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
tv173 = 20						; size = 4
_lParam$ = 20						; size = 4
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC		; CIME::WMComposition, COMDAT
; _this$ = ecx

; 2133 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2134 : 	LRESULT		result = 0;
; 2135 : 
; 2136 : 	if(ms_bCaptureInput == false)

  00003	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	74 7d		 je	 SHORT $LN14@WMComposit

; 2137 : 		return 0;
; 2138 : 
; 2139 : 	HIMC hImc = ImmGetContext(hWnd);

  0000f	56		 push	 esi
  00010	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00013	e8 00 00 00 00	 call	 _ImmGetContext@4
  00018	8b f0		 mov	 esi, eax

; 2140 : 
; 2141 : 	if(hImc == NULL)

  0001a	85 f6		 test	 esi, esi
  0001c	74 66		 je	 SHORT $LN15@WMComposit

; 2142 : 		return 0;
; 2143 : 
; 2144 : 	if(lParam&GCS_RESULTSTR) 

  0001e	53		 push	 ebx
  0001f	8b 5d 14	 mov	 ebx, DWORD PTR _lParam$[ebp]
  00022	f7 c3 00 08 00
	00		 test	 ebx, 2048		; 00000800H
  00028	74 08		 je	 SHORT $LN4@WMComposit

; 2145 : 		ResultProcess(hImc);

  0002a	56		 push	 esi
  0002b	8b cf		 mov	 ecx, edi
  0002d	e8 00 00 00 00	 call	 ?ResultProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::ResultProcess
$LN4@WMComposit:

; 2146 : 	if(lParam&GCS_COMPATTR) 

  00032	8b c3		 mov	 eax, ebx
  00034	83 e0 10	 and	 eax, 16			; 00000010H
  00037	89 45 14	 mov	 DWORD PTR tv173[ebp], eax
  0003a	74 0b		 je	 SHORT $LN5@WMComposit

; 2147 : 		AttributeProcess(hImc);

  0003c	56		 push	 esi
  0003d	8b cf		 mov	 ecx, edi
  0003f	e8 00 00 00 00	 call	 ?AttributeProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::AttributeProcess
  00044	8b 45 14	 mov	 eax, DWORD PTR tv173[ebp]
$LN5@WMComposit:

; 2148 : 	if(lParam&GCS_COMPSTR)

  00047	f6 c3 08	 test	 bl, 8
  0004a	5b		 pop	 ebx
  0004b	74 1f		 je	 SHORT $LN8@WMComposit

; 2149 : 	{
; 2150 : 		if (ms_uOutputCodePage == 950) //    

  0004d	81 3d 00 00 00
	00 b6 03 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 950 ; CIME::ms_uOutputCodePage, 000003b6H
  00057	8b cf		 mov	 ecx, edi
  00059	56		 push	 esi
  0005a	75 0b		 jne	 SHORT $LN7@WMComposit

; 2151 : 		{
; 2152 : 			if (lParam&GCS_COMPATTR) 

  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN7@WMComposit

; 2153 : 				CompositionProcessBuilding(hImc);

  00060	e8 00 00 00 00	 call	 ?CompositionProcessBuilding@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcessBuilding
  00065	eb 05		 jmp	 SHORT $LN8@WMComposit
$LN7@WMComposit:

; 2154 : 			else
; 2155 : 				CompositionProcess(hImc);
; 2156 : 		}
; 2157 : 		else
; 2158 : 		{
; 2159 : 			CompositionProcess(hImc);
; 2160 : 		}
; 2161 : 	}
; 2162 : 
; 2163 : 	ImmReleaseContext(hWnd, hImc);

  00067	e8 00 00 00 00	 call	 ?CompositionProcess@CIME@@IAEXPAUHIMC__@@@Z ; CIME::CompositionProcess
$LN8@WMComposit:
  0006c	56		 push	 esi
  0006d	ff 75 08	 push	 DWORD PTR _hWnd$[ebp]
  00070	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 2164 : 
; 2165 : 	if(ms_pEvent)

  00075	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0007b	85 c9		 test	 ecx, ecx
  0007d	74 05		 je	 SHORT $LN15@WMComposit

; 2166 : 		ms_pEvent->OnUpdate();

  0007f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00081	ff 50 04	 call	 DWORD PTR [eax+4]
$LN15@WMComposit:

; 2167 : 
; 2168 : 	return (result);

  00084	5e		 pop	 esi
  00085	33 c0		 xor	 eax, eax
  00087	5f		 pop	 edi

; 2169 : }

  00088	5d		 pop	 ebp
  00089	c2 10 00	 ret	 16			; 00000010H
$LN14@WMComposit:

; 2167 : 
; 2168 : 	return (result);

  0008c	33 c0		 xor	 eax, eax
  0008e	5f		 pop	 edi

; 2169 : }

  0008f	5d		 pop	 ebp
  00090	c2 10 00	 ret	 16			; 00000010H
?WMComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP		; CIME::WMComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 4
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMStartComposition, COMDAT
; _this$ = ecx

; 2129 : 	return 1L;

  00000	b8 01 00 00 00	 mov	 eax, 1

; 2130 : }

  00005	c2 10 00	 ret	 16			; 00000010H
?WMStartComposition@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMStartComposition
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hWnd$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_lParam$ = 20						; size = 4
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z PROC	; CIME::WMInputLanguage, COMDAT
; _this$ = ecx

; 2123 : 	ChangeInputLanguage();

  00000	e8 00 00 00 00	 call	 ?ChangeInputLanguage@CIME@@SAXXZ ; CIME::ChangeInputLanguage

; 2124 : 	return 0;

  00005	33 c0		 xor	 eax, eax

; 2125 : }

  00007	c2 10 00	 ret	 16			; 00000010H
?WMInputLanguage@CIME@@QAEJPAUHWND__@@IIJ@Z ENDP	; CIME::WMInputLanguage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguageWorker@CIME@@SAXXZ
_TEXT	SEGMENT
?ChangeInputLanguageWorker@CIME@@SAXXZ PROC		; CIME::ChangeInputLanguageWorker, COMDAT

; 758  : 	if ( !ms_bUILessMode )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00007	75 14		 jne	 SHORT $LN2@ChangeInpu

; 759  : 		ms_iCandListIndexBase = ( ms_hklCurrent == _CHT_HKL_DAYI ) ? 0 : 1;

  00009	33 c0		 xor	 eax, eax
  0000b	81 3d 00 00 00
	00 04 04 06 e0	 cmp	 DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A, -536476668 ; CIME::ms_hklCurrent, e0060404H
  00015	0f 95 c0	 setne	 al
  00018	a3 00 00 00 00	 mov	 DWORD PTR ?ms_iCandListIndexBase@CIME@@2HA, eax ; CIME::ms_iCandListIndexBase
$LN2@ChangeInpu:

; 760  : 	SetupImeApi();

  0001d	e9 00 00 00 00	 jmp	 ?SetupImeApi@CIME@@KAXXZ ; CIME::SetupImeApi
?ChangeInputLanguageWorker@CIME@@SAXXZ ENDP		; CIME::ChangeInputLanguageWorker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ChangeInputLanguage@CIME@@SAXXZ
_TEXT	SEGMENT
?ChangeInputLanguage@CIME@@SAXXZ PROC			; CIME::ChangeInputLanguage, COMDAT

; 733  : {

  00000	56		 push	 esi

; 734  : 	UINT uLanguage = (UINT) GETLANG();

  00001	0f b7 35 00 00
	00 00		 movzx	 esi, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A

; 735  : 	CheckToggleState();

  00008	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 736  : 	ChangeInputLanguageWorker();

  0000d	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 737  : 	if (uLanguage != GETLANG())

  00012	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A
  00019	66 3b f1	 cmp	 si, cx
  0001c	5e		 pop	 esi
  0001d	74 1f		 je	 SHORT $LN2@ChangeInpu

; 738  : 	{
; 739  : 		// Korean IME always uses level 3 support.
; 740  : 		// Other languages use the level that is specified by ImeUi_SetSupportLevel()
; 741  : 		SetSupportLevel( ( GETPRIMLANG() == LANG_KOREAN ) ? 3 : ms_dwIMELevelSaved );

  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwIMELevelSaved@CIME@@2KA ; CIME::ms_dwIMELevelSaved
  00024	81 e1 ff 03 00
	00		 and	 ecx, 1023		; 000003ffH
  0002a	83 f9 12	 cmp	 ecx, 18			; 00000012H
  0002d	ba 03 00 00 00	 mov	 edx, 3
  00032	0f 44 c2	 cmove	 eax, edx
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  0003b	83 c4 04	 add	 esp, 4
$LN2@ChangeInpu:

; 742  : 	}
; 743  : 
; 744  : 	if(ms_pEvent)

  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00044	85 c9		 test	 ecx, ecx
  00046	74 05		 je	 SHORT $LN3@ChangeInpu

; 745  : 		ms_pEvent->OnChangeCodePage();

  00048	8b 01		 mov	 eax, DWORD PTR [ecx]
  0004a	ff 60 08	 jmp	 DWORD PTR [eax+8]
$LN3@ChangeInpu:

; 746  : 
; 747  : 	//HWND hwndImeDef = ImmGetDefaultIMEWnd(ms_hWnd);
; 748  : 	//if ( hwndImeDef )
; 749  : 	//{
; 750  : 	//	// Fix for Zooty #3995: prevent CHT IME toobar from showing up
; 751  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_OPENSTATUSWINDOW, 0);
; 752  : 	//	SendMessageA(hwndImeDef, WM_IME_CONTROL, IMC_CLOSESTATUSWINDOW, 0);
; 753  : 	//}
; 754  : }

  0004d	c3		 ret	 0
?ChangeInputLanguage@CIME@@SAXXZ ENDP			; CIME::ChangeInputLanguage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CloseReadingInformation@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseReadingInformation@CIME@@SAXXZ PROC		; CIME::CloseReadingInformation, COMDAT

; 727  : 	CIME::ms_bReadingInformation = false;
; 728  : 	if(CIME::ms_pEvent)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00006	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation
  0000d	85 c9		 test	 ecx, ecx
  0000f	74 05		 je	 SHORT $LN2@CloseReadi

; 729  : 		CIME::ms_pEvent->OnCloseReadingWnd();

  00011	8b 01		 mov	 eax, DWORD PTR [ecx]
  00013	ff 60 18	 jmp	 DWORD PTR [eax+24]
$LN2@CloseReadi:

; 730  : }

  00016	c3		 ret	 0
?CloseReadingInformation@CIME@@SAXXZ ENDP		; CIME::CloseReadingInformation
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?CloseCandidateList@CIME@@SAXXZ
_TEXT	SEGMENT
?CloseCandidateList@CIME@@SAXXZ PROC			; CIME::CloseCandidateList, COMDAT

; 718  : 	ms_bCandidateList = false;
; 719  : 	ms_dwCandidateCount = 0;
; 720  : 	memset(&ms_wszCandidate, 0, sizeof(ms_wszCandidate));

  00000	68 00 14 00 00	 push	 5120			; 00001400H
  00005	6a 00		 push	 0
  00007	68 00 00 00 00	 push	 OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate
  0000c	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList
  00013	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_dwCandidateCount@CIME@@2KA, 0 ; CIME::ms_dwCandidateCount
  0001d	e8 00 00 00 00	 call	 _memset

; 721  : 	if(ms_pEvent)

  00022	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002b	85 c9		 test	 ecx, ecx
  0002d	74 05		 je	 SHORT $LN2@CloseCandi

; 722  : 		ms_pEvent->OnCloseCandidateList();

  0002f	8b 01		 mov	 eax, DWORD PTR [ecx]
  00031	ff 60 10	 jmp	 DWORD PTR [eax+16]
$LN2@CloseCandi:

; 723  : }

  00034	c3		 ret	 0
?CloseCandidateList@CIME@@SAXXZ ENDP			; CIME::CloseCandidateList
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetULEnd@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULEnd@CIME@@SAHXZ PROC				; CIME::GetULEnd, COMDAT

; 713  : 	return ms_ulend;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulend@CIME@@2HA ; CIME::ms_ulend

; 714  : }

  00005	c3		 ret	 0
?GetULEnd@CIME@@SAHXZ ENDP				; CIME::GetULEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetULBegin@CIME@@SAHXZ
_TEXT	SEGMENT
?GetULBegin@CIME@@SAHXZ PROC				; CIME::GetULBegin, COMDAT

; 708  : 	return ms_ulbegin;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_ulbegin@CIME@@2HA ; CIME::ms_ulbegin

; 709  : }

  00005	c3		 ret	 0
?GetULBegin@CIME@@SAHXZ ENDP				; CIME::GetULBegin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCompLen@CIME@@SAHXZ
_TEXT	SEGMENT
?GetCompLen@CIME@@SAHXZ PROC				; CIME::GetCompLen, COMDAT

; 703  : 	return ms_compLen;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen

; 704  : }

  00005	c3		 ret	 0
?GetCompLen@CIME@@SAHXZ ENDP				; CIME::GetCompLen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCurPos@CIME@@SAHXZ
_TEXT	SEGMENT
?GetCurPos@CIME@@SAHXZ PROC				; CIME::GetCurPos, COMDAT

; 808  : 	int pos = GetTextTagOutputLen(m_wText, ms_curpos);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00006	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0000b	e8 00 00 00 00	 call	 ?GetTextTagOutputLen@@YAHPB_WH@Z ; GetTextTagOutputLen
  00010	83 c4 08	 add	 esp, 8

; 809  : 	return pos;
; 810  : 	//return ms_curpos;
; 811  : }

  00013	c3		 ret	 0
?GetCurPos@CIME@@SAHXZ ENDP				; CIME::GetCurPos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?UseDefaultIME@CIME@@QAEXXZ
_TEXT	SEGMENT
?UseDefaultIME@CIME@@QAEXXZ PROC			; CIME::UseDefaultIME, COMDAT
; _this$ = ecx

; 377  : 	m_bUseDefaultIME = true;

  00000	c6 41 21 01	 mov	 BYTE PTR [ecx+33], 1

; 378  : }

  00004	c3		 ret	 0
?UseDefaultIME@CIME@@QAEXXZ ENDP			; CIME::UseDefaultIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?FinalizeString@CIME@@SAX_N@Z
_TEXT	SEGMENT
_bSend$ = 8						; size = 1
?FinalizeString@CIME@@SAX_N@Z PROC			; CIME::FinalizeString, COMDAT

; 664  : 	HIMC himc;
; 665  : 	static bool s_bProcessing = false; // to avoid infinite recursion
; 666  : 	if ( !ms_bInitialized || s_bProcessing || NULL == ( himc = ImmGetContext( ms_hWnd ) ) )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  00007	74 72		 je	 SHORT $LN3@FinalizeSt
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 0
  00010	75 69		 jne	 SHORT $LN3@FinalizeSt
  00012	56		 push	 esi
  00013	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00019	e8 00 00 00 00	 call	 _ImmGetContext@4
  0001e	8b f0		 mov	 esi, eax
  00020	85 f6		 test	 esi, esi
  00022	74 56		 je	 SHORT $LN7@FinalizeSt

; 667  : 		return;
; 668  : 	s_bProcessing = true;
; 669  : 
; 670  : 	if (ms_dwIMELevel == 2 && bSend)
; 671  : 	{
; 672  : 		//// Send composition string to app.
; 673  : 		//LONG lRet = lstrlenW( m_wszComposition );
; 674  : 		////assert( lRet >= 2);
; 675  : 		//// In case of CHT IME, don't send the trailing double byte space, if it exists.
; 676  : 		//if ( GETLANG() == LANG_CHT && (lRet >= 1)
; 677  : 		//	&& m_wszComposition[lRet - 1] == 0x3000 )
; 678  : 		//{
; 679  : 		//	lRet--;
; 680  : 		//}
; 681  : 		//SendCompString();
; 682  : 	}
; 683  : 
; 684  : 	//InitCompStringData();
; 685  : 	// clear composition string in IME
; 686  : 	ImmNotifyIME(himc, NI_COMPOSITIONSTR, CPS_CANCEL, 0);

  00024	6a 00		 push	 0
  00026	6a 04		 push	 4
  00028	6a 15		 push	 21			; 00000015H
  0002a	56		 push	 esi
  0002b	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 1
  00032	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 687  : 	if (ms_bUILessMode)

  00037	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  0003e	74 16		 je	 SHORT $LN5@FinalizeSt

; 688  : 	{
; 689  : 		// For some reason ImmNotifyIME doesn't work on DaYi and Array CHT IMEs. Cancel composition string by setting zero-length string.
; 690  : 		ImmSetCompositionStringW(himc, SCS_SETSTR, L"", sizeof(wchar_t), L"", sizeof(wchar_t));

  00040	6a 02		 push	 2
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00047	6a 02		 push	 2
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0004e	6a 09		 push	 9
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 _ImmSetCompositionStringW@24
$LN5@FinalizeSt:

; 691  : 	}
; 692  : 	// the following line is necessary as Korean IME doesn't close cand list when comp string is cancelled.
; 693  : 	ImmNotifyIME( himc, NI_CLOSECANDIDATE, 0, 0 );	

  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	6a 11		 push	 17			; 00000011H
  0005c	56		 push	 esi
  0005d	e8 00 00 00 00	 call	 _ImmNotifyIME@16

; 694  : 	ImmReleaseContext(ms_hWnd, himc);

  00062	56		 push	 esi
  00063	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00069	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 695  : 	// Zooty2 RAID #4759: Sometimes application doesn't receive IMN_CLOSECANDIDATE on Alt+Tab
; 696  : 	// So the same code for IMN_CLOSECANDIDATE is replicated here.
; 697  : 	CloseCandidateList();

  0006e	e8 00 00 00 00	 call	 ?CloseCandidateList@CIME@@SAXXZ ; CIME::CloseCandidateList

; 698  : 	s_bProcessing = false;

  00073	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?s_bProcessing@?1??FinalizeString@CIME@@SAX_N@Z@4_NA, 0
$LN7@FinalizeSt:
  0007a	5e		 pop	 esi
$LN3@FinalizeSt:

; 699  : }

  0007b	c3		 ret	 0
?FinalizeString@CIME@@SAX_N@Z ENDP			; CIME::FinalizeString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?PasteString@CIME@@QAEXPBD@Z
_TEXT	SEGMENT
_m_wText$ = -2052					; size = 2048
__$ArrayPad$ = -4					; size = 4
_str$ = 8						; size = 4
?PasteString@CIME@@QAEXPBD@Z PROC			; CIME::PasteString, COMDAT
; _this$ = ecx

; 840  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 08 00
	00		 sub	 esp, 2052		; 00000804H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 55 08	 mov	 edx, DWORD PTR _str$[ebp]

; 841  : 	const char * begin = str;
; 842  : 	const char * end = str + strlen(str);

  00016	8b c2		 mov	 eax, edx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8b f1		 mov	 esi, ecx
  0001c	8d 78 01	 lea	 edi, DWORD PTR [eax+1]
  0001f	90		 npad	 1
$LL4@PasteStrin:
  00020	8a 08		 mov	 cl, BYTE PTR [eax]
  00022	40		 inc	 eax
  00023	84 c9		 test	 cl, cl
  00025	75 f9		 jne	 SHORT $LL4@PasteStrin

; 843  : 	wchar_t m_wText[IMESTR_MAXLEN];
; 844  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end - begin, m_wText, IMESTR_MAXLEN);

  00027	68 00 04 00 00	 push	 1024			; 00000400H
  0002c	8d 8d fc f7 ff
	ff		 lea	 ecx, DWORD PTR _m_wText$[ebp]
  00032	2b c7		 sub	 eax, edi
  00034	51		 push	 ecx
  00035	50		 push	 eax
  00036	52		 push	 edx
  00037	6a 00		 push	 0
  00039	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 845  : 	InsertString(m_wText, wstrLen);

  00045	50		 push	 eax
  00046	8d 85 fc f7 ff
	ff		 lea	 eax, DWORD PTR _m_wText$[ebp]
  0004c	8b ce		 mov	 ecx, esi
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 846  : 	if(ms_pEvent)

  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	85 c9		 test	 ecx, ecx
  0005e	74 05		 je	 SHORT $LN2@PasteStrin

; 847  : 		ms_pEvent->OnUpdate();

  00060	8b 01		 mov	 eax, DWORD PTR [ecx]
  00062	ff 50 04	 call	 DWORD PTR [eax+4]
$LN2@PasteStrin:

; 848  : }

  00065	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00068	33 cd		 xor	 ecx, ebp
  0006a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?PasteString@CIME@@QAEXPBD@Z ENDP			; CIME::PasteString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnablePaste@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_bFlag$ = 8						; size = 1
?EnablePaste@CIME@@QAEX_N@Z PROC			; CIME::EnablePaste, COMDAT
; _this$ = ecx

; 631  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 632  : 	m_bEnablePaste = bFlag;

  00003	8a 45 08	 mov	 al, BYTE PTR _bFlag$[ebp]
  00006	88 41 20	 mov	 BYTE PTR [ecx+32], al

; 633  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?EnablePaste@CIME@@QAEX_N@Z ENDP			; CIME::EnablePaste
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?PasteTextFromClipBoard@CIME@@QAEXXZ
_TEXT	SEGMENT
_handle$1$ = -2104					; size = 4
_this$GSCopy$1$ = -2100					; size = 4
__New_ptr$2 = -2096					; size = 4
_buffer$1$ = -2092					; size = 4
_strClipboard$ = -2088					; size = 24
_m_wText$ = -2064					; size = 2048
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?PasteTextFromClipBoard@CIME@@QAEXXZ PROC		; CIME::PasteTextFromClipBoard, COMDAT
; _this$ = ecx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 2c 08 00
	00		 sub	 esp, 2092		; 0000082cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	56		 push	 esi
  00023	57		 push	 edi
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	8b d9		 mov	 ebx, ecx
  00030	89 9d cc f7 ff
	ff		 mov	 DWORD PTR _this$GSCopy$1$[ebp], ebx

; 637  : 	if (!m_bEnablePaste)

  00036	80 7b 20 00	 cmp	 BYTE PTR [ebx+32], 0
  0003a	0f 84 83 01 00
	00		 je	 $LN81@PasteTextF

; 638  : 		return;
; 639  : 
; 640  : 	if (!OpenClipboard(NULL))

  00040	6a 00		 push	 0
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenClipboard@4
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 73 01 00
	00		 je	 $LN81@PasteTextF

; 641  : 		return;
; 642  : 
; 643  : 	HANDLE handle = GetClipboardData(CF_TEXT);

  00050	6a 01		 push	 1
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetClipboardData@4

; 644  : 	char * buffer = (char*)GlobalLock(handle);

  00058	50		 push	 eax
  00059	89 85 c8 f7 ff
	ff		 mov	 DWORD PTR _handle$1$[ebp], eax
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalLock@4
  00065	8b c8		 mov	 ecx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00067	c7 85 e8 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _strClipboard$[ebp+16], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00071	8b f9		 mov	 edi, ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 644  : 	char * buffer = (char*)GlobalLock(handle);

  00073	89 8d d4 f7 ff
	ff		 mov	 DWORD PTR _buffer$1$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00079	c7 85 ec f7 ff
	ff 0f 00 00 00	 mov	 DWORD PTR _strClipboard$[ebp+20], 15 ; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00083	c6 85 d8 f7 ff
	ff 00		 mov	 BYTE PTR _strClipboard$[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0008a	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
  0008d	0f 1f 00	 npad	 3
$LL87@PasteTextF:
  00090	8a 07		 mov	 al, BYTE PTR [edi]
  00092	47		 inc	 edi
  00093	84 c0		 test	 al, al
  00095	75 f9		 jne	 SHORT $LL87@PasteTextF
  00097	2b fa		 sub	 edi, edx
  00099	83 ff 0f	 cmp	 edi, 15			; 0000000fH

; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  0009c	77 21		 ja	 SHORT $LN24@PasteTextF

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0009e	57		 push	 edi
  0009f	51		 push	 ecx
  000a0	8d 85 d8 f7 ff
	ff		 lea	 eax, DWORD PTR _strClipboard$[ebp]

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  000a6	89 bd e8 f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+16], edi

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 _memmove
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  000b5	c6 84 3d d8 f7
	ff ff 00	 mov	 BYTE PTR _strClipboard$[ebp+edi], 0

; 3049 :             return *this;

  000bd	eb 74		 jmp	 SHORT $LN36@PasteTextF
$LN24@PasteTextF:

; 4305 :         if (_New_size > max_size()) {

  000bf	81 ff ff ff ff
	7f		 cmp	 edi, 2147483647		; 7fffffffH
  000c5	0f 87 14 01 00
	00		 ja	 $LN91@PasteTextF

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  000cb	8b df		 mov	 ebx, edi
  000cd	83 cb 0f	 or	 ebx, 15			; 0000000fH
  000d0	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000d6	76 07		 jbe	 SHORT $LN41@PasteTextF

; 4287 :             return _Max;

  000d8	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  000dd	eb 0a		 jmp	 SHORT $LN40@PasteTextF
$LN41@PasteTextF:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows
; 4291 :             return _Max;
; 4292 :         }
; 4293 : 
; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000df	b8 16 00 00 00	 mov	 eax, 22			; 00000016H
  000e4	3b d8		 cmp	 ebx, eax
  000e6	0f 42 d8	 cmovb	 ebx, eax
$LN40@PasteTextF:

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000e9	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000f2	57		 push	 edi
  000f3	ff b5 d4 f7 ff
	ff		 push	 DWORD PTR _buffer$1$[ebp]

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000f9	8b f0		 mov	 esi, eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  000fb	89 bd e8 f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+16], edi

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00101	56		 push	 esi

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00102	89 b5 d0 f7 ff
	ff		 mov	 DWORD PTR __New_ptr$2[ebp], esi

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00108	89 9d ec f7 ff
	ff		 mov	 DWORD PTR _strClipboard$[ebp+20], ebx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0010e	e8 00 00 00 00	 call	 _memcpy

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00113	8d 85 d0 f7 ff
	ff		 lea	 eax, DWORD PTR __New_ptr$2[ebp]

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00119	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  0011d	50		 push	 eax
  0011e	8d 85 d8 f7 ff
	ff		 lea	 eax, DWORD PTR _strClipboard$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0012a	8b 9d cc f7 ff
	ff		 mov	 ebx, DWORD PTR _this$GSCopy$1$[ebp]
  00130	83 c4 18	 add	 esp, 24			; 00000018H
$LN36@PasteTextF:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 646  : 	GlobalUnlock(handle);

  00133	ff b5 c8 f7 ff
	ff		 push	 DWORD PTR _handle$1$[ebp]
  00139	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GlobalUnlock@4

; 647  : 	CloseClipboard();

  00146	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseClipboard@0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3848 :         return size() == 0;

  0014c	8b 85 e8 f7 ff
	ff		 mov	 eax, DWORD PTR _strClipboard$[ebp+16]
  00152	85 c0		 test	 eax, eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 649  : 	if (strClipboard.empty())

  00154	74 52		 je	 SHORT $LN5@PasteTextF
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  00156	83 bd ec f7 ff
	ff 10		 cmp	 DWORD PTR _strClipboard$[ebp+20], 16 ; 00000010H

; 2218 :         const value_type* _Result = _Bx._Buf;

  0015d	8d 95 d8 f7 ff
	ff		 lea	 edx, DWORD PTR _strClipboard$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 655  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end-begin, m_wText, IMESTR_MAXLEN);

  00163	68 00 04 00 00	 push	 1024			; 00000400H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2219 :         if (_Large_string_engaged()) {

  00168	0f 43 95 d8 f7
	ff ff		 cmovae	 edx, DWORD PTR _strClipboard$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 655  : 	int wstrLen = MultiByteToWideChar(ms_uInputCodePage, 0, begin, end-begin, m_wText, IMESTR_MAXLEN);

  0016f	8d 8d f0 f7 ff
	ff		 lea	 ecx, DWORD PTR _m_wText$[ebp]
  00175	51		 push	 ecx
  00176	03 c2		 add	 eax, edx
  00178	2b c2		 sub	 eax, edx
  0017a	50		 push	 eax
  0017b	52		 push	 edx
  0017c	6a 00		 push	 0
  0017e	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00184	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MultiByteToWideChar@24

; 656  : 
; 657  : 	InsertString(m_wText, wstrLen);

  0018a	50		 push	 eax
  0018b	8d 85 f0 f7 ff
	ff		 lea	 eax, DWORD PTR _m_wText$[ebp]
  00191	8b cb		 mov	 ecx, ebx
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 ?InsertString@CIME@@IAEXPA_WH@Z ; CIME::InsertString

; 658  : 	if(ms_pEvent)

  00199	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_pEvent@CIME@@2PAVIIMEEventSink@@A ; CIME::ms_pEvent
  0019f	85 c9		 test	 ecx, ecx
  001a1	74 05		 je	 SHORT $LN5@PasteTextF

; 659  : 		ms_pEvent->OnUpdate();

  001a3	8b 01		 mov	 eax, DWORD PTR [ecx]
  001a5	ff 50 04	 call	 DWORD PTR [eax+4]
$LN5@PasteTextF:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  001a8	8b 85 ec f7 ff
	ff		 mov	 eax, DWORD PTR _strClipboard$[ebp+20]
  001ae	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  001b1	72 10		 jb	 SHORT $LN81@PasteTextF

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  001b3	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  001b4	50		 push	 eax
  001b5	ff b5 d8 f7 ff
	ff		 push	 DWORD PTR _strClipboard$[ebp]
  001bb	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  001c0	83 c4 08	 add	 esp, 8
$LN81@PasteTextF:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 660  : }

  001c3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cd	59		 pop	 ecx
  001ce	5f		 pop	 edi
  001cf	5e		 pop	 esi
  001d0	5b		 pop	 ebx
  001d1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d4	33 cd		 xor	 ecx, ebp
  001d6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001db	8b e5		 mov	 esp, ebp
  001dd	5d		 pop	 ebp
  001de	c3		 ret	 0
$LN91@PasteTextF:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4306 :             _Xlen_string(); // result too long

  001df	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN89@PasteTextF:
  001e4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?PasteTextFromClipBoard@CIME@@QAEXXZ$0:
  00000	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR _strClipboard$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?PasteTextFromClipBoard@CIME@@QAEXXZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a c4 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2108]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?PasteTextFromClipBoard@CIME@@QAEXXZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?PasteTextFromClipBoard@CIME@@QAEXXZ ENDP		; CIME::PasteTextFromClipBoard
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?ClearExceptKey@CIME@@QAEXXZ
_TEXT	SEGMENT
?ClearExceptKey@CIME@@QAEXXZ PROC			; CIME::ClearExceptKey, COMDAT
; _this$ = ecx

; 619  : 	m_exceptKey.clear();

  00000	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00003	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 620  : }

  00006	c3		 ret	 0
?ClearExceptKey@CIME@@QAEXXZ ENDP			; CIME::ClearExceptKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?AddExceptKey@CIME@@QAEX_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 2
?AddExceptKey@CIME@@QAEX_W@Z PROC			; CIME::AddExceptKey, COMDAT
; _this$ = ecx

; 613  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00003	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 614  : 	m_exceptKey.push_back(key);

  00006	83 c1 14	 add	 ecx, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 704  :         if (_Mylast != _My_data._Myend) {

  00009	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0000c	74 0f		 je	 SHORT $LN6@AddExceptK

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0000e	66 8b 45 08	 mov	 ax, WORD PTR _key$[ebp]
  00012	66 89 02	 mov	 WORD PTR [edx], ax

; 688  :         _Orphan_range(_Mylast, _Mylast);
; 689  :         _Ty& _Result = *_Mylast;
; 690  :         ++_Mylast;

  00015	83 41 04 02	 add	 DWORD PTR [ecx+4], 2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 615  : }

  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
$LN6@AddExceptK:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0001d	8d 45 08	 lea	 eax, DWORD PTR _key$[ebp]
  00020	50		 push	 eax
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@AB_W@?$vector@_WV?$allocator@_W@std@@@std@@QAEPA_WQA_WAB_W@Z ; std::vector<wchar_t,std::allocator<wchar_t> >::_Emplace_reallocate<wchar_t const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 615  : }

  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
?AddExceptKey@CIME@@QAEX_W@Z ENDP			; CIME::AddExceptKey
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?__IsWritable@CIME@@QAE_N_W@Z
_TEXT	SEGMENT
_key$ = 8						; size = 2
?__IsWritable@CIME@@QAE_N_W@Z PROC			; CIME::__IsWritable, COMDAT
; _this$ = ecx

; 623  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00003	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 623  : {

  00006	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00007	8b 71 18	 mov	 esi, DWORD PTR [ecx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5439 :     for (; _First != _Last; ++_First) {

  0000a	3b c6		 cmp	 eax, esi
  0000c	74 10		 je	 SHORT $LN44@IsWritable
  0000e	66 8b 4d 08	 mov	 cx, WORD PTR _key$[ebp]
$LL24@IsWritable:

; 5440 :         if (*_First == _Val) {

  00012	66 39 08	 cmp	 WORD PTR [eax], cx
  00015	74 07		 je	 SHORT $LN44@IsWritable

; 5439 :     for (; _First != _Last; ++_First) {

  00017	83 c0 02	 add	 eax, 2
  0001a	3b c6		 cmp	 eax, esi
  0001c	75 f4		 jne	 SHORT $LL24@IsWritable
$LN44@IsWritable:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 195  :         _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));

  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??$_Refancy@PA_W$0A@@std@@YAPA_WPA_W@Z ; std::_Refancy<wchar_t *,0>
  00024	83 c4 04	 add	 esp, 4
  00027	3b f0		 cmp	 esi, eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 624  : 	if ( m_exceptKey.end() == std::find(m_exceptKey.begin(),m_exceptKey.end(),key) )

  00029	0f 94 c0	 sete	 al
  0002c	5e		 pop	 esi

; 625  : 		return true;
; 626  : 	else
; 627  : 		return false;
; 628  : }

  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?__IsWritable@CIME@@QAE_N_W@Z ENDP			; CIME::__IsWritable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetStringMode@CIME@@QAEXXZ
_TEXT	SEGMENT
?SetStringMode@CIME@@QAEXXZ PROC			; CIME::SetStringMode, COMDAT
; _this$ = ecx

; 609  : 	m_bOnlyNumberMode = FALSE;

  00000	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 610  : }

  00007	c3		 ret	 0
?SetStringMode@CIME@@QAEXXZ ENDP			; CIME::SetStringMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetNumberMode@CIME@@QAEXXZ
_TEXT	SEGMENT
?SetNumberMode@CIME@@QAEXXZ PROC			; CIME::SetNumberMode, COMDAT
; _this$ = ecx

; 604  : 	m_bOnlyNumberMode = TRUE;

  00000	c7 41 10 01 00
	00 00		 mov	 DWORD PTR [ecx+16], 1

; 605  : }

  00007	c3		 ret	 0
?SetNumberMode@CIME@@QAEXXZ ENDP			; CIME::SetNumberMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsCaptureEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
?IsCaptureEnabled@CIME@@QAE_NXZ PROC			; CIME::IsCaptureEnabled, COMDAT
; _this$ = ecx

; 415  : 	return ms_bCaptureInput;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bCaptureInput@CIME@@2_NA ; CIME::ms_bCaptureInput

; 416  : }

  00005	c3		 ret	 0
?IsCaptureEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsCaptureEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DisableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
?DisableCaptureInput@CIME@@QAEXXZ PROC			; CIME::DisableCaptureInput, COMDAT
; _this$ = ecx

; 410  : 	ms_bCaptureInput = false;

  00000	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 0 ; CIME::ms_bCaptureInput

; 411  : }

  00007	c3		 ret	 0
?DisableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::DisableCaptureInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableCaptureInput@CIME@@QAEXXZ
_TEXT	SEGMENT
?EnableCaptureInput@CIME@@QAEXXZ PROC			; CIME::EnableCaptureInput, COMDAT
; _this$ = ecx

; 405  : 	ms_bCaptureInput = true;

  00000	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bCaptureInput@CIME@@2_NA, 1 ; CIME::ms_bCaptureInput

; 406  : }

  00007	c3		 ret	 0
?EnableCaptureInput@CIME@@QAEXXZ ENDP			; CIME::EnableCaptureInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?DisableIME@CIME@@QAEXXZ
_TEXT	SEGMENT
?DisableIME@CIME@@QAEXXZ PROC				; CIME::DisableIME, COMDAT
; _this$ = ecx

; 400  : 	EnableIME(false);

  00000	6a 00		 push	 0
  00002	e8 00 00 00 00	 call	 ?EnableIME@CIME@@QAEX_N@Z ; CIME::EnableIME

; 401  : }

  00007	c3		 ret	 0
?DisableIME@CIME@@QAEXXZ ENDP				; CIME::DisableIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?EnableIME@CIME@@QAEX_N@Z
_TEXT	SEGMENT
_bEnable$ = 8						; size = 1
?EnableIME@CIME@@QAEX_N@Z PROC				; CIME::EnableIME, COMDAT
; _this$ = ecx

; 386  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 387  : 	if (!ms_bInitialized || !ms_hWnd)

  00003	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  0000a	53		 push	 ebx
  0000b	8a 5d 08	 mov	 bl, BYTE PTR _bEnable$[ebp]
  0000e	74 30		 je	 SHORT $LN3@EnableIME
  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00015	85 c0		 test	 eax, eax
  00017	74 27		 je	 SHORT $LN3@EnableIME

; 388  : 		return;
; 389  : 	if (ms_bDisableIMECompletely)

  00019	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 0 ; CIME::ms_bDisableIMECompletely
  00020	74 23		 je	 SHORT $LN4@EnableIME

; 390  : 		bEnable = false;

  00022	32 db		 xor	 bl, bl
  00024	88 5d 08	 mov	 BYTE PTR _bEnable$[ebp], bl
$LN7@EnableIME:

; 391  : 	ImmAssociateContext(ms_hWnd, bEnable ? m_hOrgIMC : NULL);

  00027	6a 00		 push	 0
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _ImmAssociateContext@8

; 395  : 	CTsfUiLessMode::EnableUiUpdates(bEnable);

  0002f	ff 75 08	 push	 DWORD PTR _bEnable$[ebp]
  00032	88 1d 00 00 00
	00		 mov	 BYTE PTR ?ms_bImeEnabled@CIME@@2_NA, bl ; CIME::ms_bImeEnabled
  00038	e8 00 00 00 00	 call	 ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ; CTsfUiLessMode::EnableUiUpdates
  0003d	83 c4 04	 add	 esp, 4
$LN3@EnableIME:
  00040	5b		 pop	 ebx

; 396  : }

  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
$LN4@EnableIME:

; 391  : 	ImmAssociateContext(ms_hWnd, bEnable ? m_hOrgIMC : NULL);

  00045	84 db		 test	 bl, bl
  00047	74 de		 je	 SHORT $LN7@EnableIME
  00049	ff 71 04	 push	 DWORD PTR [ecx+4]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _ImmAssociateContext@8
  00052	88 1d 00 00 00
	00		 mov	 BYTE PTR ?ms_bImeEnabled@CIME@@2_NA, bl ; CIME::ms_bImeEnabled

; 392  : 	ms_bImeEnabled = bEnable;
; 393  : 	if (bEnable)
; 394  : 		CheckToggleState();

  00058	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState
  0005d	88 5d 08	 mov	 BYTE PTR _bEnable$[ebp], bl

; 395  : 	CTsfUiLessMode::EnableUiUpdates(bEnable);

  00060	ff 75 08	 push	 DWORD PTR _bEnable$[ebp]
  00063	e8 00 00 00 00	 call	 ?EnableUiUpdates@CTsfUiLessMode@@SAX_N@Z ; CTsfUiLessMode::EnableUiUpdates
  00068	83 c4 04	 add	 esp, 4
  0006b	5b		 pop	 ebx

; 396  : }

  0006c	5d		 pop	 ebp
  0006d	c2 04 00	 ret	 4
?EnableIME@CIME@@QAEX_N@Z ENDP				; CIME::EnableIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?IsIMEEnabled@CIME@@QAE_NXZ
_TEXT	SEGMENT
?IsIMEEnabled@CIME@@QAE_NXZ PROC			; CIME::IsIMEEnabled, COMDAT
; _this$ = ecx

; 382  : 	return ms_bImeEnabled;

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR ?ms_bImeEnabled@CIME@@2_NA ; CIME::ms_bImeEnabled

; 383  : }

  00005	c3		 ret	 0
?IsIMEEnabled@CIME@@QAE_NXZ ENDP			; CIME::IsIMEEnabled
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetInputMode@CIME@@QAEKXZ
_TEXT	SEGMENT
_dwSMode$ = -8						; size = 4
_dwCMode$ = -4						; size = 4
?GetInputMode@CIME@@QAEKXZ PROC				; CIME::GetInputMode, COMDAT
; _this$ = ecx

; 590  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi

; 591  : 	DWORD dwCMode, dwSMode;
; 592  : 
; 593  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000d	e8 00 00 00 00	 call	 _ImmGetContext@4
  00012	8b f0		 mov	 esi, eax

; 594  : 
; 595  : 	ImmGetConversionStatus(hImc, &dwCMode, &dwSMode);

  00014	8d 45 f8	 lea	 eax, DWORD PTR _dwSMode$[ebp]
  00017	50		 push	 eax
  00018	8d 45 fc	 lea	 eax, DWORD PTR _dwCMode$[ebp]
  0001b	50		 push	 eax
  0001c	56		 push	 esi
  0001d	e8 00 00 00 00	 call	 _ImmGetConversionStatus@12

; 596  : 
; 597  : 	ImmReleaseContext(ms_hWnd, hImc);

  00022	56		 push	 esi
  00023	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00029	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 598  : 
; 599  : 	return dwCMode;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _dwCMode$[ebp]
  00031	5e		 pop	 esi

; 600  : }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?GetInputMode@CIME@@QAEKXZ ENDP				; CIME::GetInputMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetInputMode@CIME@@QAEXK@Z
_TEXT	SEGMENT
_dwMode$ = 8						; size = 4
?SetInputMode@CIME@@QAEXK@Z PROC			; CIME::SetInputMode, COMDAT
; _this$ = ecx

; 581  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 582  : 	HIMC hImc = ImmGetContext(ms_hWnd);

  00004	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0000a	e8 00 00 00 00	 call	 _ImmGetContext@4

; 583  : 
; 584  : 	ImmSetConversionStatus(hImc, dwMode, IME_SMODE_AUTOMATIC);

  0000f	6a 04		 push	 4
  00011	ff 75 08	 push	 DWORD PTR _dwMode$[ebp]
  00014	8b f0		 mov	 esi, eax
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 _ImmSetConversionStatus@12

; 585  : 
; 586  : 	ImmReleaseContext(ms_hWnd, hImc);

  0001c	56		 push	 esi
  0001d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00023	e8 00 00 00 00	 call	 _ImmReleaseContext@8
  00028	5e		 pop	 esi

; 587  : }

  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?SetInputMode@CIME@@QAEXK@Z ENDP			; CIME::SetInputMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReadingError@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetReadingError@CIME@@QAEHXZ PROC			; CIME::GetReadingError, COMDAT
; _this$ = ecx

; 444  : 	return ms_iReadingError;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_iReadingError@CIME@@2HA ; CIME::ms_iReadingError

; 445  : }

  00005	c3		 ret	 0
?GetReadingError@CIME@@QAEHXZ ENDP			; CIME::GetReadingError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_reading$ = -132					; size = 128
__$ArrayPad$ = -4					; size = 4
_rstrText$ = 8						; size = 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetReading, COMDAT
; _this$ = ecx

; 429  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00013	a1 04 00 00 00	 mov	 eax, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A+4
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 429  : {

  00018	56		 push	 esi
  00019	8b 75 08	 mov	 esi, DWORD PTR _rstrText$[ebp]
  0001c	57		 push	 edi
  0001d	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_wstrReading@CIME@@2V?$vector@_WV?$allocator@_W@std@@@std@@A
  00025	2b c1		 sub	 eax, ecx
  00027	d1 f8		 sar	 eax, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 432  : 	if(ms_wstrReading.size() == 0)

  00029	75 14		 jne	 SHORT $LN2@GetReading

; 433  : 		return 0;

  0002b	5f		 pop	 edi
  0002c	33 c0		 xor	 eax, eax

; 440  : }

  0002e	5e		 pop	 esi
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00032	33 cd		 xor	 ecx, ebp
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
$LN2@GetReading:
  0003f	53		 push	 ebx

; 434  : 	int readingLen = WideCharToMultiByte(ms_uOutputCodePage, 0, &ms_wstrReading[0], ms_wstrReading.size(), reading, sizeof(reading), NULL, NULL);

  00040	6a 00		 push	 0
  00042	6a 00		 push	 0
  00044	68 80 00 00 00	 push	 128			; 00000080H
  00049	8d 95 7c ff ff
	ff		 lea	 edx, DWORD PTR _reading$[ebp]
  0004f	52		 push	 edx
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	6a 00		 push	 0
  00054	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32

; 435  : 
; 436  : 	rstrText.append(GetCodePageText());

  00060	8b cf		 mov	 ecx, edi
  00062	8b d8		 mov	 ebx, eax
  00064	e8 00 00 00 00	 call	 ?GetCodePageText@CIME@@QAEPBDXZ ; CIME::GetCodePageText
  00069	8b d0		 mov	 edx, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0006b	8b ca		 mov	 ecx, edx
  0006d	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL16@GetReading:
  00070	8a 01		 mov	 al, BYTE PTR [ecx]
  00072	41		 inc	 ecx
  00073	84 c0		 test	 al, al
  00075	75 f9		 jne	 SHORT $LL16@GetReading
  00077	2b cf		 sub	 ecx, edi

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00079	51		 push	 ecx
  0007a	52		 push	 edx
  0007b	8b ce		 mov	 ecx, esi
  0007d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00082	53		 push	 ebx
  00083	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR _reading$[ebp]
  00089	8b ce		 mov	 ecx, esi
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 440  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00097	33 cd		 xor	 ecx, ebp
  00099	5b		 pop	 ebx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?GetReading@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetReading
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateSelection@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidateSelection@CIME@@QAEHXZ PROC		; CIME::GetCandidateSelection, COMDAT
; _this$ = ecx

; 577  : 	return ms_dwCandidateSelection;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateSelection@CIME@@2KA ; CIME::ms_dwCandidateSelection

; 578  : }

  00005	c3		 ret	 0
?GetCandidateSelection@CIME@@QAEHXZ ENDP		; CIME::GetCandidateSelection
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_index$ = 8						; size = 4
_rstrText$ = 12						; size = 4
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CIME::GetCandidate, COMDAT
; _this$ = ecx

; 554  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 04 04 00
	00		 sub	 esp, 1028		; 00000404H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  00016	53		 push	 ebx
  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _rstrText$[ebp]
  0001a	56		 push	 esi

; 555  : 	if(index >= MAX_CANDLIST)

  0001b	83 f9 0a	 cmp	 ecx, 10			; 0000000aH
  0001e	73 75		 jae	 SHORT $LN12@GetCandida

; 556  : 		return 0;
; 557  : 
; 558  : 	LPCWSTR wszText = ms_wszCandidate[index];

  00020	c1 e1 09	 shl	 ecx, 9
  00023	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?ms_wszCandidate@CIME@@2PAY0BAA@_WA ; CIME::ms_wszCandidate

; 559  : 	if(wszText == NULL)

  00029	74 6a		 je	 SHORT $LN12@GetCandida

; 560  : 		return 0;
; 561  : 
; 562  : 	int wTextLen = wcslen(wszText);

  0002b	8b f1		 mov	 esi, ecx
  0002d	8d 56 02	 lea	 edx, DWORD PTR [esi+2]
$LL13@GetCandida:
  00030	66 8b 06	 mov	 ax, WORD PTR [esi]
  00033	83 c6 02	 add	 esi, 2
  00036	66 85 c0	 test	 ax, ax
  00039	75 f5		 jne	 SHORT $LL13@GetCandida
  0003b	2b f2		 sub	 esi, edx
  0003d	d1 fe		 sar	 esi, 1

; 563  : 	if(wTextLen == 0)

  0003f	74 54		 je	 SHORT $LN12@GetCandida

; 567  : 	int len = ::WideCharToMultiByte(CP_UTF8, 0, wszText, wTextLen, text, sizeof(text), 0, 0);

  00041	57		 push	 edi
  00042	6a 00		 push	 0
  00044	6a 00		 push	 0
  00046	68 00 04 00 00	 push	 1024			; 00000400H
  0004b	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  00051	50		 push	 eax
  00052	56		 push	 esi
  00053	51		 push	 ecx
  00054	6a 00		 push	 0
  00056	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00061	6a 05		 push	 5
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_05EFEJGKEJ@?$EA9999@
  00068	8b cb		 mov	 ecx, ebx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 567  : 	int len = ::WideCharToMultiByte(CP_UTF8, 0, wszText, wTextLen, text, sizeof(text), 0, 0);

  0006a	8b f8		 mov	 edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00071	57		 push	 edi
  00072	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  00078	8b cb		 mov	 ecx, ebx
  0007a	50		 push	 eax
  0007b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 572  : 	return wTextLen;

  00080	5f		 pop	 edi
  00081	8b c6		 mov	 eax, esi
  00083	5e		 pop	 esi

; 573  : }

  00084	5b		 pop	 ebx
  00085	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00088	33 cd		 xor	 ecx, ebp
  0008a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 08 00	 ret	 8
$LN12@GetCandida:
  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 c0		 xor	 eax, eax
  0009a	5e		 pop	 esi
  0009b	33 cd		 xor	 ecx, ebp
  0009d	5b		 pop	 ebx
  0009e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 08 00	 ret	 8
?GetCandidate@CIME@@QAEHKAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CIME::GetCandidate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidatePageCount@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidatePageCount@CIME@@QAEHXZ PROC		; CIME::GetCandidatePageCount, COMDAT
; _this$ = ecx

; 545  : 	return ms_dwCandidatePageSize;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidatePageSize@CIME@@2KA ; CIME::ms_dwCandidatePageSize

; 546  : }

  00005	c3		 ret	 0
?GetCandidatePageCount@CIME@@QAEHXZ ENDP		; CIME::GetCandidatePageCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCandidateCount@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCandidateCount@CIME@@QAEHXZ PROC			; CIME::GetCandidateCount, COMDAT
; _this$ = ecx

; 550  : 	return ms_dwCandidateCount;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwCandidateCount@CIME@@2KA ; CIME::ms_dwCandidateCount

; 551  : }

  00005	c3		 ret	 0
?GetCandidateCount@CIME@@QAEHXZ ENDP			; CIME::GetCandidateCount
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePage@CIME@@QAEHXZ
_TEXT	SEGMENT
?GetCodePage@CIME@@QAEHXZ PROC				; CIME::GetCodePage, COMDAT
; _this$ = ecx

; 540  : 	return ms_uOutputCodePage;

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage

; 541  : }

  00005	c3		 ret	 0
?GetCodePage@CIME@@QAEHXZ ENDP				; CIME::GetCodePage
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetCodePageText@CIME@@QAEPBDXZ
_TEXT	SEGMENT
?GetCodePageText@CIME@@QAEPBDXZ PROC			; CIME::GetCodePageText, COMDAT
; _this$ = ecx

; 521  : 	static char szCodePage[16];
; 522  : 
; 523  : 	const int defCodePage = GetDefaultCodePage();

  00000	e8 00 00 00 00	 call	 ?GetDefaultCodePage@@YAKXZ ; GetDefaultCodePage

; 524  : 	const int outCodePage = ms_uOutputCodePage;

  00005	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage

; 525  : 
; 526  : 	if (outCodePage != defCodePage)

  0000b	3b c8		 cmp	 ecx, eax
  0000d	74 19		 je	 SHORT $LN2@GetCodePag

; 527  : 	{
; 528  : 		sprintf(szCodePage, "@%04d", outCodePage);

  0000f	51		 push	 ecx
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_05JKJMOPAK@?$EA?$CF04d@
  00015	68 00 00 00 00	 push	 OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  0001a	e8 00 00 00 00	 call	 _sprintf
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 533  : 	}
; 534  : 
; 535  : 	return szCodePage;
; 536  : }

  00022	b8 00 00 00 00	 mov	 eax, OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  00027	c3		 ret	 0
$LN2@GetCodePag:

; 529  : 	}
; 530  : 	else
; 531  : 	{
; 532  : 		szCodePage[0] = 0;

  00028	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA, 0

; 533  : 	}
; 534  : 
; 535  : 	return szCodePage;
; 536  : }

  0002f	b8 00 00 00 00	 mov	 eax, OFFSET ?szCodePage@?1??GetCodePageText@CIME@@QAEPBDXZ@4PADA
  00034	c3		 ret	 0
?GetCodePageText@CIME@@QAEPBDXZ ENDP			; CIME::GetCodePageText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
_dataCodePage$1$ = -1040				; size = 4
_rstrText$GSCopy$1$ = -1036				; size = 4
$T1 = -1032						; size = 4
_text$ = -1028						; size = 1024
__$ArrayPad$ = -4					; size = 4
_rstrText$ = 8						; size = 4
_addCodePage$ = 12					; size = 1
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CIME::GetText, COMDAT
; _this$ = ecx

; 478  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	8b 45 08	 mov	 eax, DWORD PTR _rstrText$[ebp]

; 479  : 	int outCodePage = ms_uOutputCodePage;
; 480  : 	int dataCodePage;
; 481  : 	switch (outCodePage)

  00016	81 3d 00 00 00
	00 f4 04 00 00	 cmp	 DWORD PTR ?ms_uOutputCodePage@CIME@@2IA, 1268 ; CIME::ms_uOutputCodePage, 000004f4H
  00020	53		 push	 ebx
  00021	56		 push	 esi
  00022	57		 push	 edi

; 482  : 	{
; 483  : 		//case 1256: // ARABIC
; 484  : 		case 1268: // VIETNAM
; 485  : 			dataCodePage = CP_UTF8;
; 486  : 			break;
; 487  : 		default:
; 488  : 			dataCodePage = outCodePage;
; 489  : 	}
; 490  : 
; 491  : 	int len = 0;
; 492  : 	char text[IMESTR_MAXLEN];
; 493  : 
; 494  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText, ms_curpos, text, sizeof(text)-len, NULL, NULL);

  00023	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WideCharToMultiByte@32
  00029	8b d9		 mov	 ebx, ecx
  0002b	6a 00		 push	 0
  0002d	6a 00		 push	 0
  0002f	68 00 04 00 00	 push	 1024			; 00000400H
  00034	89 85 f4 fb ff
	ff		 mov	 DWORD PTR _rstrText$GSCopy$1$[ebp], eax
  0003a	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0003f	0f 45 0d 00 00
	00 00		 cmovne	 ecx, DWORD PTR ?ms_uOutputCodePage@CIME@@2IA ; CIME::ms_uOutputCodePage
  00046	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0004c	50		 push	 eax
  0004d	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  00053	89 8d f0 fb ff
	ff		 mov	 DWORD PTR _dataCodePage$1$[ebp], ecx
  00059	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  0005e	6a 00		 push	 0
  00060	51		 push	 ecx
  00061	ff d7		 call	 edi
  00063	8b c8		 mov	 ecx, eax

; 495  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wszComposition, ms_compLen, text+len, sizeof(text)-len, NULL, NULL);

  00065	be 00 04 00 00	 mov	 esi, 1024		; 00000400H
  0006a	6a 00		 push	 0
  0006c	6a 00		 push	 0
  0006e	8b c6		 mov	 eax, esi
  00070	89 8d f8 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  00076	2b c1		 sub	 eax, ecx
  00078	50		 push	 eax
  00079	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0007f	03 c1		 add	 eax, ecx
  00081	50		 push	 eax
  00082	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_compLen@CIME@@2HA ; CIME::ms_compLen
  00088	8d 43 22	 lea	 eax, DWORD PTR [ebx+34]
  0008b	8b 9d f0 fb ff
	ff		 mov	 ebx, DWORD PTR _dataCodePage$1$[ebp]
  00091	50		 push	 eax
  00092	6a 00		 push	 0
  00094	53		 push	 ebx
  00095	ff d7		 call	 edi
  00097	8b 8d f8 fb ff
	ff		 mov	 ecx, DWORD PTR $T1[ebp]
  0009d	03 c8		 add	 ecx, eax

; 496  : 	len += WideCharToMultiByte(dataCodePage, 0, m_wText+ms_curpos, ms_lastpos-ms_curpos, text+len, sizeof(text)-len, NULL, NULL);

  0009f	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  000a5	6a 00		 push	 0
  000a7	6a 00		 push	 0
  000a9	03 c1		 add	 eax, ecx
  000ab	89 8d f8 fb ff
	ff		 mov	 DWORD PTR $T1[ebp], ecx
  000b1	2b f1		 sub	 esi, ecx
  000b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000b9	56		 push	 esi
  000ba	50		 push	 eax
  000bb	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  000c0	2b c1		 sub	 eax, ecx
  000c2	50		 push	 eax
  000c3	8d 04 4d 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[ecx*2]
  000ca	50		 push	 eax
  000cb	6a 00		 push	 0
  000cd	53		 push	 ebx
  000ce	ff d7		 call	 edi
  000d0	8b 9d f8 fb ff
	ff		 mov	 ebx, DWORD PTR $T1[ebp]

; 497  : 
; 498  : 	int i;
; 499  : 	for(i=0; i<len; ++i)

  000d6	33 f6		 xor	 esi, esi
  000d8	03 d8		 add	 ebx, eax
  000da	85 db		 test	 ebx, ebx
  000dc	7e 11		 jle	 SHORT $LN20@GetText
  000de	66 90		 npad	 2
$LL6@GetText:

; 500  : 		if((BYTE)text[i] > 0x7F) break;

  000e0	80 bc 35 fc fb
	ff ff 7f	 cmp	 BYTE PTR _text$[ebp+esi], 127 ; 0000007fH
  000e8	77 17		 ja	 SHORT $LN10@GetText

; 497  : 
; 498  : 	int i;
; 499  : 	for(i=0; i<len; ++i)

  000ea	46		 inc	 esi
  000eb	3b f3		 cmp	 esi, ebx
  000ed	7c f1		 jl	 SHORT $LL6@GetText
$LN20@GetText:

; 501  : 
; 502  : 	if(i == len)

  000ef	3b f3		 cmp	 esi, ebx
  000f1	75 0e		 jne	 SHORT $LN10@GetText

; 505  : 	}

  000f3	8b bd f4 fb ff
	ff		 mov	 edi, DWORD PTR _rstrText$GSCopy$1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  000f9	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 505  : 	}

  000ff	eb 26		 jmp	 SHORT $LN11@GetText
$LN10@GetText:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00101	8b bd f4 fb ff
	ff		 mov	 edi, DWORD PTR _rstrText$GSCopy$1$[ebp]
  00107	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0010d	56		 push	 esi
  0010e	50		 push	 eax
  0010f	8b cf		 mov	 ecx, edi
  00111	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 513  : 		rstrText.append(text+i, text+len);

  00116	8d 85 fc fb ff
	ff		 lea	 eax, DWORD PTR _text$[ebp]
  0011c	03 c6		 add	 eax, esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  0011e	2b d8		 sub	 ebx, eax
  00120	8d 9c 1d fc fb
	ff ff		 lea	 ebx, DWORD PTR _text$[ebp+ebx]
$LN11@GetText:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 516  : 	return rstrText.size();

  00127	53		 push	 ebx
  00128	50		 push	 eax
  00129	8b cf		 mov	 ecx, edi
  0012b	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00130	8b 47 10	 mov	 eax, DWORD PTR [edi+16]

; 517  : }

  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	33 cd		 xor	 ecx, ebp
  0013a	5b		 pop	 ebx
  0013b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00140	8b e5		 mov	 esp, ebp
  00142	5d		 pop	 ebp
  00143	c2 08 00	 ret	 8
?GetText@CIME@@QAEHAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CIME::GetText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetText@CIME@@QAEXPBDH@Z
_TEXT	SEGMENT
_szText$ = 8						; size = 4
_len$ = 12						; size = 4
?SetText@CIME@@QAEXPBDH@Z PROC				; CIME::SetText, COMDAT
; _this$ = ecx

; 458  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 459  : 	ms_compLen = 0;
; 460  : 	ms_ulbegin = 0;
; 461  : 	ms_ulend = 0;
; 462  : 
; 463  : 	const char* begin = szText;
; 464  : 	const char* end = begin + len;

  00005	8b 75 08	 mov	 esi, DWORD PTR _szText$[ebp]
  00008	57		 push	 edi
  00009	8b 7d 0c	 mov	 edi, DWORD PTR _len$[ebp]
  0000c	03 fe		 add	 edi, esi
  0000e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 465  : 	const char* iter = FindToken(begin, end);

  00018	57		 push	 edi
  00019	56		 push	 esi
  0001a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin
  00024	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend
  0002e	e8 00 00 00 00	 call	 ?FindToken@@YAPBDPBD0@Z	; FindToken
  00033	83 c4 08	 add	 esp, 8
  00036	8b d8		 mov	 ebx, eax

; 466  : 
; 467  : 	int m_wTextLen = sizeof(m_wText)/sizeof(wchar_t);
; 468  : 
; 469  : 	ms_lastpos = MultiByteToWideChar(ms_uInputCodePage, 0, begin, iter-begin, m_wText, m_wTextLen);

  00038	8b cb		 mov	 ecx, ebx
  0003a	2b ce		 sub	 ecx, esi
  0003c	68 00 04 00 00	 push	 1024			; 00000400H
  00041	68 00 00 00 00	 push	 OFFSET ?m_wText@CIME@@2PA_WA ; CIME::m_wText
  00046	51		 push	 ecx
  00047	56		 push	 esi
  00048	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__MultiByteToWideChar@24
  0004e	6a 00		 push	 0
  00050	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_uInputCodePage@CIME@@2IA ; CIME::ms_uInputCodePage
  00056	ff d6		 call	 esi
  00058	8b d0		 mov	 edx, eax
  0005a	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, edx ; CIME::ms_lastpos

; 470  : 
; 471  : 	if (iter < end)

  00060	3b df		 cmp	 ebx, edi
  00062	73 36		 jae	 SHORT $LN2@SetText

; 472  : 		ms_lastpos += MultiByteToWideChar(ReadToken(iter), 0, (iter+5), end-(iter+5), m_wText+ms_lastpos, m_wTextLen-ms_lastpos);

  00064	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00069	8d 04 55 00 00
	00 00		 lea	 eax, DWORD PTR ?m_wText@CIME@@2PA_WA[edx*2]
  00070	2b ca		 sub	 ecx, edx
  00072	2b fb		 sub	 edi, ebx
  00074	51		 push	 ecx
  00075	50		 push	 eax
  00076	83 ef 05	 sub	 edi, 5
  00079	8d 43 05	 lea	 eax, DWORD PTR [ebx+5]
  0007c	57		 push	 edi
  0007d	50		 push	 eax
  0007e	6a 00		 push	 0
  00080	53		 push	 ebx
  00081	e8 00 00 00 00	 call	 ?ReadToken@@YAHPBD@Z	; ReadToken
  00086	83 c4 04	 add	 esp, 4
  00089	50		 push	 eax
  0008a	ff d6		 call	 esi
  0008c	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?ms_lastpos@CIME@@2HA ; CIME::ms_lastpos
  00092	03 d0		 add	 edx, eax
  00094	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, edx ; CIME::ms_lastpos
$LN2@SetText:

; 473  : 
; 474  : 	ms_curpos = min(ms_curpos, ms_lastpos);

  0009a	39 15 00 00 00
	00		 cmp	 DWORD PTR ?ms_curpos@CIME@@2HA, edx ; CIME::ms_curpos
  000a0	5f		 pop	 edi
  000a1	0f 4c 15 00 00
	00 00		 cmovl	 edx, DWORD PTR ?ms_curpos@CIME@@2HA ; CIME::ms_curpos
  000a8	5e		 pop	 esi
  000a9	89 15 00 00 00
	00		 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, edx ; CIME::ms_curpos
  000af	5b		 pop	 ebx

; 475  : }

  000b0	5d		 pop	 ebp
  000b1	c2 08 00	 ret	 8
?SetText@CIME@@QAEXPBDH@Z ENDP				; CIME::SetText
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetUserMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_iMax$ = 8						; size = 4
?SetUserMax@CIME@@QAEXH@Z PROC				; CIME::SetUserMax, COMDAT
; _this$ = ecx

; 453  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 454  : 	m_userMax = iMax;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMax$[ebp]
  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 455  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetUserMax@CIME@@QAEXH@Z ENDP				; CIME::SetUserMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?SetMax@CIME@@QAEXH@Z
_TEXT	SEGMENT
_iMax$ = 8						; size = 4
?SetMax@CIME@@QAEXH@Z PROC				; CIME::SetMax, COMDAT
; _this$ = ecx

; 448  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 449  : 	m_max = iMax;

  00003	8b 45 08	 mov	 eax, DWORD PTR _iMax$[ebp]
  00006	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 450  : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?SetMax@CIME@@QAEXH@Z ENDP				; CIME::SetMax
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Clear@CIME@@SAXXZ
_TEXT	SEGMENT
?Clear@CIME@@SAXXZ PROC					; CIME::Clear, COMDAT

; 420  : 	ms_lastpos = 0;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_lastpos@CIME@@2HA, 0 ; CIME::ms_lastpos

; 421  : 	ms_curpos = 0;

  0000a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_curpos@CIME@@2HA, 0 ; CIME::ms_curpos

; 422  : 
; 423  : 	ms_compLen = 0;

  00014	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_compLen@CIME@@2HA, 0 ; CIME::ms_compLen

; 424  : 	ms_ulbegin = 0;

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulbegin@CIME@@2HA, 0 ; CIME::ms_ulbegin

; 425  : 	ms_ulend = 0;

  00028	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_ulend@CIME@@2HA, 0 ; CIME::ms_ulend

; 426  : }

  00032	c3		 ret	 0
?Clear@CIME@@SAXXZ ENDP					; CIME::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Uninitialize@CIME@@QAEXXZ
_TEXT	SEGMENT
?Uninitialize@CIME@@QAEXXZ PROC				; CIME::Uninitialize, COMDAT
; _this$ = ecx

; 362  : 	if ( !ms_bInitialized )

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	0f 84 91 00 00
	00		 je	 $LN1@Uninitiali

; 363  : 		return;
; 364  : 	CTsfUiLessMode::ReleaseSinks();

  00010	e8 00 00 00 00	 call	 ?ReleaseSinks@CTsfUiLessMode@@SAXXZ ; CTsfUiLessMode::ReleaseSinks

; 365  : 	if ( ms_hWnd )

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  0001a	85 c0		 test	 eax, eax
  0001c	74 09		 je	 SHORT $LN3@Uninitiali

; 366  : 		ImmAssociateContext(ms_hWnd, m_hOrgIMC);

  0001e	ff 76 04	 push	 DWORD PTR [esi+4]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _ImmAssociateContext@8
$LN3@Uninitiali:

; 367  : 	ms_hWnd = NULL;

  00027	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 368  : 	m_hOrgIMC = NULL;

  00031	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 369  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00038	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  0003d	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__FreeLibrary@4
  00043	85 c0		 test	 eax, eax
  00045	74 0d		 je	 SHORT $LN4@Uninitiali
  00047	50		 push	 eax
  00048	ff d6		 call	 esi
  0004a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN4@Uninitiali:

; 370  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  00054	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00059	85 c0		 test	 eax, eax
  0005b	74 0d		 je	 SHORT $LN5@Uninitiali
  0005d	50		 push	 eax
  0005e	ff d6		 call	 esi
  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN5@Uninitiali:

; 244  : 		if ( m_ptim )

  0006a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A
  00070	85 c9		 test	 ecx, ecx
  00072	74 10		 je	 SHORT $LN8@Uninitiali

; 245  : 		{
; 246  : 			m_ptim->Release();

  00074	8b 01		 mov	 eax, DWORD PTR [ecx]
  00076	51		 push	 ecx
  00077	ff 50 08	 call	 DWORD PTR [eax+8]

; 247  : 			m_ptim = NULL;

  0007a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_disableCicero@@3VCDisableCicero@@A, 0
$LN8@Uninitiali:

; 248  : 		}
; 249  : 		if ( m_bComInit )

  00084	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0
  0008b	74 06		 je	 SHORT $LN9@Uninitiali

; 250  : 			CoUninitialize();

  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoUninitialize@0
$LN9@Uninitiali:

; 251  : 		m_bComInit = false;

  00093	c6 05 04 00 00
	00 00		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0

; 371  : 	g_disableCicero.Uninitialize();
; 372  : 	ms_bInitialized = false;

  0009a	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
$LN1@Uninitiali:

; 373  : }

  000a1	5e		 pop	 esi
  000a2	c3		 ret	 0
?Uninitialize@CIME@@QAEXXZ ENDP				; CIME::Uninitialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ?Initialize@CIME@@QAE_NPAUHWND__@@@Z
_TEXT	SEGMENT
_szPath$ = -268						; size = 261
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z PROC		; CIME::Initialize, COMDAT
; _this$ = ecx

; 301  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 01 00
	00		 sub	 esp, 268		; 0000010cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 302  : 	if(ms_bInitialized)

  00013	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 0 ; CIME::ms_bInitialized
  0001a	8b 45 08	 mov	 eax, DWORD PTR _hWnd$[ebp]
  0001d	57		 push	 edi
  0001e	8b f9		 mov	 edi, ecx
  00020	0f 85 a2 01 00
	00		 jne	 $LN19@Initialize

; 226  : 		if ( m_bComInit )

  00026	80 3d 04 00 00
	00 00		 cmp	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 0

; 303  : 		return true;
; 304  : 	ms_hWnd = hWnd;

  0002d	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, eax ; CIME::ms_hWnd

; 226  : 		if ( m_bComInit )

  00032	75 2e		 jne	 SHORT $LN15@Initialize

; 227  : 		{
; 228  : 			return;
; 229  : 		}
; 230  : 		HRESULT hr;
; 231  : 		hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );

  00034	6a 02		 push	 2
  00036	6a 00		 push	 0
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoInitializeEx@8

; 232  : 	    if ( SUCCEEDED( hr ) )

  0003e	85 c0		 test	 eax, eax
  00040	78 20		 js	 SHORT $LN15@Initialize

; 233  : 		{
; 234  : 			m_bComInit = true;
; 235  : 			hr = CoCreateInstance( CLSID_TF_ThreadMgr,

  00042	68 00 00 00 00	 push	 OFFSET ?g_disableCicero@@3VCDisableCicero@@A
  00047	68 00 00 00 00	 push	 OFFSET __GUID_aa80e801_2021_11d2_93e0_0060b067b86e
  0004c	6a 01		 push	 1
  0004e	6a 00		 push	 0
  00050	68 00 00 00 00	 push	 OFFSET _CLSID_TF_ThreadMgr
  00055	c6 05 04 00 00
	00 01		 mov	 BYTE PTR ?g_disableCicero@@3VCDisableCicero@@A+4, 1
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CoCreateInstance@20
$LN15@Initialize:

; 305  : 
; 306  : 	g_disableCicero.Initialize();
; 307  : 
; 308  : 	ms_stOSVI.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
; 309  : 	GetVersionExA(&ms_stOSVI);

  00062	68 00 00 00 00	 push	 OFFSET ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A ; CIME::ms_stOSVI
  00067	c7 05 00 00 00
	00 94 00 00 00	 mov	 DWORD PTR ?ms_stOSVI@CIME@@2U_OSVERSIONINFOA@@A, 148 ; 00000094H
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetVersionExA@4

; 310  : 
; 311  : 	bool bUnicodeImm = false;
; 312  : 	// IMM in NT or Win98 supports Unicode
; 313  : 	if ( ms_stOSVI.dwPlatformId == VER_PLATFORM_WIN32_NT ||
; 314  : 		( ms_stOSVI.dwMajorVersion > 4 ) ||
; 315  : 		( ms_stOSVI.dwMajorVersion == 4 ) && ( ms_stOSVI.dwMinorVersion > 0 ) ) {
; 316  : 		bUnicodeImm = true;
; 317  : 	}
; 318  : 
; 319  : 	// Load ImmLock/ImmUnlock Function Proc
; 320  :     CHAR szPath[MAX_PATH+1];
; 321  : 	ms_bDisableIMECompletely = false;
; 322  :     
; 323  : 	if(GetSystemDirectoryA(szPath, MAX_PATH+1)) {

  00077	68 05 01 00 00	 push	 261			; 00000105H
  0007c	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$[ebp]
  00082	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 0 ; CIME::ms_bDisableIMECompletely
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetSystemDirectoryA@8
  00090	85 c0		 test	 eax, eax
  00092	0f 84 b2 00 00
	00		 je	 $LN7@Initialize

; 324  : 		strcat(szPath, "\\imm32.dll");

  00098	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR _szPath$[ebp]
  0009e	49		 dec	 ecx
  0009f	90		 npad	 1
$LL17@Initialize:
  000a0	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  000a3	8d 49 01	 lea	 ecx, DWORD PTR [ecx+1]
  000a6	84 c0		 test	 al, al
  000a8	75 f6		 jne	 SHORT $LL17@Initialize
  000aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@
  000af	89 01		 mov	 DWORD PTR [ecx], eax
  000b1	a1 04 00 00 00	 mov	 eax, DWORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+4
  000b6	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000b9	66 a1 08 00 00
	00		 mov	 ax, WORD PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+8
  000bf	66 89 41 08	 mov	 WORD PTR [ecx+8], ax
  000c3	a0 0a 00 00 00	 mov	 al, BYTE PTR ??_C@_0L@LPOFADGE@?2imm32?4dll@+10
  000c8	88 41 0a	 mov	 BYTE PTR [ecx+10], al

; 325  : 		ms_hImm32Dll = LoadLibraryA(szPath);

  000cb	8d 85 f4 fe ff
	ff		 lea	 eax, DWORD PTR _szPath$[ebp]
  000d1	50		 push	 eax
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LoadLibraryA@4
  000d8	a3 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, eax ; CIME::ms_hImm32Dll

; 326  : 		if(ms_hImm32Dll)

  000dd	85 c0		 test	 eax, eax
  000df	74 62		 je	 SHORT $LN6@Initialize

; 327  : 		{
; 328  : 			_ImmLockIMC		= (INPUTCONTEXT*(WINAPI *)(HIMC))	GetProcAddress(ms_hImm32Dll, "ImmLockIMC");

  000e1	56		 push	 esi
  000e2	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__GetProcAddress@8
  000e8	68 00 00 00 00	 push	 OFFSET ??_C@_0L@JGAMEFKO@ImmLockIMC@
  000ed	50		 push	 eax
  000ee	ff d6		 call	 esi

; 329  : 			_ImmUnlockIMC	= (BOOL(WINAPI *)(HIMC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMC");

  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PDIACEGP@ImmUnlockIMC@
  000f5	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  000fb	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMC@CIME@@1P6GPAU__MIDL___MIDL_itf_dimm_0000_0012@@PAUHIMC__@@@ZA, eax ; CIME::_ImmLockIMC
  00100	ff d6		 call	 esi

; 330  : 			_ImmLockIMCC	= (LPVOID(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmLockIMCC");

  00102	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OKKMJOGM@ImmLockIMCC@
  00107	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0010d	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMC@CIME@@1P6GHPAUHIMC__@@@ZA, eax ; CIME::_ImmUnlockIMC
  00112	ff d6		 call	 esi

; 331  : 			_ImmUnlockIMCC	= (BOOL(WINAPI *)(HIMCC))			GetProcAddress(ms_hImm32Dll, "ImmUnlockIMCC");

  00114	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GKKOACL@ImmUnlockIMCC@
  00119	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  0011f	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmLockIMCC@CIME@@1P6GPAXPAUHIMCC__@@@ZA, eax ; CIME::_ImmLockIMCC
  00124	ff d6		 call	 esi

; 332  : 			BOOL (WINAPI* _ImmDisableTextFrameService)(DWORD) = (BOOL (WINAPI*)(DWORD))GetProcAddress(ms_hImm32Dll, "ImmDisableTextFrameService");

  00126	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MBEANDFB@ImmDisableTextFrameService@
  0012b	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00131	a3 00 00 00 00	 mov	 DWORD PTR ?_ImmUnlockIMCC@CIME@@1P6GHPAUHIMCC__@@@ZA, eax ; CIME::_ImmUnlockIMCC
  00136	ff d6		 call	 esi
  00138	5e		 pop	 esi

; 333  : 			if ( _ImmDisableTextFrameService )

  00139	85 c0		 test	 eax, eax
  0013b	74 0d		 je	 SHORT $LN7@Initialize

; 334  : 				_ImmDisableTextFrameService( (DWORD)-1 );

  0013d	6a ff		 push	 -1
  0013f	ff d0		 call	 eax

; 335  : 		} else {

  00141	eb 07		 jmp	 SHORT $LN7@Initialize
$LN6@Initialize:

; 336  : 			ms_bDisableIMECompletely = true;

  00143	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bDisableIMECompletely@CIME@@2_NA, 1 ; CIME::ms_bDisableIMECompletely
$LN7@Initialize:

; 337  : 		}
; 338  : 	}
; 339  : 
; 340  : 	ms_bInitialized = true;
; 341  : 
; 342  : 	m_hOrgIMC = ImmGetContext( ms_hWnd );

  0014a	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00150	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?ms_bInitialized@CIME@@2_NA, 1 ; CIME::ms_bInitialized
  00157	e8 00 00 00 00	 call	 _ImmGetContext@4

; 343  : 	ImmReleaseContext( ms_hWnd, m_hOrgIMC );

  0015c	50		 push	 eax
  0015d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00160	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A ; CIME::ms_hWnd
  00166	e8 00 00 00 00	 call	 _ImmReleaseContext@8

; 344  : 
; 345  : 	CheckInputLocale();

  0016b	e8 00 00 00 00	 call	 ?CheckInputLocale@CIME@@KAXXZ ; CIME::CheckInputLocale

; 346  : 	ChangeInputLanguageWorker();

  00170	e8 00 00 00 00	 call	 ?ChangeInputLanguageWorker@CIME@@SAXXZ ; CIME::ChangeInputLanguageWorker

; 347  : 	SetSupportLevel(2);

  00175	6a 02		 push	 2
  00177	e8 00 00 00 00	 call	 ?SetSupportLevel@CIME@@KAXK@Z ; CIME::SetSupportLevel
  0017c	83 c4 04	 add	 esp, 4

; 348  : 
; 349  : 	ms_bUILessMode = CTsfUiLessMode::SetupSinks() != FALSE;

  0017f	e8 00 00 00 00	 call	 ?SetupSinks@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::SetupSinks
  00184	85 c0		 test	 eax, eax
  00186	0f 95 05 00 00
	00 00		 setne	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA ; CIME::ms_bUILessMode

; 350  : 	CheckToggleState();

  0018d	e8 00 00 00 00	 call	 ?CheckToggleState@CIME@@KAXXZ ; CIME::CheckToggleState

; 351  : 	if ( ms_bUILessMode )

  00192	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?ms_bUILessMode@CIME@@2_NA, 0 ; CIME::ms_bUILessMode
  00199	74 2d		 je	 SHORT $LN19@Initialize

; 352  : 	{
; 353  : 		ms_bChineseIME = ( GETPRIMLANG() == LANG_CHINESE ) && CTsfUiLessMode::CurrentInputLocaleIsIme();

  0019b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hklCurrent@CIME@@2PAUHKL__@@A ; CIME::ms_hklCurrent
  001a0	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  001a5	83 f8 04	 cmp	 eax, 4
  001a8	75 0d		 jne	 SHORT $LN11@Initialize
  001aa	e8 00 00 00 00	 call	 ?CurrentInputLocaleIsIme@CTsfUiLessMode@@SAHXZ ; CTsfUiLessMode::CurrentInputLocaleIsIme
  001af	85 c0		 test	 eax, eax
  001b1	74 04		 je	 SHORT $LN11@Initialize
  001b3	b0 01		 mov	 al, 1
  001b5	eb 02		 jmp	 SHORT $LN12@Initialize
$LN11@Initialize:
  001b7	32 c0		 xor	 al, al
$LN12@Initialize:

; 354  : 		CTsfUiLessMode::UpdateImeState();

  001b9	6a 00		 push	 0
  001bb	a2 00 00 00 00	 mov	 BYTE PTR ?ms_bChineseIME@CIME@@2_NA, al ; CIME::ms_bChineseIME
  001c0	e8 00 00 00 00	 call	 ?UpdateImeState@CTsfUiLessMode@@SAXH@Z ; CTsfUiLessMode::UpdateImeState
  001c5	83 c4 04	 add	 esp, 4
$LN19@Initialize:

; 355  : 	}
; 356  : 
; 357  : 	return true;
; 358  : }

  001c8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001cb	b0 01		 mov	 al, 1
  001cd	33 cd		 xor	 ecx, ebp
  001cf	5f		 pop	 edi
  001d0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001d5	8b e5		 mov	 esp, ebp
  001d7	5d		 pop	 ebp
  001d8	c2 04 00	 ret	 4
?Initialize@CIME@@QAE_NPAUHWND__@@@Z ENDP		; CIME::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??1CIME@@UAE@XZ
_TEXT	SEGMENT
??1CIME@@UAE@XZ PROC					; CIME::~CIME, COMDAT
; _this$ = ecx

; 295  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIME@@6B@

; 296  : 	SAFE_FREE_LIBRARY(ms_hCurrentImeDll);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hCurrentImeDll
  0000e	85 c0		 test	 eax, eax
  00010	74 11		 je	 SHORT $LN2@CIME
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00019	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hCurrentImeDll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hCurrentImeDll
$LN2@CIME:

; 297  : 	SAFE_FREE_LIBRARY(ms_hImm32Dll);

  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A ; CIME::ms_hImm32Dll
  00028	85 c0		 test	 eax, eax
  0002a	74 11		 je	 SHORT $LN3@CIME
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FreeLibrary@4
  00033	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hImm32Dll@CIME@@2PAUHINSTANCE__@@A, 0 ; CIME::ms_hImm32Dll
$LN3@CIME:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  0003d	8b 4e 14	 mov	 ecx, DWORD PTR [esi+20]
  00040	85 c9		 test	 ecx, ecx
  00042	74 27		 je	 SHORT $LN8@CIME

; 1695 :             _Destroy(_Myfirst, _Mylast);
; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00044	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
  00047	2b c1		 sub	 eax, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00049	83 e0 fe	 and	 eax, -2			; fffffffeH
  0004c	50		 push	 eax
  0004d	51		 push	 ecx
  0004e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00053	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0005a	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1699 :             _Mylast  = pointer();

  0005d	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0

; 1700 :             _Myend   = pointer();

  00064	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@CIME:
  0006b	5e		 pop	 esi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 298  : }

  0006c	c3		 ret	 0
??1CIME@@UAE@XZ ENDP					; CIME::~CIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp
;	COMDAT ??0CIME@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CIME@@QAE@XZ PROC					; CIME::CIME, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 75 fc	 mov	 DWORD PTR _this$[ebp], esi
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7CIME@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00010	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
  00017	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0001e	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\IME.cpp

; 277  : 	ms_hWnd = NULL;

  00025	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_hWnd@CIME@@2PAUHWND__@@A, 0 ; CIME::ms_hWnd

; 278  : 
; 279  : 	ms_bCandidateList = false;

  0002f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bCandidateList@CIME@@2_NA, 0 ; CIME::ms_bCandidateList

; 280  : 	ms_bReadingInformation = false;

  00036	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?ms_bReadingInformation@CIME@@2_NA, 0 ; CIME::ms_bReadingInformation

; 281  : 
; 282  : 	Clear();

  0003d	e8 00 00 00 00	 call	 ?Clear@CIME@@SAXXZ	; CIME::Clear

; 283  : 
; 284  : 	m_max = 0;

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0

; 285  : 	m_userMax = 0;
; 286  : 
; 287  : 	m_bOnlyNumberMode = FALSE;
; 288  : 	m_hOrgIMC = NULL;
; 289  : 
; 290  : 	m_bEnablePaste = false;
; 291  : 	m_bUseDefaultIME = false;
; 292  : }

  00049	8b c6		 mov	 eax, esi
  0004b	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0
  00052	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00059	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0
  00060	66 c7 46 20 00
	00		 mov	 WORD PTR [esi+32], 0
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0CIME@@QAE@XZ ENDP					; CIME::CIME
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 08	 cmp	 eax, 8

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 12		 jb	 SHORT $LN4@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000b	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  00012	50		 push	 eax
  00013	ff 36		 push	 DWORD PTR [esi]
  00015	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001a	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0001d	33 c0		 xor	 eax, eax
  0001f	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  00026	c7 46 14 07 00
	00 00		 mov	 DWORD PTR [esi+20], 7
  0002d	66 89 06	 mov	 WORD PTR [esi], ax
  00030	5e		 pop	 esi

; 2801 :         _Tidy_deallocate();
; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  00031	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old_size$1$ = -16					; size = 4
__New_ptr$1 = -12					; size = 4
tv448 = -8						; size = 4
__Old$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
tv452 = 12						; size = 4
tv449 = 12						; size = 4
$T2 = 12						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;
; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR __Count$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx
  0000e	8b 57 14	 mov	 edx, DWORD PTR [edi+20]
  00011	8b c2		 mov	 eax, edx
  00013	8b 77 10	 mov	 esi, DWORD PTR [edi+16]
  00016	2b c6		 sub	 eax, esi
  00018	89 75 f0	 mov	 DWORD PTR __Old_size$1$[ebp], esi
  0001b	89 55 fc	 mov	 DWORD PTR __Old$1$[ebp], edx
  0001e	3b d8		 cmp	 ebx, eax
  00020	77 2d		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00022	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
  00025	89 47 10	 mov	 DWORD PTR [edi+16], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  00028	8b c7		 mov	 eax, edi

; 2227 :         return _BUF_SIZE <= _Myres;

  0002a	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2210 :         if (_Large_string_engaged()) {

  0002d	72 02		 jb	 SHORT $LN5@append

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0002f	8b 07		 mov	 eax, DWORD PTR [edi]
$LN5@append:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00031	53		 push	 ebx
  00032	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();
; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00035	03 f0		 add	 esi, eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00037	56		 push	 esi
  00038	e8 00 00 00 00	 call	 _memmove
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00040	c6 04 1e 00	 mov	 BYTE PTR [esi+ebx], 0

; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00044	8b c7		 mov	 eax, edi
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 08 00	 ret	 8
$LN2@append:

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  0004f	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00054	2b c6		 sub	 eax, esi
  00056	3b c3		 cmp	 eax, ebx
  00058	0f 82 d6 00 00
	00		 jb	 $LN45@append

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0005e	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00061	83 c9 0f	 or	 ecx, 15			; 0000000fH
  00064	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0006a	76 07		 jbe	 SHORT $LN19@append

; 4287 :             return _Max;

  0006c	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00071	eb 24		 jmp	 SHORT $LN42@append
$LN19@append:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00073	8b c2		 mov	 eax, edx
  00075	d1 e8		 shr	 eax, 1
  00077	89 45 0c	 mov	 DWORD PTR tv452[ebp], eax
  0007a	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0007f	2b 45 0c	 sub	 eax, DWORD PTR tv452[ebp]
  00082	3b d0		 cmp	 edx, eax
  00084	76 07		 jbe	 SHORT $LN20@append

; 4291 :             return _Max;

  00086	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0008b	eb 0a		 jmp	 SHORT $LN42@append
$LN20@append:

; 4292 :         }
; 4293 : 
; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0008d	8b 45 0c	 mov	 eax, DWORD PTR tv452[ebp]
  00090	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00092	3b c8		 cmp	 ecx, eax
  00094	0f 42 c8	 cmovb	 ecx, eax
$LN42@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00097	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009a	89 4d 0c	 mov	 DWORD PTR $T2[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0009d	50		 push	 eax
  0009e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4343 :         _My_data._Mysize      = _New_size;

  000a3	8d 0c 1e	 lea	 ecx, DWORD PTR [esi+ebx]
  000a6	89 45 f4	 mov	 DWORD PTR __New_ptr$1[ebp], eax
  000a9	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000ac	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4344 :         _My_data._Myres       = _New_capacity;

  000af	8b 4d 0c	 mov	 ecx, DWORD PTR $T2[ebp]
  000b2	89 4f 14	 mov	 DWORD PTR [edi+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b5	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  000b8	89 4d 0c	 mov	 DWORD PTR tv449[ebp], ecx
  000bb	03 cb		 add	 ecx, ebx

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  000bd	83 7d fc 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000c1	89 4d f8	 mov	 DWORD PTR tv448[ebp], ecx
  000c4	72 3c		 jb	 SHORT $LN13@append

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 f0	 push	 DWORD PTR __Old_size$1$[ebp]

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c9	8b 37		 mov	 esi, DWORD PTR [edi]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cb	56		 push	 esi
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 _memcpy
  000d2	53		 push	 ebx
  000d3	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  000d6	ff 75 0c	 push	 DWORD PTR tv449[ebp]
  000d9	e8 00 00 00 00	 call	 _memcpy

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000de	8b 45 f8	 mov	 eax, DWORD PTR tv448[ebp]
  000e1	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e4	8b 45 fc	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000e7	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e8	50		 push	 eax
  000e9	56		 push	 esi
  000ea	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000ef	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1[ebp]

; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  000f2	83 c4 20	 add	 esp, 32			; 00000020H

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f5	89 07		 mov	 DWORD PTR [edi], eax

; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  000f7	8b c7		 mov	 eax, edi
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c2 08 00	 ret	 8
$LN13@append:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00102	56		 push	 esi
  00103	57		 push	 edi
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 _memcpy
  0010a	53		 push	 ebx
  0010b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0010e	ff 75 0c	 push	 DWORD PTR tv449[ebp]
  00111	e8 00 00 00 00	 call	 _memcpy

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00116	8b 45 f8	 mov	 eax, DWORD PTR tv448[ebp]
  00119	c6 00 00	 mov	 BYTE PTR [eax], 0

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0011c	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$1[ebp]
  0011f	50		 push	 eax
  00120	57		 push	 edi
  00121	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00126	83 c4 20	 add	 esp, 32			; 00000020H
  00129	8b c7		 mov	 eax, edi
  0012b	5f		 pop	 edi
  0012c	5e		 pop	 esi
  0012d	5b		 pop	 ebx
  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 08 00	 ret	 8
$LN45@append:

; 4334 :             _Xlen_string(); // result too long

  00134	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN41@append:
  00139	cc		 int	 3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00003	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00006	83 f8 10	 cmp	 eax, 16			; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00009	72 0c		 jb	 SHORT $LN4@basic_stri

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0000b	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000c	50		 push	 eax
  0000d	ff 36		 push	 DWORD PTR [esi]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	83 c4 08	 add	 esp, 8
$LN4@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00017	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0001e	c7 46 14 0f 00
	00 00		 mov	 DWORD PTR [esi+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00025	c6 06 00	 mov	 BYTE PTR [esi], 0
  00028	5e		 pop	 esi

; 2801 :         _Tidy_deallocate();
; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  00029	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2275 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00003	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	ff 75 0c	 push	 DWORD PTR __Format$[ebp]
  0000c	6a ff		 push	 -1
  0000e	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00011	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	ff 70 04	 push	 DWORD PTR [eax+4]
  0001b	83 c9 01	 or	 ecx, 1
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00024	83 c9 ff	 or	 ecx, -1
  00027	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002a	85 c0		 test	 eax, eax
  0002c	0f 48 c1	 cmovs	 eax, ecx

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);
; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);
; 1792 :         return _Result;
; 1793 :     }

  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00000	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00005	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
