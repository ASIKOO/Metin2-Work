; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0CDecal@@QAE@XZ				; CDecal::CDecal
PUBLIC	??1CDecal@@UAE@XZ				; CDecal::~CDecal
PUBLIC	?Clear@CDecal@@QAEXXZ				; CDecal::Clear
PUBLIC	?Render@CDecal@@UAEXXZ				; CDecal::Render
PUBLIC	?deallocate@?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@QAEXQAUTTRIANGLEFANSTRUCT@CDecal@@I@Z ; std::allocator<CDecal::TTRIANGLEFANSTRUCT>::deallocate
PUBLIC	??1?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::~vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
PUBLIC	?clear@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::clear
PUBLIC	?_Destroy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXPAUTTRIANGLEFANSTRUCT@CDecal@@0@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@ABEII@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXQAUTTRIANGLEFANSTRUCT@CDecal@@II@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Change_array
PUBLIC	?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Tidy
PUBLIC	?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
PUBLIC	?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z	; CDecal::AddPolygon
PUBLIC	?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z	; CDecal::ClipMesh
PUBLIC	?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon
PUBLIC	?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
PUBLIC	??_GCDecal@@UAEPAXI@Z				; CDecal::`scalar deleting destructor'
PUBLIC	??$emplace_back@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXABUTTRIANGLEFANSTRUCT@CDecal@@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::emplace_back<CDecal::TTRIANGLEFANSTRUCT const &>
PUBLIC	??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
PUBLIC	??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
PUBLIC	??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
PUBLIC	??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CDecal@@6B@					; CDecal::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CDecal@@6B@				; CDecal::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDecal@@@8				; CDecal `RTTI Type Descriptor'
PUBLIC	??_R3CDecal@@8					; CDecal::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDecal@@8					; CDecal::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDecal@@8				; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@3e800000
PUBLIC	__real@3f800000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_sqrt:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??_ECDecal@@UAEPAXI@Z:PROC			; CDecal::`vector deleting destructor'
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z:PROC ; CStateManager::SetTransform
EXTRN	?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z:PROC ; CStateManager::DrawIndexedPrimitiveUP
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e800000
CONST	SEGMENT
__real@3e800000 DD 03e800000r			; 0.25
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CDecal@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDecal@@8 DD FLAT:??_R0?AVCDecal@@@8	; CDecal::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R2CDecal@@8
rdata$r	SEGMENT
??_R2CDecal@@8 DD FLAT:??_R1A@?0A@EA@CDecal@@8		; CDecal::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDecal@@8
rdata$r	SEGMENT
??_R3CDecal@@8 DD 00H					; CDecal::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDecal@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDecal@@@8
data$rs	SEGMENT
??_R0?AVCDecal@@@8 DD FLAT:??_7type_info@@6B@		; CDecal `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDecal@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDecal@@6B@
rdata$r	SEGMENT
??_R4CDecal@@6B@ DD 00H					; CDecal::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDecal@@@8
	DD	FLAT:??_R3CDecal@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CDecal@@6B@
CONST	SEGMENT
??_7CDecal@@6B@ DD FLAT:??_R4CDecal@@6B@		; CDecal::`vftable'
	DD	FLAT:??_ECDecal@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:?Render@CDecal@@UAEXXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDecal@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CDecal@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDecal@@QAE@XZ$0
__ehfuncinfo$??0CDecal@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDecal@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z PROC ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ENDP ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z PROC ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@PAU12@00@Z ; std::_Copy_memmove<CDecal::TTRIANGLEFANSTRUCT *,CDecal::TTRIANGLEFANSTRUCT *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 04	 sar	 eax, 4
  00032	c1 e0 04	 shl	 eax, 4
  00035	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ENDP ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 04	 sar	 ecx, 4
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 04	 sar	 eax, 4
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 0f		 mov	 DWORD PTR $T22[ebp], 268435455 ; 0fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@ABEII@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$2[ebp], 268435455 ; 0fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 0f		 cmp	 DWORD PTR __Newcapacity$[ebp], 268435455 ; 0fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 04	 shl	 eax, 4
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	c1 e0 04	 shl	 eax, 4
  00113	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00116	8d 44 01 10	 lea	 eax, DWORD PTR [ecx+eax+16]
  0011a	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011d	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00120	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00123	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00127	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012a	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00130	c1 e0 04	 shl	 eax, 4
  00133	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00136	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00139	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013c	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013f	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00142	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00145	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  00148	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  0014b	a5		 movsd
  0014c	a5		 movsd
  0014d	a5		 movsd
  0014e	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014f	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00152	c1 e0 04	 shl	 eax, 4
  00155	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00158	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015b	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015e	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00161	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00163	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00165	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016d	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00170	8b 00		 mov	 eax, DWORD PTR [eax]
  00172	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00175	33 c0		 xor	 eax, eax
  00177	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017a	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017d	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00180	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00183	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00186	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00189	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018c	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00192	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00195	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00198	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  0019d	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a0	eb 61		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a2	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a5	8b 00		 mov	 eax, DWORD PTR [eax]
  001a7	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001aa	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ad	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b0	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b3	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b6	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b9	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bc	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bf	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c2	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  001c7	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001ca	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001cd	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d0	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d3	8b 00		 mov	 eax, DWORD PTR [eax]
  001d5	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d8	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001db	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001de	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e1	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e4	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e7	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001ea	c1 e0 04	 shl	 eax, 4
  001ed	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001f0	8d 44 01 10	 lea	 eax, DWORD PTR [ecx+eax+16]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f4	50		 push	 eax
  001f5	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f8	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fb	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@0PAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Uninitialized_move<CDecal::TTRIANGLEFANSTRUCT *,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  00200	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00203	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00205	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00208	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020b	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXPAUTTRIANGLEFANSTRUCT@CDecal@@0@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00213	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00216	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00219	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021c	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@QAEXQAUTTRIANGLEFANSTRUCT@CDecal@@I@Z ; std::allocator<CDecal::TTRIANGLEFANSTRUCT>::deallocate

; 762  :         _RERAISE;

  00221	6a 00		 push	 0
  00223	6a 00		 push	 0
  00225	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  0022a	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022f	c3		 ret	 0
$LN7@Emplace_re:
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00234	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00236	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  0023a	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023d	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  00240	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00243	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00246	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXQAUTTRIANGLEFANSTRUCT@CDecal@@II@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024b	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0024e	c1 e0 04	 shl	 eax, 4
  00251	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00254	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00257	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025e	59		 pop	 ecx
  0025f	5f		 pop	 edi
  00260	5e		 pop	 esi
  00261	5b		 pop	 ebx
  00262	83 c5 70	 add	 ebp, 112		; 00000070H
  00265	c9		 leave
  00266	c2 08 00	 ret	 8
  00269	cc		 int	 3
  0026a	cc		 int	 3
  0026b	cc		 int	 3
  0026c	cc		 int	 3
  0026d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXABUTTRIANGLEFANSTRUCT@CDecal@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXABUTTRIANGLEFANSTRUCT@CDecal@@@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::emplace_back<CDecal::TTRIANGLEFANSTRUCT const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 62		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006b	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  0006e	a5		 movsd
  0006f	a5		 movsd
  00070	a5		 movsd
  00071	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00072	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	83 c0 10	 add	 eax, 16			; 00000010H
  00082	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00085	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00087	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00089	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008c	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0008f	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00092	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	ff 30		 push	 DWORD PTR [eax]
  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEPAUTTRIANGLEFANSTRUCT@CDecal@@QAU23@ABU23@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Emplace_reallocate<CDecal::TTRIANGLEFANSTRUCT const &>
  0009f	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	c9		 leave
  000a5	c2 04 00	 ret	 4
??$emplace_back@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXABUTTRIANGLEFANSTRUCT@CDecal@@@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::emplace_back<CDecal::TTRIANGLEFANSTRUCT const &>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCDecal@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDecal@@UAEPAXI@Z PROC				; CDecal::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDecal@@UAE@XZ	; CDecal::~CDecal
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 94 1a 00 00	 push	 6804			; 00001a94H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCDecal@@UAEPAXI@Z ENDP				; CDecal::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z
_TEXT	SEGMENT
_fx$ = -300						; size = 4
_fy$ = -296						; size = 4
_fz$ = -292						; size = 4
_fx$ = -288						; size = 4
_fy$ = -284						; size = 4
_fz$ = -280						; size = 4
_fx$ = -276						; size = 4
_fy$ = -272						; size = 4
_fz$ = -268						; size = 4
_fy$ = -264						; size = 4
_fx$ = -260						; size = 4
_fy$ = -256						; size = 4
_fz$ = -252						; size = 4
_fz$ = -248						; size = 4
_fy$ = -244						; size = 4
_fx$ = -240						; size = 4
_fz$ = -236						; size = 4
_fy$ = -232						; size = 4
_fx$ = -228						; size = 4
_fz$ = -224						; size = 4
_fy$ = -220						; size = 4
_fx$ = -216						; size = 4
_fz$ = -212						; size = 4
_fy$ = -208						; size = 4
_fx$ = -204						; size = 4
_fz$ = -200						; size = 4
_fy$ = -196						; size = 4
_fx$ = -192						; size = 4
_fz$ = -188						; size = 4
_fy$ = -184						; size = 4
_fx$ = -180						; size = 4
_fz$ = -176						; size = 4
_fy$ = -172						; size = 4
_fx$ = -168						; size = 4
_fz$ = -164						; size = 4
_fx$ = -160						; size = 4
tv84 = -156						; size = 4
tv72 = -152						; size = 4
_f$ = -148						; size = 4
_v3_n1$1 = -144						; size = 4
_v3_n2$2 = -140						; size = 4
_f$ = -136						; size = 4
_f$ = -132						; size = 4
_v3_n1$3 = -128						; size = 4
_v3_n2$4 = -124						; size = 4
_f$ = -120						; size = 4
_dwNegativeCount$ = -116				; size = 4
_pV$ = -112						; size = 4
_dwi$5 = -108						; size = 4
_dwPrevIndex$6 = -104					; size = 4
_v3_2$7 = -100						; size = 4
_v3_2$8 = -96						; size = 4
_ft$9 = -92						; size = 4
_ft$10 = -88						; size = 4
_v3_1$11 = -84						; size = 4
_v3_1$12 = -80						; size = 4
_bNeg$13 = -73						; size = 1
_dwCurIndex$14 = -72					; size = 4
_dwCount$ = -68						; size = 4
$T15 = -64						; size = 12
$T16 = -52						; size = 12
$T17 = -40						; size = 12
$T18 = -28						; size = 12
$T19 = -16						; size = 12
$T20 = -4						; size = 12
$T21 = 8						; size = 12
$T22 = 20						; size = 12
$T23 = 32						; size = 12
$T24 = 44						; size = 12
$T25 = 56						; size = 12
$T26 = 68						; size = 12
_bNegative$ = 80					; size = 10
__$ArrayPad$ = 92					; size = 4
_c_rv4Plane$ = 104					; size = 4
_dwVertexCount$ = 108					; size = 4
_c_pv3Vertex$ = 112					; size = 4
_c_pv3Normal$ = 116					; size = 4
_c_pv3NewVertex$ = 120					; size = 4
_c_pv3NewNormal$ = 124					; size = 4
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z PROC ; CDecal::ClipPolygonAgainstPlane, COMDAT

; 151  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 a0	 lea	 ebp, DWORD PTR [esp-96]
  00005	81 ec 8c 01 00
	00		 sub	 esp, 396		; 0000018cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 5c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi

; 152  : 	bool bNegative[10];
; 153  : 	
; 154  : 	// Classify vertices
; 155  : 	DWORD dwNegativeCount = 0;

  00017	83 65 8c 00	 and	 DWORD PTR _dwNegativeCount$[ebp], 0

; 156  : 	for (DWORD dwi = 0; dwi < dwVertexCount; ++dwi)

  0001b	83 65 94 00	 and	 DWORD PTR _dwi$5[ebp], 0
  0001f	eb 07		 jmp	 SHORT $LN4@ClipPolygo
$LN2@ClipPolygo:
  00021	8b 45 94	 mov	 eax, DWORD PTR _dwi$5[ebp]
  00024	40		 inc	 eax
  00025	89 45 94	 mov	 DWORD PTR _dwi$5[ebp], eax
$LN4@ClipPolygo:
  00028	8b 45 94	 mov	 eax, DWORD PTR _dwi$5[ebp]
  0002b	3b 45 6c	 cmp	 eax, DWORD PTR _dwVertexCount$[ebp]
  0002e	0f 83 85 00 00
	00		 jae	 $LN3@ClipPolygo

; 158  : 		bool bNeg = (D3DXPlaneDotCoord(&c_rv4Plane, &c_pv3Vertex[dwi]) < 0.0F);

  00034	6b 45 94 0c	 imul	 eax, DWORD PTR _dwi$5[ebp], 12
  00038	03 45 70	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  0003b	89 45 90	 mov	 DWORD PTR _pV$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0003e	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00041	8b 4d 90	 mov	 ecx, DWORD PTR _pV$[ebp]
  00044	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00049	f3 0f 59 41 08	 mulss	 xmm0, DWORD PTR [ecx+8]
  0004e	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00051	8b 4d 90	 mov	 ecx, DWORD PTR _pV$[ebp]
  00054	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  00059	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [ecx+4]
  0005e	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00061	8b 4d 90	 mov	 ecx, DWORD PTR _pV$[ebp]
  00064	f3 0f 10 10	 movss	 xmm2, DWORD PTR [eax]
  00068	f3 0f 59 11	 mulss	 xmm2, DWORD PTR [ecx]
  0006c	f3 0f 58 d1	 addss	 xmm2, xmm1
  00070	f3 0f 58 d0	 addss	 xmm2, xmm0
  00074	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00077	f3 0f 58 50 0c	 addss	 xmm2, DWORD PTR [eax+12]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 158  : 		bool bNeg = (D3DXPlaneDotCoord(&c_rv4Plane, &c_pv3Vertex[dwi]) < 0.0F);

  0007c	0f 57 c0	 xorps	 xmm0, xmm0
  0007f	0f 2f c2	 comiss	 xmm0, xmm2
  00082	76 0c		 jbe	 SHORT $LN14@ClipPolygo
  00084	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv72[ebp], 1
  0008e	eb 07		 jmp	 SHORT $LN15@ClipPolygo
$LN14@ClipPolygo:
  00090	83 a5 68 ff ff
	ff 00		 and	 DWORD PTR tv72[ebp], 0
$LN15@ClipPolygo:
  00097	8a 85 68 ff ff
	ff		 mov	 al, BYTE PTR tv72[ebp]
  0009d	88 45 b7	 mov	 BYTE PTR _bNeg$13[ebp], al

; 159  : 		bNegative[dwi] = bNeg;

  000a0	8b 45 94	 mov	 eax, DWORD PTR _dwi$5[ebp]
  000a3	8a 4d b7	 mov	 cl, BYTE PTR _bNeg$13[ebp]
  000a6	88 4c 05 50	 mov	 BYTE PTR _bNegative$[ebp+eax], cl

; 160  : 		dwNegativeCount += bNeg;

  000aa	0f b6 45 b7	 movzx	 eax, BYTE PTR _bNeg$13[ebp]
  000ae	03 45 8c	 add	 eax, DWORD PTR _dwNegativeCount$[ebp]
  000b1	89 45 8c	 mov	 DWORD PTR _dwNegativeCount$[ebp], eax

; 161  : 	}

  000b4	e9 68 ff ff ff	 jmp	 $LN2@ClipPolygo
$LN3@ClipPolygo:

; 162  : 	
; 163  : 	// Discard this polygon if it's completely culled
; 164  : 	if (dwNegativeCount == dwVertexCount)

  000b9	8b 45 8c	 mov	 eax, DWORD PTR _dwNegativeCount$[ebp]
  000bc	3b 45 6c	 cmp	 eax, DWORD PTR _dwVertexCount$[ebp]
  000bf	75 07		 jne	 SHORT $LN8@ClipPolygo

; 165  : 		return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	e9 82 07 00 00	 jmp	 $LN1@ClipPolygo
$LN8@ClipPolygo:

; 166  : 	
; 167  : 	DWORD dwCount = 0;

  000c8	83 65 bc 00	 and	 DWORD PTR _dwCount$[ebp], 0

; 168  : 	for (DWORD dwCurIndex = 0; dwCurIndex < dwVertexCount; ++dwCurIndex)

  000cc	83 65 b8 00	 and	 DWORD PTR _dwCurIndex$14[ebp], 0
  000d0	eb 07		 jmp	 SHORT $LN7@ClipPolygo
$LN5@ClipPolygo:
  000d2	8b 45 b8	 mov	 eax, DWORD PTR _dwCurIndex$14[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 b8	 mov	 DWORD PTR _dwCurIndex$14[ebp], eax
$LN7@ClipPolygo:
  000d9	8b 45 b8	 mov	 eax, DWORD PTR _dwCurIndex$14[ebp]
  000dc	3b 45 6c	 cmp	 eax, DWORD PTR _dwVertexCount$[ebp]
  000df	0f 83 62 07 00
	00		 jae	 $LN6@ClipPolygo

; 169  : 	{
; 170  : 		// dwPrevIndex is the index of the previous vertex
; 171  : 		DWORD dwPrevIndex = (dwCurIndex != 0) ? dwCurIndex - 1 : dwVertexCount - 1;

  000e5	83 7d b8 00	 cmp	 DWORD PTR _dwCurIndex$14[ebp], 0
  000e9	74 0c		 je	 SHORT $LN16@ClipPolygo
  000eb	8b 45 b8	 mov	 eax, DWORD PTR _dwCurIndex$14[ebp]
  000ee	48		 dec	 eax
  000ef	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  000f5	eb 0a		 jmp	 SHORT $LN17@ClipPolygo
$LN16@ClipPolygo:
  000f7	8b 45 6c	 mov	 eax, DWORD PTR _dwVertexCount$[ebp]
  000fa	48		 dec	 eax
  000fb	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
$LN17@ClipPolygo:
  00101	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv84[ebp]
  00107	89 45 98	 mov	 DWORD PTR _dwPrevIndex$6[ebp], eax

; 172  : 		
; 173  : 		if (bNegative[dwCurIndex])

  0010a	8b 45 b8	 mov	 eax, DWORD PTR _dwCurIndex$14[ebp]
  0010d	0f b6 44 05 50	 movzx	 eax, BYTE PTR _bNegative$[ebp+eax]
  00112	85 c0		 test	 eax, eax
  00114	0f 84 70 03 00
	00		 je	 $LN9@ClipPolygo

; 174  : 		{
; 175  : 			if (!bNegative[dwPrevIndex])

  0011a	8b 45 98	 mov	 eax, DWORD PTR _dwPrevIndex$6[ebp]
  0011d	0f b6 44 05 50	 movzx	 eax, BYTE PTR _bNegative$[ebp+eax]
  00122	85 c0		 test	 eax, eax
  00124	0f 85 5b 03 00
	00		 jne	 $LN11@ClipPolygo

; 176  : 			{
; 177  : 				// Current vertex is on negative side of plane,
; 178  : 				// but previous vertex is on positive side.
; 179  : 				const D3DXVECTOR3& v3_1 = c_pv3Vertex[dwPrevIndex];

  0012a	6b 45 98 0c	 imul	 eax, DWORD PTR _dwPrevIndex$6[ebp], 12
  0012e	03 45 70	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  00131	89 45 b0	 mov	 DWORD PTR _v3_1$12[ebp], eax

; 180  : 				const D3DXVECTOR3& v3_2 = c_pv3Vertex[dwCurIndex];

  00134	6b 45 b8 0c	 imul	 eax, DWORD PTR _dwCurIndex$14[ebp], 12
  00138	03 45 70	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  0013b	89 45 a0	 mov	 DWORD PTR _v3_2$8[ebp], eax

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  0013e	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  00141	8b 4d a0	 mov	 ecx, DWORD PTR _v3_2$8[ebp]
  00144	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00148	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0014c	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  0014f	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00153	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  00156	8b 4d a0	 mov	 ecx, DWORD PTR _v3_2$8[ebp]
  00159	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0015e	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  00163	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00166	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  0016b	f3 0f 58 c1	 addss	 xmm0, xmm1
  0016f	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  00172	8b 4d a0	 mov	 ecx, DWORD PTR _v3_2$8[ebp]
  00175	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  0017a	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  0017f	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00182	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  00187	f3 0f 58 c1	 addss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  0018b	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  0018e	8b 4d b0	 mov	 ecx, DWORD PTR _v3_1$12[ebp]
  00191	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00196	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  0019b	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  0019e	8b 4d b0	 mov	 ecx, DWORD PTR _v3_1$12[ebp]
  001a1	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  001a6	f3 0f 59 51 04	 mulss	 xmm2, DWORD PTR [ecx+4]
  001ab	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  001ae	8b 4d b0	 mov	 ecx, DWORD PTR _v3_1$12[ebp]
  001b1	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  001b5	f3 0f 59 19	 mulss	 xmm3, DWORD PTR [ecx]
  001b9	f3 0f 58 da	 addss	 xmm3, xmm2
  001bd	f3 0f 58 d9	 addss	 xmm3, xmm1
  001c1	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  001c4	f3 0f 58 58 0c	 addss	 xmm3, DWORD PTR [eax+12]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 181  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  001c9	f3 0f 5e d8	 divss	 xmm3, xmm0
  001cd	f3 0f 11 5d a8	 movss	 DWORD PTR _ft$10[ebp], xmm3
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  001d2	8b 45 a0	 mov	 eax, DWORD PTR _v3_2$8[ebp]
  001d5	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001d9	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  001de	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  001e6	8b 45 a0	 mov	 eax, DWORD PTR _v3_2$8[ebp]
  001e9	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001ee	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  001f3	f3 0f 11 85 d8
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  001fb	8b 45 a0	 mov	 eax, DWORD PTR _v3_2$8[ebp]
  001fe	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00203	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  00208	f3 0f 11 85 dc
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00210	f3 0f 10 85 60
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00218	f3 0f 11 45 44	 movss	 DWORD PTR $T26[ebp], xmm0

; 181  :     y = fy;

  0021d	f3 0f 10 85 d8
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00225	f3 0f 11 45 48	 movss	 DWORD PTR $T26[ebp+4], xmm0

; 182  :     z = fz;

  0022a	f3 0f 10 85 dc
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00232	f3 0f 11 45 4c	 movss	 DWORD PTR $T26[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 182  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00237	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0023f	f3 0f 5c 45 a8	 subss	 xmm0, DWORD PTR _ft$10[ebp]
  00244	f3 0f 11 45 88	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00249	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  0024c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00250	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00255	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0025d	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  00260	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00265	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _f$[ebp]
  0026a	f3 0f 11 85 e4
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00272	8b 45 b0	 mov	 eax, DWORD PTR _v3_1$12[ebp]
  00275	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0027a	f3 0f 59 45 88	 mulss	 xmm0, DWORD PTR _f$[ebp]
  0027f	f3 0f 11 85 e8
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00287	f3 0f 10 85 e0
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0028f	f3 0f 11 45 38	 movss	 DWORD PTR $T25[ebp], xmm0

; 181  :     y = fy;

  00294	f3 0f 10 85 e4
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0029c	f3 0f 11 45 3c	 movss	 DWORD PTR $T25[ebp+4], xmm0

; 182  :     z = fz;

  002a1	f3 0f 10 85 e8
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002a9	f3 0f 11 45 40	 movss	 DWORD PTR $T25[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  002ae	f3 0f 10 45 38	 movss	 xmm0, DWORD PTR $T25[ebp]
  002b3	f3 0f 58 45 44	 addss	 xmm0, DWORD PTR $T26[ebp]
  002b8	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  002c0	f3 0f 10 45 3c	 movss	 xmm0, DWORD PTR $T25[ebp+4]
  002c5	f3 0f 58 45 48	 addss	 xmm0, DWORD PTR $T26[ebp+4]
  002ca	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  002d2	f3 0f 10 45 40	 movss	 xmm0, DWORD PTR $T25[ebp+8]
  002d7	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR $T26[ebp+8]
  002dc	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002e4	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002ec	f3 0f 11 45 c0	 movss	 DWORD PTR $T15[ebp], xmm0

; 181  :     y = fy;

  002f1	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002f9	f3 0f 11 45 c4	 movss	 DWORD PTR $T15[ebp+4], xmm0

; 182  :     z = fz;

  002fe	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00306	f3 0f 11 45 c8	 movss	 DWORD PTR $T15[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 182  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  0030b	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  0030f	03 7d 78	 add	 edi, DWORD PTR _c_pv3NewVertex$[ebp]
  00312	8d 75 c0	 lea	 esi, DWORD PTR $T15[ebp]
  00315	a5		 movsd
  00316	a5		 movsd
  00317	a5		 movsd

; 183  : 				const D3DXVECTOR3& v3_n1 = c_pv3Normal[dwPrevIndex];

  00318	6b 45 98 0c	 imul	 eax, DWORD PTR _dwPrevIndex$6[ebp], 12
  0031c	03 45 74	 add	 eax, DWORD PTR _c_pv3Normal$[ebp]
  0031f	89 45 80	 mov	 DWORD PTR _v3_n1$3[ebp], eax

; 184  : 				const D3DXVECTOR3& v3_n2 = c_pv3Normal[dwCurIndex];

  00322	6b 45 b8 0c	 imul	 eax, DWORD PTR _dwCurIndex$14[ebp], 12
  00326	03 45 74	 add	 eax, DWORD PTR _c_pv3Normal$[ebp]
  00329	89 45 84	 mov	 DWORD PTR _v3_n2$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  0032c	8b 45 84	 mov	 eax, DWORD PTR _v3_n2$4[ebp]
  0032f	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00333	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  00338	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00340	8b 45 84	 mov	 eax, DWORD PTR _v3_n2$4[ebp]
  00343	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00348	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  0034d	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00355	8b 45 84	 mov	 eax, DWORD PTR _v3_n2$4[ebp]
  00358	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0035d	f3 0f 59 45 a8	 mulss	 xmm0, DWORD PTR _ft$10[ebp]
  00362	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0036a	f3 0f 10 85 fc
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00372	f3 0f 11 45 f0	 movss	 DWORD PTR $T19[ebp], xmm0

; 181  :     y = fy;

  00377	f3 0f 10 85 00
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0037f	f3 0f 11 45 f4	 movss	 DWORD PTR $T19[ebp+4], xmm0

; 182  :     z = fz;

  00384	f3 0f 10 85 04
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0038c	f3 0f 11 45 f8	 movss	 DWORD PTR $T19[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00391	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00399	f3 0f 5c 45 a8	 subss	 xmm0, DWORD PTR _ft$10[ebp]
  0039e	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  003a6	8b 45 80	 mov	 eax, DWORD PTR _v3_n1$3[ebp]
  003a9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003ad	f3 0f 59 85 7c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  003b5	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  003bd	8b 45 80	 mov	 eax, DWORD PTR _v3_n1$3[ebp]
  003c0	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  003c5	f3 0f 59 85 7c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  003cd	f3 0f 11 85 f8
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  003d5	8b 45 80	 mov	 eax, DWORD PTR _v3_n1$3[ebp]
  003d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  003dd	f3 0f 59 85 7c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  003e5	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  003ed	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003f5	f3 0f 11 45 2c	 movss	 DWORD PTR $T24[ebp], xmm0

; 181  :     y = fy;

  003fa	f3 0f 10 85 f8
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00402	f3 0f 11 45 30	 movss	 DWORD PTR $T24[ebp+4], xmm0

; 182  :     z = fz;

  00407	f3 0f 10 85 5c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0040f	f3 0f 11 45 34	 movss	 DWORD PTR $T24[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00414	f3 0f 10 45 2c	 movss	 xmm0, DWORD PTR $T24[ebp]
  00419	f3 0f 58 45 f0	 addss	 xmm0, DWORD PTR $T19[ebp]
  0041e	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00426	f3 0f 10 45 30	 movss	 xmm0, DWORD PTR $T24[ebp+4]
  0042b	f3 0f 58 45 f4	 addss	 xmm0, DWORD PTR $T19[ebp+4]
  00430	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00438	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR $T24[ebp+8]
  0043d	f3 0f 58 45 f8	 addss	 xmm0, DWORD PTR $T19[ebp+8]
  00442	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0044a	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00452	f3 0f 11 45 cc	 movss	 DWORD PTR $T16[ebp], xmm0

; 181  :     y = fy;

  00457	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0045f	f3 0f 11 45 d0	 movss	 DWORD PTR $T16[ebp+4], xmm0

; 182  :     z = fz;

  00464	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0046c	f3 0f 11 45 d4	 movss	 DWORD PTR $T16[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 185  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00471	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  00475	03 7d 7c	 add	 edi, DWORD PTR _c_pv3NewNormal$[ebp]
  00478	8d 75 cc	 lea	 esi, DWORD PTR $T16[ebp]
  0047b	a5		 movsd
  0047c	a5		 movsd
  0047d	a5		 movsd

; 186  : 				++dwCount;

  0047e	8b 45 bc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00481	40		 inc	 eax
  00482	89 45 bc	 mov	 DWORD PTR _dwCount$[ebp], eax
$LN11@ClipPolygo:

; 187  : 			}
; 188  : 		}

  00485	e9 b8 03 00 00	 jmp	 $LN10@ClipPolygo
$LN9@ClipPolygo:

; 189  : 		else
; 190  : 		{
; 191  : 			if (bNegative[dwPrevIndex])

  0048a	8b 45 98	 mov	 eax, DWORD PTR _dwPrevIndex$6[ebp]
  0048d	0f b6 44 05 50	 movzx	 eax, BYTE PTR _bNegative$[ebp+eax]
  00492	85 c0		 test	 eax, eax
  00494	0f 84 7f 03 00
	00		 je	 $LN12@ClipPolygo

; 192  : 			{
; 193  : 				// Current vertex is on positive side of plane,
; 194  : 				// but previous vertex is on negative side.
; 195  : 				const D3DXVECTOR3& v3_1 = c_pv3Vertex[dwCurIndex];

  0049a	6b 45 b8 0c	 imul	 eax, DWORD PTR _dwCurIndex$14[ebp], 12
  0049e	03 45 70	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  004a1	89 45 ac	 mov	 DWORD PTR _v3_1$11[ebp], eax

; 196  : 				const D3DXVECTOR3& v3_2 = c_pv3Vertex[dwPrevIndex];

  004a4	6b 45 98 0c	 imul	 eax, DWORD PTR _dwPrevIndex$6[ebp], 12
  004a8	03 45 70	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  004ab	89 45 9c	 mov	 DWORD PTR _v3_2$7[ebp], eax

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  004ae	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  004b1	8b 4d 9c	 mov	 ecx, DWORD PTR _v3_2$7[ebp]
  004b4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004b8	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  004bc	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  004bf	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  004c3	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  004c6	8b 4d 9c	 mov	 ecx, DWORD PTR _v3_2$7[ebp]
  004c9	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  004ce	f3 0f 5c 49 04	 subss	 xmm1, DWORD PTR [ecx+4]
  004d3	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  004d6	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  004db	f3 0f 58 c1	 addss	 xmm0, xmm1
  004df	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  004e2	8b 4d 9c	 mov	 ecx, DWORD PTR _v3_2$7[ebp]
  004e5	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  004ea	f3 0f 5c 49 08	 subss	 xmm1, DWORD PTR [ecx+8]
  004ef	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  004f2	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  004f7	f3 0f 58 c1	 addss	 xmm0, xmm1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1647 :     return pP->a * pV->x + pP->b * pV->y + pP->c * pV->z + pP->d;

  004fb	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  004fe	8b 4d ac	 mov	 ecx, DWORD PTR _v3_1$11[ebp]
  00501	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  00506	f3 0f 59 49 08	 mulss	 xmm1, DWORD PTR [ecx+8]
  0050b	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  0050e	8b 4d ac	 mov	 ecx, DWORD PTR _v3_1$11[ebp]
  00511	f3 0f 10 50 04	 movss	 xmm2, DWORD PTR [eax+4]
  00516	f3 0f 59 51 04	 mulss	 xmm2, DWORD PTR [ecx+4]
  0051b	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  0051e	8b 4d ac	 mov	 ecx, DWORD PTR _v3_1$11[ebp]
  00521	f3 0f 10 18	 movss	 xmm3, DWORD PTR [eax]
  00525	f3 0f 59 19	 mulss	 xmm3, DWORD PTR [ecx]
  00529	f3 0f 58 da	 addss	 xmm3, xmm2
  0052d	f3 0f 58 d9	 addss	 xmm3, xmm1
  00531	8b 45 68	 mov	 eax, DWORD PTR _c_rv4Plane$[ebp]
  00534	f3 0f 58 58 0c	 addss	 xmm3, DWORD PTR [eax+12]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 197  : 				float ft = D3DXPlaneDotCoord(&c_rv4Plane, &v3_1) / (c_rv4Plane.a * (v3_1.x - v3_2.x) + c_rv4Plane.b * (v3_1.y - v3_2.y) + c_rv4Plane.c * (v3_1.z - v3_2.z));

  00539	f3 0f 5e d8	 divss	 xmm3, xmm0
  0053d	f3 0f 11 5d a4	 movss	 DWORD PTR _ft$9[ebp], xmm3
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00542	8b 45 9c	 mov	 eax, DWORD PTR _v3_2$7[ebp]
  00545	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00549	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  0054e	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00556	8b 45 9c	 mov	 eax, DWORD PTR _v3_2$7[ebp]
  00559	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0055e	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  00563	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0056b	8b 45 9c	 mov	 eax, DWORD PTR _v3_2$7[ebp]
  0056e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00573	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  00578	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00580	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00588	f3 0f 11 45 08	 movss	 DWORD PTR $T21[ebp], xmm0

; 181  :     y = fy;

  0058d	f3 0f 10 85 48
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00595	f3 0f 11 45 0c	 movss	 DWORD PTR $T21[ebp+4], xmm0

; 182  :     z = fz;

  0059a	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  005a2	f3 0f 11 45 10	 movss	 DWORD PTR $T21[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 198  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  005a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005af	f3 0f 5c 45 a4	 subss	 xmm0, DWORD PTR _ft$9[ebp]
  005b4	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  005bc	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  005bf	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  005c3	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  005cb	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  005d3	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  005d6	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005db	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  005e3	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  005eb	8b 45 ac	 mov	 eax, DWORD PTR _v3_1$11[ebp]
  005ee	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  005f3	f3 0f 59 85 78
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  005fb	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00603	f3 0f 10 85 40
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0060b	f3 0f 11 45 fc	 movss	 DWORD PTR $T20[ebp], xmm0

; 181  :     y = fy;

  00610	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00618	f3 0f 11 45 00	 movss	 DWORD PTR $T20[ebp+4], xmm0

; 182  :     z = fz;

  0061d	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00625	f3 0f 11 45 04	 movss	 DWORD PTR $T20[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0062a	f3 0f 10 45 fc	 movss	 xmm0, DWORD PTR $T20[ebp]
  0062f	f3 0f 58 45 08	 addss	 xmm0, DWORD PTR $T21[ebp]
  00634	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0063c	f3 0f 10 45 00	 movss	 xmm0, DWORD PTR $T20[ebp+4]
  00641	f3 0f 58 45 0c	 addss	 xmm0, DWORD PTR $T21[ebp+4]
  00646	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0064e	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR $T20[ebp+8]
  00653	f3 0f 58 45 10	 addss	 xmm0, DWORD PTR $T21[ebp+8]
  00658	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00660	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00668	f3 0f 11 45 d8	 movss	 DWORD PTR $T17[ebp], xmm0

; 181  :     y = fy;

  0066d	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00675	f3 0f 11 45 dc	 movss	 DWORD PTR $T17[ebp+4], xmm0

; 182  :     z = fz;

  0067a	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00682	f3 0f 11 45 e0	 movss	 DWORD PTR $T17[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 198  :  				c_pv3NewVertex[dwCount] = v3_1 * (1.0f - ft) + v3_2 * ft;

  00687	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  0068b	03 7d 78	 add	 edi, DWORD PTR _c_pv3NewVertex$[ebp]
  0068e	8d 75 d8	 lea	 esi, DWORD PTR $T17[ebp]
  00691	a5		 movsd
  00692	a5		 movsd
  00693	a5		 movsd

; 199  : 				const D3DXVECTOR3& v3_n1 = c_pv3Normal[dwCurIndex];

  00694	6b 45 b8 0c	 imul	 eax, DWORD PTR _dwCurIndex$14[ebp], 12
  00698	03 45 74	 add	 eax, DWORD PTR _c_pv3Normal$[ebp]
  0069b	89 85 70 ff ff
	ff		 mov	 DWORD PTR _v3_n1$1[ebp], eax

; 200  : 				const D3DXVECTOR3& v3_n2 = c_pv3Normal[dwPrevIndex];

  006a1	6b 45 98 0c	 imul	 eax, DWORD PTR _dwPrevIndex$6[ebp], 12
  006a5	03 45 74	 add	 eax, DWORD PTR _c_pv3Normal$[ebp]
  006a8	89 85 74 ff ff
	ff		 mov	 DWORD PTR _v3_n2$2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  006ae	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n2$2[ebp]
  006b4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006b8	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  006bd	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  006c5	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n2$2[ebp]
  006cb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  006d0	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  006d5	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  006dd	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n2$2[ebp]
  006e3	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  006e8	f3 0f 59 45 a4	 mulss	 xmm0, DWORD PTR _ft$9[ebp]
  006ed	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  006f5	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  006fd	f3 0f 11 45 20	 movss	 DWORD PTR $T23[ebp], xmm0

; 181  :     y = fy;

  00702	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0070a	f3 0f 11 45 24	 movss	 DWORD PTR $T23[ebp+4], xmm0

; 182  :     z = fz;

  0070f	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00717	f3 0f 11 45 28	 movss	 DWORD PTR $T23[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  0071c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00724	f3 0f 5c 45 a4	 subss	 xmm0, DWORD PTR _ft$9[ebp]
  00729	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 269  :     return D3DXVECTOR3(x * f, y * f, z * f);

  00731	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n1$1[ebp]
  00737	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0073b	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00743	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0074b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n1$1[ebp]
  00751	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00756	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  0075e	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00766	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _v3_n1$1[ebp]
  0076c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00771	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR _f$[ebp]
  00779	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00781	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00789	f3 0f 11 45 14	 movss	 DWORD PTR $T22[ebp], xmm0

; 181  :     y = fy;

  0078e	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00796	f3 0f 11 45 18	 movss	 DWORD PTR $T22[ebp+4], xmm0

; 182  :     z = fz;

  0079b	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  007a3	f3 0f 11 45 1c	 movss	 DWORD PTR $T22[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  007a8	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR $T22[ebp]
  007ad	f3 0f 58 45 20	 addss	 xmm0, DWORD PTR $T23[ebp]
  007b2	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  007ba	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR $T22[ebp+4]
  007bf	f3 0f 58 45 24	 addss	 xmm0, DWORD PTR $T23[ebp+4]
  007c4	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  007cc	f3 0f 10 45 1c	 movss	 xmm0, DWORD PTR $T22[ebp+8]
  007d1	f3 0f 58 45 28	 addss	 xmm0, DWORD PTR $T23[ebp+8]
  007d6	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  007de	f3 0f 10 85 10
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  007e6	f3 0f 11 45 e4	 movss	 DWORD PTR $T18[ebp], xmm0

; 181  :     y = fy;

  007eb	f3 0f 10 85 0c
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  007f3	f3 0f 11 45 e8	 movss	 DWORD PTR $T18[ebp+4], xmm0

; 182  :     z = fz;

  007f8	f3 0f 10 85 08
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00800	f3 0f 11 45 ec	 movss	 DWORD PTR $T18[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 201  :  				c_pv3NewNormal[dwCount] = v3_n1 * (1.0f - ft) + v3_n2 * ft;

  00805	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  00809	03 7d 7c	 add	 edi, DWORD PTR _c_pv3NewNormal$[ebp]
  0080c	8d 75 e4	 lea	 esi, DWORD PTR $T18[ebp]
  0080f	a5		 movsd
  00810	a5		 movsd
  00811	a5		 movsd

; 202  : 				++dwCount;

  00812	8b 45 bc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  00815	40		 inc	 eax
  00816	89 45 bc	 mov	 DWORD PTR _dwCount$[ebp], eax
$LN12@ClipPolygo:

; 203  : 			}
; 204  : 			
; 205  : 			// Include current vertex
; 206  :  			c_pv3NewVertex[dwCount] = c_pv3Vertex[dwCurIndex];

  00819	6b 75 b8 0c	 imul	 esi, DWORD PTR _dwCurIndex$14[ebp], 12
  0081d	03 75 70	 add	 esi, DWORD PTR _c_pv3Vertex$[ebp]
  00820	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  00824	03 7d 78	 add	 edi, DWORD PTR _c_pv3NewVertex$[ebp]
  00827	a5		 movsd
  00828	a5		 movsd
  00829	a5		 movsd

; 207  :  			c_pv3NewNormal[dwCount] = c_pv3Normal[dwCurIndex];

  0082a	6b 75 b8 0c	 imul	 esi, DWORD PTR _dwCurIndex$14[ebp], 12
  0082e	03 75 74	 add	 esi, DWORD PTR _c_pv3Normal$[ebp]
  00831	6b 7d bc 0c	 imul	 edi, DWORD PTR _dwCount$[ebp], 12
  00835	03 7d 7c	 add	 edi, DWORD PTR _c_pv3NewNormal$[ebp]
  00838	a5		 movsd
  00839	a5		 movsd
  0083a	a5		 movsd

; 208  : 			++dwCount;

  0083b	8b 45 bc	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0083e	40		 inc	 eax
  0083f	89 45 bc	 mov	 DWORD PTR _dwCount$[ebp], eax
$LN10@ClipPolygo:

; 209  : 		}
; 210  : 	}

  00842	e9 8b f8 ff ff	 jmp	 $LN5@ClipPolygo
$LN6@ClipPolygo:

; 211  : 	
; 212  : 	// Return number of vertices in clipped polygon
; 213  : 	return dwCount;

  00847	8b 45 bc	 mov	 eax, DWORD PTR _dwCount$[ebp]
$LN1@ClipPolygo:

; 214  : }

  0084a	5f		 pop	 edi
  0084b	5e		 pop	 esi
  0084c	8b 4d 5c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0084f	33 cd		 xor	 ecx, ebp
  00851	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00856	83 c5 60	 add	 ebp, 96			; 00000060H
  00859	c9		 leave
  0085a	c3		 ret	 0
?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ENDP ; CDecal::ClipPolygonAgainstPlane
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z
_TEXT	SEGMENT
tv66 = -152						; size = 4
tv159 = -148						; size = 4
___t$ = -144						; size = 4
___t$ = -140						; size = 4
___n$ = -136						; size = 4
___n$ = -132						; size = 4
_this$ = -128						; size = 4
_dwCount$ = -124					; size = 4
_v3TempVertex$ = -120					; size = 108
_v3TempNormal$ = -12					; size = 108
__$ArrayPad$ = 96					; size = 4
_dwVertexCount$ = 108					; size = 4
_c_pv3Vertex$ = 112					; size = 4
_c_pv3Normal$ = 116					; size = 4
_c_pv3NewVertex$ = 120					; size = 4
_c_pv3NewNormal$ = 124					; size = 4
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z PROC ; CDecal::ClipPolygon, COMDAT
; _this$ = ecx

; 116  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 9c	 lea	 ebp, DWORD PTR [esp-100]
  00005	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 60	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 117  : 	D3DXVECTOR3		v3TempVertex[9];

  00018	c7 85 7c ff ff
	ff 09 00 00 00	 mov	 DWORD PTR ___n$[ebp], 9
  00022	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  00025	89 85 74 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN9@ClipPolygo:
  0002b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00031	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv159[ebp], eax
  00037	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  0003d	48		 dec	 eax
  0003e	89 85 7c ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  00044	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR tv159[ebp], 0
  0004b	76 11		 jbe	 SHORT $LN8@ClipPolygo
  0004d	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  00053	83 c0 0c	 add	 eax, 12			; 0000000cH
  00056	89 85 74 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  0005c	eb cd		 jmp	 SHORT $LN9@ClipPolygo
$LN8@ClipPolygo:

; 118  : 	D3DXVECTOR3		v3TempNormal[9];

  0005e	c7 85 78 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR ___n$[ebp], 9
  00068	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  0006b	89 85 70 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN15@ClipPolygo:
  00071	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00077	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  0007d	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00083	48		 dec	 eax
  00084	89 85 78 ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  0008a	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv66[ebp], 0
  00091	76 11		 jbe	 SHORT $LN14@ClipPolygo
  00093	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  00099	83 c0 0c	 add	 eax, 12			; 0000000cH
  0009c	89 85 70 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  000a2	eb cd		 jmp	 SHORT $LN15@ClipPolygo
$LN14@ClipPolygo:

; 119  : 	
; 120  : 	// Clip against all six planes
; 121  : 	DWORD dwCount = ClipPolygonAgainstPlane(m_v4LeftPlane, dwVertexCount, c_pv3Vertex, c_pv3Normal, v3TempVertex, v3TempNormal);

  000a4	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  000a7	50		 push	 eax
  000a8	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  000ab	50		 push	 eax
  000ac	ff 75 74	 push	 DWORD PTR _c_pv3Normal$[ebp]
  000af	ff 75 70	 push	 DWORD PTR _c_pv3Vertex$[ebp]
  000b2	ff 75 6c	 push	 DWORD PTR _dwVertexCount$[ebp]
  000b5	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	83 c0 1c	 add	 eax, 28			; 0000001cH
  000bb	50		 push	 eax
  000bc	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000c1	83 c4 18	 add	 esp, 24			; 00000018H
  000c4	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax

; 122  : 	if (dwCount != 0)

  000c7	83 7d 84 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  000cb	0f 84 cb 00 00
	00		 je	 $LN2@ClipPolygo

; 123  : 	{
; 124  : 		dwCount = ClipPolygonAgainstPlane(m_v4RightPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  000d1	ff 75 7c	 push	 DWORD PTR _c_pv3NewNormal$[ebp]
  000d4	ff 75 78	 push	 DWORD PTR _c_pv3NewVertex$[ebp]
  000d7	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  000da	50		 push	 eax
  000db	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  000de	50		 push	 eax
  000df	ff 75 84	 push	 DWORD PTR _dwCount$[ebp]
  000e2	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	83 c0 2c	 add	 eax, 44			; 0000002cH
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  000ee	83 c4 18	 add	 esp, 24			; 00000018H
  000f1	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax

; 125  : 		if (dwCount != 0)

  000f4	83 7d 84 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  000f8	0f 84 9e 00 00
	00		 je	 $LN2@ClipPolygo

; 126  : 		{
; 127  : 			dwCount = ClipPolygonAgainstPlane(m_v4BottomPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  000fe	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  00101	50		 push	 eax
  00102	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  00105	50		 push	 eax
  00106	ff 75 7c	 push	 DWORD PTR _c_pv3NewNormal$[ebp]
  00109	ff 75 78	 push	 DWORD PTR _c_pv3NewVertex$[ebp]
  0010c	ff 75 84	 push	 DWORD PTR _dwCount$[ebp]
  0010f	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00112	83 c0 3c	 add	 eax, 60			; 0000003cH
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0011b	83 c4 18	 add	 esp, 24			; 00000018H
  0011e	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax

; 128  : 			if (dwCount != 0)

  00121	83 7d 84 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  00125	74 75		 je	 SHORT $LN2@ClipPolygo

; 129  : 			{
; 130  : 				dwCount = ClipPolygonAgainstPlane(m_v4TopPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00127	ff 75 7c	 push	 DWORD PTR _c_pv3NewNormal$[ebp]
  0012a	ff 75 78	 push	 DWORD PTR _c_pv3NewVertex$[ebp]
  0012d	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  00130	50		 push	 eax
  00131	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  00134	50		 push	 eax
  00135	ff 75 84	 push	 DWORD PTR _dwCount$[ebp]
  00138	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	83 c0 4c	 add	 eax, 76			; 0000004cH
  0013e	50		 push	 eax
  0013f	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  00144	83 c4 18	 add	 esp, 24			; 00000018H
  00147	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax

; 131  : 				if (dwCount != 0)

  0014a	83 7d 84 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  0014e	74 4c		 je	 SHORT $LN2@ClipPolygo

; 132  : 				{
; 133  : 					dwCount = ClipPolygonAgainstPlane(m_v4BackPlane, dwCount, c_pv3NewVertex, c_pv3NewNormal, v3TempVertex, v3TempNormal);

  00150	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  00153	50		 push	 eax
  00154	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  00157	50		 push	 eax
  00158	ff 75 7c	 push	 DWORD PTR _c_pv3NewNormal$[ebp]
  0015b	ff 75 78	 push	 DWORD PTR _c_pv3NewVertex$[ebp]
  0015e	ff 75 84	 push	 DWORD PTR _dwCount$[ebp]
  00161	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  00164	83 c0 6c	 add	 eax, 108		; 0000006cH
  00167	50		 push	 eax
  00168	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  0016d	83 c4 18	 add	 esp, 24			; 00000018H
  00170	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax

; 134  : 					if (dwCount != 0)

  00173	83 7d 84 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  00177	74 23		 je	 SHORT $LN2@ClipPolygo

; 135  : 					{
; 136  : 						dwCount = ClipPolygonAgainstPlane(m_v4FrontPlane, dwCount, v3TempVertex, v3TempNormal, c_pv3NewVertex, c_pv3NewNormal);

  00179	ff 75 7c	 push	 DWORD PTR _c_pv3NewNormal$[ebp]
  0017c	ff 75 78	 push	 DWORD PTR _c_pv3NewVertex$[ebp]
  0017f	8d 45 f4	 lea	 eax, DWORD PTR _v3TempNormal$[ebp]
  00182	50		 push	 eax
  00183	8d 45 88	 lea	 eax, DWORD PTR _v3TempVertex$[ebp]
  00186	50		 push	 eax
  00187	ff 75 84	 push	 DWORD PTR _dwCount$[ebp]
  0018a	8b 45 80	 mov	 eax, DWORD PTR _this$[ebp]
  0018d	83 c0 5c	 add	 eax, 92			; 0000005cH
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 ?ClipPolygonAgainstPlane@CDecal@@KAKABUD3DXPLANE@@KPBUD3DXVECTOR3@@1PAU3@2@Z ; CDecal::ClipPolygonAgainstPlane
  00196	83 c4 18	 add	 esp, 24			; 00000018H
  00199	89 45 84	 mov	 DWORD PTR _dwCount$[ebp], eax
$LN2@ClipPolygo:

; 137  : 					}
; 138  : 				}
; 139  : 			}
; 140  : 		}
; 141  : 	}
; 142  : 	return dwCount;

  0019c	8b 45 84	 mov	 eax, DWORD PTR _dwCount$[ebp]

; 143  : }

  0019f	8b 4d 60	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001a2	33 cd		 xor	 ecx, ebp
  001a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001a9	83 c5 64	 add	 ebp, 100		; 00000064H
  001ac	c9		 leave
  001ad	c2 14 00	 ret	 20			; 00000014H
?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ENDP ; CDecal::ClipPolygon
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
$T1 = -248						; size = 4
$T2 = -244						; size = 4
__X$ = -240						; size = 4
_fz$ = -236						; size = 4
_fy$ = -232						; size = 4
_fx$ = -228						; size = 4
_fz$ = -224						; size = 4
_fy$ = -220						; size = 4
_fx$ = -216						; size = 4
tv66 = -212						; size = 4
tv184 = -208						; size = 4
_dwCount$3 = -204					; size = 4
___t$ = -200						; size = 4
___t$ = -196						; size = 4
_pV1$ = -192						; size = 4
___n$ = -188						; size = 4
___n$ = -184						; size = 4
_this$ = -180						; size = 4
_v3_3$4 = -176						; size = 4
_v3_2$5 = -172						; size = 4
_v3_1$6 = -168						; size = 4
_dwi$7 = -164						; size = 4
_v$8 = -160						; size = 12
$T9 = -148						; size = 12
$T10 = -136						; size = 12
_v3Cross$11 = -124					; size = 12
_v3NewVertex$ = -112					; size = 108
_v3NewNormal$ = -4					; size = 108
__$ArrayPad$ = 104					; size = 4
_dwPrimitiveCount$ = 116				; size = 4
_c_pv3Vertex$ = 120					; size = 4
_c_pv3Normal$ = 124					; size = 4
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z PROC		; CDecal::ClipMesh, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 68	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 8d 4c ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 46   : 	D3DXVECTOR3		v3NewVertex[9];

  0001d	c7 85 48 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR ___n$[ebp], 9
  00027	8d 45 90	 lea	 eax, DWORD PTR _v3NewVertex$[ebp]
  0002a	89 85 3c ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN9@ClipMesh:
  00030	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00036	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv184[ebp], eax
  0003c	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00042	48		 dec	 eax
  00043	89 85 48 ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  00049	83 bd 30 ff ff
	ff 00		 cmp	 DWORD PTR tv184[ebp], 0
  00050	76 11		 jbe	 SHORT $LN10@ClipMesh
  00052	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  00058	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005b	89 85 3c ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  00061	eb cd		 jmp	 SHORT $LN9@ClipMesh
$LN10@ClipMesh:

; 47   : 	D3DXVECTOR3		v3NewNormal[9];

  00063	c7 85 44 ff ff
	ff 09 00 00 00	 mov	 DWORD PTR ___n$[ebp], 9
  0006d	8d 45 fc	 lea	 eax, DWORD PTR _v3NewNormal$[ebp]
  00070	89 85 38 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN15@ClipMesh:
  00076	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  0007c	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  00082	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00088	48		 dec	 eax
  00089	89 85 44 ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  0008f	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR tv66[ebp], 0
  00096	76 11		 jbe	 SHORT $LN16@ClipMesh
  00098	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  0009e	83 c0 0c	 add	 eax, 12			; 0000000cH
  000a1	89 85 38 ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  000a7	eb cd		 jmp	 SHORT $LN15@ClipMesh
$LN16@ClipMesh:

; 48   : 	
; 49   : 	// Clip one triangle at a time
; 50   : 	for(DWORD dwi = 0; dwi < dwPrimitiveCount; ++dwi)

  000a9	83 a5 5c ff ff
	ff 00		 and	 DWORD PTR _dwi$7[ebp], 0
  000b0	eb 0d		 jmp	 SHORT $LN4@ClipMesh
$LN2@ClipMesh:
  000b2	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _dwi$7[ebp]
  000b8	40		 inc	 eax
  000b9	89 85 5c ff ff
	ff		 mov	 DWORD PTR _dwi$7[ebp], eax
$LN4@ClipMesh:
  000bf	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR _dwi$7[ebp]
  000c5	3b 45 74	 cmp	 eax, DWORD PTR _dwPrimitiveCount$[ebp]
  000c8	0f 83 6d 03 00
	00		 jae	 $LN3@ClipMesh

; 51   : 	{
; 52   : 		const D3DXVECTOR3 & v3_1 = c_pv3Vertex[3 * dwi];

  000ce	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  000d5	6b c0 0c	 imul	 eax, eax, 12
  000d8	03 45 78	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  000db	89 85 58 ff ff
	ff		 mov	 DWORD PTR _v3_1$6[ebp], eax

; 53   : 		const D3DXVECTOR3 & v3_2 = c_pv3Vertex[3 * dwi + 1];

  000e1	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  000e8	40		 inc	 eax
  000e9	6b c0 0c	 imul	 eax, eax, 12
  000ec	03 45 78	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  000ef	89 85 54 ff ff
	ff		 mov	 DWORD PTR _v3_2$5[ebp], eax

; 54   : 		const D3DXVECTOR3 & v3_3 = c_pv3Vertex[3 * dwi + 2];

  000f5	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  000fc	40		 inc	 eax
  000fd	40		 inc	 eax
  000fe	6b c0 0c	 imul	 eax, eax, 12
  00101	03 45 78	 add	 eax, DWORD PTR _c_pv3Vertex$[ebp]
  00104	89 85 50 ff ff
	ff		 mov	 DWORD PTR _v3_3$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0010a	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _v3_3$4[ebp]
  00110	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  00116	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0011a	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0011e	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00126	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _v3_3$4[ebp]
  0012c	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  00132	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00137	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  0013c	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00144	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR _v3_3$4[ebp]
  0014a	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  00150	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00155	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0015a	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00162	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0016a	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T9[ebp], xmm0

; 181  :     y = fy;

  00172	f3 0f 10 85 24
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0017a	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T9[ebp+4], xmm0

; 182  :     z = fz;

  00182	f3 0f 10 85 20
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0018a	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T9[ebp+8], xmm0

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00192	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _v3_2$5[ebp]
  00198	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  0019e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001a2	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  001a6	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  001ae	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _v3_2$5[ebp]
  001b4	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  001ba	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001bf	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  001c4	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  001cc	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR _v3_2$5[ebp]
  001d2	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR _v3_1$6[ebp]
  001d8	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001dd	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  001e2	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001ea	f3 0f 10 85 1c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001f2	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T10[ebp], xmm0

; 181  :     y = fy;

  001fa	f3 0f 10 85 18
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00202	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T10[ebp+4], xmm0

; 182  :     z = fz;

  0020a	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00212	f3 0f 11 45 80	 movss	 DWORD PTR $T10[ebp+8], xmm0

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00217	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR $T10[ebp+4]
  0021f	f3 0f 59 85 74
	ff ff ff	 mulss	 xmm0, DWORD PTR $T9[ebp+8]
  00227	f3 0f 10 4d 80	 movss	 xmm1, DWORD PTR $T10[ebp+8]
  0022c	f3 0f 59 8d 70
	ff ff ff	 mulss	 xmm1, DWORD PTR $T9[ebp+4]
  00234	f3 0f 5c c1	 subss	 xmm0, xmm1
  00238	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR _v$8[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00240	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR $T10[ebp+8]
  00245	f3 0f 59 85 6c
	ff ff ff	 mulss	 xmm0, DWORD PTR $T9[ebp]
  0024d	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR $T10[ebp]
  00255	f3 0f 59 8d 74
	ff ff ff	 mulss	 xmm1, DWORD PTR $T9[ebp+8]
  0025d	f3 0f 5c c1	 subss	 xmm0, xmm1
  00261	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR _v$8[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  00269	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR $T10[ebp]
  00271	f3 0f 59 85 70
	ff ff ff	 mulss	 xmm0, DWORD PTR $T9[ebp+4]
  00279	f3 0f 10 8d 7c
	ff ff ff	 movss	 xmm1, DWORD PTR $T10[ebp+4]
  00281	f3 0f 59 8d 6c
	ff ff ff	 mulss	 xmm1, DWORD PTR $T9[ebp]
  00289	f3 0f 5c c1	 subss	 xmm0, xmm1
  0028d	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR _v$8[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  00295	8d b5 60 ff ff
	ff		 lea	 esi, DWORD PTR _v$8[ebp]
  0029b	8d 7d 84	 lea	 edi, DWORD PTR _v3Cross$11[ebp]
  0029e	a5		 movsd
  0029f	a5		 movsd
  002a0	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 58   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > ( m_cfDecalEpsilon ) * D3DXVec3Length(&v3Cross))

  002a1	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002a7	83 c0 10	 add	 eax, 16			; 00000010H
  002aa	89 85 40 ff ff
	ff		 mov	 DWORD PTR _pV1$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  002b0	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  002b6	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  002ba	f3 0f 59 45 84	 mulss	 xmm0, DWORD PTR _v3Cross$11[ebp]
  002bf	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  002c5	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  002ca	f3 0f 59 4d 88	 mulss	 xmm1, DWORD PTR _v3Cross$11[ebp+4]
  002cf	f3 0f 58 c1	 addss	 xmm0, xmm1
  002d3	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _pV1$[ebp]
  002d9	f3 0f 10 48 08	 movss	 xmm1, DWORD PTR [eax+8]
  002de	f3 0f 59 4d 8c	 mulss	 xmm1, DWORD PTR _v3Cross$11[ebp+8]
  002e3	f3 0f 58 c1	 addss	 xmm0, xmm1
  002e7	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR $T1[ebp], xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  002ef	f3 0f 10 45 8c	 movss	 xmm0, DWORD PTR _v3Cross$11[ebp+8]
  002f4	f3 0f 59 45 8c	 mulss	 xmm0, DWORD PTR _v3Cross$11[ebp+8]
  002f9	f3 0f 10 4d 88	 movss	 xmm1, DWORD PTR _v3Cross$11[ebp+4]
  002fe	f3 0f 59 4d 88	 mulss	 xmm1, DWORD PTR _v3Cross$11[ebp+4]
  00303	f3 0f 10 55 84	 movss	 xmm2, DWORD PTR _v3Cross$11[ebp]
  00308	f3 0f 59 55 84	 mulss	 xmm2, DWORD PTR _v3Cross$11[ebp]
  0030d	f3 0f 58 d1	 addss	 xmm2, xmm1
  00311	f3 0f 58 d0	 addss	 xmm2, xmm0
  00315	f3 0f 11 95 10
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  0031d	f3 0f 5a 85 10
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00325	51		 push	 ecx
  00326	51		 push	 ecx
  00327	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0032c	e8 00 00 00 00	 call	 _sqrt
  00331	59		 pop	 ecx
  00332	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00333	d9 9d 0c ff ff
	ff		 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 58   : 		if (D3DXVec3Dot(&m_v3Normal, &v3Cross) > ( m_cfDecalEpsilon ) * D3DXVec3Length(&v3Cross))

  00339	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0033f	f3 0f 10 80 90
	1a 00 00	 movss	 xmm0, DWORD PTR [eax+6800]
  00347	f3 0f 59 85 0c
	ff ff ff	 mulss	 xmm0, DWORD PTR $T2[ebp]
  0034f	f3 0f 10 8d 08
	ff ff ff	 movss	 xmm1, DWORD PTR $T1[ebp]
  00357	0f 2f c8	 comiss	 xmm1, xmm0
  0035a	0f 86 d6 00 00
	00		 jbe	 $LN6@ClipMesh

; 59   : 		{
; 60   : 			v3NewVertex[0] = v3_1;

  00360	6a 0c		 push	 12			; 0000000cH
  00362	58		 pop	 eax
  00363	6b c0 00	 imul	 eax, eax, 0
  00366	8d 7c 05 90	 lea	 edi, DWORD PTR _v3NewVertex$[ebp+eax]
  0036a	8b b5 58 ff ff
	ff		 mov	 esi, DWORD PTR _v3_1$6[ebp]
  00370	a5		 movsd
  00371	a5		 movsd
  00372	a5		 movsd

; 61   : 			v3NewVertex[1] = v3_2;

  00373	6a 0c		 push	 12			; 0000000cH
  00375	58		 pop	 eax
  00376	c1 e0 00	 shl	 eax, 0
  00379	8d 7c 05 90	 lea	 edi, DWORD PTR _v3NewVertex$[ebp+eax]
  0037d	8b b5 54 ff ff
	ff		 mov	 esi, DWORD PTR _v3_2$5[ebp]
  00383	a5		 movsd
  00384	a5		 movsd
  00385	a5		 movsd

; 62   : 			v3NewVertex[2] = v3_3;

  00386	6a 0c		 push	 12			; 0000000cH
  00388	58		 pop	 eax
  00389	d1 e0		 shl	 eax, 1
  0038b	8d 7c 05 90	 lea	 edi, DWORD PTR _v3NewVertex$[ebp+eax]
  0038f	8b b5 50 ff ff
	ff		 mov	 esi, DWORD PTR _v3_3$4[ebp]
  00395	a5		 movsd
  00396	a5		 movsd
  00397	a5		 movsd

; 63   : 			
; 64   : 			v3NewNormal[0] = c_pv3Normal[3 * dwi];

  00398	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  0039f	6b f0 0c	 imul	 esi, eax, 12
  003a2	03 75 7c	 add	 esi, DWORD PTR _c_pv3Normal$[ebp]
  003a5	6a 0c		 push	 12			; 0000000cH
  003a7	58		 pop	 eax
  003a8	6b c0 00	 imul	 eax, eax, 0
  003ab	8d 7c 05 fc	 lea	 edi, DWORD PTR _v3NewNormal$[ebp+eax]
  003af	a5		 movsd
  003b0	a5		 movsd
  003b1	a5		 movsd

; 65   : 			v3NewNormal[1] = c_pv3Normal[3 * dwi + 1];

  003b2	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  003b9	40		 inc	 eax
  003ba	6b f0 0c	 imul	 esi, eax, 12
  003bd	03 75 7c	 add	 esi, DWORD PTR _c_pv3Normal$[ebp]
  003c0	6a 0c		 push	 12			; 0000000cH
  003c2	58		 pop	 eax
  003c3	c1 e0 00	 shl	 eax, 0
  003c6	8d 7c 05 fc	 lea	 edi, DWORD PTR _v3NewNormal$[ebp+eax]
  003ca	a5		 movsd
  003cb	a5		 movsd
  003cc	a5		 movsd

; 66   : 			v3NewNormal[2] = c_pv3Normal[3 * dwi + 2];

  003cd	6b 85 5c ff ff
	ff 03		 imul	 eax, DWORD PTR _dwi$7[ebp], 3
  003d4	40		 inc	 eax
  003d5	40		 inc	 eax
  003d6	6b f0 0c	 imul	 esi, eax, 12
  003d9	03 75 7c	 add	 esi, DWORD PTR _c_pv3Normal$[ebp]
  003dc	6a 0c		 push	 12			; 0000000cH
  003de	58		 pop	 eax
  003df	d1 e0		 shl	 eax, 1
  003e1	8d 7c 05 fc	 lea	 edi, DWORD PTR _v3NewNormal$[ebp+eax]
  003e5	a5		 movsd
  003e6	a5		 movsd
  003e7	a5		 movsd

; 67   : 			
; 68   : 			DWORD dwCount = ClipPolygon(3, v3NewVertex, v3NewNormal, v3NewVertex, v3NewNormal);

  003e8	8d 45 fc	 lea	 eax, DWORD PTR _v3NewNormal$[ebp]
  003eb	50		 push	 eax
  003ec	8d 45 90	 lea	 eax, DWORD PTR _v3NewVertex$[ebp]
  003ef	50		 push	 eax
  003f0	8d 45 fc	 lea	 eax, DWORD PTR _v3NewNormal$[ebp]
  003f3	50		 push	 eax
  003f4	8d 45 90	 lea	 eax, DWORD PTR _v3NewVertex$[ebp]
  003f7	50		 push	 eax
  003f8	6a 03		 push	 3
  003fa	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00400	e8 00 00 00 00	 call	 ?ClipPolygon@CDecal@@IBEKKPBUD3DXVECTOR3@@0PAU2@1@Z ; CDecal::ClipPolygon
  00405	89 85 34 ff ff
	ff		 mov	 DWORD PTR _dwCount$3[ebp], eax

; 69   : 			if ((dwCount != 0) && (!AddPolygon(dwCount, v3NewVertex, v3NewNormal))) break;

  0040b	83 bd 34 ff ff
	ff 00		 cmp	 DWORD PTR _dwCount$3[ebp], 0
  00412	74 22		 je	 SHORT $LN6@ClipMesh
  00414	8d 45 fc	 lea	 eax, DWORD PTR _v3NewNormal$[ebp]
  00417	50		 push	 eax
  00418	8d 45 90	 lea	 eax, DWORD PTR _v3NewVertex$[ebp]
  0041b	50		 push	 eax
  0041c	ff b5 34 ff ff
	ff		 push	 DWORD PTR _dwCount$3[ebp]
  00422	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00428	e8 00 00 00 00	 call	 ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ; CDecal::AddPolygon
  0042d	0f b6 c0	 movzx	 eax, al
  00430	85 c0		 test	 eax, eax
  00432	75 02		 jne	 SHORT $LN6@ClipMesh
  00434	eb 05		 jmp	 SHORT $LN3@ClipMesh
$LN6@ClipMesh:

; 70   :  		}
; 71   : 	}

  00436	e9 77 fc ff ff	 jmp	 $LN2@ClipMesh
$LN3@ClipMesh:

; 72   : }

  0043b	5f		 pop	 edi
  0043c	5e		 pop	 esi
  0043d	8b 4d 68	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00440	33 cd		 xor	 ecx, ebp
  00442	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00447	83 c5 6c	 add	 ebp, 108		; 0000006cH
  0044a	c9		 leave
  0044b	c2 0c 00	 ret	 12			; 0000000cH
?ClipMesh@CDecal@@IAEXKPBUD3DXVECTOR3@@0@Z ENDP		; CDecal::ClipMesh
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_wIndex$ = -36						; size = 4
_dwVertexNum$1 = -32					; size = 4
_dwCount$ = -28						; size = 4
_this$ = -24						; size = 4
_aTriangleFanStruct$ = -20				; size = 16
__$ArrayPad$ = -4					; size = 4
_dwAddCount$ = 8					; size = 4
_c_pv3Vertex$ = 12					; size = 4
___formal$ = 16						; size = 4
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z PROC	; CDecal::AddPolygon, COMDAT
; _this$ = ecx

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 76   : 	if (m_dwVertexCount + dwAddCount >= MAX_DECAL_VERTICES)

  00015	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0001b	03 45 08	 add	 eax, DWORD PTR _dwAddCount$[ebp]
  0001e	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00023	72 07		 jb	 SHORT $LN5@AddPolygon

; 77   : 		return false;

  00025	32 c0		 xor	 al, al
  00027	e9 c8 00 00 00	 jmp	 $LN1@AddPolygon
$LN5@AddPolygon:

; 78   : 
; 79   : 	TTRIANGLEFANSTRUCT aTriangleFanStruct;
; 80   : 	aTriangleFanStruct.m_wMinIndex = m_dwVertexCount;

  0002c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	66 8b 40 7c	 mov	 ax, WORD PTR [eax+124]
  00033	66 89 45 ec	 mov	 WORD PTR _aTriangleFanStruct$[ebp], ax

; 81   : 	aTriangleFanStruct.m_dwVertexCount = dwAddCount;

  00037	8b 45 08	 mov	 eax, DWORD PTR _dwAddCount$[ebp]
  0003a	89 45 f0	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+4], eax

; 82   : 	aTriangleFanStruct.m_dwPrimitiveCount = dwAddCount - 2;

  0003d	8b 45 08	 mov	 eax, DWORD PTR _dwAddCount$[ebp]
  00040	48		 dec	 eax
  00041	48		 dec	 eax
  00042	89 45 f4	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+8], eax

; 83   : 	aTriangleFanStruct.m_dwVBOffset = m_dwVertexCount;

  00045	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0004b	89 45 f8	 mov	 DWORD PTR _aTriangleFanStruct$[ebp+12], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0004e	8d 45 ec	 lea	 eax, DWORD PTR _aTriangleFanStruct$[ebp]
  00051	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 85   : 	m_TriangleFanStructVector.push_back(aTriangleFanStruct);

  00052	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0005b	e8 00 00 00 00	 call	 ??$emplace_back@ABUTTRIANGLEFANSTRUCT@CDecal@@@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXABUTTRIANGLEFANSTRUCT@CDecal@@@Z ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::emplace_back<CDecal::TTRIANGLEFANSTRUCT const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 87   : 	DWORD dwCount = m_dwVertexCount;

  00060	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  00066	89 45 e4	 mov	 DWORD PTR _dwCount$[ebp], eax

; 88   : 
; 89   : 	// Add polygon as a triangle fan
; 90   : 	WORD * wIndex = m_Indices + dwCount;

  00069	8b 45 e4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  0006c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8d 84 41 90 18
	00 00		 lea	 eax, DWORD PTR [ecx+eax*2+6288]
  00076	89 45 dc	 mov	 DWORD PTR _wIndex$[ebp], eax

; 91   : 
; 92   : 	m_dwPrimitiveCount += dwAddCount - 2;

  00079	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _dwAddCount$[ebp]
  00085	8d 44 01 fe	 lea	 eax, DWORD PTR [ecx+eax-2]
  00089	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	89 81 80 00 00
	00		 mov	 DWORD PTR [ecx+128], eax

; 93   : 	//float fOne_over_1MinusDecalEpsilon = 1.0f / (1.0f - m_cfDecalEpsilon);
; 94   : 	
; 95   : 	// Assign vertex colors
; 96   : 	for (DWORD dwVertexNum = 0; dwVertexNum < dwAddCount; ++dwVertexNum)

  00092	83 65 e0 00	 and	 DWORD PTR _dwVertexNum$1[ebp], 0
  00096	eb 07		 jmp	 SHORT $LN4@AddPolygon
$LN2@AddPolygon:
  00098	8b 45 e0	 mov	 eax, DWORD PTR _dwVertexNum$1[ebp]
  0009b	40		 inc	 eax
  0009c	89 45 e0	 mov	 DWORD PTR _dwVertexNum$1[ebp], eax
$LN4@AddPolygon:
  0009f	8b 45 e0	 mov	 eax, DWORD PTR _dwVertexNum$1[ebp]
  000a2	3b 45 08	 cmp	 eax, DWORD PTR _dwAddCount$[ebp]
  000a5	73 42		 jae	 SHORT $LN3@AddPolygon

; 97   : 	{
; 98   : 		*wIndex++ = (WORD) dwCount;

  000a7	8b 45 dc	 mov	 eax, DWORD PTR _wIndex$[ebp]
  000aa	66 8b 4d e4	 mov	 cx, WORD PTR _dwCount$[ebp]
  000ae	66 89 08	 mov	 WORD PTR [eax], cx
  000b1	8b 45 dc	 mov	 eax, DWORD PTR _wIndex$[ebp]
  000b4	40		 inc	 eax
  000b5	40		 inc	 eax
  000b6	89 45 dc	 mov	 DWORD PTR _wIndex$[ebp], eax

; 99   : 		m_Vertices[dwCount].position = c_pv3Vertex[dwVertexNum];

  000b9	6b 75 e0 0c	 imul	 esi, DWORD PTR _dwVertexNum$1[ebp], 12
  000bd	03 75 0c	 add	 esi, DWORD PTR _c_pv3Vertex$[ebp]
  000c0	6b 45 e4 18	 imul	 eax, DWORD PTR _dwCount$[ebp], 24
  000c4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	8d bc 01 90 00
	00 00		 lea	 edi, DWORD PTR [ecx+eax+144]
  000ce	a5		 movsd
  000cf	a5		 movsd
  000d0	a5		 movsd

; 100  : 		//const D3DXVECTOR3 & v3Normal = c_pv3Normal[dwVertexNum];
; 101  : 		//float fAlpha = (D3DXVec3Dot(&m_v3Normal, &v3Normal) / D3DXVec3Length(&v3Normal) - m_cfDecalEpsilon) * fOne_over_1MinusDecalEpsilon;
; 102  : 		//m_Vertices[dwCount].diffuse = D3DXCOLOR(1.0f, 1.0f, 1.0f, (fAlpha > 0.0f) ? fAlpha : 0.0f);
; 103  : 		m_Vertices[dwCount].diffuse = 0xFFFFFFFF;

  000d1	6b 45 e4 18	 imul	 eax, DWORD PTR _dwCount$[ebp], 24
  000d5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	83 8c 01 9c 00
	00 00 ff	 or	 DWORD PTR [ecx+eax+156], -1

; 104  : 		++dwCount;

  000e0	8b 45 e4	 mov	 eax, DWORD PTR _dwCount$[ebp]
  000e3	40		 inc	 eax
  000e4	89 45 e4	 mov	 DWORD PTR _dwCount$[ebp], eax

; 105  : 	}

  000e7	eb af		 jmp	 SHORT $LN2@AddPolygon
$LN3@AddPolygon:

; 106  : 
; 107  : 	m_dwVertexCount = dwCount;

  000e9	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	8b 4d e4	 mov	 ecx, DWORD PTR _dwCount$[ebp]
  000ef	89 48 7c	 mov	 DWORD PTR [eax+124], ecx

; 108  : 	return true;

  000f2	b0 01		 mov	 al, 1
$LN1@AddPolygon:

; 109  : }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	c9		 leave
  00101	c2 0c 00	 ret	 12			; 0000000cH
?AddPolygon@CDecal@@IAE_NKPBUD3DXVECTOR3@@0@Z ENDP	; CDecal::AddPolygon
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@CAXXZ ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 04	 sar	 eax, 4
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 04	 shl	 eax, 4
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXQAUTTRIANGLEFANSTRUCT@CDecal@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXQAUTTRIANGLEFANSTRUCT@CDecal@@II@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 04	 sar	 eax, 4
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 04	 shl	 eax, 4
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	c1 e0 04	 shl	 eax, 4
  0009f	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	c1 e0 04	 shl	 eax, 4
  000ad	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXQAUTTRIANGLEFANSTRUCT@CDecal@@II@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@ABEII@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 04	 sar	 eax, 4
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 0f		 mov	 DWORD PTR $T7[ebp], 268435455 ; 0fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@ABEII@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXPAUTTRIANGLEFANSTRUCT@CDecal@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXPAUTTRIANGLEFANSTRUCT@CDecal@@0@Z PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXPAUTTRIANGLEFANSTRUCT@CDecal@@0@Z ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXXZ PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@YAXPAUTTRIANGLEFANSTRUCT@CDecal@@QAU12@AAV?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@0@@Z ; std::_Destroy_range<std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXXZ ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ PROC ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::~vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ENDP ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::~vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@QAEXQAUTTRIANGLEFANSTRUCT@CDecal@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@QAEXQAUTTRIANGLEFANSTRUCT@CDecal@@I@Z PROC ; std::allocator<CDecal::TTRIANGLEFANSTRUCT>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 04	 shl	 eax, 4
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@QAEXQAUTTRIANGLEFANSTRUCT@CDecal@@I@Z ENDP ; std::allocator<CDecal::TTRIANGLEFANSTRUCT>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?Render@CDecal@@UAEXXZ
_TEXT	SEGMENT
$T1 = -116						; size = 4
$T2 = -112						; size = 4
$T3 = -108						; size = 4
$T4 = -104						; size = 4
__My_data$5 = -100					; size = 4
__My_data$6 = -96					; size = 4
__My_data$7 = -92					; size = 4
__My_data$8 = -88					; size = 4
$T9 = -84						; size = 4
__My_data$10 = -80					; size = 4
_this$ = -76						; size = 4
_dwi$11 = -72						; size = 4
_matWorld$ = -68					; size = 64
__$ArrayPad$ = -4					; size = 4
?Render@CDecal@@UAEXXZ PROC				; CDecal::Render, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1516 :     pOut->m[0][1] = pOut->m[0][2] = pOut->m[0][3] =

  00013	6a 10		 push	 16			; 00000010H
  00015	58		 pop	 eax
  00016	6b c0 03	 imul	 eax, eax, 3
  00019	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0001d	6a 04		 push	 4
  0001f	59		 pop	 ecx
  00020	d1 e1		 shl	 ecx, 1
  00022	0f 57 c0	 xorps	 xmm0, xmm0
  00025	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0002a	6a 10		 push	 16			; 00000010H
  0002c	58		 pop	 eax
  0002d	6b c0 03	 imul	 eax, eax, 3
  00030	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00034	6a 04		 push	 4
  00036	59		 pop	 ecx
  00037	c1 e1 00	 shl	 ecx, 0
  0003a	0f 57 c0	 xorps	 xmm0, xmm0
  0003d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00042	6a 10		 push	 16			; 00000010H
  00044	58		 pop	 eax
  00045	6b c0 03	 imul	 eax, eax, 3
  00048	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0004c	6a 04		 push	 4
  0004e	59		 pop	 ecx
  0004f	6b c9 00	 imul	 ecx, ecx, 0
  00052	0f 57 c0	 xorps	 xmm0, xmm0
  00055	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0005a	6a 10		 push	 16			; 00000010H
  0005c	58		 pop	 eax
  0005d	d1 e0		 shl	 eax, 1
  0005f	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00063	6a 04		 push	 4
  00065	59		 pop	 ecx
  00066	6b c9 03	 imul	 ecx, ecx, 3
  00069	0f 57 c0	 xorps	 xmm0, xmm0
  0006c	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00071	6a 10		 push	 16			; 00000010H
  00073	58		 pop	 eax
  00074	d1 e0		 shl	 eax, 1
  00076	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0007a	6a 04		 push	 4
  0007c	59		 pop	 ecx
  0007d	c1 e1 00	 shl	 ecx, 0
  00080	0f 57 c0	 xorps	 xmm0, xmm0
  00083	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00088	6a 10		 push	 16			; 00000010H
  0008a	58		 pop	 eax
  0008b	d1 e0		 shl	 eax, 1
  0008d	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00091	6a 04		 push	 4
  00093	59		 pop	 ecx
  00094	6b c9 00	 imul	 ecx, ecx, 0
  00097	0f 57 c0	 xorps	 xmm0, xmm0
  0009a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0009f	6a 10		 push	 16			; 00000010H
  000a1	58		 pop	 eax
  000a2	c1 e0 00	 shl	 eax, 0
  000a5	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  000a9	6a 04		 push	 4
  000ab	59		 pop	 ecx
  000ac	6b c9 03	 imul	 ecx, ecx, 3
  000af	0f 57 c0	 xorps	 xmm0, xmm0
  000b2	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000b7	6a 10		 push	 16			; 00000010H
  000b9	58		 pop	 eax
  000ba	c1 e0 00	 shl	 eax, 0
  000bd	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  000c1	6a 04		 push	 4
  000c3	59		 pop	 ecx
  000c4	d1 e1		 shl	 ecx, 1
  000c6	0f 57 c0	 xorps	 xmm0, xmm0
  000c9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000ce	6a 10		 push	 16			; 00000010H
  000d0	58		 pop	 eax
  000d1	c1 e0 00	 shl	 eax, 0
  000d4	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  000d8	6a 04		 push	 4
  000da	59		 pop	 ecx
  000db	6b c9 00	 imul	 ecx, ecx, 0
  000de	0f 57 c0	 xorps	 xmm0, xmm0
  000e1	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000e6	6a 10		 push	 16			; 00000010H
  000e8	58		 pop	 eax
  000e9	6b c0 00	 imul	 eax, eax, 0
  000ec	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  000f0	6a 04		 push	 4
  000f2	59		 pop	 ecx
  000f3	6b c9 03	 imul	 ecx, ecx, 3
  000f6	0f 57 c0	 xorps	 xmm0, xmm0
  000f9	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  000fe	6a 10		 push	 16			; 00000010H
  00100	58		 pop	 eax
  00101	6b c0 00	 imul	 eax, eax, 0
  00104	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00108	6a 04		 push	 4
  0010a	59		 pop	 ecx
  0010b	d1 e1		 shl	 ecx, 1
  0010d	0f 57 c0	 xorps	 xmm0, xmm0
  00110	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00115	6a 10		 push	 16			; 00000010H
  00117	58		 pop	 eax
  00118	6b c0 00	 imul	 eax, eax, 0
  0011b	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0011f	6a 04		 push	 4
  00121	59		 pop	 ecx
  00122	c1 e1 00	 shl	 ecx, 0
  00125	0f 57 c0	 xorps	 xmm0, xmm0
  00128	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0

; 1517 :     pOut->m[1][0] = pOut->m[1][2] = pOut->m[1][3] =
; 1518 :     pOut->m[2][0] = pOut->m[2][1] = pOut->m[2][3] =
; 1519 :     pOut->m[3][0] = pOut->m[3][1] = pOut->m[3][2] = 0.0f;
; 1520 : 
; 1521 :     pOut->m[0][0] = pOut->m[1][1] = pOut->m[2][2] = pOut->m[3][3] = 1.0f;

  0012d	6a 10		 push	 16			; 00000010H
  0012f	58		 pop	 eax
  00130	6b c0 03	 imul	 eax, eax, 3
  00133	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00137	6a 04		 push	 4
  00139	59		 pop	 ecx
  0013a	6b c9 03	 imul	 ecx, ecx, 3
  0013d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00145	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  0014a	6a 10		 push	 16			; 00000010H
  0014c	58		 pop	 eax
  0014d	d1 e0		 shl	 eax, 1
  0014f	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  00153	6a 04		 push	 4
  00155	59		 pop	 ecx
  00156	d1 e1		 shl	 ecx, 1
  00158	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00160	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00165	6a 10		 push	 16			; 00000010H
  00167	58		 pop	 eax
  00168	c1 e0 00	 shl	 eax, 0
  0016b	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0016f	6a 04		 push	 4
  00171	59		 pop	 ecx
  00172	c1 e1 00	 shl	 ecx, 0
  00175	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0017d	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
  00182	6a 10		 push	 16			; 00000010H
  00184	58		 pop	 eax
  00185	6b c0 00	 imul	 eax, eax, 0
  00188	8d 44 05 bc	 lea	 eax, DWORD PTR _matWorld$[ebp+eax]
  0018c	6a 04		 push	 4
  0018e	59		 pop	 ecx
  0018f	6b c9 00	 imul	 ecx, ecx, 0
  00192	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0019a	f3 0f 11 04 08	 movss	 DWORD PTR [eax+ecx], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 226  : 	STATEMANAGER.SetTransform(D3DTS_WORLD, &matWorld);

  0019f	8d 45 bc	 lea	 eax, DWORD PTR _matWorld$[ebp]
  001a2	50		 push	 eax
  001a3	68 00 01 00 00	 push	 256			; 00000100H
  001a8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001ae	e8 00 00 00 00	 call	 ?SetTransform@CStateManager@@QAEXW4_D3DTRANSFORMSTATETYPE@@PBU_D3DMATRIX@@@Z ; CStateManager::SetTransform

; 227  : 	
; 228  : 	STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  001b3	68 42 01 00 00	 push	 322			; 00000142H
  001b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  001be	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  001c3	83 65 b8 00	 and	 DWORD PTR _dwi$11[ebp], 0
  001c7	eb 07		 jmp	 SHORT $LN4@Render
$LN2@Render:
  001c9	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  001cc	40		 inc	 eax
  001cd	89 45 b8	 mov	 DWORD PTR _dwi$11[ebp], eax
$LN4@Render:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  001d0	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	05 84 00 00 00	 add	 eax, 132		; 00000084H
  001d8	89 45 b0	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  001db	8b 45 b0	 mov	 eax, DWORD PTR __My_data$10[ebp]
  001de	8b 4d b0	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  001e1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e4	2b 01		 sub	 eax, DWORD PTR [ecx]
  001e6	c1 f8 04	 sar	 eax, 4
  001e9	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 230  : 	for (DWORD dwi = 0; dwi < m_TriangleFanStructVector.size(); ++dwi)

  001ec	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  001ef	3b 45 ac	 cmp	 eax, DWORD PTR $T9[ebp]
  001f2	0f 83 a7 00 00
	00		 jae	 $LN3@Render
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001f8	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  001fb	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00200	89 45 a8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00203	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  00206	c1 e0 04	 shl	 eax, 4
  00209	8b 4d a8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  0020c	03 01		 add	 eax, DWORD PTR [ecx]
  0020e	89 45 98	 mov	 DWORD PTR $T4[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00211	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00214	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00219	89 45 a4	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0021c	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  0021f	c1 e0 04	 shl	 eax, 4
  00222	8b 4d a4	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  00225	03 01		 add	 eax, DWORD PTR [ecx]
  00227	89 45 94	 mov	 DWORD PTR $T3[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0022a	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  0022d	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00232	89 45 a0	 mov	 DWORD PTR __My_data$6[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00235	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  00238	c1 e0 04	 shl	 eax, 4
  0023b	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$6[ebp]
  0023e	03 01		 add	 eax, DWORD PTR [ecx]
  00240	89 45 90	 mov	 DWORD PTR $T2[ebp], eax

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00243	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00246	05 84 00 00 00	 add	 eax, 132		; 00000084H
  0024b	89 45 9c	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0024e	8b 45 b8	 mov	 eax, DWORD PTR _dwi$11[ebp]
  00251	c1 e0 04	 shl	 eax, 4
  00254	8b 4d 9c	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  00257	03 01		 add	 eax, DWORD PTR [ecx]
  00259	89 45 8c	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 231  : 		STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLEFAN,

  0025c	6a 18		 push	 24			; 00000018H
  0025e	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00261	05 90 00 00 00	 add	 eax, 144		; 00000090H
  00266	50		 push	 eax
  00267	6a 65		 push	 101			; 00000065H
  00269	8b 45 98	 mov	 eax, DWORD PTR $T4[ebp]
  0026c	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0026f	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00272	8d 84 41 90 18
	00 00		 lea	 eax, DWORD PTR [ecx+eax*2+6288]
  00279	50		 push	 eax
  0027a	8b 45 94	 mov	 eax, DWORD PTR $T3[ebp]
  0027d	ff 70 08	 push	 DWORD PTR [eax+8]
  00280	8b 45 90	 mov	 eax, DWORD PTR $T2[ebp]
  00283	ff 70 04	 push	 DWORD PTR [eax+4]
  00286	8b 45 8c	 mov	 eax, DWORD PTR $T1[ebp]
  00289	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0028c	50		 push	 eax
  0028d	6a 06		 push	 6
  0028f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00295	e8 00 00 00 00	 call	 ?DrawIndexedPrimitiveUP@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIIPBXW4_D3DFORMAT@@1I@Z ; CStateManager::DrawIndexedPrimitiveUP
  0029a	e9 2a ff ff ff	 jmp	 $LN2@Render
$LN3@Render:

; 232  : 		m_TriangleFanStructVector[dwi].m_wMinIndex,
; 233  : 		m_TriangleFanStructVector[dwi].m_dwVertexCount,
; 234  : 		m_TriangleFanStructVector[dwi].m_dwPrimitiveCount,
; 235  : 		m_Indices + m_TriangleFanStructVector[dwi].m_wMinIndex,
; 236  : 		D3DFMT_INDEX16,
; 237  : 		m_Vertices,
; 238  : 		sizeof(TPDTVertex));
; 239  : }

  0029f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a2	33 cd		 xor	 ecx, ebp
  002a4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002a9	c9		 leave
  002aa	c3		 ret	 0
?Render@CDecal@@UAEXXZ ENDP				; CDecal::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ?Clear@CDecal@@QAEXXZ
_TEXT	SEGMENT
$T1 = -128						; size = 16
$T2 = -112						; size = 16
$T3 = -96						; size = 16
$T4 = -80						; size = 16
$T5 = -64						; size = 16
$T6 = -48						; size = 16
_this$ = -32						; size = 4
$T7 = -28						; size = 12
$T8 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?Clear@CDecal@@QAEXXZ PROC				; CDecal::Clear, COMDAT
; _this$ = ecx

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	57		 push	 edi
  00015	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00018	0f 57 c0	 xorps	 xmm0, xmm0
  0001b	f3 0f 11 45 f0	 movss	 DWORD PTR $T8[ebp], xmm0

; 181  :     y = fy;

  00020	0f 57 c0	 xorps	 xmm0, xmm0
  00023	f3 0f 11 45 f4	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 182  :     z = fz;

  00028	0f 57 c0	 xorps	 xmm0, xmm0
  0002b	f3 0f 11 45 f8	 movss	 DWORD PTR $T8[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 25   : 	m_v3Center = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00030	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  00033	83 c7 04	 add	 edi, 4
  00036	8d 75 f0	 lea	 esi, DWORD PTR $T8[ebp]
  00039	a5		 movsd
  0003a	a5		 movsd
  0003b	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0003c	0f 57 c0	 xorps	 xmm0, xmm0
  0003f	f3 0f 11 45 e4	 movss	 DWORD PTR $T7[ebp], xmm0

; 181  :     y = fy;

  00044	0f 57 c0	 xorps	 xmm0, xmm0
  00047	f3 0f 11 45 e8	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 182  :     z = fz;

  0004c	0f 57 c0	 xorps	 xmm0, xmm0
  0004f	f3 0f 11 45 ec	 movss	 DWORD PTR $T7[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 26   : 	m_v3Normal = D3DXVECTOR3(0.0f, 0.0f, 0.0f);

  00054	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  00057	83 c7 10	 add	 edi, 16			; 00000010H
  0005a	8d 75 e4	 lea	 esi, DWORD PTR $T7[ebp]
  0005d	a5		 movsd
  0005e	a5		 movsd
  0005f	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00060	0f 57 c0	 xorps	 xmm0, xmm0
  00063	f3 0f 11 45 d0	 movss	 DWORD PTR $T6[ebp], xmm0

; 830  :     b = fb;

  00068	0f 57 c0	 xorps	 xmm0, xmm0
  0006b	f3 0f 11 45 d4	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 831  :     c = fc;

  00070	0f 57 c0	 xorps	 xmm0, xmm0
  00073	f3 0f 11 45 d8	 movss	 DWORD PTR $T6[ebp+8], xmm0

; 832  :     d = fd;

  00078	0f 57 c0	 xorps	 xmm0, xmm0
  0007b	f3 0f 11 45 dc	 movss	 DWORD PTR $T6[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 28   : 	m_v4LeftPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00080	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  00083	83 c7 1c	 add	 edi, 28			; 0000001cH
  00086	8d 75 d0	 lea	 esi, DWORD PTR $T6[ebp]
  00089	a5		 movsd
  0008a	a5		 movsd
  0008b	a5		 movsd
  0008c	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  0008d	0f 57 c0	 xorps	 xmm0, xmm0
  00090	f3 0f 11 45 c0	 movss	 DWORD PTR $T5[ebp], xmm0

; 830  :     b = fb;

  00095	0f 57 c0	 xorps	 xmm0, xmm0
  00098	f3 0f 11 45 c4	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 831  :     c = fc;

  0009d	0f 57 c0	 xorps	 xmm0, xmm0
  000a0	f3 0f 11 45 c8	 movss	 DWORD PTR $T5[ebp+8], xmm0

; 832  :     d = fd;

  000a5	0f 57 c0	 xorps	 xmm0, xmm0
  000a8	f3 0f 11 45 cc	 movss	 DWORD PTR $T5[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 29   : 	m_v4RightPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  000ad	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  000b0	83 c7 2c	 add	 edi, 44			; 0000002cH
  000b3	8d 75 c0	 lea	 esi, DWORD PTR $T5[ebp]
  000b6	a5		 movsd
  000b7	a5		 movsd
  000b8	a5		 movsd
  000b9	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  000ba	0f 57 c0	 xorps	 xmm0, xmm0
  000bd	f3 0f 11 45 b0	 movss	 DWORD PTR $T4[ebp], xmm0

; 830  :     b = fb;

  000c2	0f 57 c0	 xorps	 xmm0, xmm0
  000c5	f3 0f 11 45 b4	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 831  :     c = fc;

  000ca	0f 57 c0	 xorps	 xmm0, xmm0
  000cd	f3 0f 11 45 b8	 movss	 DWORD PTR $T4[ebp+8], xmm0

; 832  :     d = fd;

  000d2	0f 57 c0	 xorps	 xmm0, xmm0
  000d5	f3 0f 11 45 bc	 movss	 DWORD PTR $T4[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 30   : 	m_v4TopPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  000da	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  000dd	83 c7 4c	 add	 edi, 76			; 0000004cH
  000e0	8d 75 b0	 lea	 esi, DWORD PTR $T4[ebp]
  000e3	a5		 movsd
  000e4	a5		 movsd
  000e5	a5		 movsd
  000e6	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  000e7	0f 57 c0	 xorps	 xmm0, xmm0
  000ea	f3 0f 11 45 a0	 movss	 DWORD PTR $T3[ebp], xmm0

; 830  :     b = fb;

  000ef	0f 57 c0	 xorps	 xmm0, xmm0
  000f2	f3 0f 11 45 a4	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 831  :     c = fc;

  000f7	0f 57 c0	 xorps	 xmm0, xmm0
  000fa	f3 0f 11 45 a8	 movss	 DWORD PTR $T3[ebp+8], xmm0

; 832  :     d = fd;

  000ff	0f 57 c0	 xorps	 xmm0, xmm0
  00102	f3 0f 11 45 ac	 movss	 DWORD PTR $T3[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 31   : 	m_v4BottomPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00107	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  0010a	83 c7 3c	 add	 edi, 60			; 0000003cH
  0010d	8d 75 a0	 lea	 esi, DWORD PTR $T3[ebp]
  00110	a5		 movsd
  00111	a5		 movsd
  00112	a5		 movsd
  00113	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00114	0f 57 c0	 xorps	 xmm0, xmm0
  00117	f3 0f 11 45 90	 movss	 DWORD PTR $T2[ebp], xmm0

; 830  :     b = fb;

  0011c	0f 57 c0	 xorps	 xmm0, xmm0
  0011f	f3 0f 11 45 94	 movss	 DWORD PTR $T2[ebp+4], xmm0

; 831  :     c = fc;

  00124	0f 57 c0	 xorps	 xmm0, xmm0
  00127	f3 0f 11 45 98	 movss	 DWORD PTR $T2[ebp+8], xmm0

; 832  :     d = fd;

  0012c	0f 57 c0	 xorps	 xmm0, xmm0
  0012f	f3 0f 11 45 9c	 movss	 DWORD PTR $T2[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 32   : 	m_v4FrontPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00134	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  00137	83 c7 5c	 add	 edi, 92			; 0000005cH
  0013a	8d 75 90	 lea	 esi, DWORD PTR $T2[ebp]
  0013d	a5		 movsd
  0013e	a5		 movsd
  0013f	a5		 movsd
  00140	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 829  :     a = fa;

  00141	0f 57 c0	 xorps	 xmm0, xmm0
  00144	f3 0f 11 45 80	 movss	 DWORD PTR $T1[ebp], xmm0

; 830  :     b = fb;

  00149	0f 57 c0	 xorps	 xmm0, xmm0
  0014c	f3 0f 11 45 84	 movss	 DWORD PTR $T1[ebp+4], xmm0

; 831  :     c = fc;

  00151	0f 57 c0	 xorps	 xmm0, xmm0
  00154	f3 0f 11 45 88	 movss	 DWORD PTR $T1[ebp+8], xmm0

; 832  :     d = fd;

  00159	0f 57 c0	 xorps	 xmm0, xmm0
  0015c	f3 0f 11 45 8c	 movss	 DWORD PTR $T1[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 33   : 	m_v4BackPlane = D3DXPLANE(0.0f, 0.0f, 0.0f, 0.0f);

  00161	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  00164	83 c7 6c	 add	 edi, 108		; 0000006cH
  00167	8d 75 80	 lea	 esi, DWORD PTR $T1[ebp]
  0016a	a5		 movsd
  0016b	a5		 movsd
  0016c	a5		 movsd
  0016d	a5		 movsd

; 34   : 
; 35   : 	m_dwVertexCount = 0;

  0016e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00171	83 60 7c 00	 and	 DWORD PTR [eax+124], 0

; 36   : 	m_dwPrimitiveCount = 0;

  00175	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00178	83 a0 80 00 00
	00 00		 and	 DWORD PTR [eax+128], 0

; 37   : 	
; 38   : 	m_TriangleFanStructVector.clear();

  0017f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00188	e8 00 00 00 00	 call	 ?clear@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAEXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::clear

; 39   : 
; 40   : 	memset(m_Vertices, 0, sizeof(m_Vertices));

  0018d	68 00 18 00 00	 push	 6144			; 00001800H
  00192	6a 00		 push	 0
  00194	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00197	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0019c	50		 push	 eax
  0019d	e8 00 00 00 00	 call	 _memset
  001a2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 41   : 	memset(m_Indices, 0, sizeof(m_Indices));

  001a5	68 00 02 00 00	 push	 512			; 00000200H
  001aa	6a 00		 push	 0
  001ac	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001af	05 90 18 00 00	 add	 eax, 6288		; 00001890H
  001b4	50		 push	 eax
  001b5	e8 00 00 00 00	 call	 _memset
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 42   : }

  001bd	5f		 pop	 edi
  001be	5e		 pop	 esi
  001bf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c2	33 cd		 xor	 ecx, ebp
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	c9		 leave
  001ca	c3		 ret	 0
?Clear@CDecal@@QAEXXZ ENDP				; CDecal::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ??1CDecal@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDecal@@UAE@XZ PROC					; CDecal::~CDecal, COMDAT
; _this$ = ecx

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDecal@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDecal@@6B@

; 20   : 	Clear();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear

; 21   : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00040	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@AAEXXZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 21   : }

  00045	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004f	59		 pop	 ecx
  00050	c9		 leave
  00051	c3		 ret	 0
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDecal@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDecal@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDecal@@UAE@XZ ENDP					; CDecal::~CDecal
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp
;	COMDAT ??0CDecal@@QAE@XZ
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
___t$ = -28						; size = 4
___n$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDecal@@QAE@XZ PROC					; CDecal::CDecal, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDecal@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDecal@@6B@
  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00039	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0003c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00042	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  0004b	83 20 00	 and	 DWORD PTR [eax], 0
  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00051	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$2[ebp]
  00058	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Decal.cpp

; 14   : {

  0005c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	c7 45 e8 00 01
	00 00		 mov	 DWORD PTR ___n$[ebp], 256 ; 00000100H
  00067	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	05 90 00 00 00	 add	 eax, 144		; 00000090H
  0006f	89 45 e4	 mov	 DWORD PTR ___t$[ebp], eax
$LN36@CDecal:
  00072	8b 45 e8	 mov	 eax, DWORD PTR ___n$[ebp]
  00075	89 45 d8	 mov	 DWORD PTR tv72[ebp], eax
  00078	8b 45 e8	 mov	 eax, DWORD PTR ___n$[ebp]
  0007b	48		 dec	 eax
  0007c	89 45 e8	 mov	 DWORD PTR ___n$[ebp], eax
  0007f	83 7d d8 00	 cmp	 DWORD PTR tv72[ebp], 0
  00083	76 0b		 jbe	 SHORT $LN37@CDecal
  00085	8b 45 e4	 mov	 eax, DWORD PTR ___t$[ebp]
  00088	83 c0 18	 add	 eax, 24			; 00000018H
  0008b	89 45 e4	 mov	 DWORD PTR ___t$[ebp], eax
  0008e	eb e2		 jmp	 SHORT $LN36@CDecal
$LN37@CDecal:

; 13   : CDecal::CDecal():m_cfDecalEpsilon(0.25f)

  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e800000
  0009b	f3 0f 11 80 90
	1a 00 00	 movss	 DWORD PTR [eax+6800], xmm0

; 15   : 	Clear();

  000a3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?Clear@CDecal@@QAEXXZ	; CDecal::Clear

; 16   : }

  000ab	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bc	59		 pop	 ecx
  000bd	c9		 leave
  000be	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDecal@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  00009	e9 00 00 00 00	 jmp	 ??1?$vector@UTTRIANGLEFANSTRUCT@CDecal@@V?$allocator@UTTRIANGLEFANSTRUCT@CDecal@@@std@@@std@@QAE@XZ ; std::vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >::~vector<CDecal::TTRIANGLEFANSTRUCT,std::allocator<CDecal::TTRIANGLEFANSTRUCT> >
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
__ehhandler$??0CDecal@@QAE@XZ:
  00013	90		 npad	 1
  00014	90		 npad	 1
  00015	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00019	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001c	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDecal@@QAE@XZ
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDecal@@QAE@XZ ENDP					; CDecal::CDecal
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
