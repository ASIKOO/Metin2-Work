; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Type@CGraphicExpandedImageInstance@@SAKXZ	; CGraphicExpandedImageInstance::Type
PUBLIC	??0CGraphicExpandedImageInstance@@QAE@XZ	; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
PUBLIC	??1CGraphicExpandedImageInstance@@UAE@XZ	; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
PUBLIC	?Destroy@CGraphicExpandedImageInstance@@QAEXXZ	; CGraphicExpandedImageInstance::Destroy
PUBLIC	?SetDepth@CGraphicExpandedImageInstance@@QAEXM@Z ; CGraphicExpandedImageInstance::SetDepth
PUBLIC	?SetOrigin@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::SetOrigin
PUBLIC	?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z ; CGraphicExpandedImageInstance::SetOrigin
PUBLIC	?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z ; CGraphicExpandedImageInstance::SetRotation
PUBLIC	?SetScale@CGraphicExpandedImageInstance@@QAEXMM@Z ; CGraphicExpandedImageInstance::SetScale
PUBLIC	?SetRenderingRect@CGraphicExpandedImageInstance@@QAEXMMMM@Z ; CGraphicExpandedImageInstance::SetRenderingRect
PUBLIC	?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z ; CGraphicExpandedImageInstance::SetRenderingMode
PUBLIC	?Initialize@CGraphicExpandedImageInstance@@IAEXXZ ; CGraphicExpandedImageInstance::Initialize
PUBLIC	?OnRender@CGraphicExpandedImageInstance@@MAEXXZ	; CGraphicExpandedImageInstance::OnRender
PUBLIC	?OnSetImagePointer@CGraphicExpandedImageInstance@@MAEXXZ ; CGraphicExpandedImageInstance::OnSetImagePointer
PUBLIC	?OnIsType@CGraphicExpandedImageInstance@@MAEHK@Z ; CGraphicExpandedImageInstance::OnIsType
PUBLIC	?CreateSystem@CGraphicExpandedImageInstance@@SAXI@Z ; CGraphicExpandedImageInstance::CreateSystem
PUBLIC	?DestroySystem@CGraphicExpandedImageInstance@@SAXXZ ; CGraphicExpandedImageInstance::DestroySystem
PUBLIC	?New@CGraphicExpandedImageInstance@@SAPAV1@XZ	; CGraphicExpandedImageInstance::New
PUBLIC	?Delete@CGraphicExpandedImageInstance@@SAXPAV1@@Z ; CGraphicExpandedImageInstance::Delete
PUBLIC	??_GCGraphicExpandedImageInstance@@UAEPAXI@Z	; CGraphicExpandedImageInstance::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAE@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::CDynamicPool<CGraphicExpandedImageInstance>
PUBLIC	??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::~CDynamicPool<CGraphicExpandedImageInstance>
PUBLIC	?Destroy@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEXXZ ; CDynamicPool<CGraphicExpandedImageInstance>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@KAXPAVCGraphicExpandedImageInstance@@@Z ; CDynamicPool<CGraphicExpandedImageInstance>::Delete
PUBLIC	?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z ; std::allocator<CGraphicExpandedImageInstance *>::deallocate
PUBLIC	?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::reserve
PUBLIC	?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXPAPAVCGraphicExpandedImageInstance@@0@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicExpandedImageInstance@@@2@XZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Getal
PUBLIC	??_G?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z ; CDynamicPool<CGraphicExpandedImageInstance>::`scalar deleting destructor'
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicExpandedImageInstance@@@Z@std@@YAP6AXPAVCGraphicExpandedImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicExpandedImageInstance *> > >,void (__cdecl*)(CGraphicExpandedImageInstance *)>
PUBLIC	??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::emplace_back<CGraphicExpandedImageInstance * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXABQAVCGraphicExpandedImageInstance@@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicExpandedImageInstance * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_reallocate<CGraphicExpandedImageInstance * const &>
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
PUBLIC	??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
PUBLIC	??$_Copy_memmove@PAPAVCGraphicExpandedImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicExpandedImageInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicExpandedImageInstance * *,CGraphicExpandedImageInstance * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A ; CGraphicExpandedImageInstance::ms_kPool
PUBLIC	??_7CGraphicExpandedImageInstance@@6B@		; CGraphicExpandedImageInstance::`vftable'
PUBLIC	??_7?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@ ; CDynamicPool<CGraphicExpandedImageInstance>::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	??_C@_0BO@COPDODEE@CGraphicExpandedImageInstance@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4CGraphicExpandedImageInstance@@6B@		; CGraphicExpandedImageInstance::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGraphicExpandedImageInstance@@@8	; CGraphicExpandedImageInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicExpandedImageInstance@@8		; CGraphicExpandedImageInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicExpandedImageInstance@@8		; CGraphicExpandedImageInstance::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGraphicExpandedImageInstance@@8	; CGraphicExpandedImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CGraphicImageInstance@@8		; CGraphicImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCGraphicImageInstance@@@8		; CGraphicImageInstance `RTTI Type Descriptor'
PUBLIC	??_R3CGraphicImageInstance@@8			; CGraphicImageInstance::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGraphicImageInstance@@8			; CGraphicImageInstance::`RTTI Base Class Array'
PUBLIC	??_R4?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@ ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3c8efa35
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@437f0000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_cos:PROC
EXTRN	_sin:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z:PROC ; CGraphicBase::SetDefaultIndexBuffer
EXTRN	?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z:PROC ; CGraphicBase::SetPDTStream
EXTRN	?GetWidth@CGraphicTexture@@QBEHXZ:PROC		; CGraphicTexture::GetWidth
EXTRN	?GetHeight@CGraphicTexture@@QBEHXZ:PROC		; CGraphicTexture::GetHeight
EXTRN	?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ:PROC ; CGraphicTexture::GetD3DTexture
EXTRN	?GetWidth@CGraphicImage@@QBEHXZ:PROC		; CGraphicImage::GetWidth
EXTRN	?GetHeight@CGraphicImage@@QBEHXZ:PROC		; CGraphicImage::GetHeight
EXTRN	?GetRectReference@CGraphicImage@@QBEABUtagRECT@@XZ:PROC ; CGraphicImage::GetRectReference
EXTRN	?GetTexturePointer@CGraphicImage@@QAEPAVCGraphicTexture@@XZ:PROC ; CGraphicImage::GetTexturePointer
EXTRN	?IsType@CGraphicImageInstance@@QAEHK@Z:PROC	; CGraphicImageInstance::IsType
EXTRN	??0CGraphicImageInstance@@QAE@XZ:PROC		; CGraphicImageInstance::CGraphicImageInstance
EXTRN	??1CGraphicImageInstance@@UAE@XZ:PROC		; CGraphicImageInstance::~CGraphicImageInstance
EXTRN	?Destroy@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Destroy
EXTRN	?IsEmpty@CGraphicImageInstance@@QBE_NXZ:PROC	; CGraphicImageInstance::IsEmpty
EXTRN	?GetWidth@CGraphicImageInstance@@QAEHXZ:PROC	; CGraphicImageInstance::GetWidth
EXTRN	?GetHeight@CGraphicImageInstance@@QAEHXZ:PROC	; CGraphicImageInstance::GetHeight
EXTRN	??_ECGraphicExpandedImageInstance@@UAEPAXI@Z:PROC ; CGraphicExpandedImageInstance::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z:PROC ; CDynamicPool<CGraphicExpandedImageInstance>::`vector deleting destructor'
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z:PROC ; CStateManager::SetTexture
EXTRN	?SetVertexShader@CStateManager@@QAEXK@Z:PROC	; CStateManager::SetVertexShader
EXTRN	?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z:PROC ; CStateManager::DrawIndexedPrimitive
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__ftoui3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_BSS	SEGMENT
?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A DB 024H DUP (?) ; CGraphicExpandedImageInstance::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_dwType@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4KA
_BSS	SEGMENT
?s_dwType@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4KA DD 01H DUP (?) ; `CGraphicExpandedImageInstance::Type'::`2'::s_dwType
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA DD 01H DUP (?) ; `CGraphicExpandedImageInstance::Type'::`2'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CGraphicExpandedImageInstance@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CGraphicExpandedImageInstance@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@437f0000
CONST	SEGMENT
__real@437f0000 DD 0437f0000r			; 255
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3c8efa35
CONST	SEGMENT
__real@3c8efa35 DD 03c8efa35r			; 0.0174533
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8 DD 00H ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CGraphicExpandedImageInstance> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@ DD 00H ; CDynamicPool<CGraphicExpandedImageInstance>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCGraphicExpandedImageInstance@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCGraphicExpandedImageInstance@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R2CGraphicImageInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicImageInstance@@8 ; CGraphicImageInstance::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R3CGraphicImageInstance@@8 DD 00H			; CGraphicImageInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicImageInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicImageInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicImageInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicImageInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicImageInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicImageInstance@@8 DD FLAT:??_R0?AVCGraphicImageInstance@@@8 ; CGraphicImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGraphicExpandedImageInstance@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGraphicExpandedImageInstance@@8 DD FLAT:??_R0?AVCGraphicExpandedImageInstance@@@8 ; CGraphicExpandedImageInstance::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGraphicExpandedImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R2CGraphicExpandedImageInstance@@8
rdata$r	SEGMENT
??_R2CGraphicExpandedImageInstance@@8 DD FLAT:??_R1A@?0A@EA@CGraphicExpandedImageInstance@@8 ; CGraphicExpandedImageInstance::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CGraphicImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R3CGraphicExpandedImageInstance@@8
rdata$r	SEGMENT
??_R3CGraphicExpandedImageInstance@@8 DD 00H		; CGraphicExpandedImageInstance::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CGraphicExpandedImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGraphicExpandedImageInstance@@@8
data$rs	SEGMENT
??_R0?AVCGraphicExpandedImageInstance@@@8 DD FLAT:??_7type_info@@6B@ ; CGraphicExpandedImageInstance `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGraphicExpandedImageInstance@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGraphicExpandedImageInstance@@6B@
rdata$r	SEGMENT
??_R4CGraphicExpandedImageInstance@@6B@ DD 00H		; CGraphicExpandedImageInstance::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGraphicExpandedImageInstance@@@8
	DD	FLAT:??_R3CGraphicExpandedImageInstance@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@COPDODEE@CGraphicExpandedImageInstance@
CONST	SEGMENT
??_C@_0BO@COPDODEE@CGraphicExpandedImageInstance@ DB 'CGraphicExpandedIma'
	DB	'geInstance', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@ ; CDynamicPool<CGraphicExpandedImageInstance>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CGraphicExpandedImageInstance@@6B@
CONST	SEGMENT
??_7CGraphicExpandedImageInstance@@6B@ DD FLAT:??_R4CGraphicExpandedImageInstance@@6B@ ; CGraphicExpandedImageInstance::`vftable'
	DD	FLAT:??_ECGraphicExpandedImageInstance@@UAEPAXI@Z
	DD	FLAT:?OnRender@CGraphicExpandedImageInstance@@MAEXXZ
	DD	FLAT:?OnSetImagePointer@CGraphicExpandedImageInstance@@MAEXXZ
	DD	FLAT:?OnIsType@CGraphicExpandedImageInstance@@MAEHK@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$11
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CGraphicExpandedImageInstance@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CGraphicExpandedImageInstance@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CGraphicExpandedImageInstance@@QAE@XZ$0
__ehfuncinfo$??0CGraphicExpandedImageInstance@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CGraphicExpandedImageInstance@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Type@CGraphicExpandedImageInstance@@SAKXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Type@CGraphicExpandedImageInstance@@SAKXZ$0
__ehfuncinfo$?Type@CGraphicExpandedImageInstance@@SAKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Type@CGraphicExpandedImageInstance@@SAKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCGraphicExpandedImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicExpandedImageInstance@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCGraphicExpandedImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicExpandedImageInstance@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CGraphicExpandedImageInstance * *,CGraphicExpandedImageInstance * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCGraphicExpandedImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicExpandedImageInstance@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CGraphicExpandedImageInstance * *,CGraphicExpandedImageInstance * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z PROC ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCGraphicExpandedImageInstance@@PAPAV1@@std@@YAPAPAVCGraphicExpandedImageInstance@@PAPAV1@00@Z ; std::_Copy_memmove<CGraphicExpandedImageInstance * *,CGraphicExpandedImageInstance * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ENDP ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_reallocate<CGraphicExpandedImageInstance * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@ABEII@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXPAPAVCGraphicExpandedImageInstance@@0@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z ; std::allocator<CGraphicExpandedImageInstance *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_reallocate<CGraphicExpandedImageInstance * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXABQAVCGraphicExpandedImageInstance@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXABQAVCGraphicExpandedImageInstance@@@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicExpandedImageInstance * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXABQAVCGraphicExpandedImageInstance@@@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicExpandedImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::emplace_back<CGraphicExpandedImageInstance * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXABQAVCGraphicExpandedImageInstance@@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_back_with_unused_capacity<CGraphicExpandedImageInstance * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEPAPAVCGraphicExpandedImageInstance@@QAPAV2@ABQAV2@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Emplace_reallocate<CGraphicExpandedImageInstance * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::emplace_back<CGraphicExpandedImageInstance * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicExpandedImageInstance@@@Z@std@@YAP6AXPAVCGraphicExpandedImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicExpandedImageInstance@@@Z@std@@YAP6AXPAVCGraphicExpandedImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicExpandedImageInstance *> > >,void (__cdecl*)(CGraphicExpandedImageInstance *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicExpandedImageInstance@@@Z@std@@YAP6AXPAVCGraphicExpandedImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicExpandedImageInstance *> > >,void (__cdecl*)(CGraphicExpandedImageInstance *)>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CGraphicExpandedImageInstance::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A ; CGraphicExpandedImageInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::~CDynamicPool<CGraphicExpandedImageInstance>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CGraphicExpandedImageInstance::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ??__E?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CGraphicExpandedImageInstance::ms_kPool'', COMDAT

; 6    : CDynamicPool<CGraphicExpandedImageInstance>		CGraphicExpandedImageInstance::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A ; CGraphicExpandedImageInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAE@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::CDynamicPool<CGraphicExpandedImageInstance>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CGraphicExpandedImageInstance::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CGraphicExpandedImageInstance::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z PROC ; CDynamicPool<CGraphicExpandedImageInstance>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::~CDynamicPool<CGraphicExpandedImageInstance>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAEPAXI@Z ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicExpandedImageInstance@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicExpandedImageInstance@@@2@XZ PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicExpandedImageInstance@@@2@XZ ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@ABEII@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@ABEII@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXPAPAVCGraphicExpandedImageInstance@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXPAPAVCGraphicExpandedImageInstance@@0@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXPAPAVCGraphicExpandedImageInstance@@0@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAXPAPAVCGraphicExpandedImageInstance@@QAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Destroy_range<std::allocator<CGraphicExpandedImageInstance *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
tv81 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
__My_data$10 = -8					; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR $T7[ebp]
  00026	76 62		 jbe	 SHORT $LN4@reserve

; 1737 :         return _Mypair._Get_first();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00031	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00034	c7 45 f4 ff ff
	ff 3f		 mov	 DWORD PTR $T9[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0003b	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00045	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00048	8b 45 f4	 mov	 eax, DWORD PTR $T9[ebp]
  0004b	3b 45 f0	 cmp	 eax, DWORD PTR $T8[ebp]
  0004e	73 08		 jae	 SHORT $LN25@reserve
  00050	8d 45 f4	 lea	 eax, DWORD PTR $T9[ebp]
  00053	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  00056	eb 06		 jmp	 SHORT $LN26@reserve
$LN25@reserve:
  00058	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN26@reserve:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR tv81[ebp]
  00061	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00064	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00067	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0006a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1307 :             if (_Newcapacity > max_size()) {

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00075	3b 45 d4	 cmp	 eax, DWORD PTR $T2[ebp]
  00078	76 05		 jbe	 SHORT $LN3@reserve

; 1308 :                 _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@CAXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Xlength
$LN3@reserve:

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0007f	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Reallocate_exactly
$LN4@reserve:

; 1312 :         }
; 1313 :     }

  0008a	c9		 leave
  0008b	c2 04 00	 ret	 4
?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$2 = -80					; size = 4
$T3 = -76						; size = 4
__Size$ = -72						; size = 4
__First$ = -68						; size = 4
__Last$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
__Myfirst$ = -44					; size = 4
__Mylast$ = -40						; size = 4
__My_data$ = -36					; size = 4
__Newvec$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$ = -24					; size = 1
__Overflow_is_possible$8 = -18				; size = 1
$T9 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z PROC ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1254 :         pointer& _Myfirst = _My_data._Myfirst;

  00035	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	89 45 d4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1255 :         pointer& _Mylast  = _My_data._Mylast;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 d8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00044	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004e	c1 f8 02	 sar	 eax, 2
  00051	89 45 b8	 mov	 DWORD PTR __Size$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00057	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00060	c6 45 ee 01	 mov	 BYTE PTR __Overflow_is_possible$8[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00064	c7 45 b0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0006b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00072	76 05		 jbe	 SHORT $LN17@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00074	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN17@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0008a	59		 pop	 ecx
  0008b	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1261 :         _TRY_BEGIN

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00092	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  000a2	33 c0		 xor	 eax, eax
  000a4	88 45 ef	 mov	 BYTE PTR $T9[ebp], al
  000a7	8a 45 ef	 mov	 al, BYTE PTR $T9[ebp]
  000aa	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b0	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000b9	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000bc	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000bf	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  000c2	ff 75 bc	 push	 DWORD PTR __First$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@YAPAPAVCGraphicExpandedImageInstance@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCGraphicExpandedImageInstance@@@0@@Z ; std::_Uninitialized_move<CGraphicExpandedImageInstance * *,std::allocator<CGraphicExpandedImageInstance *> >
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000cd	eb 24		 jmp	 SHORT $LN4@Reallocate
__catch$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$0:

; 1263 :         _CATCH_ALL
; 1264 :         _Getal().deallocate(_Newvec, _Newcapacity);

  000cf	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  000d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEAAV?$allocator@PAVCGraphicExpandedImageInstance@@@2@XZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Getal
  000dd	8b c8		 mov	 ecx, eax
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z ; std::allocator<CGraphicExpandedImageInstance *>::deallocate

; 1265 :         _RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1266 :         _CATCH_END

  000ed	b8 00 00 00 00	 mov	 eax, $LN7@Reallocate
  000f2	c3		 ret	 0
$LN4@Reallocate:
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 04		 jmp	 SHORT __tryend$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$1
$LN7@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  000f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1267 : 
; 1268 :         _Change_array(_Newvec, _Size, _Newcapacity);

  000fd	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00100	ff 75 b8	 push	 DWORD PTR __Size$[ebp]
  00103	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXQAPAVCGraphicExpandedImageInstance@@II@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Change_array
$LN20@Reallocate:

; 1269 :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	c9		 leave
  0011d	c2 04 00	 ret	 4
  00120	cc		 int	 3
  00121	cc		 int	 3
  00122	cc		 int	 3
  00123	cc		 int	 3
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Reallocate_exactly
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z PROC ; std::allocator<CGraphicExpandedImageInstance *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCGraphicExpandedImageInstance@@@std@@QAEXQAPAVCGraphicExpandedImageInstance@@I@Z ENDP ; std::allocator<CGraphicExpandedImageInstance *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@KAXPAVCGraphicExpandedImageInstance@@@Z
_TEXT	SEGMENT
tv74 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@KAXPAVCGraphicExpandedImageInstance@@@Z PROC ; CDynamicPool<CGraphicExpandedImageInstance>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@KAXPAVCGraphicExpandedImageInstance@@@Z ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ PROC ; CDynamicPool<CGraphicExpandedImageInstance>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 57		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	6a 4c		 push	 76			; 0000004cH
  0005b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00060	59		 pop	 ecx
  00061	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00068	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006c	74 0d		 je	 SHORT $LN4@Alloc
  0006e	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00071	e8 00 00 00 00	 call	 ??0CGraphicExpandedImageInstance@@QAE@XZ ; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
  00076	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  00079	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007b	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  0007f	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00082	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00085	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00089	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008c	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0008f	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00092	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00099	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::emplace_back<CGraphicExpandedImageInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  0009e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a4	40		 inc	 eax
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ab	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000ae	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 10	 add	 eax, 16			; 00000010H
  000b6	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000b9	6a 04		 push	 4
  000bb	58		 pop	 eax
  000bc	6b c0 ff	 imul	 eax, eax, -1
  000bf	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c2	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c5	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000c8	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	83 c0 10	 add	 eax, 16			; 00000010H
  000d6	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000df	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000e8	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	83 e8 04	 sub	 eax, 4
  000f0	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f3	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f6	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000fc	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ff	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00105	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  00108	8b 00		 mov	 eax, DWORD PTR [eax]
  0010a	83 e8 04	 sub	 eax, 4
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00110	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 73   : 			return pkFreeData;

  00112	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00115	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00118	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011f	59		 pop	 ecx
  00120	c9		 leave
  00121	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ$0:
  00000	6a 4c		 push	 76			; 0000004cH
  00002	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEXXZ PROC ; CDynamicPool<CGraphicExpandedImageInstance>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@KAXPAVCGraphicExpandedImageInstance@@@Z ; CDynamicPool<CGraphicExpandedImageInstance>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@std@@P6AXPAVCGraphicExpandedImageInstance@@@Z@std@@YAP6AXPAVCGraphicExpandedImageInstance@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGraphicExpandedImageInstance@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CGraphicExpandedImageInstance *> > >,void (__cdecl*)(CGraphicExpandedImageInstance *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEXXZ ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ PROC ; CDynamicPool<CGraphicExpandedImageInstance>::~CDynamicPool<CGraphicExpandedImageInstance>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@AAEXXZ ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCGraphicExpandedImageInstance@@@@UAE@XZ ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::~CDynamicPool<CGraphicExpandedImageInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAE@XZ PROC ; CDynamicPool<CGraphicExpandedImageInstance>::CDynamicPool<CGraphicExpandedImageInstance>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCGraphicExpandedImageInstance@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAE@XZ ENDP ; CDynamicPool<CGraphicExpandedImageInstance>::CDynamicPool<CGraphicExpandedImageInstance>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGraphicExpandedImageInstance@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGraphicExpandedImageInstance@@UAEPAXI@Z PROC	; CGraphicExpandedImageInstance::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGraphicExpandedImageInstance@@UAE@XZ ; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 4c		 push	 76			; 0000004cH
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCGraphicExpandedImageInstance@@UAEPAXI@Z ENDP	; CGraphicExpandedImageInstance::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?Delete@CGraphicExpandedImageInstance@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkImgInst$ = 8						; size = 4
?Delete@CGraphicExpandedImageInstance@@SAXPAV1@@Z PROC	; CGraphicExpandedImageInstance::Delete, COMDAT

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 25   : 	pkImgInst->Destroy();

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _pkImgInst$[ebp]
  00007	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy

; 26   : 	ms_kPool.Free(pkImgInst);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkImgInst$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00015	50		 push	 eax
  00016	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A+16
  0001b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCGraphicExpandedImageInstance@@@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXABQAVCGraphicExpandedImageInstance@@@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::emplace_back<CGraphicExpandedImageInstance * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 27   : }

  00020	c9		 leave
  00021	c3		 ret	 0
?Delete@CGraphicExpandedImageInstance@@SAXPAV1@@Z ENDP	; CGraphicExpandedImageInstance::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?New@CGraphicExpandedImageInstance@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CGraphicExpandedImageInstance@@SAPAV1@XZ PROC	; CGraphicExpandedImageInstance::New, COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 20   : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A ; CGraphicExpandedImageInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEPAVCGraphicExpandedImageInstance@@XZ ; CDynamicPool<CGraphicExpandedImageInstance>::Alloc

; 21   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CGraphicExpandedImageInstance@@SAPAV1@XZ ENDP	; CGraphicExpandedImageInstance::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?DestroySystem@CGraphicExpandedImageInstance@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CGraphicExpandedImageInstance@@SAXXZ PROC ; CGraphicExpandedImageInstance::DestroySystem, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	ms_kPool.Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A ; CGraphicExpandedImageInstance::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCGraphicExpandedImageInstance@@@@QAEXXZ ; CDynamicPool<CGraphicExpandedImageInstance>::Destroy

; 16   : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CGraphicExpandedImageInstance@@SAXXZ ENDP ; CGraphicExpandedImageInstance::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?CreateSystem@CGraphicExpandedImageInstance@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CGraphicExpandedImageInstance@@SAXI@Z PROC ; CGraphicExpandedImageInstance::CreateSystem, COMDAT

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  00003	8b 45 08	 mov	 eax, DWORD PTR _uCapacity$[ebp]
  00006	a3 1c 00 00 00	 mov	 DWORD PTR ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A+28, eax

; 58   : 			m_kVct_pkData.reserve(uCapacity);

  0000b	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0000e	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A+4
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::reserve

; 59   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0001b	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CGraphicExpandedImageInstance@@2V?$CDynamicPool@VCGraphicExpandedImageInstance@@@@A+16
  00020	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCGraphicExpandedImageInstance@@V?$allocator@PAVCGraphicExpandedImageInstance@@@std@@@std@@QAEXI@Z ; std::vector<CGraphicExpandedImageInstance *,std::allocator<CGraphicExpandedImageInstance *> >::reserve
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 11   : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?CreateSystem@CGraphicExpandedImageInstance@@SAXI@Z ENDP ; CGraphicExpandedImageInstance::CreateSystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?OnIsType@CGraphicExpandedImageInstance@@MAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwType$ = 8						; size = 4
?OnIsType@CGraphicExpandedImageInstance@@MAEHK@Z PROC	; CGraphicExpandedImageInstance::OnIsType, COMDAT
; _this$ = ecx

; 205  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 206  : 	if (CGraphicExpandedImageInstance::Type() == dwType)

  00007	e8 00 00 00 00	 call	 ?Type@CGraphicExpandedImageInstance@@SAKXZ ; CGraphicExpandedImageInstance::Type
  0000c	3b 45 08	 cmp	 eax, DWORD PTR _dwType$[ebp]
  0000f	75 05		 jne	 SHORT $LN2@OnIsType

; 207  : 		return TRUE;

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	eb 0b		 jmp	 SHORT $LN1@OnIsType
$LN2@OnIsType:

; 208  : 
; 209  : 	return CGraphicImageInstance::IsType(dwType);

  00016	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?IsType@CGraphicImageInstance@@QAEHK@Z ; CGraphicImageInstance::IsType
$LN1@OnIsType:

; 210  : }

  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?OnIsType@CGraphicExpandedImageInstance@@MAEHK@Z ENDP	; CGraphicExpandedImageInstance::OnIsType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?OnSetImagePointer@CGraphicExpandedImageInstance@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnSetImagePointer@CGraphicExpandedImageInstance@@MAEXXZ PROC ; CGraphicExpandedImageInstance::OnSetImagePointer, COMDAT
; _this$ = ecx

; 197  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 198  : 	if (IsEmpty())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	74 02		 je	 SHORT $LN2@OnSetImage

; 199  : 		return;

  00016	eb 3c		 jmp	 SHORT $LN1@OnSetImage
$LN2@OnSetImage:

; 200  : 
; 201  : 	SetOrigin(float(GetWidth()) / 2.0f, float(GetHeight()) / 2.0f);

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00020	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00024	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0002c	51		 push	 ecx
  0002d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  0003a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0003e	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00046	51		 push	 ecx
  00047	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z ; CGraphicExpandedImageInstance::SetOrigin
$LN1@OnSetImage:

; 202  : }

  00054	c9		 leave
  00055	c3		 ret	 0
?OnSetImagePointer@CGraphicExpandedImageInstance@@MAEXXZ ENDP ; CGraphicExpandedImageInstance::OnSetImagePointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?OnRender@CGraphicExpandedImageInstance@@MAEXXZ
_TEXT	SEGMENT
$T1 = -492						; size = 4
$T2 = -488						; size = 8
$T3 = -480						; size = 8
$T4 = -472						; size = 8
$T5 = -464						; size = 8
$T6 = -456						; size = 4
$T7 = -452						; size = 4
$T8 = -448						; size = 4
$T9 = -444						; size = 4
$T10 = -440						; size = 4
$T11 = -436						; size = 4
_dwB$12 = -432						; size = 4
$T13 = -428						; size = 4
$T14 = -424						; size = 4
$T15 = -420						; size = 4
$T16 = -416						; size = 4
$T17 = -412						; size = 4
$T18 = -408						; size = 4
$T19 = -404						; size = 4
$T20 = -400						; size = 4
$T21 = -396						; size = 4
$T22 = -392						; size = 4
tv818 = -388						; size = 4
_dwA$23 = -384						; size = 4
_dwR$24 = -380						; size = 4
_dwG$25 = -376						; size = 4
_dwB$26 = -372						; size = 4
_dwA$27 = -368						; size = 4
_dwR$28 = -364						; size = 4
_dwG$29 = -360						; size = 4
_dwB$30 = -356						; size = 4
_dwA$31 = -352						; size = 4
_dwR$32 = -348						; size = 4
_dwG$33 = -344						; size = 4
_dwB$34 = -340						; size = 4
_dwA$35 = -336						; size = 4
_dwR$36 = -332						; size = 4
_dwG$37 = -328						; size = 4
_texReverseWidth$ = -324				; size = 4
tv800 = -320						; size = 4
_fimgHeight$38 = -316					; size = 4
_fimgWidth$39 = -312					; size = 4
tv1038 = -308						; size = 4
tv1037 = -304						; size = 4
tv1027 = -300						; size = 4
tv1026 = -296						; size = 4
tv1016 = -292						; size = 4
tv1015 = -288						; size = 4
tv1005 = -284						; size = 4
tv1004 = -280						; size = 4
_ev$ = -276						; size = 4
_eu$ = -272						; size = 4
tv990 = -268						; size = 4
tv989 = -264						; size = 4
tv979 = -260						; size = 4
tv978 = -256						; size = 4
tv968 = -252						; size = 4
tv967 = -248						; size = 4
tv957 = -244						; size = 4
tv956 = -240						; size = 4
_su$ = -236						; size = 4
tv942 = -232						; size = 4
tv941 = -228						; size = 4
tv931 = -224						; size = 4
tv930 = -220						; size = 4
tv888 = -216						; size = 4
tv887 = -212						; size = 4
tv877 = -208						; size = 4
tv876 = -204						; size = 4
_sv$ = -200						; size = 4
tv862 = -196						; size = 4
tv861 = -192						; size = 4
tv851 = -188						; size = 4
tv850 = -184						; size = 4
tv840 = -180						; size = 4
tv839 = -176						; size = 4
tv829 = -172						; size = 4
tv822 = -168						; size = 4
___t$ = -164						; size = 4
_texReverseHeight$ = -160				; size = 4
_pTexture$ = -156					; size = 4
tv749 = -152						; size = 4
___n$ = -148						; size = 4
_pImage$ = -144						; size = 4
_i$40 = -140						; size = 4
_fimgHalfHeight$41 = -136				; size = 4
_fimgHalfWidth$42 = -132				; size = 4
_c_rRect$ = -128					; size = 4
_this$ = -124						; size = 4
_this$ = -120						; size = 4
_this$ = -116						; size = 4
_this$ = -112						; size = 4
_fRadian$43 = -108					; size = 4
_this$ = -104						; size = 4
_vertices$ = -100					; size = 96
__$ArrayPad$ = -4					; size = 4
?OnRender@CGraphicExpandedImageInstance@@MAEXXZ PROC	; CGraphicExpandedImageInstance::OnRender, COMDAT
; _this$ = ecx

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec ec 01 00
	00		 sub	 esp, 492		; 000001ecH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	56		 push	 esi
  00014	89 4d 98	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\Ref.h

; 80   : 			return static_cast<T*>(m_pObject);

  00017	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0001d	89 85 70 ff ff
	ff		 mov	 DWORD PTR _pImage$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 32   : 	CGraphicTexture * pTexture = pImage->GetTexturePointer();

  00023	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  00029	e8 00 00 00 00	 call	 ?GetTexturePointer@CGraphicImage@@QAEPAVCGraphicTexture@@XZ ; CGraphicImage::GetTexturePointer
  0002e	89 85 64 ff ff
	ff		 mov	 DWORD PTR _pTexture$[ebp], eax

; 33   : 
; 34   : 	const RECT& c_rRect = pImage->GetRectReference();

  00034	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetRectReference@CGraphicImage@@QBEABUtagRECT@@XZ ; CGraphicImage::GetRectReference
  0003f	89 45 80	 mov	 DWORD PTR _c_rRect$[ebp], eax

; 35   : 	float texReverseWidth = 1.0f / float(pTexture->GetWidth());

  00042	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pTexture$[ebp]
  00048	e8 00 00 00 00	 call	 ?GetWidth@CGraphicTexture@@QBEHXZ ; CGraphicTexture::GetWidth
  0004d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00051	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  00059	f3 0f 5e c8	 divss	 xmm1, xmm0
  0005d	f3 0f 11 8d bc
	fe ff ff	 movss	 DWORD PTR _texReverseWidth$[ebp], xmm1

; 36   : 	float texReverseHeight = 1.0f / float(pTexture->GetHeight());

  00065	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pTexture$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetHeight@CGraphicTexture@@QBEHXZ ; CGraphicTexture::GetHeight
  00070	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00074	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  0007c	f3 0f 5e c8	 divss	 xmm1, xmm0
  00080	f3 0f 11 8d 60
	ff ff ff	 movss	 DWORD PTR _texReverseHeight$[ebp], xmm1

; 37   : 	float su = (c_rRect.left - m_RenderingRect.left) * texReverseWidth;

  00088	8b 45 80	 mov	 eax, DWORD PTR _c_rRect$[ebp]
  0008b	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	2b 41 38	 sub	 eax, DWORD PTR [ecx+56]
  00093	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00097	f3 0f 59 85 bc
	fe ff ff	 mulss	 xmm0, DWORD PTR _texReverseWidth$[ebp]
  0009f	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _su$[ebp], xmm0

; 38   : 	float sv = (c_rRect.top - m_RenderingRect.top) * texReverseHeight;

  000a7	8b 45 80	 mov	 eax, DWORD PTR _c_rRect$[ebp]
  000aa	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  000ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b0	2b 41 3c	 sub	 eax, DWORD PTR [ecx+60]
  000b3	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000b7	f3 0f 59 85 60
	ff ff ff	 mulss	 xmm0, DWORD PTR _texReverseHeight$[ebp]
  000bf	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR _sv$[ebp], xmm0

; 39   : 	float eu = (c_rRect.left + m_RenderingRect.right + (c_rRect.right-c_rRect.left)) * texReverseWidth;

  000c7	8b 45 80	 mov	 eax, DWORD PTR _c_rRect$[ebp]
  000ca	8b 00		 mov	 eax, DWORD PTR [eax]
  000cc	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  000cf	03 41 40	 add	 eax, DWORD PTR [ecx+64]
  000d2	8b 4d 80	 mov	 ecx, DWORD PTR _c_rRect$[ebp]
  000d5	8b 55 80	 mov	 edx, DWORD PTR _c_rRect$[ebp]
  000d8	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000db	2b 0a		 sub	 ecx, DWORD PTR [edx]
  000dd	03 c1		 add	 eax, ecx
  000df	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e3	f3 0f 59 85 bc
	fe ff ff	 mulss	 xmm0, DWORD PTR _texReverseWidth$[ebp]
  000eb	f3 0f 11 85 f0
	fe ff ff	 movss	 DWORD PTR _eu$[ebp], xmm0

; 40   : 	float ev = (c_rRect.top + m_RenderingRect.bottom + (c_rRect.bottom-c_rRect.top)) * texReverseHeight;

  000f3	8b 45 80	 mov	 eax, DWORD PTR _c_rRect$[ebp]
  000f6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000f9	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  000ff	8b 4d 80	 mov	 ecx, DWORD PTR _c_rRect$[ebp]
  00102	8b 55 80	 mov	 edx, DWORD PTR _c_rRect$[ebp]
  00105	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00108	2b 4a 04	 sub	 ecx, DWORD PTR [edx+4]
  0010b	03 c1		 add	 eax, ecx
  0010d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00111	f3 0f 59 85 60
	ff ff ff	 mulss	 xmm0, DWORD PTR _texReverseHeight$[ebp]
  00119	f3 0f 11 85 ec
	fe ff ff	 movss	 DWORD PTR _ev$[ebp], xmm0

; 41   : 
; 42   : 	TPDTVertex vertices[4];	

  00121	c7 85 6c ff ff
	ff 04 00 00 00	 mov	 DWORD PTR ___n$[ebp], 4
  0012b	8d 45 9c	 lea	 eax, DWORD PTR _vertices$[ebp]
  0012e	89 85 5c ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
$LN22@OnRender:
  00134	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  0013a	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv818[ebp], eax
  00140	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR ___n$[ebp]
  00146	48		 dec	 eax
  00147	89 85 6c ff ff
	ff		 mov	 DWORD PTR ___n$[ebp], eax
  0014d	83 bd 7c fe ff
	ff 00		 cmp	 DWORD PTR tv818[ebp], 0
  00154	76 11		 jbe	 SHORT $LN23@OnRender
  00156	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR ___t$[ebp]
  0015c	83 c0 18	 add	 eax, 24			; 00000018H
  0015f	89 85 5c ff ff
	ff		 mov	 DWORD PTR ___t$[ebp], eax
  00165	eb cd		 jmp	 SHORT $LN22@OnRender
$LN23@OnRender:

; 43   : 	vertices[0].position.x	= m_v2Position.x-0.5f;

  00167	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  0016a	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  0016f	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  00177	6a 18		 push	 24			; 00000018H
  00179	58		 pop	 eax
  0017a	6b c0 00	 imul	 eax, eax, 0
  0017d	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 44   : 	vertices[0].position.y	= m_v2Position.y-0.5f;

  00183	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00186	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  0018b	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  00193	6a 18		 push	 24			; 00000018H
  00195	58		 pop	 eax
  00196	6b c0 00	 imul	 eax, eax, 0
  00199	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 45   : 	vertices[0].position.z	= m_fDepth;

  0019f	6a 18		 push	 24			; 00000018H
  001a1	58		 pop	 eax
  001a2	6b c0 00	 imul	 eax, eax, 0
  001a5	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  001a8	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  001ab	89 4c 05 a4	 mov	 DWORD PTR _vertices$[ebp+eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 41   :     x = fx;

  001af	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _su$[ebp]
  001b7	f3 0f 11 85 30
	fe ff ff	 movss	 DWORD PTR $T5[ebp], xmm0

; 42   :     y = fy;

  001bf	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _sv$[ebp]
  001c7	f3 0f 11 85 34
	fe ff ff	 movss	 DWORD PTR $T5[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 46   : 	vertices[0].texCoord	= TTextureCoordinate(su, sv);

  001cf	8b 85 30 fe ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  001d5	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR $T5[ebp+4]
  001db	6a 18		 push	 24			; 00000018H
  001dd	5a		 pop	 edx
  001de	6b d2 00	 imul	 edx, edx, 0
  001e1	89 44 15 ac	 mov	 DWORD PTR _vertices$[ebp+edx+16], eax
  001e5	89 4c 15 b0	 mov	 DWORD PTR _vertices$[ebp+edx+20], ecx

; 47   : 	vertices[0].diffuse		= m_DiffuseColor;

  001e9	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 90	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  001f2	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  001f5	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001f9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00200	72 0c		 jb	 SHORT $LN37@OnRender
  00202	c7 85 54 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv829[ebp], 255 ; 000000ffH
  0020c	eb 42		 jmp	 SHORT $LN38@OnRender
$LN37@OnRender:
  0020e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00211	0f 57 c0	 xorps	 xmm0, xmm0
  00214	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00217	72 09		 jb	 SHORT $LN35@OnRender
  00219	83 a5 58 ff ff
	ff 00		 and	 DWORD PTR tv822[ebp], 0
  00220	eb 22		 jmp	 SHORT $LN36@OnRender
$LN35@OnRender:
  00222	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00225	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00229	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00231	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00239	e8 00 00 00 00	 call	 __ftoui3
  0023e	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv822[ebp], eax
$LN36@OnRender:
  00244	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv822[ebp]
  0024a	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv829[ebp], eax
$LN38@OnRender:
  00250	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv829[ebp]
  00256	89 85 b4 fe ff
	ff		 mov	 DWORD PTR _dwR$36[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0025c	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0025f	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00264	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0026b	72 0c		 jb	 SHORT $LN41@OnRender
  0026d	c7 85 4c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv840[ebp], 255 ; 000000ffH
  00277	eb 44		 jmp	 SHORT $LN42@OnRender
$LN41@OnRender:
  00279	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	0f 57 c0	 xorps	 xmm0, xmm0
  0027f	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00283	72 09		 jb	 SHORT $LN39@OnRender
  00285	83 a5 50 ff ff
	ff 00		 and	 DWORD PTR tv839[ebp], 0
  0028c	eb 23		 jmp	 SHORT $LN40@OnRender
$LN39@OnRender:
  0028e	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00291	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00296	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0029e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  002a6	e8 00 00 00 00	 call	 __ftoui3
  002ab	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv839[ebp], eax
$LN40@OnRender:
  002b1	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv839[ebp]
  002b7	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv840[ebp], eax
$LN42@OnRender:
  002bd	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv840[ebp]
  002c3	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _dwG$37[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  002c9	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  002cc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002d1	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  002d8	72 0c		 jb	 SHORT $LN45@OnRender
  002da	c7 85 44 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv851[ebp], 255 ; 000000ffH
  002e4	eb 44		 jmp	 SHORT $LN46@OnRender
$LN45@OnRender:
  002e6	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  002e9	0f 57 c0	 xorps	 xmm0, xmm0
  002ec	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  002f0	72 09		 jb	 SHORT $LN43@OnRender
  002f2	83 a5 48 ff ff
	ff 00		 and	 DWORD PTR tv850[ebp], 0
  002f9	eb 23		 jmp	 SHORT $LN44@OnRender
$LN43@OnRender:
  002fb	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  002fe	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00303	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0030b	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00313	e8 00 00 00 00	 call	 __ftoui3
  00318	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv850[ebp], eax
$LN44@OnRender:
  0031e	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv850[ebp]
  00324	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv851[ebp], eax
$LN46@OnRender:
  0032a	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv851[ebp]
  00330	89 85 ac fe ff
	ff		 mov	 DWORD PTR _dwB$34[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00336	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00339	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  0033e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00345	72 0c		 jb	 SHORT $LN49@OnRender
  00347	c7 85 3c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv862[ebp], 255 ; 000000ffH
  00351	eb 44		 jmp	 SHORT $LN50@OnRender
$LN49@OnRender:
  00353	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  00356	0f 57 c0	 xorps	 xmm0, xmm0
  00359	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0035d	72 09		 jb	 SHORT $LN47@OnRender
  0035f	83 a5 40 ff ff
	ff 00		 and	 DWORD PTR tv861[ebp], 0
  00366	eb 23		 jmp	 SHORT $LN48@OnRender
$LN47@OnRender:
  00368	8b 45 90	 mov	 eax, DWORD PTR _this$[ebp]
  0036b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00370	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00378	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00380	e8 00 00 00 00	 call	 __ftoui3
  00385	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv861[ebp], eax
$LN48@OnRender:
  0038b	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv861[ebp]
  00391	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv862[ebp], eax
$LN50@OnRender:
  00397	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv862[ebp]
  0039d	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _dwA$35[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 47   : 	vertices[0].diffuse		= m_DiffuseColor;

  003a3	6a 18		 push	 24			; 00000018H
  003a5	58		 pop	 eax
  003a6	6b c0 00	 imul	 eax, eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  003a9	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$37[ebp]
  003af	c1 e1 08	 shl	 ecx, 8
  003b2	8b 95 b4 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$36[ebp]
  003b8	c1 e2 10	 shl	 edx, 16			; 00000010H
  003bb	8b b5 b0 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$35[ebp]
  003c1	c1 e6 18	 shl	 esi, 24			; 00000018H
  003c4	0b f2		 or	 esi, edx
  003c6	0b f1		 or	 esi, ecx
  003c8	0b b5 ac fe ff
	ff		 or	 esi, DWORD PTR _dwB$34[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 47   : 	vertices[0].diffuse		= m_DiffuseColor;

  003ce	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 48   : 
; 49   : 	vertices[1].position.x	= m_v2Position.x-0.5f;

  003d2	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  003d5	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  003da	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  003e2	6a 18		 push	 24			; 00000018H
  003e4	58		 pop	 eax
  003e5	c1 e0 00	 shl	 eax, 0
  003e8	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 50   : 	vertices[1].position.y	= m_v2Position.y-0.5f;

  003ee	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  003f1	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  003f6	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  003fe	6a 18		 push	 24			; 00000018H
  00400	58		 pop	 eax
  00401	c1 e0 00	 shl	 eax, 0
  00404	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 51   : 	vertices[1].position.z	= m_fDepth;

  0040a	6a 18		 push	 24			; 00000018H
  0040c	58		 pop	 eax
  0040d	c1 e0 00	 shl	 eax, 0
  00410	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00413	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00416	89 4c 05 a4	 mov	 DWORD PTR _vertices$[ebp+eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 41   :     x = fx;

  0041a	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _eu$[ebp]
  00422	f3 0f 11 85 28
	fe ff ff	 movss	 DWORD PTR $T4[ebp], xmm0

; 42   :     y = fy;

  0042a	f3 0f 10 85 38
	ff ff ff	 movss	 xmm0, DWORD PTR _sv$[ebp]
  00432	f3 0f 11 85 2c
	fe ff ff	 movss	 DWORD PTR $T4[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 52   : 	vertices[1].texCoord	= TTextureCoordinate(eu, sv);

  0043a	8b 85 28 fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00440	8b 8d 2c fe ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp+4]
  00446	6a 18		 push	 24			; 00000018H
  00448	5a		 pop	 edx
  00449	c1 e2 00	 shl	 edx, 0
  0044c	89 44 15 ac	 mov	 DWORD PTR _vertices$[ebp+edx+16], eax
  00450	89 4c 15 b0	 mov	 DWORD PTR _vertices$[ebp+edx+20], ecx

; 53   : 	vertices[1].diffuse		= m_DiffuseColor;

  00454	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00457	83 c0 04	 add	 eax, 4
  0045a	89 45 8c	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0045d	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00460	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00464	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0046b	72 0c		 jb	 SHORT $LN57@OnRender
  0046d	c7 85 30 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv877[ebp], 255 ; 000000ffH
  00477	eb 42		 jmp	 SHORT $LN58@OnRender
$LN57@OnRender:
  00479	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0047c	0f 57 c0	 xorps	 xmm0, xmm0
  0047f	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00482	72 09		 jb	 SHORT $LN55@OnRender
  00484	83 a5 34 ff ff
	ff 00		 and	 DWORD PTR tv876[ebp], 0
  0048b	eb 22		 jmp	 SHORT $LN56@OnRender
$LN55@OnRender:
  0048d	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00490	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00494	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0049c	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  004a4	e8 00 00 00 00	 call	 __ftoui3
  004a9	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv876[ebp], eax
$LN56@OnRender:
  004af	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv876[ebp]
  004b5	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv877[ebp], eax
$LN58@OnRender:
  004bb	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv877[ebp]
  004c1	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _dwR$32[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  004c7	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  004ca	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  004cf	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  004d6	72 0c		 jb	 SHORT $LN61@OnRender
  004d8	c7 85 28 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv888[ebp], 255 ; 000000ffH
  004e2	eb 44		 jmp	 SHORT $LN62@OnRender
$LN61@OnRender:
  004e4	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  004e7	0f 57 c0	 xorps	 xmm0, xmm0
  004ea	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  004ee	72 09		 jb	 SHORT $LN59@OnRender
  004f0	83 a5 2c ff ff
	ff 00		 and	 DWORD PTR tv887[ebp], 0
  004f7	eb 23		 jmp	 SHORT $LN60@OnRender
$LN59@OnRender:
  004f9	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  004fc	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00501	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00509	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00511	e8 00 00 00 00	 call	 __ftoui3
  00516	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv887[ebp], eax
$LN60@OnRender:
  0051c	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv887[ebp]
  00522	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv888[ebp], eax
$LN62@OnRender:
  00528	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv888[ebp]
  0052e	89 85 a8 fe ff
	ff		 mov	 DWORD PTR _dwG$33[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00534	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00537	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0053c	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00543	72 0c		 jb	 SHORT $LN65@OnRender
  00545	c7 85 20 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv931[ebp], 255 ; 000000ffH
  0054f	eb 44		 jmp	 SHORT $LN66@OnRender
$LN65@OnRender:
  00551	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00554	0f 57 c0	 xorps	 xmm0, xmm0
  00557	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  0055b	72 09		 jb	 SHORT $LN63@OnRender
  0055d	83 a5 24 ff ff
	ff 00		 and	 DWORD PTR tv930[ebp], 0
  00564	eb 23		 jmp	 SHORT $LN64@OnRender
$LN63@OnRender:
  00566	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00569	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0056e	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00576	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0057e	e8 00 00 00 00	 call	 __ftoui3
  00583	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv930[ebp], eax
$LN64@OnRender:
  00589	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  0058f	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv931[ebp], eax
$LN66@OnRender:
  00595	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv931[ebp]
  0059b	89 85 9c fe ff
	ff		 mov	 DWORD PTR _dwB$30[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  005a1	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  005a4	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  005a9	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  005b0	72 0c		 jb	 SHORT $LN69@OnRender
  005b2	c7 85 18 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv942[ebp], 255 ; 000000ffH
  005bc	eb 44		 jmp	 SHORT $LN70@OnRender
$LN69@OnRender:
  005be	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  005c1	0f 57 c0	 xorps	 xmm0, xmm0
  005c4	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  005c8	72 09		 jb	 SHORT $LN67@OnRender
  005ca	83 a5 1c ff ff
	ff 00		 and	 DWORD PTR tv941[ebp], 0
  005d1	eb 23		 jmp	 SHORT $LN68@OnRender
$LN67@OnRender:
  005d3	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  005d6	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  005db	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  005e3	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  005eb	e8 00 00 00 00	 call	 __ftoui3
  005f0	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv941[ebp], eax
$LN68@OnRender:
  005f6	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv941[ebp]
  005fc	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv942[ebp], eax
$LN70@OnRender:
  00602	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  00608	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _dwA$31[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 53   : 	vertices[1].diffuse		= m_DiffuseColor;

  0060e	6a 18		 push	 24			; 00000018H
  00610	58		 pop	 eax
  00611	c1 e0 00	 shl	 eax, 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00614	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$33[ebp]
  0061a	c1 e1 08	 shl	 ecx, 8
  0061d	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$32[ebp]
  00623	c1 e2 10	 shl	 edx, 16			; 00000010H
  00626	8b b5 a0 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$31[ebp]
  0062c	c1 e6 18	 shl	 esi, 24			; 00000018H
  0062f	0b f2		 or	 esi, edx
  00631	0b f1		 or	 esi, ecx
  00633	0b b5 9c fe ff
	ff		 or	 esi, DWORD PTR _dwB$30[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 53   : 	vertices[1].diffuse		= m_DiffuseColor;

  00639	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 54   : 
; 55   : 	vertices[2].position.x	= m_v2Position.x-0.5f;

  0063d	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00640	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00645	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  0064d	6a 18		 push	 24			; 00000018H
  0064f	58		 pop	 eax
  00650	d1 e0		 shl	 eax, 1
  00652	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 56   : 	vertices[2].position.y	= m_v2Position.y-0.5f;

  00658	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  0065b	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  00660	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  00668	6a 18		 push	 24			; 00000018H
  0066a	58		 pop	 eax
  0066b	d1 e0		 shl	 eax, 1
  0066d	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 57   : 	vertices[2].position.z	= m_fDepth;

  00673	6a 18		 push	 24			; 00000018H
  00675	58		 pop	 eax
  00676	d1 e0		 shl	 eax, 1
  00678	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  0067b	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  0067e	89 4c 05 a4	 mov	 DWORD PTR _vertices$[ebp+eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 41   :     x = fx;

  00682	f3 0f 10 85 14
	ff ff ff	 movss	 xmm0, DWORD PTR _su$[ebp]
  0068a	f3 0f 11 85 20
	fe ff ff	 movss	 DWORD PTR $T3[ebp], xmm0

; 42   :     y = fy;

  00692	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _ev$[ebp]
  0069a	f3 0f 11 85 24
	fe ff ff	 movss	 DWORD PTR $T3[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 58   : 	vertices[2].texCoord	= TTextureCoordinate(su, ev);

  006a2	8b 85 20 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  006a8	8b 8d 24 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp+4]
  006ae	6a 18		 push	 24			; 00000018H
  006b0	5a		 pop	 edx
  006b1	d1 e2		 shl	 edx, 1
  006b3	89 44 15 ac	 mov	 DWORD PTR _vertices$[ebp+edx+16], eax
  006b7	89 4c 15 b0	 mov	 DWORD PTR _vertices$[ebp+edx+20], ecx

; 59   : 	vertices[2].diffuse		= m_DiffuseColor;

  006bb	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  006be	83 c0 04	 add	 eax, 4
  006c1	89 45 88	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  006c4	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  006c7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006cb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  006d2	72 0c		 jb	 SHORT $LN77@OnRender
  006d4	c7 85 0c ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv957[ebp], 255 ; 000000ffH
  006de	eb 42		 jmp	 SHORT $LN78@OnRender
$LN77@OnRender:
  006e0	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  006e3	0f 57 c0	 xorps	 xmm0, xmm0
  006e6	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  006e9	72 09		 jb	 SHORT $LN75@OnRender
  006eb	83 a5 10 ff ff
	ff 00		 and	 DWORD PTR tv956[ebp], 0
  006f2	eb 22		 jmp	 SHORT $LN76@OnRender
$LN75@OnRender:
  006f4	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  006f7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006fb	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00703	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  0070b	e8 00 00 00 00	 call	 __ftoui3
  00710	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv956[ebp], eax
$LN76@OnRender:
  00716	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv956[ebp]
  0071c	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv957[ebp], eax
$LN78@OnRender:
  00722	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv957[ebp]
  00728	89 85 94 fe ff
	ff		 mov	 DWORD PTR _dwR$28[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  0072e	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00731	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00736	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0073d	72 0c		 jb	 SHORT $LN81@OnRender
  0073f	c7 85 04 ff ff
	ff ff 00 00 00	 mov	 DWORD PTR tv968[ebp], 255 ; 000000ffH
  00749	eb 44		 jmp	 SHORT $LN82@OnRender
$LN81@OnRender:
  0074b	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0074e	0f 57 c0	 xorps	 xmm0, xmm0
  00751	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  00755	72 09		 jb	 SHORT $LN79@OnRender
  00757	83 a5 08 ff ff
	ff 00		 and	 DWORD PTR tv967[ebp], 0
  0075e	eb 23		 jmp	 SHORT $LN80@OnRender
$LN79@OnRender:
  00760	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00763	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00768	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00770	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00778	e8 00 00 00 00	 call	 __ftoui3
  0077d	89 85 08 ff ff
	ff		 mov	 DWORD PTR tv967[ebp], eax
$LN80@OnRender:
  00783	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv967[ebp]
  00789	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv968[ebp], eax
$LN82@OnRender:
  0078f	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR tv968[ebp]
  00795	89 85 98 fe ff
	ff		 mov	 DWORD PTR _dwG$29[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  0079b	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0079e	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  007a3	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  007aa	72 0c		 jb	 SHORT $LN85@OnRender
  007ac	c7 85 fc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv979[ebp], 255 ; 000000ffH
  007b6	eb 44		 jmp	 SHORT $LN86@OnRender
$LN85@OnRender:
  007b8	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  007bb	0f 57 c0	 xorps	 xmm0, xmm0
  007be	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  007c2	72 09		 jb	 SHORT $LN83@OnRender
  007c4	83 a5 00 ff ff
	ff 00		 and	 DWORD PTR tv978[ebp], 0
  007cb	eb 23		 jmp	 SHORT $LN84@OnRender
$LN83@OnRender:
  007cd	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  007d0	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  007d5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  007dd	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  007e5	e8 00 00 00 00	 call	 __ftoui3
  007ea	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv978[ebp], eax
$LN84@OnRender:
  007f0	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  007f6	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv979[ebp], eax
$LN86@OnRender:
  007fc	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv979[ebp]
  00802	89 85 8c fe ff
	ff		 mov	 DWORD PTR _dwB$26[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00808	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0080b	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00810	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00817	72 0c		 jb	 SHORT $LN89@OnRender
  00819	c7 85 f4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv990[ebp], 255 ; 000000ffH
  00823	eb 44		 jmp	 SHORT $LN90@OnRender
$LN89@OnRender:
  00825	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00828	0f 57 c0	 xorps	 xmm0, xmm0
  0082b	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  0082f	72 09		 jb	 SHORT $LN87@OnRender
  00831	83 a5 f8 fe ff
	ff 00		 and	 DWORD PTR tv989[ebp], 0
  00838	eb 23		 jmp	 SHORT $LN88@OnRender
$LN87@OnRender:
  0083a	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  0083d	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00842	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0084a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00852	e8 00 00 00 00	 call	 __ftoui3
  00857	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv989[ebp], eax
$LN88@OnRender:
  0085d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv989[ebp]
  00863	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv990[ebp], eax
$LN90@OnRender:
  00869	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  0086f	89 85 90 fe ff
	ff		 mov	 DWORD PTR _dwA$27[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 59   : 	vertices[2].diffuse		= m_DiffuseColor;

  00875	6a 18		 push	 24			; 00000018H
  00877	58		 pop	 eax
  00878	d1 e0		 shl	 eax, 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  0087a	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$29[ebp]
  00880	c1 e1 08	 shl	 ecx, 8
  00883	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$28[ebp]
  00889	c1 e2 10	 shl	 edx, 16			; 00000010H
  0088c	8b b5 90 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$27[ebp]
  00892	c1 e6 18	 shl	 esi, 24			; 00000018H
  00895	0b f2		 or	 esi, edx
  00897	0b f1		 or	 esi, ecx
  00899	0b b5 8c fe ff
	ff		 or	 esi, DWORD PTR _dwB$26[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 59   : 	vertices[2].diffuse		= m_DiffuseColor;

  0089f	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 60   : 
; 61   : 	vertices[3].position.x	= m_v2Position.x-0.5f;

  008a3	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  008a6	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  008ab	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  008b3	6a 18		 push	 24			; 00000018H
  008b5	58		 pop	 eax
  008b6	6b c0 03	 imul	 eax, eax, 3
  008b9	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 62   : 	vertices[3].position.y	= m_v2Position.y-0.5f;

  008bf	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  008c2	f3 0f 10 40 18	 movss	 xmm0, DWORD PTR [eax+24]
  008c7	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f000000
  008cf	6a 18		 push	 24			; 00000018H
  008d1	58		 pop	 eax
  008d2	6b c0 03	 imul	 eax, eax, 3
  008d5	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 63   : 	vertices[3].position.z	= m_fDepth;

  008db	6a 18		 push	 24			; 00000018H
  008dd	58		 pop	 eax
  008de	6b c0 03	 imul	 eax, eax, 3
  008e1	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  008e4	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  008e7	89 4c 05 a4	 mov	 DWORD PTR _vertices$[ebp+eax+8], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 41   :     x = fx;

  008eb	f3 0f 10 85 f0
	fe ff ff	 movss	 xmm0, DWORD PTR _eu$[ebp]
  008f3	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR $T2[ebp], xmm0

; 42   :     y = fy;

  008fb	f3 0f 10 85 ec
	fe ff ff	 movss	 xmm0, DWORD PTR _ev$[ebp]
  00903	f3 0f 11 85 1c
	fe ff ff	 movss	 DWORD PTR $T2[ebp+4], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 64   : 	vertices[3].texCoord	= TTextureCoordinate(eu, ev);	

  0090b	8b 85 18 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00911	8b 8d 1c fe ff
	ff		 mov	 ecx, DWORD PTR $T2[ebp+4]
  00917	6a 18		 push	 24			; 00000018H
  00919	5a		 pop	 edx
  0091a	6b d2 03	 imul	 edx, edx, 3
  0091d	89 44 15 ac	 mov	 DWORD PTR _vertices$[ebp+edx+16], eax
  00921	89 4c 15 b0	 mov	 DWORD PTR _vertices$[ebp+edx+20], ecx

; 65   : 	vertices[3].diffuse		= m_DiffuseColor;

  00925	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00928	83 c0 04	 add	 eax, 4
  0092b	89 45 84	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 931  :     DWORD dwR = r >= 1.0f ? 0xff : r <= 0.0f ? 0x00 : (DWORD) (r * 255.0f + 0.5f);

  0092e	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00931	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00935	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  0093c	72 0c		 jb	 SHORT $LN97@OnRender
  0093e	c7 85 e4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1005[ebp], 255 ; 000000ffH
  00948	eb 42		 jmp	 SHORT $LN98@OnRender
$LN97@OnRender:
  0094a	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  0094d	0f 57 c0	 xorps	 xmm0, xmm0
  00950	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00953	72 09		 jb	 SHORT $LN95@OnRender
  00955	83 a5 e8 fe ff
	ff 00		 and	 DWORD PTR tv1004[ebp], 0
  0095c	eb 22		 jmp	 SHORT $LN96@OnRender
$LN95@OnRender:
  0095e	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00961	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00965	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  0096d	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00975	e8 00 00 00 00	 call	 __ftoui3
  0097a	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv1004[ebp], eax
$LN96@OnRender:
  00980	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv1004[ebp]
  00986	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv1005[ebp], eax
$LN98@OnRender:
  0098c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR tv1005[ebp]
  00992	89 85 84 fe ff
	ff		 mov	 DWORD PTR _dwR$24[ebp], eax

; 932  :     DWORD dwG = g >= 1.0f ? 0xff : g <= 0.0f ? 0x00 : (DWORD) (g * 255.0f + 0.5f);

  00998	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  0099b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  009a0	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  009a7	72 0c		 jb	 SHORT $LN101@OnRender
  009a9	c7 85 dc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1016[ebp], 255 ; 000000ffH
  009b3	eb 44		 jmp	 SHORT $LN102@OnRender
$LN101@OnRender:
  009b5	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  009b8	0f 57 c0	 xorps	 xmm0, xmm0
  009bb	0f 2f 40 04	 comiss	 xmm0, DWORD PTR [eax+4]
  009bf	72 09		 jb	 SHORT $LN99@OnRender
  009c1	83 a5 e0 fe ff
	ff 00		 and	 DWORD PTR tv1015[ebp], 0
  009c8	eb 23		 jmp	 SHORT $LN100@OnRender
$LN99@OnRender:
  009ca	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  009cd	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  009d2	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  009da	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  009e2	e8 00 00 00 00	 call	 __ftoui3
  009e7	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv1015[ebp], eax
$LN100@OnRender:
  009ed	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv1015[ebp]
  009f3	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], eax
$LN102@OnRender:
  009f9	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv1016[ebp]
  009ff	89 85 88 fe ff
	ff		 mov	 DWORD PTR _dwG$25[ebp], eax

; 933  :     DWORD dwB = b >= 1.0f ? 0xff : b <= 0.0f ? 0x00 : (DWORD) (b * 255.0f + 0.5f);

  00a05	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00a08	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00a0d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a14	72 0c		 jb	 SHORT $LN105@OnRender
  00a16	c7 85 d4 fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1027[ebp], 255 ; 000000ffH
  00a20	eb 44		 jmp	 SHORT $LN106@OnRender
$LN105@OnRender:
  00a22	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00a25	0f 57 c0	 xorps	 xmm0, xmm0
  00a28	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00a2c	72 09		 jb	 SHORT $LN103@OnRender
  00a2e	83 a5 d8 fe ff
	ff 00		 and	 DWORD PTR tv1026[ebp], 0
  00a35	eb 23		 jmp	 SHORT $LN104@OnRender
$LN103@OnRender:
  00a37	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00a3a	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00a3f	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00a47	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00a4f	e8 00 00 00 00	 call	 __ftoui3
  00a54	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv1026[ebp], eax
$LN104@OnRender:
  00a5a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv1026[ebp]
  00a60	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv1027[ebp], eax
$LN106@OnRender:
  00a66	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv1027[ebp]
  00a6c	89 85 50 fe ff
	ff		 mov	 DWORD PTR _dwB$12[ebp], eax

; 934  :     DWORD dwA = a >= 1.0f ? 0xff : a <= 0.0f ? 0x00 : (DWORD) (a * 255.0f + 0.5f);

  00a72	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00a75	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00a7a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00a81	72 0c		 jb	 SHORT $LN109@OnRender
  00a83	c7 85 cc fe ff
	ff ff 00 00 00	 mov	 DWORD PTR tv1038[ebp], 255 ; 000000ffH
  00a8d	eb 44		 jmp	 SHORT $LN110@OnRender
$LN109@OnRender:
  00a8f	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00a92	0f 57 c0	 xorps	 xmm0, xmm0
  00a95	0f 2f 40 0c	 comiss	 xmm0, DWORD PTR [eax+12]
  00a99	72 09		 jb	 SHORT $LN107@OnRender
  00a9b	83 a5 d0 fe ff
	ff 00		 and	 DWORD PTR tv1037[ebp], 0
  00aa2	eb 23		 jmp	 SHORT $LN108@OnRender
$LN107@OnRender:
  00aa4	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  00aa7	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  00aac	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@437f0000
  00ab4	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f000000
  00abc	e8 00 00 00 00	 call	 __ftoui3
  00ac1	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv1037[ebp], eax
$LN108@OnRender:
  00ac7	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv1037[ebp]
  00acd	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv1038[ebp], eax
$LN110@OnRender:
  00ad3	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv1038[ebp]
  00ad9	89 85 80 fe ff
	ff		 mov	 DWORD PTR _dwA$23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 65   : 	vertices[3].diffuse		= m_DiffuseColor;

  00adf	6a 18		 push	 24			; 00000018H
  00ae1	58		 pop	 eax
  00ae2	6b c0 03	 imul	 eax, eax, 3
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 936  :     return (dwA << 24) | (dwR << 16) | (dwG << 8) | dwB;

  00ae5	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR _dwG$25[ebp]
  00aeb	c1 e1 08	 shl	 ecx, 8
  00aee	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR _dwR$24[ebp]
  00af4	c1 e2 10	 shl	 edx, 16			; 00000010H
  00af7	8b b5 80 fe ff
	ff		 mov	 esi, DWORD PTR _dwA$23[ebp]
  00afd	c1 e6 18	 shl	 esi, 24			; 00000018H
  00b00	0b f2		 or	 esi, edx
  00b02	0b f1		 or	 esi, ecx
  00b04	0b b5 50 fe ff
	ff		 or	 esi, DWORD PTR _dwB$12[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 65   : 	vertices[3].diffuse		= m_DiffuseColor;

  00b0a	89 74 05 a8	 mov	 DWORD PTR _vertices$[ebp+eax+12], esi

; 66   : 
; 67   : 	if (0.0f == m_fRotation)

  00b0e	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00b11	0f 57 c0	 xorps	 xmm0, xmm0
  00b14	0f 2e 40 34	 ucomiss xmm0, DWORD PTR [eax+52]
  00b18	9f		 lahf
  00b19	f6 c4 44	 test	 ah, 68			; 00000044H
  00b1c	0f 8a b8 01 00
	00		 jp	 $LN9@OnRender

; 68   : 	{
; 69   : 		float fimgWidth = float(pImage->GetWidth()) * m_v2Scale.x;

  00b22	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  00b28	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImage@@QBEHXZ ; CGraphicImage::GetWidth
  00b2d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b31	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00b34	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00b39	f3 0f 11 85 c8
	fe ff ff	 movss	 DWORD PTR _fimgWidth$39[ebp], xmm0

; 70   : 		float fimgHeight = float(pImage->GetHeight()) * m_v2Scale.y;

  00b41	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  00b47	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImage@@QBEHXZ ; CGraphicImage::GetHeight
  00b4c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00b50	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00b53	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  00b58	f3 0f 11 85 c4
	fe ff ff	 movss	 DWORD PTR _fimgHeight$38[ebp], xmm0

; 71   : 
; 72   : 		vertices[0].position.x -= m_RenderingRect.left;

  00b60	6a 18		 push	 24			; 00000018H
  00b62	58		 pop	 eax
  00b63	6b c0 00	 imul	 eax, eax, 0
  00b66	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00b69	f3 0f 2a 41 38	 cvtsi2ss xmm0, DWORD PTR [ecx+56]
  00b6e	f3 0f 10 4c 05
	9c		 movss	 xmm1, DWORD PTR _vertices$[ebp+eax]
  00b74	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b78	6a 18		 push	 24			; 00000018H
  00b7a	58		 pop	 eax
  00b7b	6b c0 00	 imul	 eax, eax, 0
  00b7e	f3 0f 11 4c 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm1

; 73   : 		vertices[0].position.y -= m_RenderingRect.top;

  00b84	6a 18		 push	 24			; 00000018H
  00b86	58		 pop	 eax
  00b87	6b c0 00	 imul	 eax, eax, 0
  00b8a	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00b8d	f3 0f 2a 41 3c	 cvtsi2ss xmm0, DWORD PTR [ecx+60]
  00b92	f3 0f 10 4c 05
	a0		 movss	 xmm1, DWORD PTR _vertices$[ebp+eax+4]
  00b98	f3 0f 5c c8	 subss	 xmm1, xmm0
  00b9c	6a 18		 push	 24			; 00000018H
  00b9e	58		 pop	 eax
  00b9f	6b c0 00	 imul	 eax, eax, 0
  00ba2	f3 0f 11 4c 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm1

; 74   : 		vertices[1].position.x += fimgWidth + m_RenderingRect.right;

  00ba8	6a 18		 push	 24			; 00000018H
  00baa	58		 pop	 eax
  00bab	c1 e0 00	 shl	 eax, 0
  00bae	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00bb1	f3 0f 2a 41 40	 cvtsi2ss xmm0, DWORD PTR [ecx+64]
  00bb6	f3 0f 58 85 c8
	fe ff ff	 addss	 xmm0, DWORD PTR _fimgWidth$39[ebp]
  00bbe	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00bc4	6a 18		 push	 24			; 00000018H
  00bc6	58		 pop	 eax
  00bc7	c1 e0 00	 shl	 eax, 0
  00bca	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 75   : 		vertices[1].position.y -= m_RenderingRect.top;

  00bd0	6a 18		 push	 24			; 00000018H
  00bd2	58		 pop	 eax
  00bd3	c1 e0 00	 shl	 eax, 0
  00bd6	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00bd9	f3 0f 2a 41 3c	 cvtsi2ss xmm0, DWORD PTR [ecx+60]
  00bde	f3 0f 10 4c 05
	a0		 movss	 xmm1, DWORD PTR _vertices$[ebp+eax+4]
  00be4	f3 0f 5c c8	 subss	 xmm1, xmm0
  00be8	6a 18		 push	 24			; 00000018H
  00bea	58		 pop	 eax
  00beb	c1 e0 00	 shl	 eax, 0
  00bee	f3 0f 11 4c 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm1

; 76   : 		vertices[2].position.x -= m_RenderingRect.left;

  00bf4	6a 18		 push	 24			; 00000018H
  00bf6	58		 pop	 eax
  00bf7	d1 e0		 shl	 eax, 1
  00bf9	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00bfc	f3 0f 2a 41 38	 cvtsi2ss xmm0, DWORD PTR [ecx+56]
  00c01	f3 0f 10 4c 05
	9c		 movss	 xmm1, DWORD PTR _vertices$[ebp+eax]
  00c07	f3 0f 5c c8	 subss	 xmm1, xmm0
  00c0b	6a 18		 push	 24			; 00000018H
  00c0d	58		 pop	 eax
  00c0e	d1 e0		 shl	 eax, 1
  00c10	f3 0f 11 4c 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm1

; 77   : 		vertices[2].position.y += fimgHeight + m_RenderingRect.bottom;

  00c16	6a 18		 push	 24			; 00000018H
  00c18	58		 pop	 eax
  00c19	d1 e0		 shl	 eax, 1
  00c1b	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00c1e	f3 0f 2a 41 44	 cvtsi2ss xmm0, DWORD PTR [ecx+68]
  00c23	f3 0f 58 85 c4
	fe ff ff	 addss	 xmm0, DWORD PTR _fimgHeight$38[ebp]
  00c2b	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  00c31	6a 18		 push	 24			; 00000018H
  00c33	58		 pop	 eax
  00c34	d1 e0		 shl	 eax, 1
  00c36	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 78   : 		vertices[3].position.x += fimgWidth + m_RenderingRect.right;

  00c3c	6a 18		 push	 24			; 00000018H
  00c3e	58		 pop	 eax
  00c3f	6b c0 03	 imul	 eax, eax, 3
  00c42	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00c45	f3 0f 2a 41 40	 cvtsi2ss xmm0, DWORD PTR [ecx+64]
  00c4a	f3 0f 58 85 c8
	fe ff ff	 addss	 xmm0, DWORD PTR _fimgWidth$39[ebp]
  00c52	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00c58	6a 18		 push	 24			; 00000018H
  00c5a	58		 pop	 eax
  00c5b	6b c0 03	 imul	 eax, eax, 3
  00c5e	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 79   : 		vertices[3].position.y += fimgHeight + m_RenderingRect.bottom;

  00c64	6a 18		 push	 24			; 00000018H
  00c66	58		 pop	 eax
  00c67	6b c0 03	 imul	 eax, eax, 3
  00c6a	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00c6d	f3 0f 2a 41 44	 cvtsi2ss xmm0, DWORD PTR [ecx+68]
  00c72	f3 0f 58 85 c4
	fe ff ff	 addss	 xmm0, DWORD PTR _fimgHeight$38[ebp]
  00c7a	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  00c80	6a 18		 push	 24			; 00000018H
  00c82	58		 pop	 eax
  00c83	6b c0 03	 imul	 eax, eax, 3
  00c86	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 80   : 		if ((0.0f < m_v2Scale.x && 0.0f > m_v2Scale.y) || (0.0f > m_v2Scale.x && 0.0f < m_v2Scale.y)) {

  00c8c	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00c8f	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00c94	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00c9b	76 0c		 jbe	 SHORT $LN13@OnRender
  00c9d	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00ca0	0f 57 c0	 xorps	 xmm0, xmm0
  00ca3	0f 2f 40 30	 comiss	 xmm0, DWORD PTR [eax+48]
  00ca7	77 1d		 ja	 SHORT $LN12@OnRender
$LN13@OnRender:
  00ca9	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00cac	0f 57 c0	 xorps	 xmm0, xmm0
  00caf	0f 2f 40 2c	 comiss	 xmm0, DWORD PTR [eax+44]
  00cb3	76 20		 jbe	 SHORT $LN11@OnRender
  00cb5	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00cb8	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00cbd	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00cc4	76 0f		 jbe	 SHORT $LN11@OnRender
$LN12@OnRender:

; 81   : 			STATEMANAGER.SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);

  00cc6	6a 03		 push	 3
  00cc8	6a 16		 push	 22			; 00000016H
  00cca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00cd0	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN11@OnRender:

; 82   : 		}
; 83   : 	}

  00cd5	e9 6c 04 00 00	 jmp	 $LN10@OnRender
$LN9@OnRender:

; 84   : 	else
; 85   : 	{
; 86   : 		float fimgHalfWidth = float(pImage->GetWidth())/2.0f * m_v2Scale.x;

  00cda	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  00ce0	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImage@@QBEHXZ ; CGraphicImage::GetWidth
  00ce5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00ce9	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00cf1	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00cf4	f3 0f 59 40 2c	 mulss	 xmm0, DWORD PTR [eax+44]
  00cf9	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _fimgHalfWidth$42[ebp], xmm0

; 87   : 		float fimgHalfHeight = float(pImage->GetHeight())/2.0f * m_v2Scale.y;

  00d01	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _pImage$[ebp]
  00d07	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImage@@QBEHXZ ; CGraphicImage::GetHeight
  00d0c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00d10	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00d18	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00d1b	f3 0f 59 40 30	 mulss	 xmm0, DWORD PTR [eax+48]
  00d20	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fimgHalfHeight$41[ebp], xmm0

; 88   : 
; 89   : 		for (int i = 0; i < 4; ++i)

  00d28	83 a5 74 ff ff
	ff 00		 and	 DWORD PTR _i$40[ebp], 0
  00d2f	eb 0d		 jmp	 SHORT $LN4@OnRender
$LN2@OnRender:
  00d31	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _i$40[ebp]
  00d37	40		 inc	 eax
  00d38	89 85 74 ff ff
	ff		 mov	 DWORD PTR _i$40[ebp], eax
$LN4@OnRender:
  00d3e	83 bd 74 ff ff
	ff 04		 cmp	 DWORD PTR _i$40[ebp], 4
  00d45	7d 46		 jge	 SHORT $LN3@OnRender

; 90   : 		{
; 91   : 			vertices[i].position.x += m_v2Origin.x;

  00d47	6b 85 74 ff ff
	ff 18		 imul	 eax, DWORD PTR _i$40[ebp], 24
  00d4e	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00d51	f3 0f 10 44 05
	9c		 movss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00d57	f3 0f 58 41 24	 addss	 xmm0, DWORD PTR [ecx+36]
  00d5c	6b 85 74 ff ff
	ff 18		 imul	 eax, DWORD PTR _i$40[ebp], 24
  00d63	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0

; 92   : 			vertices[i].position.y += m_v2Origin.y;

  00d69	6b 85 74 ff ff
	ff 18		 imul	 eax, DWORD PTR _i$40[ebp], 24
  00d70	8b 4d 98	 mov	 ecx, DWORD PTR _this$[ebp]
  00d73	f3 0f 10 44 05
	a0		 movss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  00d79	f3 0f 58 41 28	 addss	 xmm0, DWORD PTR [ecx+40]
  00d7e	6b 85 74 ff ff
	ff 18		 imul	 eax, DWORD PTR _i$40[ebp], 24
  00d85	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0

; 93   : 		}

  00d8b	eb a4		 jmp	 SHORT $LN2@OnRender
$LN3@OnRender:

; 94   : 
; 95   : 		float fRadian = D3DXToRadian(m_fRotation);

  00d8d	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  00d90	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00d95	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3c8efa35
  00d9d	f3 0f 11 45 94	 movss	 DWORD PTR _fRadian$43[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  00da2	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00da7	51		 push	 ecx
  00da8	51		 push	 ecx
  00da9	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00dae	e8 00 00 00 00	 call	 _cos
  00db3	59		 pop	 ecx
  00db4	59		 pop	 ecx
  00db5	d9 9d 78 fe ff
	ff		 fstp	 DWORD PTR $T22[ebp]

; 750  :             return (float)sin(_X);

  00dbb	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00dc0	51		 push	 ecx
  00dc1	51		 push	 ecx
  00dc2	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00dc7	e8 00 00 00 00	 call	 _sin
  00dcc	59		 pop	 ecx
  00dcd	59		 pop	 ecx
  00dce	d9 9d 74 fe ff
	ff		 fstp	 DWORD PTR $T21[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 96   : 		vertices[0].position.x += (-fimgHalfWidth*cosf(fRadian)) - (-fimgHalfHeight*sinf(fRadian));

  00dd4	6a 18		 push	 24			; 00000018H
  00dd6	58		 pop	 eax
  00dd7	6b c0 00	 imul	 eax, eax, 0
  00dda	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  00de2	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00de9	f3 0f 59 85 78
	fe ff ff	 mulss	 xmm0, DWORD PTR $T22[ebp]
  00df1	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  00df9	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00e00	f3 0f 59 8d 74
	fe ff ff	 mulss	 xmm1, DWORD PTR $T21[ebp]
  00e08	f3 0f 5c c1	 subss	 xmm0, xmm1
  00e0c	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00e12	6a 18		 push	 24			; 00000018H
  00e14	58		 pop	 eax
  00e15	6b c0 00	 imul	 eax, eax, 0
  00e18	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  00e1e	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00e23	51		 push	 ecx
  00e24	51		 push	 ecx
  00e25	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00e2a	e8 00 00 00 00	 call	 _sin
  00e2f	59		 pop	 ecx
  00e30	59		 pop	 ecx
  00e31	d9 9d 70 fe ff
	ff		 fstp	 DWORD PTR $T20[ebp]

; 649  :             return (float)cos(_X);

  00e37	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00e3c	51		 push	 ecx
  00e3d	51		 push	 ecx
  00e3e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00e43	e8 00 00 00 00	 call	 _cos
  00e48	59		 pop	 ecx
  00e49	59		 pop	 ecx
  00e4a	d9 9d 6c fe ff
	ff		 fstp	 DWORD PTR $T19[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 97   : 		vertices[0].position.y += (-fimgHalfWidth*sinf(fRadian)) + (-fimgHalfHeight*cosf(fRadian));

  00e50	6a 18		 push	 24			; 00000018H
  00e52	58		 pop	 eax
  00e53	6b c0 00	 imul	 eax, eax, 0
  00e56	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  00e5e	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00e65	f3 0f 59 85 70
	fe ff ff	 mulss	 xmm0, DWORD PTR $T20[ebp]
  00e6d	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  00e75	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00e7c	f3 0f 59 8d 6c
	fe ff ff	 mulss	 xmm1, DWORD PTR $T19[ebp]
  00e84	f3 0f 58 c1	 addss	 xmm0, xmm1
  00e88	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  00e8e	6a 18		 push	 24			; 00000018H
  00e90	58		 pop	 eax
  00e91	6b c0 00	 imul	 eax, eax, 0
  00e94	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  00e9a	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00e9f	51		 push	 ecx
  00ea0	51		 push	 ecx
  00ea1	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00ea6	e8 00 00 00 00	 call	 _cos
  00eab	59		 pop	 ecx
  00eac	59		 pop	 ecx
  00ead	d9 9d 68 fe ff
	ff		 fstp	 DWORD PTR $T18[ebp]

; 750  :             return (float)sin(_X);

  00eb3	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00eb8	51		 push	 ecx
  00eb9	51		 push	 ecx
  00eba	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00ebf	e8 00 00 00 00	 call	 _sin
  00ec4	59		 pop	 ecx
  00ec5	59		 pop	 ecx
  00ec6	d9 9d 64 fe ff
	ff		 fstp	 DWORD PTR $T17[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 98   : 		vertices[1].position.x += (+fimgHalfWidth*cosf(fRadian)) - (-fimgHalfHeight*sinf(fRadian));

  00ecc	6a 18		 push	 24			; 00000018H
  00ece	58		 pop	 eax
  00ecf	c1 e0 00	 shl	 eax, 0
  00ed2	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  00eda	f3 0f 59 85 68
	fe ff ff	 mulss	 xmm0, DWORD PTR $T18[ebp]
  00ee2	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  00eea	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00ef1	f3 0f 59 8d 64
	fe ff ff	 mulss	 xmm1, DWORD PTR $T17[ebp]
  00ef9	f3 0f 5c c1	 subss	 xmm0, xmm1
  00efd	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00f03	6a 18		 push	 24			; 00000018H
  00f05	58		 pop	 eax
  00f06	c1 e0 00	 shl	 eax, 0
  00f09	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  00f0f	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00f14	51		 push	 ecx
  00f15	51		 push	 ecx
  00f16	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00f1b	e8 00 00 00 00	 call	 _sin
  00f20	59		 pop	 ecx
  00f21	59		 pop	 ecx
  00f22	d9 9d 60 fe ff
	ff		 fstp	 DWORD PTR $T16[ebp]

; 649  :             return (float)cos(_X);

  00f28	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00f2d	51		 push	 ecx
  00f2e	51		 push	 ecx
  00f2f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00f34	e8 00 00 00 00	 call	 _cos
  00f39	59		 pop	 ecx
  00f3a	59		 pop	 ecx
  00f3b	d9 9d 5c fe ff
	ff		 fstp	 DWORD PTR $T15[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 99   : 		vertices[1].position.y += (+fimgHalfWidth*sinf(fRadian)) + (-fimgHalfHeight*cosf(fRadian));

  00f41	6a 18		 push	 24			; 00000018H
  00f43	58		 pop	 eax
  00f44	c1 e0 00	 shl	 eax, 0
  00f47	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  00f4f	f3 0f 59 85 60
	fe ff ff	 mulss	 xmm0, DWORD PTR $T16[ebp]
  00f57	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  00f5f	0f 57 0d 00 00
	00 00		 xorps	 xmm1, DWORD PTR __xmm@80000000800000008000000080000000
  00f66	f3 0f 59 8d 5c
	fe ff ff	 mulss	 xmm1, DWORD PTR $T15[ebp]
  00f6e	f3 0f 58 c1	 addss	 xmm0, xmm1
  00f72	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  00f78	6a 18		 push	 24			; 00000018H
  00f7a	58		 pop	 eax
  00f7b	c1 e0 00	 shl	 eax, 0
  00f7e	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  00f84	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00f89	51		 push	 ecx
  00f8a	51		 push	 ecx
  00f8b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00f90	e8 00 00 00 00	 call	 _cos
  00f95	59		 pop	 ecx
  00f96	59		 pop	 ecx
  00f97	d9 9d 58 fe ff
	ff		 fstp	 DWORD PTR $T14[ebp]

; 750  :             return (float)sin(_X);

  00f9d	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00fa2	51		 push	 ecx
  00fa3	51		 push	 ecx
  00fa4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00fa9	e8 00 00 00 00	 call	 _sin
  00fae	59		 pop	 ecx
  00faf	59		 pop	 ecx
  00fb0	d9 9d 54 fe ff
	ff		 fstp	 DWORD PTR $T13[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 100  : 		vertices[2].position.x += (-fimgHalfWidth*cosf(fRadian)) - (+fimgHalfHeight*sinf(fRadian));

  00fb6	6a 18		 push	 24			; 00000018H
  00fb8	58		 pop	 eax
  00fb9	d1 e0		 shl	 eax, 1
  00fbb	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  00fc3	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00fca	f3 0f 59 85 58
	fe ff ff	 mulss	 xmm0, DWORD PTR $T14[ebp]
  00fd2	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  00fda	f3 0f 59 8d 54
	fe ff ff	 mulss	 xmm1, DWORD PTR $T13[ebp]
  00fe2	f3 0f 5c c1	 subss	 xmm0, xmm1
  00fe6	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  00fec	6a 18		 push	 24			; 00000018H
  00fee	58		 pop	 eax
  00fef	d1 e0		 shl	 eax, 1
  00ff1	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  00ff7	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  00ffc	51		 push	 ecx
  00ffd	51		 push	 ecx
  00ffe	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  01003	e8 00 00 00 00	 call	 _sin
  01008	59		 pop	 ecx
  01009	59		 pop	 ecx
  0100a	d9 9d 14 fe ff
	ff		 fstp	 DWORD PTR $T1[ebp]

; 649  :             return (float)cos(_X);

  01010	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  01015	51		 push	 ecx
  01016	51		 push	 ecx
  01017	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0101c	e8 00 00 00 00	 call	 _cos
  01021	59		 pop	 ecx
  01022	59		 pop	 ecx
  01023	d9 9d 4c fe ff
	ff		 fstp	 DWORD PTR $T11[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 101  : 		vertices[2].position.y += (-fimgHalfWidth*sinf(fRadian)) + (+fimgHalfHeight*cosf(fRadian));

  01029	6a 18		 push	 24			; 00000018H
  0102b	58		 pop	 eax
  0102c	d1 e0		 shl	 eax, 1
  0102e	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  01036	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0103d	f3 0f 59 85 14
	fe ff ff	 mulss	 xmm0, DWORD PTR $T1[ebp]
  01045	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  0104d	f3 0f 59 8d 4c
	fe ff ff	 mulss	 xmm1, DWORD PTR $T11[ebp]
  01055	f3 0f 58 c1	 addss	 xmm0, xmm1
  01059	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  0105f	6a 18		 push	 24			; 00000018H
  01061	58		 pop	 eax
  01062	d1 e0		 shl	 eax, 1
  01064	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 649  :             return (float)cos(_X);

  0106a	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  0106f	51		 push	 ecx
  01070	51		 push	 ecx
  01071	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  01076	e8 00 00 00 00	 call	 _cos
  0107b	59		 pop	 ecx
  0107c	59		 pop	 ecx
  0107d	d9 9d 48 fe ff
	ff		 fstp	 DWORD PTR $T10[ebp]

; 750  :             return (float)sin(_X);

  01083	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  01088	51		 push	 ecx
  01089	51		 push	 ecx
  0108a	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0108f	e8 00 00 00 00	 call	 _sin
  01094	59		 pop	 ecx
  01095	59		 pop	 ecx
  01096	d9 9d 44 fe ff
	ff		 fstp	 DWORD PTR $T9[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 102  : 		vertices[3].position.x += (+fimgHalfWidth*cosf(fRadian)) - (+fimgHalfHeight*sinf(fRadian));

  0109c	6a 18		 push	 24			; 00000018H
  0109e	58		 pop	 eax
  0109f	6b c0 03	 imul	 eax, eax, 3
  010a2	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  010aa	f3 0f 59 85 48
	fe ff ff	 mulss	 xmm0, DWORD PTR $T10[ebp]
  010b2	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  010ba	f3 0f 59 8d 44
	fe ff ff	 mulss	 xmm1, DWORD PTR $T9[ebp]
  010c2	f3 0f 5c c1	 subss	 xmm0, xmm1
  010c6	f3 0f 58 44 05
	9c		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax]
  010cc	6a 18		 push	 24			; 00000018H
  010ce	58		 pop	 eax
  010cf	6b c0 03	 imul	 eax, eax, 3
  010d2	f3 0f 11 44 05
	9c		 movss	 DWORD PTR _vertices$[ebp+eax], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 750  :             return (float)sin(_X);

  010d8	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  010dd	51		 push	 ecx
  010de	51		 push	 ecx
  010df	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  010e4	e8 00 00 00 00	 call	 _sin
  010e9	59		 pop	 ecx
  010ea	59		 pop	 ecx
  010eb	d9 9d 40 fe ff
	ff		 fstp	 DWORD PTR $T8[ebp]

; 649  :             return (float)cos(_X);

  010f1	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRadian$43[ebp]
  010f6	51		 push	 ecx
  010f7	51		 push	 ecx
  010f8	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  010fd	e8 00 00 00 00	 call	 _cos
  01102	59		 pop	 ecx
  01103	59		 pop	 ecx
  01104	d9 9d 3c fe ff
	ff		 fstp	 DWORD PTR $T7[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 103  : 		vertices[3].position.y += (+fimgHalfWidth*sinf(fRadian)) + (+fimgHalfHeight*cosf(fRadian));

  0110a	6a 18		 push	 24			; 00000018H
  0110c	58		 pop	 eax
  0110d	6b c0 03	 imul	 eax, eax, 3
  01110	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fimgHalfWidth$42[ebp]
  01118	f3 0f 59 85 40
	fe ff ff	 mulss	 xmm0, DWORD PTR $T8[ebp]
  01120	f3 0f 10 8d 78
	ff ff ff	 movss	 xmm1, DWORD PTR _fimgHalfHeight$41[ebp]
  01128	f3 0f 59 8d 3c
	fe ff ff	 mulss	 xmm1, DWORD PTR $T7[ebp]
  01130	f3 0f 58 c1	 addss	 xmm0, xmm1
  01134	f3 0f 58 44 05
	a0		 addss	 xmm0, DWORD PTR _vertices$[ebp+eax+4]
  0113a	6a 18		 push	 24			; 00000018H
  0113c	58		 pop	 eax
  0113d	6b c0 03	 imul	 eax, eax, 3
  01140	f3 0f 11 44 05
	a0		 movss	 DWORD PTR _vertices$[ebp+eax+4], xmm0
$LN10@OnRender:

; 104  : 	}
; 105  : 
; 106  : 	switch (m_iRenderingMode)

  01146	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  01149	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  0114c	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv749[ebp], eax
  01152	83 bd 68 ff ff
	ff 00		 cmp	 DWORD PTR tv749[ebp], 0
  01159	7e 52		 jle	 SHORT $LN5@OnRender
  0115b	83 bd 68 ff ff
	ff 02		 cmp	 DWORD PTR tv749[ebp], 2
  01162	7e 0b		 jle	 SHORT $LN14@OnRender
  01164	83 bd 68 ff ff
	ff 03		 cmp	 DWORD PTR tv749[ebp], 3
  0116b	74 22		 je	 SHORT $LN15@OnRender
  0116d	eb 3e		 jmp	 SHORT $LN5@OnRender
$LN14@OnRender:

; 107  : 	{
; 108  : 		case RENDERING_MODE_SCREEN:
; 109  : 		case RENDERING_MODE_COLOR_DODGE:
; 110  : 			STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_INVDESTCOLOR);

  0116f	6a 0a		 push	 10			; 0000000aH
  01171	6a 13		 push	 19			; 00000013H
  01173	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01179	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 111  : 			STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);

  0117e	6a 02		 push	 2
  01180	6a 14		 push	 20			; 00000014H
  01182	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01188	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 112  : 			break;

  0118d	eb 1e		 jmp	 SHORT $LN5@OnRender
$LN15@OnRender:

; 113  : 		case RENDERING_MODE_MODULATE:
; 114  : 			STATEMANAGER.SaveRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);

  0118f	6a 01		 push	 1
  01191	6a 13		 push	 19			; 00000013H
  01193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01199	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 115  : 			STATEMANAGER.SaveRenderState(D3DRS_DESTBLEND, D3DBLEND_SRCCOLOR);

  0119e	6a 03		 push	 3
  011a0	6a 14		 push	 20			; 00000014H
  011a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  011a8	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState
$LN5@OnRender:

; 116  : 			break;
; 117  : 	}
; 118  : 
; 119  : 	// 2004.11.18.myevan.ctrl+alt+del     	
; 120  : 	if (CGraphicBase::SetPDTStream(vertices, 4))

  011ad	6a 04		 push	 4
  011af	8d 45 9c	 lea	 eax, DWORD PTR _vertices$[ebp]
  011b2	50		 push	 eax
  011b3	e8 00 00 00 00	 call	 ?SetPDTStream@CGraphicBase@@SA_NPAUSPDTVertex@@I@Z ; CGraphicBase::SetPDTStream
  011b8	59		 pop	 ecx
  011b9	59		 pop	 ecx
  011ba	0f b6 c0	 movzx	 eax, al
  011bd	85 c0		 test	 eax, eax
  011bf	74 60		 je	 SHORT $LN16@OnRender

; 121  : 	{
; 122  : 		CGraphicBase::SetDefaultIndexBuffer(CGraphicBase::DEFAULT_IB_FILL_RECT);

  011c1	6a 05		 push	 5
  011c3	e8 00 00 00 00	 call	 ?SetDefaultIndexBuffer@CGraphicBase@@SAXI@Z ; CGraphicBase::SetDefaultIndexBuffer
  011c8	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  011c9	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  011ce	89 85 38 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp

; 124  : 		STATEMANAGER.SetTexture(0, pTexture->GetD3DTexture());

  011d4	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR _pTexture$[ebp]
  011da	e8 00 00 00 00	 call	 ?GetD3DTexture@CGraphicTexture@@QBEPAUIDirect3DTexture8@@XZ ; CGraphicTexture::GetD3DTexture
  011df	50		 push	 eax
  011e0	6a 00		 push	 0
  011e2	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  011e8	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 125  : 		STATEMANAGER.SetTexture(1, NULL);

  011ed	6a 00		 push	 0
  011ef	6a 01		 push	 1
  011f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  011f7	e8 00 00 00 00	 call	 ?SetTexture@CStateManager@@QAEXKPAUIDirect3DBaseTexture8@@@Z ; CStateManager::SetTexture

; 126  : 		STATEMANAGER.SetVertexShader(D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1);

  011fc	68 42 01 00 00	 push	 322			; 00000142H
  01201	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01207	e8 00 00 00 00	 call	 ?SetVertexShader@CStateManager@@QAEXK@Z ; CStateManager::SetVertexShader

; 127  : 		STATEMANAGER.DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 4, 0, 2);	

  0120c	6a 02		 push	 2
  0120e	6a 00		 push	 0
  01210	6a 04		 push	 4
  01212	6a 00		 push	 0
  01214	6a 04		 push	 4
  01216	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0121c	e8 00 00 00 00	 call	 ?DrawIndexedPrimitive@CStateManager@@QAEJW4_D3DPRIMITIVETYPE@@IIII@Z ; CStateManager::DrawIndexedPrimitive
$LN16@OnRender:

; 128  : 	}
; 129  : 	//STATEMANAGER.DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, c_FillRectIndices, D3DFMT_INDEX16, vertices, sizeof(TPDTVertex));
; 130  : 	/////////////////////////////////////////////////////////////
; 131  : 
; 132  : 	switch (m_iRenderingMode)

  01221	8b 45 98	 mov	 eax, DWORD PTR _this$[ebp]
  01224	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  01227	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv800[ebp], eax
  0122d	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR tv800[ebp], 0
  01234	7e 25		 jle	 SHORT $LN7@OnRender
  01236	83 bd c0 fe ff
	ff 03		 cmp	 DWORD PTR tv800[ebp], 3
  0123d	7e 02		 jle	 SHORT $LN17@OnRender
  0123f	eb 1a		 jmp	 SHORT $LN7@OnRender
$LN17@OnRender:

; 133  : 	{
; 134  : 		case RENDERING_MODE_SCREEN:
; 135  : 		case RENDERING_MODE_COLOR_DODGE:
; 136  : 		case RENDERING_MODE_MODULATE:
; 137  : 			STATEMANAGER.RestoreRenderState(D3DRS_SRCBLEND);

  01241	6a 13		 push	 19			; 00000013H
  01243	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01249	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 138  : 			STATEMANAGER.RestoreRenderState(D3DRS_DESTBLEND);

  0124e	6a 14		 push	 20			; 00000014H
  01250	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01256	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState
$LN7@OnRender:

; 139  : 			break;
; 140  : 	}
; 141  : 	STATEMANAGER.SetRenderState(D3DRS_CULLMODE, D3DCULL_CW);

  0125b	6a 02		 push	 2
  0125d	6a 16		 push	 22			; 00000016H
  0125f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  01265	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 142  : }

  0126a	5e		 pop	 esi
  0126b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0126e	33 cd		 xor	 ecx, ebp
  01270	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01275	c9		 leave
  01276	c3		 ret	 0
?OnRender@CGraphicExpandedImageInstance@@MAEXXZ ENDP	; CGraphicExpandedImageInstance::OnRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?Initialize@CGraphicExpandedImageInstance@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@CGraphicExpandedImageInstance@@IAEXXZ PROC	; CGraphicExpandedImageInstance::Initialize, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	m_iRenderingMode = RENDERING_MODE_NORMAL;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 48 00	 and	 DWORD PTR [eax+72], 0

; 215  : 	m_fDepth = 0.0f;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	0f 57 c0	 xorps	 xmm0, xmm0
  00014	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 216  : 	m_v2Origin.x = m_v2Origin.y = 0.0f;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	0f 57 c0	 xorps	 xmm0, xmm0
  0001f	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f 57 c0	 xorps	 xmm0, xmm0
  0002a	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 217  : 	m_v2Scale.x = m_v2Scale.y = 1.0f;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0003a	f3 0f 11 40 30	 movss	 DWORD PTR [eax+48], xmm0
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004a	f3 0f 11 40 2c	 movss	 DWORD PTR [eax+44], xmm0

; 218  : 	m_fRotation = 0.0f;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	0f 57 c0	 xorps	 xmm0, xmm0
  00055	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0

; 219  : 	memset(&m_RenderingRect, 0, sizeof(RECT));

  0005a	6a 10		 push	 16			; 00000010H
  0005c	6a 00		 push	 0
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	83 c0 38	 add	 eax, 56			; 00000038H
  00064	50		 push	 eax
  00065	e8 00 00 00 00	 call	 _memset
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 220  : }

  0006d	c9		 leave
  0006e	c3		 ret	 0
?Initialize@CGraphicExpandedImageInstance@@IAEXXZ ENDP	; CGraphicExpandedImageInstance::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iMode$ = 8						; size = 4
?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z PROC ; CGraphicExpandedImageInstance::SetRenderingMode, COMDAT
; _this$ = ecx

; 186  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  : 	m_iRenderingMode = iMode;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _iMode$[ebp]
  0000d	89 48 48	 mov	 DWORD PTR [eax+72], ecx

; 188  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetRenderingMode@CGraphicExpandedImageInstance@@QAEXH@Z ENDP ; CGraphicExpandedImageInstance::SetRenderingMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetRenderingRect@CGraphicExpandedImageInstance@@QAEXMMMM@Z
_TEXT	SEGMENT
_fHeight$ = -12						; size = 4
_fWidth$ = -8						; size = 4
_this$ = -4						; size = 4
_fLeft$ = 8						; size = 4
_fTop$ = 12						; size = 4
_fRight$ = 16						; size = 4
_fBottom$ = 20						; size = 4
?SetRenderingRect@CGraphicExpandedImageInstance@@QAEXMMMM@Z PROC ; CGraphicExpandedImageInstance::SetRenderingRect, COMDAT
; _this$ = ecx

; 172  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 173  : 	if (IsEmpty())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsEmpty@CGraphicImageInstance@@QBE_NXZ ; CGraphicImageInstance::IsEmpty
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 02		 je	 SHORT $LN2@SetRenderi

; 174  : 		return;

  00018	eb 72		 jmp	 SHORT $LN1@SetRenderi
$LN2@SetRenderi:

; 175  : 
; 176  : 	float fWidth = float(GetWidth());

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00022	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00026	f3 0f 11 45 f8	 movss	 DWORD PTR _fWidth$[ebp], xmm0

; 177  : 	float fHeight = float(GetHeight());

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  00033	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00037	f3 0f 11 45 f4	 movss	 DWORD PTR _fHeight$[ebp], xmm0

; 178  : 
; 179  : 	m_RenderingRect.left = fWidth * fLeft;

  0003c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fWidth$[ebp]
  00041	f3 0f 59 45 08	 mulss	 xmm0, DWORD PTR _fLeft$[ebp]
  00046	f3 0f 2c c0	 cvttss2si eax, xmm0
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 180  : 	m_RenderingRect.top = fHeight * fTop;

  00050	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  00055	f3 0f 59 45 0c	 mulss	 xmm0, DWORD PTR _fTop$[ebp]
  0005a	f3 0f 2c c0	 cvttss2si eax, xmm0
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	89 41 3c	 mov	 DWORD PTR [ecx+60], eax

; 181  : 	m_RenderingRect.right = fWidth * fRight;

  00064	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _fWidth$[ebp]
  00069	f3 0f 59 45 10	 mulss	 xmm0, DWORD PTR _fRight$[ebp]
  0006e	f3 0f 2c c0	 cvttss2si eax, xmm0
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 182  : 	m_RenderingRect.bottom = fHeight * fBottom;

  00078	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fHeight$[ebp]
  0007d	f3 0f 59 45 14	 mulss	 xmm0, DWORD PTR _fBottom$[ebp]
  00082	f3 0f 2c c0	 cvttss2si eax, xmm0
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	89 41 44	 mov	 DWORD PTR [ecx+68], eax
$LN1@SetRenderi:

; 183  : }

  0008c	c9		 leave
  0008d	c2 10 00	 ret	 16			; 00000010H
?SetRenderingRect@CGraphicExpandedImageInstance@@QAEXMMMM@Z ENDP ; CGraphicExpandedImageInstance::SetRenderingRect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetScale@CGraphicExpandedImageInstance@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?SetScale@CGraphicExpandedImageInstance@@QAEXMM@Z PROC	; CGraphicExpandedImageInstance::SetScale, COMDAT
; _this$ = ecx

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 	m_v2Scale.x = fx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0000f	f3 0f 11 40 2c	 movss	 DWORD PTR [eax+44], xmm0

; 168  : 	m_v2Scale.y = fy;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0001c	f3 0f 11 40 30	 movss	 DWORD PTR [eax+48], xmm0

; 169  : }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?SetScale@CGraphicExpandedImageInstance@@QAEXMM@Z ENDP	; CGraphicExpandedImageInstance::SetScale
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fRotation$ = 8						; size = 4
?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z PROC ; CGraphicExpandedImageInstance::SetRotation, COMDAT
; _this$ = ecx

; 161  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 162  : 	m_fRotation = fRotation;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fRotation$[ebp]
  0000f	f3 0f 11 40 34	 movss	 DWORD PTR [eax+52], xmm0

; 163  : }

  00014	c9		 leave
  00015	c2 04 00	 ret	 4
?SetRotation@CGraphicExpandedImageInstance@@QAEXM@Z ENDP ; CGraphicExpandedImageInstance::SetRotation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fx$ = 8						; size = 4
_fy$ = 12						; size = 4
?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z PROC	; CGraphicExpandedImageInstance::SetOrigin, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 156  : 	m_v2Origin.x = fx;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0000f	f3 0f 11 40 24	 movss	 DWORD PTR [eax+36], xmm0

; 157  : 	m_v2Origin.y = fy;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0001c	f3 0f 11 40 28	 movss	 DWORD PTR [eax+40], xmm0

; 158  : }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z ENDP	; CGraphicExpandedImageInstance::SetOrigin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetOrigin@CGraphicExpandedImageInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetOrigin@CGraphicExpandedImageInstance@@QAEXXZ PROC	; CGraphicExpandedImageInstance::SetOrigin, COMDAT
; _this$ = ecx

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 151  : 	SetOrigin(float(GetWidth()) / 2.0f, float(GetHeight()) / 2.0f);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetHeight@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetHeight
  0000f	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00013	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  0001b	51		 push	 ecx
  0001c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?GetWidth@CGraphicImageInstance@@QAEHXZ ; CGraphicImageInstance::GetWidth
  00029	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0002d	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@40000000
  00035	51		 push	 ecx
  00036	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?SetOrigin@CGraphicExpandedImageInstance@@QAEXMM@Z ; CGraphicExpandedImageInstance::SetOrigin

; 152  : }

  00043	c9		 leave
  00044	c3		 ret	 0
?SetOrigin@CGraphicExpandedImageInstance@@QAEXXZ ENDP	; CGraphicExpandedImageInstance::SetOrigin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?SetDepth@CGraphicExpandedImageInstance@@QAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fDepth$ = 8						; size = 4
?SetDepth@CGraphicExpandedImageInstance@@QAEXM@Z PROC	; CGraphicExpandedImageInstance::SetDepth, COMDAT
; _this$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	m_fDepth = fDepth;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fDepth$[ebp]
  0000f	f3 0f 11 40 20	 movss	 DWORD PTR [eax+32], xmm0

; 147  : }

  00014	c9		 leave
  00015	c2 04 00	 ret	 4
?SetDepth@CGraphicExpandedImageInstance@@QAEXM@Z ENDP	; CGraphicExpandedImageInstance::SetDepth
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CGraphicExpandedImageInstance@@QAEXXZ PROC	; CGraphicExpandedImageInstance::Destroy, COMDAT
; _this$ = ecx

; 223  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 224  : 	CGraphicImageInstance::Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Destroy@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Destroy

; 225  : 	Initialize();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Initialize@CGraphicExpandedImageInstance@@IAEXXZ ; CGraphicExpandedImageInstance::Initialize

; 226  : }

  00017	c9		 leave
  00018	c3		 ret	 0
?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ENDP	; CGraphicExpandedImageInstance::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ??1CGraphicExpandedImageInstance@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CGraphicExpandedImageInstance@@UAE@XZ PROC		; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance, COMDAT
; _this$ = ecx

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CGraphicExpandedImageInstance@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicExpandedImageInstance@@6B@

; 235  : 	Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@CGraphicExpandedImageInstance@@QAEXXZ ; CGraphicExpandedImageInstance::Destroy

; 236  : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00042	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00049	59		 pop	 ecx
  0004a	c9		 leave
  0004b	c3		 ret	 0
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CGraphicExpandedImageInstance@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CGraphicExpandedImageInstance@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CGraphicExpandedImageInstance@@UAE@XZ ENDP		; CGraphicExpandedImageInstance::~CGraphicExpandedImageInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ??0CGraphicExpandedImageInstance@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CGraphicExpandedImageInstance@@QAE@XZ PROC		; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance, COMDAT
; _this$ = ecx

; 229  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CGraphicExpandedImageInstance@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0CGraphicImageInstance@@QAE@XZ ; CGraphicImageInstance::CGraphicImageInstance
  0002e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGraphicExpandedImageInstance@@6B@

; 230  : 	Initialize();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?Initialize@CGraphicExpandedImageInstance@@IAEXXZ ; CGraphicExpandedImageInstance::Initialize

; 231  : }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00054	59		 pop	 ecx
  00055	c9		 leave
  00056	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CGraphicExpandedImageInstance@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CGraphicImageInstance@@UAE@XZ ; CGraphicImageInstance::~CGraphicImageInstance
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CGraphicExpandedImageInstance@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CGraphicExpandedImageInstance@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CGraphicExpandedImageInstance@@QAE@XZ ENDP		; CGraphicExpandedImageInstance::CGraphicExpandedImageInstance
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterLib\GrpExpandedImageInstance.cpp
;	COMDAT ?Type@CGraphicExpandedImageInstance@@SAKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Type@CGraphicExpandedImageInstance@@SAKXZ PROC		; CGraphicExpandedImageInstance::Type, COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Type@CGraphicExpandedImageInstance@@SAKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 192  : 	static DWORD s_dwType = GetCRC32("CGraphicExpandedImageInstance", strlen("CGraphicExpandedImageInstance"));

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00027	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0002e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA
  00037	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0003d	7e 44		 jle	 SHORT $LN2@Type
  0003f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA
  00044	e8 00 00 00 00	 call	 __Init_thread_header
  00049	59		 pop	 ecx
  0004a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA, -1
  00051	75 30		 jne	 SHORT $LN2@Type
  00053	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@COPDODEE@CGraphicExpandedImageInstance@
  0005c	e8 00 00 00 00	 call	 _strlen
  00061	59		 pop	 ecx
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@COPDODEE@CGraphicExpandedImageInstance@
  00068	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  0006d	59		 pop	 ecx
  0006e	59		 pop	 ecx
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?s_dwType@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4KA, eax
  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA
  0007d	e8 00 00 00 00	 call	 __Init_thread_footer
  00082	59		 pop	 ecx
$LN2@Type:

; 193  : 	return (s_dwType);

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_dwType@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4KA

; 194  : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	c9		 leave
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Type@CGraphicExpandedImageInstance@@SAKXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGraphicExpandedImageInstance@@SAKXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Type@CGraphicExpandedImageInstance@@SAKXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Type@CGraphicExpandedImageInstance@@SAKXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Type@CGraphicExpandedImageInstance@@SAKXZ ENDP		; CGraphicExpandedImageInstance::Type
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
